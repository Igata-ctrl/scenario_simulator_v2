{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ScenarioSimulator # OpenSCENARIO interpreter and simple simulator for Autoware Purpose of this package # Currently, various kinds of simulators and scenario formats are developed all over the world. We need an open-source framework for integrating those testing tools with Autoware easily and quickly. So, we developed this package. This package is designed to easily accommodate multiple simulators and scenario description formats. This package provides under the Apache License, Version 2.0. See also LICENSE . How to use # Running example scenario # ros2 launch scenario_test_runner scenario_test_runner.launch.py workflow: = '$(find-pkg-share scenario_test_runner)/workflow_example.yaml' log_directory: = '/tmp' Running with docker image # Download docker image tar file form Here . # loading docker docker load -i scenario_simulator.tar # create sharing directory mkdir ${ HOME } /scenarios # running docker docker run -it -p 6080 :80 -v ${ HOME } /scenarios:/home/ubuntu/Desktop/scenarios --shm-size = 512m scenario_simulator . When you see following message in the terminal, * enable custom user: ubuntu useradd: user 'ubuntu' already exists set default password to \"ubuntu\" Press ctrl+c once to start VNC server. Then, open http://localhost:6080/ in your browser. Launch lx terminal in VNC, and run an example below. ros2 launch scenario_test_runner scenario_test_runner.launch.py workflow:='$(find-pkg-share scenario_test_runner)/workflow_example.yaml' log_directory:='/tmp' Creating & Running Your Own Simulation Scenarios # Create a scenario file with the scenario editor. See Scenario Editor After downloading the scenario file, open it in a text editor and modify map path to the path in your local environment RoadNetwork: LogicFile: filepath: /full/path/to/your/map_file.osm Create workflow configuration file as shown below. You can also specify multiple scenario files and add optional configurations. See here for details. Scenario: - { path: /full/path/to/your/scenario_file.yaml } Run the scenario: ros2 launch scenario_test_runner scenario_test_runner.launch.py workflow:='path/to/your/workflow_config.yaml' log_directory:='/tmp' Detailed Documentations # How to use scenario editor # See Scenario Editor How to use scenario test runner # See Scenario Test Runner Architecture documentation # See Architecture Documentation Contact Information # See Contact Information","title":"Home"},{"location":"#scenariosimulator","text":"OpenSCENARIO interpreter and simple simulator for Autoware","title":"ScenarioSimulator"},{"location":"#purpose-of-this-package","text":"Currently, various kinds of simulators and scenario formats are developed all over the world. We need an open-source framework for integrating those testing tools with Autoware easily and quickly. So, we developed this package. This package is designed to easily accommodate multiple simulators and scenario description formats. This package provides under the Apache License, Version 2.0. See also LICENSE .","title":"Purpose of this package"},{"location":"#how-to-use","text":"","title":"How to use"},{"location":"#running-example-scenario","text":"ros2 launch scenario_test_runner scenario_test_runner.launch.py workflow: = '$(find-pkg-share scenario_test_runner)/workflow_example.yaml' log_directory: = '/tmp'","title":"Running example scenario"},{"location":"#running-with-docker-image","text":"Download docker image tar file form Here . # loading docker docker load -i scenario_simulator.tar # create sharing directory mkdir ${ HOME } /scenarios # running docker docker run -it -p 6080 :80 -v ${ HOME } /scenarios:/home/ubuntu/Desktop/scenarios --shm-size = 512m scenario_simulator . When you see following message in the terminal, * enable custom user: ubuntu useradd: user 'ubuntu' already exists set default password to \"ubuntu\" Press ctrl+c once to start VNC server. Then, open http://localhost:6080/ in your browser. Launch lx terminal in VNC, and run an example below. ros2 launch scenario_test_runner scenario_test_runner.launch.py workflow:='$(find-pkg-share scenario_test_runner)/workflow_example.yaml' log_directory:='/tmp'","title":"Running with docker image"},{"location":"#creating-running-your-own-simulation-scenarios","text":"Create a scenario file with the scenario editor. See Scenario Editor After downloading the scenario file, open it in a text editor and modify map path to the path in your local environment RoadNetwork: LogicFile: filepath: /full/path/to/your/map_file.osm Create workflow configuration file as shown below. You can also specify multiple scenario files and add optional configurations. See here for details. Scenario: - { path: /full/path/to/your/scenario_file.yaml } Run the scenario: ros2 launch scenario_test_runner scenario_test_runner.launch.py workflow:='path/to/your/workflow_config.yaml' log_directory:='/tmp'","title":"Creating &amp; Running Your Own Simulation Scenarios"},{"location":"#detailed-documentations","text":"","title":"Detailed Documentations"},{"location":"#how-to-use-scenario-editor","text":"See Scenario Editor","title":"How to use scenario editor"},{"location":"#how-to-use-scenario-test-runner","text":"See Scenario Test Runner","title":"How to use scenario test runner"},{"location":"#architecture-documentation","text":"See Architecture Documentation","title":"Architecture documentation"},{"location":"#contact-information","text":"See Contact Information","title":"Contact Information"},{"location":"LICENSE/","text":"This package provides under Apache License Version 2.0. Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"LICENSE"},{"location":"design/About/","text":"Architecture Design # This documentation describes the architecture design of this scenario testing framework. This framework is designed for executing scenario test with Autoware. This framework is designed to easily accommodate multiple simulators and scenario description formats.","title":"About"},{"location":"design/About/#architecture-design","text":"This documentation describes the architecture design of this scenario testing framework. This framework is designed for executing scenario test with Autoware. This framework is designed to easily accommodate multiple simulators and scenario description formats.","title":"Architecture Design"},{"location":"design/AutowareAPI/","text":"Autoware API # Autoware API provides features to control autoware easilly via ROS2 API. AWAPI accessor is a C++ wrapper of the Autoware API, and it enables us to integrate with Autoware and other tools very easily! Note! Autoware API is now under development and we are preparing documentation about this. We provide source code, but it is not a final version.","title":"Autoware API"},{"location":"design/AutowareAPI/#autoware-api","text":"Autoware API provides features to control autoware easilly via ROS2 API. AWAPI accessor is a C++ wrapper of the Autoware API, and it enables us to integrate with Autoware and other tools very easily! Note! Autoware API is now under development and we are preparing documentation about this. We provide source code, but it is not a final version.","title":"Autoware API"},{"location":"design/OpenSCENARIOSupport/","text":"OpenSCENARIO Support # The ROS2 package openscenario_interpreter provides scenario-based simulation on ASAM OpenSCENARIO 1.0 . This section describes the differences between our OpenSCENARIO Interpreter and the OpenSCENARIO standard set by ASAM, and the OpenSCENARIO implementation by other companies and organizations. If you want to know about OpenSCENARIO, refer to the link below. ASAM OpenSCENARIO: User Guide OpenSCENARIO 1.0.0 XSD documentation Specific Features # ROS 2 Launch-like substitution syntax # Our interpreter supports some of the substitution syntax of the ROS 2 Launch system (a.k.a string-interpolation). The substitution syntax works with any attribute string in OpenSCENARIO XML. This substitution is done only once when reading the attribute. Note that the substitution result is finalized before the simulation starts, so it is not affected by the ParameterModifyAction , etc. that takes effect during the simulation. The supported functions and their behavior are shown below. $(find-pkg-prefix <package-name>) # Equivalent to the following description given in ROS 2 Design (unless we made a mistake in our implementation). Substituted by the install prefix path of the given package. Forward and backwards slashes will be resolved to the local filesystem convention. Substitution will fail if the package cannot be found. The package specified must be a ROS 2 package. $(var <parameter-name>) # Replaces with an external representation of the value of the specified OpenSCENARIO parameter. The parameters you specify must be declared by ParameterDeclarations before $ (var ...) is written. $(dirname) # Substitute the path to the directory where the running scenario script is located. Evaluation of nested substitution syntax # These substitution syntaxes can be nested in any rank. The replacement is done from the inside to the outside of the nest. An example is shown below. <ParameterDeclarations> <ParameterDeclaration name= \"map-name\" parameterType= \"string\" value= \"kashiwanoha\" /> </ParameterDeclarations> <CatalogLocations/> <RoadNetwork> <LogicFile filepath= \"$(find-pkg-share $(var map-name)_map)/map/lanelet2_map.osm\" /> </RoadNetwork> Implementation Dependent Behaviors # OpenSCENARIO has the function that the detailed behavior is left to the decision of the implementation side, which is defined as \"subject of a contract between simulation environment provider and scenario author\". Scoping # The OpenSCENARIO standard does not define what to do if the name cannot be resolved, as quoted below. If a reference cannot be resolved uniquely, for example if too few name prefixes have been specified to disambiguate fully, the result of the lookup is undefined. In our interpreter, the names of the Element and Parameter are lexically scoped. If you refer to an identifier that does not exist, the simulation will stop with an error. If multiple identifiers with the same name are defined, the identifier reference is chosen that is closest to the lexical position where the reference occurred. Defining a StoryboardElement with the same name at the same level is treated as a syntax error (In normal lexical scoping, this should be handled by shadowing, but in scenario languages it is likely a copy-and-paste mistake). CustomCommandAction # This Action is specified in the standard as follows. Used to either issue a command to the simulation environment or start an external script. Allows the user to activate custom actions in their simulation tool. For OpenSCENARIO interpreters implemented in scripting languages such as Python, this Action is often implemented as a call to an external script file written in the same language as the host language. However, our interpreter is implemented in C ++ and we cannot simply implement such a feature. Therefore, our interpreter treats the string given in CustomCommandAction.type as a command and executes it on a subprocess, as sh does. For example, the echo command can be written as follows: <UserDefinedAction> <CustomCommandAction type= \"echo\" > Hello, world! </CustomCommandAction> </UserDefinedAction> The string given to attribute type of CustomCommandAction and the string given to its content are concatenated with whitespace and passed to the subprocess. Therefore, the following two cases have the same effect. <UserDefinedAction> <CustomCommandAction type= \"echo\" > Hello, world\" </CustomCommandAction> </UserDefinedAction> <UserDefinedAction> <CustomCommandAction type= \"echo Hello, world!\" /> </UserDefinedAction> The effect of calling a command with CustomCommandAction is outside the control of the interpreter. Therefore, if you call a command that has a destructive effect on the system, there is no guarantee that the scenario execution can continue normally. For portable scenarios, the use of CustomCommandAction should be avoided as much as possible or limited to the scope of POSIX. NullAction # In particular, the following usages that achieve \"do nothing action\" are worth special mention. Here, the colon ( : ) specified in the CustomCommandAction.type is the sh command is known by the name of the null-command. <UserDefinedAction> <CustomCommandAction type= \":\" /> </UserDefinedAction> Built-in commands # Name Effect exitSuccess Immediately terminates the simulation as successful. exitFailure Immediately terminates the simulation as a failure. These built-in commands force the simulation to terminate. This termination ignores the StoryboardElement's lifecycle transition (that is, it means that StoryboardElementStateCondition cannot be used to prevent or detect the execution of this command). The terminated scenario determines the final success / failure / error by collating the called command with the expected simulation result specified in expect of the workflow file . Currently, simulation results are notified by simply writing to standard output as text. This notification method is temporary and will change in the near future. The following built-in commands are debug commands for interpreter developers, not scenario creators. It is unlikely that you will need these commands for normal scenario creation. Name Effect error Generate internal error: Used to ensure that the simulator does not crash with an internal error. sigsegv Access a null pointer: Used to make sure the simulator does not crash with an internal error. Non-Standard Extensions # Success/failure judgment # Our interpreters have been developed with the intention of incorporating them into the CI / CD pipelines in autonomous driving systems. Therefore, executing a scenario can result in success, failure, or error. Note that \"error\" means a flaw in the scenario, such as a syntax error, or an internal error, not an \"error in an automated driving system\" such as \"a vehicle accident occurred in a simulation\". In such cases, you will be notified of a \"failure\". Supporting Status # Our OpenSCENARIO Interpreter does not currently support the full range of OpenSCENARIO standards. Actions # Name Status Limitations GlobalAction. EnvironmentAction Unsupported GlobalAction.EntityAction. AddEntityAction Unsupported GlobalAction.EntityAction. DeleteEntityAction Unsupported GlobalAction.ParameterAction. ParameterSetAction \u2714 See here GlobalAction.ParameterAction. ParameterModifyAction \u2714 No GlobalAction.InfrastructureAction.TrafficSignalAction. TrafficSignalControllerAction Unsupported GlobalAction.InfrastructureAction.TrafficSignalAction. TrafficSignalStateAction Unsupported GlobalAction.TrafficAction. TrafficSourceAction Unsupported GlobalAction.TrafficAction. TrafficSinkAction Unsupported GlobalAction.TrafficAction. TrafficSwarmAction Unsupported UserDefinedAction. CustomCommandAction \u2714 No PrivateAction.LongitudinalAction. SpeedAction \u2714 See here PrivateAction.LongitudinalAction. LongitudinalDistanceAction Unsupported PrivateAction.LateralAction. LaneChangeAction \u2714 See here PrivateAction.LateralAction. LaneOffsetAction Unsupported PrivateAction.LateralAction. LateralDistanceAction Unsupported PrivateAction. VisibilityAction Unsupported PrivateAction. SynchronizeAction Unsupported PrivateAction. ActivateControllerAction Unsupported PrivateAction.ControllerAction. AssignControllerAction Unsupported PrivateAction.ControllerAction. OverrideControllerAction Unsupported PrivateAction. TeleportAction \u2714 See here PrivateAction.RoutingAction. AssignRouteAction Unsupported PrivateAction.RoutingAction. FollowTrajectoryAction Unsupported PrivateAction.RoutingAction. AcquirePositionAction \u2714 See here Conditions # Name Status Limitations ByEntityCondition.EntityCondition. EndOfRoadCondition Unsupported ByEntityCondition.EntityCondition. CollisionCondition \u2714 See here ByEntityCondition.EntityCondition. OffroadCondition Unsupported ByEntityCondition.EntityCondition. TimeHeadwayCondition \u2714 See here ByEntityCondition.EntityCondition. TimeToCollisionCondition Unsupported ByEntityCondition.EntityCondition. AccelerationCondition \u2714 No ByEntityCondition.EntityCondition. StandStillCondition \u2714 No ByEntityCondition.EntityCondition. SpeedCondition \u2714 No ByEntityCondition.EntityCondition. RelativeSpeedCondition Unsupported ByEntityCondition.EntityCondition. TraveledDistanceCondition Unsupported ByEntityCondition.EntityCondition. ReachPositionCondition \u2714 See here ByEntityCondition.EntityCondition. DistanceCondition \u2714 See here ByEntityCondition.EntityCondition. RelativeDistanceCondition \u2714 See here ByEntityCondition. ParameterCondition \u2714 ByEntityCondition. TimeOfDayCondition Unsupported ByEntityCondition. SimulationTimeCondition \u2714 No ByEntityCondition. StoryboardElementStateCondition \u2714 See here ByEntityCondition. UserDefinedValueCondition Unsupported ByEntityCondition. TrafficSignalCondition Unsupported ByEntityCondition. TrafficSignalControllerCondition Unsupported Limitations # ParameterSetAction # Currently, ParameterSetAction cannot handle dateTime type parameters. SpeedAction # The implementation of type TransitionDynamics for element SpeedActionDynamics is incomplete and SpeedActionDynamics.dynamicsDimention is ignored . LaneChangeAction # The implementation of type TransitionDynamics for element LaneChangeActionDynamics and type LaneChangeTarget for element LaneChangeTarget are incomplete. TeleportAction # Currently, only LanePosition can be specified for element of TeleportAction. AcquirePositionAction # Currently, only LanePosition can be specified for element of AcquirePositionAction. CollisionCondition # Currently, only EntityRef can be specified for element of CollisionCondition. TimeHeadwayCondition # Currently, the values of attribute \"freespace\" and \"alongRoute\" are ignored and always behave as if freespace=\"false\" and alongRoute=\"true\" were specified. ReachPositionCondition # Currently, only LanePosition and WorldPosition can be specified for the element of ReachPositionCondition. DistanceCondition # Currently, the values of attribute \"freespace\" and \"alongRoute\" are ignored and always behave as if freespace=\"false\" and alongRoute=\"false\" were specified. Currently, only LanePosition and WorldPosition can be specified for the element of Position of DistanceCondition. RelativeDistanceCondition # Currently, the values of attribute \"freespace\" is ignored and always behave as if freespace=\"false\" was specified. StoryboardElementStateCondition # Currently, a feature called \"name prefix\" (in OpenSCENARIO User Guide 3.1.2. Naming ) is unsupported. Instead, our interpreter implements lexical scoping. See also section Scoping . TransitionDynamics # The implementation of type DynamicsShape for attribute dynamicsShape is incomplete. Name Type Status dynamicsShape DynamicsShape Incomplete value Double \u2714 dynamicsDimention DynamicsDimension \u2714 DynamicsShape # Currently, only linear and step are implemented for values of this enumeration. If you specify cubic and sinusoidal , you will get an ImplementationFault. Value Status linear \u2714 cubic Unsupported sinusoidal Unsupported step \u2714 LaneChangeTarget # Currently, only AbsoluteTargetLane is implemented for element of this type. If you specify RelativeTargetLane, you will get a SyntaxError. Element Status AbsoluteTargetLane \u2714 RelativeTargetLane Unsupported Position # Currently, only WorldPosition and LanePosition are implemented for an element of this type. Element Status WorldPosition \u2714 RelativeWorldPosition Unsupported RelativeObjectPosition Unsupported RoadPosition Unsupported RelativeRoadPosition Unsupported LanePosition \u2714 RelativeLanePosition Unsupported RoutePosition Unsupported","title":"OpenSCENARIO Support"},{"location":"design/OpenSCENARIOSupport/#openscenario-support","text":"The ROS2 package openscenario_interpreter provides scenario-based simulation on ASAM OpenSCENARIO 1.0 . This section describes the differences between our OpenSCENARIO Interpreter and the OpenSCENARIO standard set by ASAM, and the OpenSCENARIO implementation by other companies and organizations. If you want to know about OpenSCENARIO, refer to the link below. ASAM OpenSCENARIO: User Guide OpenSCENARIO 1.0.0 XSD documentation","title":"OpenSCENARIO Support"},{"location":"design/OpenSCENARIOSupport/#specific-features","text":"","title":"Specific Features"},{"location":"design/OpenSCENARIOSupport/#ros-2-launch-like-substitution-syntax","text":"Our interpreter supports some of the substitution syntax of the ROS 2 Launch system (a.k.a string-interpolation). The substitution syntax works with any attribute string in OpenSCENARIO XML. This substitution is done only once when reading the attribute. Note that the substitution result is finalized before the simulation starts, so it is not affected by the ParameterModifyAction , etc. that takes effect during the simulation. The supported functions and their behavior are shown below.","title":"ROS 2 Launch-like substitution syntax"},{"location":"design/OpenSCENARIOSupport/#find-pkg-prefix-package-name","text":"Equivalent to the following description given in ROS 2 Design (unless we made a mistake in our implementation). Substituted by the install prefix path of the given package. Forward and backwards slashes will be resolved to the local filesystem convention. Substitution will fail if the package cannot be found. The package specified must be a ROS 2 package.","title":"$(find-pkg-prefix &lt;package-name&gt;)"},{"location":"design/OpenSCENARIOSupport/#var-parameter-name","text":"Replaces with an external representation of the value of the specified OpenSCENARIO parameter. The parameters you specify must be declared by ParameterDeclarations before $ (var ...) is written.","title":"$(var &lt;parameter-name&gt;)"},{"location":"design/OpenSCENARIOSupport/#dirname","text":"Substitute the path to the directory where the running scenario script is located.","title":"$(dirname)"},{"location":"design/OpenSCENARIOSupport/#evaluation-of-nested-substitution-syntax","text":"These substitution syntaxes can be nested in any rank. The replacement is done from the inside to the outside of the nest. An example is shown below. <ParameterDeclarations> <ParameterDeclaration name= \"map-name\" parameterType= \"string\" value= \"kashiwanoha\" /> </ParameterDeclarations> <CatalogLocations/> <RoadNetwork> <LogicFile filepath= \"$(find-pkg-share $(var map-name)_map)/map/lanelet2_map.osm\" /> </RoadNetwork>","title":"Evaluation of nested substitution syntax"},{"location":"design/OpenSCENARIOSupport/#implementation-dependent-behaviors","text":"OpenSCENARIO has the function that the detailed behavior is left to the decision of the implementation side, which is defined as \"subject of a contract between simulation environment provider and scenario author\".","title":"Implementation Dependent Behaviors"},{"location":"design/OpenSCENARIOSupport/#scoping","text":"The OpenSCENARIO standard does not define what to do if the name cannot be resolved, as quoted below. If a reference cannot be resolved uniquely, for example if too few name prefixes have been specified to disambiguate fully, the result of the lookup is undefined. In our interpreter, the names of the Element and Parameter are lexically scoped. If you refer to an identifier that does not exist, the simulation will stop with an error. If multiple identifiers with the same name are defined, the identifier reference is chosen that is closest to the lexical position where the reference occurred. Defining a StoryboardElement with the same name at the same level is treated as a syntax error (In normal lexical scoping, this should be handled by shadowing, but in scenario languages it is likely a copy-and-paste mistake).","title":"Scoping"},{"location":"design/OpenSCENARIOSupport/#customcommandaction","text":"This Action is specified in the standard as follows. Used to either issue a command to the simulation environment or start an external script. Allows the user to activate custom actions in their simulation tool. For OpenSCENARIO interpreters implemented in scripting languages such as Python, this Action is often implemented as a call to an external script file written in the same language as the host language. However, our interpreter is implemented in C ++ and we cannot simply implement such a feature. Therefore, our interpreter treats the string given in CustomCommandAction.type as a command and executes it on a subprocess, as sh does. For example, the echo command can be written as follows: <UserDefinedAction> <CustomCommandAction type= \"echo\" > Hello, world! </CustomCommandAction> </UserDefinedAction> The string given to attribute type of CustomCommandAction and the string given to its content are concatenated with whitespace and passed to the subprocess. Therefore, the following two cases have the same effect. <UserDefinedAction> <CustomCommandAction type= \"echo\" > Hello, world\" </CustomCommandAction> </UserDefinedAction> <UserDefinedAction> <CustomCommandAction type= \"echo Hello, world!\" /> </UserDefinedAction> The effect of calling a command with CustomCommandAction is outside the control of the interpreter. Therefore, if you call a command that has a destructive effect on the system, there is no guarantee that the scenario execution can continue normally. For portable scenarios, the use of CustomCommandAction should be avoided as much as possible or limited to the scope of POSIX.","title":"CustomCommandAction"},{"location":"design/OpenSCENARIOSupport/#nullaction","text":"In particular, the following usages that achieve \"do nothing action\" are worth special mention. Here, the colon ( : ) specified in the CustomCommandAction.type is the sh command is known by the name of the null-command. <UserDefinedAction> <CustomCommandAction type= \":\" /> </UserDefinedAction>","title":"NullAction"},{"location":"design/OpenSCENARIOSupport/#built-in-commands","text":"Name Effect exitSuccess Immediately terminates the simulation as successful. exitFailure Immediately terminates the simulation as a failure. These built-in commands force the simulation to terminate. This termination ignores the StoryboardElement's lifecycle transition (that is, it means that StoryboardElementStateCondition cannot be used to prevent or detect the execution of this command). The terminated scenario determines the final success / failure / error by collating the called command with the expected simulation result specified in expect of the workflow file . Currently, simulation results are notified by simply writing to standard output as text. This notification method is temporary and will change in the near future. The following built-in commands are debug commands for interpreter developers, not scenario creators. It is unlikely that you will need these commands for normal scenario creation. Name Effect error Generate internal error: Used to ensure that the simulator does not crash with an internal error. sigsegv Access a null pointer: Used to make sure the simulator does not crash with an internal error.","title":"Built-in commands"},{"location":"design/OpenSCENARIOSupport/#non-standard-extensions","text":"","title":"Non-Standard Extensions"},{"location":"design/OpenSCENARIOSupport/#successfailure-judgment","text":"Our interpreters have been developed with the intention of incorporating them into the CI / CD pipelines in autonomous driving systems. Therefore, executing a scenario can result in success, failure, or error. Note that \"error\" means a flaw in the scenario, such as a syntax error, or an internal error, not an \"error in an automated driving system\" such as \"a vehicle accident occurred in a simulation\". In such cases, you will be notified of a \"failure\".","title":"Success/failure judgment"},{"location":"design/OpenSCENARIOSupport/#supporting-status","text":"Our OpenSCENARIO Interpreter does not currently support the full range of OpenSCENARIO standards.","title":"Supporting Status"},{"location":"design/OpenSCENARIOSupport/#actions","text":"Name Status Limitations GlobalAction. EnvironmentAction Unsupported GlobalAction.EntityAction. AddEntityAction Unsupported GlobalAction.EntityAction. DeleteEntityAction Unsupported GlobalAction.ParameterAction. ParameterSetAction \u2714 See here GlobalAction.ParameterAction. ParameterModifyAction \u2714 No GlobalAction.InfrastructureAction.TrafficSignalAction. TrafficSignalControllerAction Unsupported GlobalAction.InfrastructureAction.TrafficSignalAction. TrafficSignalStateAction Unsupported GlobalAction.TrafficAction. TrafficSourceAction Unsupported GlobalAction.TrafficAction. TrafficSinkAction Unsupported GlobalAction.TrafficAction. TrafficSwarmAction Unsupported UserDefinedAction. CustomCommandAction \u2714 No PrivateAction.LongitudinalAction. SpeedAction \u2714 See here PrivateAction.LongitudinalAction. LongitudinalDistanceAction Unsupported PrivateAction.LateralAction. LaneChangeAction \u2714 See here PrivateAction.LateralAction. LaneOffsetAction Unsupported PrivateAction.LateralAction. LateralDistanceAction Unsupported PrivateAction. VisibilityAction Unsupported PrivateAction. SynchronizeAction Unsupported PrivateAction. ActivateControllerAction Unsupported PrivateAction.ControllerAction. AssignControllerAction Unsupported PrivateAction.ControllerAction. OverrideControllerAction Unsupported PrivateAction. TeleportAction \u2714 See here PrivateAction.RoutingAction. AssignRouteAction Unsupported PrivateAction.RoutingAction. FollowTrajectoryAction Unsupported PrivateAction.RoutingAction. AcquirePositionAction \u2714 See here","title":"Actions"},{"location":"design/OpenSCENARIOSupport/#conditions","text":"Name Status Limitations ByEntityCondition.EntityCondition. EndOfRoadCondition Unsupported ByEntityCondition.EntityCondition. CollisionCondition \u2714 See here ByEntityCondition.EntityCondition. OffroadCondition Unsupported ByEntityCondition.EntityCondition. TimeHeadwayCondition \u2714 See here ByEntityCondition.EntityCondition. TimeToCollisionCondition Unsupported ByEntityCondition.EntityCondition. AccelerationCondition \u2714 No ByEntityCondition.EntityCondition. StandStillCondition \u2714 No ByEntityCondition.EntityCondition. SpeedCondition \u2714 No ByEntityCondition.EntityCondition. RelativeSpeedCondition Unsupported ByEntityCondition.EntityCondition. TraveledDistanceCondition Unsupported ByEntityCondition.EntityCondition. ReachPositionCondition \u2714 See here ByEntityCondition.EntityCondition. DistanceCondition \u2714 See here ByEntityCondition.EntityCondition. RelativeDistanceCondition \u2714 See here ByEntityCondition. ParameterCondition \u2714 ByEntityCondition. TimeOfDayCondition Unsupported ByEntityCondition. SimulationTimeCondition \u2714 No ByEntityCondition. StoryboardElementStateCondition \u2714 See here ByEntityCondition. UserDefinedValueCondition Unsupported ByEntityCondition. TrafficSignalCondition Unsupported ByEntityCondition. TrafficSignalControllerCondition Unsupported","title":"Conditions"},{"location":"design/OpenSCENARIOSupport/#limitations","text":"","title":"Limitations"},{"location":"design/OpenSCENARIOSupport/#parametersetaction","text":"Currently, ParameterSetAction cannot handle dateTime type parameters.","title":"ParameterSetAction"},{"location":"design/OpenSCENARIOSupport/#speedaction","text":"The implementation of type TransitionDynamics for element SpeedActionDynamics is incomplete and SpeedActionDynamics.dynamicsDimention is ignored .","title":"SpeedAction"},{"location":"design/OpenSCENARIOSupport/#lanechangeaction","text":"The implementation of type TransitionDynamics for element LaneChangeActionDynamics and type LaneChangeTarget for element LaneChangeTarget are incomplete.","title":"LaneChangeAction"},{"location":"design/OpenSCENARIOSupport/#teleportaction","text":"Currently, only LanePosition can be specified for element of TeleportAction.","title":"TeleportAction"},{"location":"design/OpenSCENARIOSupport/#acquirepositionaction","text":"Currently, only LanePosition can be specified for element of AcquirePositionAction.","title":"AcquirePositionAction"},{"location":"design/OpenSCENARIOSupport/#collisioncondition","text":"Currently, only EntityRef can be specified for element of CollisionCondition.","title":"CollisionCondition"},{"location":"design/OpenSCENARIOSupport/#timeheadwaycondition","text":"Currently, the values of attribute \"freespace\" and \"alongRoute\" are ignored and always behave as if freespace=\"false\" and alongRoute=\"true\" were specified.","title":"TimeHeadwayCondition"},{"location":"design/OpenSCENARIOSupport/#reachpositioncondition","text":"Currently, only LanePosition and WorldPosition can be specified for the element of ReachPositionCondition.","title":"ReachPositionCondition"},{"location":"design/OpenSCENARIOSupport/#distancecondition","text":"Currently, the values of attribute \"freespace\" and \"alongRoute\" are ignored and always behave as if freespace=\"false\" and alongRoute=\"false\" were specified. Currently, only LanePosition and WorldPosition can be specified for the element of Position of DistanceCondition.","title":"DistanceCondition"},{"location":"design/OpenSCENARIOSupport/#relativedistancecondition","text":"Currently, the values of attribute \"freespace\" is ignored and always behave as if freespace=\"false\" was specified.","title":"RelativeDistanceCondition"},{"location":"design/OpenSCENARIOSupport/#storyboardelementstatecondition","text":"Currently, a feature called \"name prefix\" (in OpenSCENARIO User Guide 3.1.2. Naming ) is unsupported. Instead, our interpreter implements lexical scoping. See also section Scoping .","title":"StoryboardElementStateCondition"},{"location":"design/OpenSCENARIOSupport/#transitiondynamics","text":"The implementation of type DynamicsShape for attribute dynamicsShape is incomplete. Name Type Status dynamicsShape DynamicsShape Incomplete value Double \u2714 dynamicsDimention DynamicsDimension \u2714","title":"TransitionDynamics"},{"location":"design/OpenSCENARIOSupport/#dynamicsshape","text":"Currently, only linear and step are implemented for values of this enumeration. If you specify cubic and sinusoidal , you will get an ImplementationFault. Value Status linear \u2714 cubic Unsupported sinusoidal Unsupported step \u2714","title":"DynamicsShape"},{"location":"design/OpenSCENARIOSupport/#lanechangetarget","text":"Currently, only AbsoluteTargetLane is implemented for element of this type. If you specify RelativeTargetLane, you will get a SyntaxError. Element Status AbsoluteTargetLane \u2714 RelativeTargetLane Unsupported","title":"LaneChangeTarget"},{"location":"design/OpenSCENARIOSupport/#position","text":"Currently, only WorldPosition and LanePosition are implemented for an element of this type. Element Status WorldPosition \u2714 RelativeWorldPosition Unsupported RelativeObjectPosition Unsupported RoadPosition Unsupported RelativeRoadPosition Unsupported LanePosition \u2714 RelativeLanePosition Unsupported RoutePosition Unsupported","title":"Position"},{"location":"design/SimulationAPI/","text":"Simulation API # Simulation API provides an C++ API to control NPC behavior in simulation. The sample code is below. minimal example # #include <simulation_api/api/api.hpp> #include <quaternion_operation/quaternion_operation.h> #include <ament_index_cpp/get_package_share_directory.hpp> #include <rclcpp/rclcpp.hpp> // headers in STL #include <memory> #include <vector> #include <string> // headers in pugixml #include \"pugixml.hpp\" class ScenarioRunnerMoc : public rclcpp :: Node { public : explicit ScenarioRunnerMoc ( const rclcpp :: NodeOptions & option ) : Node ( \"scenario_runner\" , option ), api_ ( this , ament_index_cpp :: get_package_share_directory ( \"kashiwanoha_map\" ) + \"/map/lanelet2_map.osm\" ) { api_ . setVerbose ( true ); api_ . initialize ( 1.0 , 0.02 ); pugi :: xml_document catalog_xml_doc ; catalog_xml_doc . load_string ( catalog_xml . c_str ()); simulation_api :: entity :: VehicleParameters params ( catalog_xml_doc ); api_ . spawn ( false , \"ego\" , params ); api_ . setEntityStatus ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 120545 , 0 ), simulation_api :: helper :: constructActionStatus ( 10 )); api_ . setTargetSpeed ( \"ego\" , 15 , true ); pugi :: xml_document pedestrian_xml_doc ; pedestrian_xml_doc . load_string ( pedestrian_xml . c_str ()); simulation_api :: entity :: PedestrianParameters pedestrian_params ( pedestrian_xml_doc ); api_ . spawn ( false , \"tom\" , pedestrian_params ); api_ . setEntityStatus ( \"tom\" , \"ego\" , simulation_api :: helper :: constructPose ( 10 , 3 , 0 , 0 , 0 , 1.57 ), simulation_api :: helper :: constructActionStatus ()); api_ . spawn ( false , \"bob\" , pedestrian_params , simulation_api :: helper :: constructLaneletPose ( 34378 , 0.0 ), simulation_api :: helper :: constructActionStatus ( 1 )); api_ . setTargetSpeed ( \"bob\" , 1 , true ); api_ . spawn ( false , \"npc1\" , params , simulation_api :: helper :: constructLaneletPose ( 34579 , 20.0 ), simulation_api :: helper :: constructActionStatus ( 5 )); api_ . setTargetSpeed ( \"npc1\" , 5 , true ); lanechange_excuted_ = false ; api_ . spawn ( false , \"npc2\" , params , simulation_api :: helper :: constructLaneletPose ( 34606 , 20.0 ), simulation_api :: helper :: constructActionStatus ( 5 )); api_ . setTargetSpeed ( \"npc2\" , 0 , true ); using namespace std :: chrono_literals ; update_timer_ = this -> create_wall_timer ( 20 ms , std :: bind ( & ScenarioRunnerMoc :: update , this )); } private : void update () { if ( api_ . reachPosition ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 34615 , 10.0 ), 5 )) { api_ . requestAcquirePosition ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 35026 , 0.0 ) ); api_ . setTargetSpeed ( \"npc2\" , 13 , true ); } if ( api_ . reachPosition ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 34579 , 0.0 ), 5 )) { api_ . setTargetSpeed ( \"npc2\" , 3 , true ); } if ( api_ . checkCollision ( \"ego\" , \"npc1\" )) { std :: cout << \"npc1 collision!\" << std :: endl ; } if ( api_ . checkCollision ( \"ego\" , \"npc2\" )) { std :: cout << \"npc2 collision!\" << std :: endl ; } api_ . updateFrame (); current_time_ = current_time_ + 0.02 ; } bool lanechange_excuted_ ; bool target_speed_setted_ ; bool bob_spawned_ ; double current_time_ ; int port_ ; scenario_simulator :: API api_ ; rclcpp :: TimerBase :: SharedPtr update_timer_ ; std :: string catalog_xml = R \" ( <Vehicle name= 'vehicle.volkswagen.t2' vehicleCategory='car'> <ParameterDeclarations/> <Performance maxSpeed='69.444' maxAcceleration='200' maxDeceleration='10.0'/> <BoundingBox> <Center x='1.5' y='0.0' z='0.9'/> <Dimensions width='2.1' length='4.5' height='1.8'/> </BoundingBox> <Axles> <FrontAxle maxSteering='0.5' wheelDiameter='0.6' trackWidth='1.8' positionX='3.1' positionZ='0.3'/> <RearAxle maxSteering='0.0' wheelDiameter='0.6' trackWidth='1.8' positionX='0.0' positionZ='0.3'/> </Axles> <Properties> <Property name='type' value='ego_vehicle'/> </Properties> </Vehicle> ) \" ; std :: string pedestrian_xml = R \" ( <Pedestrian model='bob' mass='0.0' name='Bob' pedestrianCategory='pedestrian'> <BoundingBox> <Center x='0.0' y='0.0' z='0.5'/> <Dimensions width='1.0' length='1.0' height='2.0'/> </BoundingBox> <Properties/> </Pedestrian> ) \" ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: NodeOptions options ; auto component = std :: make_shared < ScenarioRunnerMoc > ( options ); rclcpp :: spin ( component ); rclcpp :: shutdown (); return 0 ; } API Documentation # See package details .","title":"Simulation API"},{"location":"design/SimulationAPI/#simulation-api","text":"Simulation API provides an C++ API to control NPC behavior in simulation. The sample code is below.","title":"Simulation API"},{"location":"design/SimulationAPI/#minimal-example","text":"#include <simulation_api/api/api.hpp> #include <quaternion_operation/quaternion_operation.h> #include <ament_index_cpp/get_package_share_directory.hpp> #include <rclcpp/rclcpp.hpp> // headers in STL #include <memory> #include <vector> #include <string> // headers in pugixml #include \"pugixml.hpp\" class ScenarioRunnerMoc : public rclcpp :: Node { public : explicit ScenarioRunnerMoc ( const rclcpp :: NodeOptions & option ) : Node ( \"scenario_runner\" , option ), api_ ( this , ament_index_cpp :: get_package_share_directory ( \"kashiwanoha_map\" ) + \"/map/lanelet2_map.osm\" ) { api_ . setVerbose ( true ); api_ . initialize ( 1.0 , 0.02 ); pugi :: xml_document catalog_xml_doc ; catalog_xml_doc . load_string ( catalog_xml . c_str ()); simulation_api :: entity :: VehicleParameters params ( catalog_xml_doc ); api_ . spawn ( false , \"ego\" , params ); api_ . setEntityStatus ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 120545 , 0 ), simulation_api :: helper :: constructActionStatus ( 10 )); api_ . setTargetSpeed ( \"ego\" , 15 , true ); pugi :: xml_document pedestrian_xml_doc ; pedestrian_xml_doc . load_string ( pedestrian_xml . c_str ()); simulation_api :: entity :: PedestrianParameters pedestrian_params ( pedestrian_xml_doc ); api_ . spawn ( false , \"tom\" , pedestrian_params ); api_ . setEntityStatus ( \"tom\" , \"ego\" , simulation_api :: helper :: constructPose ( 10 , 3 , 0 , 0 , 0 , 1.57 ), simulation_api :: helper :: constructActionStatus ()); api_ . spawn ( false , \"bob\" , pedestrian_params , simulation_api :: helper :: constructLaneletPose ( 34378 , 0.0 ), simulation_api :: helper :: constructActionStatus ( 1 )); api_ . setTargetSpeed ( \"bob\" , 1 , true ); api_ . spawn ( false , \"npc1\" , params , simulation_api :: helper :: constructLaneletPose ( 34579 , 20.0 ), simulation_api :: helper :: constructActionStatus ( 5 )); api_ . setTargetSpeed ( \"npc1\" , 5 , true ); lanechange_excuted_ = false ; api_ . spawn ( false , \"npc2\" , params , simulation_api :: helper :: constructLaneletPose ( 34606 , 20.0 ), simulation_api :: helper :: constructActionStatus ( 5 )); api_ . setTargetSpeed ( \"npc2\" , 0 , true ); using namespace std :: chrono_literals ; update_timer_ = this -> create_wall_timer ( 20 ms , std :: bind ( & ScenarioRunnerMoc :: update , this )); } private : void update () { if ( api_ . reachPosition ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 34615 , 10.0 ), 5 )) { api_ . requestAcquirePosition ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 35026 , 0.0 ) ); api_ . setTargetSpeed ( \"npc2\" , 13 , true ); } if ( api_ . reachPosition ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 34579 , 0.0 ), 5 )) { api_ . setTargetSpeed ( \"npc2\" , 3 , true ); } if ( api_ . checkCollision ( \"ego\" , \"npc1\" )) { std :: cout << \"npc1 collision!\" << std :: endl ; } if ( api_ . checkCollision ( \"ego\" , \"npc2\" )) { std :: cout << \"npc2 collision!\" << std :: endl ; } api_ . updateFrame (); current_time_ = current_time_ + 0.02 ; } bool lanechange_excuted_ ; bool target_speed_setted_ ; bool bob_spawned_ ; double current_time_ ; int port_ ; scenario_simulator :: API api_ ; rclcpp :: TimerBase :: SharedPtr update_timer_ ; std :: string catalog_xml = R \" ( <Vehicle name= 'vehicle.volkswagen.t2' vehicleCategory='car'> <ParameterDeclarations/> <Performance maxSpeed='69.444' maxAcceleration='200' maxDeceleration='10.0'/> <BoundingBox> <Center x='1.5' y='0.0' z='0.9'/> <Dimensions width='2.1' length='4.5' height='1.8'/> </BoundingBox> <Axles> <FrontAxle maxSteering='0.5' wheelDiameter='0.6' trackWidth='1.8' positionX='3.1' positionZ='0.3'/> <RearAxle maxSteering='0.0' wheelDiameter='0.6' trackWidth='1.8' positionX='0.0' positionZ='0.3'/> </Axles> <Properties> <Property name='type' value='ego_vehicle'/> </Properties> </Vehicle> ) \" ; std :: string pedestrian_xml = R \" ( <Pedestrian model='bob' mass='0.0' name='Bob' pedestrianCategory='pedestrian'> <BoundingBox> <Center x='0.0' y='0.0' z='0.5'/> <Dimensions width='1.0' length='1.0' height='2.0'/> </BoundingBox> <Properties/> </Pedestrian> ) \" ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: NodeOptions options ; auto component = std :: make_shared < ScenarioRunnerMoc > ( options ); rclcpp :: spin ( component ); rclcpp :: shutdown (); return 0 ; }","title":"minimal example"},{"location":"design/SimulationAPI/#api-documentation","text":"See package details .","title":"API Documentation"},{"location":"design/SystemArchitecture/","text":"System Architecture # This tool consists of 3 components, test runner, oepnscenario_interpretor and simulator. Each component has these features. test_runner \"test_runner\" launch Autoware and other components in this tool. \"test_runner\" communicate with \"openscenario_interpretor\" with ros2 lifecycle. (https://design.ros2.org/articles/node_lifecycle.html) openscenario_interpretor test runner communicate with openscenario_interpretor with rclcpp lifecycle. openscenario_interpretor is a rclcpp lifecycle component. When the openscenario_interpretor launched, the state of openscenario_interpretor is \"Unconfigured\". When the test runner launched, ths test runner configures openscenario_interpretor and the state of the openscenario_interpretor becomes \"Inactive\". After the, the test runner activates openscenario_interpretor and move the state into \"Active\". When the exception was thrown in openscenario interpretor, the openscenario interpretor moves into \"Inactive\" state. sensor_simulator sensor_simulator communicates with openscenario_interpretor by using XMLRPC API. You can use any times of simulator by adapting this API. Execution sequence of scenario testing. #","title":"System Architecture"},{"location":"design/SystemArchitecture/#system-architecture","text":"This tool consists of 3 components, test runner, oepnscenario_interpretor and simulator. Each component has these features. test_runner \"test_runner\" launch Autoware and other components in this tool. \"test_runner\" communicate with \"openscenario_interpretor\" with ros2 lifecycle. (https://design.ros2.org/articles/node_lifecycle.html) openscenario_interpretor test runner communicate with openscenario_interpretor with rclcpp lifecycle. openscenario_interpretor is a rclcpp lifecycle component. When the openscenario_interpretor launched, the state of openscenario_interpretor is \"Unconfigured\". When the test runner launched, ths test runner configures openscenario_interpretor and the state of the openscenario_interpretor becomes \"Inactive\". After the, the test runner activates openscenario_interpretor and move the state into \"Active\". When the exception was thrown in openscenario interpretor, the openscenario interpretor moves into \"Inactive\" state. sensor_simulator sensor_simulator communicates with openscenario_interpretor by using XMLRPC API. You can use any times of simulator by adapting this API.","title":"System Architecture"},{"location":"design/SystemArchitecture/#execution-sequence-of-scenario-testing","text":"","title":"Execution sequence of scenario testing."},{"location":"design/Tier4ScenarioFormatVersion2/","text":"TierIV Scenario Format Version 2.0 # What is TierIV Scenario Format version 2.0 # The \"TierIV Scenario format version 2.0\" is a yaml-based scenario description format. \"TierIV Scenario format version 2.0\" consisting of two blocks below. ScenarioModifiers : ScenarioModifier : - name : <string> list : [ <any> , <any> ... , <any> ] - name : <string> start : <float or int> step : <float or int> stop : <float or int> OpenSCENARIO : FileHeader : <string> revMajor : <string or int> revMinor : <string or int> date : <string or int> description : <string> author : <string> ParameterDeclarations : . . ScenarioModifiers Block # This block provides features to provide parameter distribution. The parameter, \"name\" express a variable It is not case sensitive, but attributes must be a lower snake case and it converts to a variable in its list during parameter distribution. See more details in test folder in scenario_test_runner package. Three parameters, \"start\", \"stop\" and \"step\" express its varied range. Initial parameter distribution is from start to finish while increasing a value. We can define parameter distributions like below ScenarioModifiers : ScenarioModifier : - name : \"distributions\" start : 10 stop : 20 step : 3 if the step value is 1 then distributed parameter is [10] if the step is value 2 distributed parameters are [10, 20] if the step is value 3 distributed parameters are [10, 15, 20] attention - If the step is one, the only parameter of start is used - If the step is zero, it returns error - The number of simulations is factorial to number of steps. OpenSCENARIO Block # This block is a pure yaml conversion of the OpenSCENARIO xml file. The OpenSCENARIO user guide is here.","title":"TierIV Scenario Format Version 2.0"},{"location":"design/Tier4ScenarioFormatVersion2/#tieriv-scenario-format-version-20","text":"","title":"TierIV Scenario Format Version 2.0"},{"location":"design/Tier4ScenarioFormatVersion2/#what-is-tieriv-scenario-format-version-20","text":"The \"TierIV Scenario format version 2.0\" is a yaml-based scenario description format. \"TierIV Scenario format version 2.0\" consisting of two blocks below. ScenarioModifiers : ScenarioModifier : - name : <string> list : [ <any> , <any> ... , <any> ] - name : <string> start : <float or int> step : <float or int> stop : <float or int> OpenSCENARIO : FileHeader : <string> revMajor : <string or int> revMinor : <string or int> date : <string or int> description : <string> author : <string> ParameterDeclarations : . .","title":"What is TierIV Scenario Format version 2.0"},{"location":"design/Tier4ScenarioFormatVersion2/#scenariomodifiers-block","text":"This block provides features to provide parameter distribution. The parameter, \"name\" express a variable It is not case sensitive, but attributes must be a lower snake case and it converts to a variable in its list during parameter distribution. See more details in test folder in scenario_test_runner package. Three parameters, \"start\", \"stop\" and \"step\" express its varied range. Initial parameter distribution is from start to finish while increasing a value. We can define parameter distributions like below ScenarioModifiers : ScenarioModifier : - name : \"distributions\" start : 10 stop : 20 step : 3 if the step value is 1 then distributed parameter is [10] if the step is value 2 distributed parameters are [10, 20] if the step is value 3 distributed parameters are [10, 15, 20] attention - If the step is one, the only parameter of start is used - If the step is zero, it returns error - The number of simulations is factorial to number of steps.","title":"ScenarioModifiers Block"},{"location":"design/Tier4ScenarioFormatVersion2/#openscenario-block","text":"This block is a pure yaml conversion of the OpenSCENARIO xml file. The OpenSCENARIO user guide is here.","title":"OpenSCENARIO Block"},{"location":"design/ZeroMQ/","text":"Communication with simulator and interpreter # We use ZeroMQ Inter-Process communication with simulator and interpreter. All communications are synchronized. What is ZeroMQ # ZeroMQ is an open-source messaging library, it supports TCP/UDP/Intra-Process messaging communication. We use ZeroMQ in order to communicate with the simulator and interpreter. We use Request/Reply socket in order to run the simulator synchronously. Schema of the message # scenario_simulator::API send the request to the simulator, Requests are serialized by using protobuf and use different port in order to communicate with the simulator. Protobuf Definition # Protobuf Definition is here. all datas are serialized as string and send via TCP by using ZeroMQ.","title":"Communication with simulator and interpreter"},{"location":"design/ZeroMQ/#communication-with-simulator-and-interpreter","text":"We use ZeroMQ Inter-Process communication with simulator and interpreter. All communications are synchronized.","title":"Communication with simulator and interpreter"},{"location":"design/ZeroMQ/#what-is-zeromq","text":"ZeroMQ is an open-source messaging library, it supports TCP/UDP/Intra-Process messaging communication. We use ZeroMQ in order to communicate with the simulator and interpreter. We use Request/Reply socket in order to run the simulator synchronously.","title":"What is ZeroMQ"},{"location":"design/ZeroMQ/#schema-of-the-message","text":"scenario_simulator::API send the request to the simulator, Requests are serialized by using protobuf and use different port in order to communicate with the simulator.","title":"Schema of the message"},{"location":"design/ZeroMQ/#protobuf-definition","text":"Protobuf Definition is here. all datas are serialized as string and send via TCP by using ZeroMQ.","title":"Protobuf Definition"},{"location":"etc/ContactUs/","text":"Contact us # If you have some question about this package, please post issue or contact us! Maintainers # Masaya Kataoka # hakuturu583 Software Engineer @ Tier IV, Inc. masaya.kataoka@tier4.jp Tatsuya Yamasaki # yamacir-kit Software Engineer @ Tier IV, Inc. tatsuya.yamasaki@tier4.jp","title":"Contact Infomation"},{"location":"etc/ContactUs/#contact-us","text":"If you have some question about this package, please post issue or contact us!","title":"Contact us"},{"location":"etc/ContactUs/#maintainers","text":"","title":"Maintainers"},{"location":"etc/ContactUs/#masaya-kataoka","text":"hakuturu583 Software Engineer @ Tier IV, Inc. masaya.kataoka@tier4.jp","title":"Masaya Kataoka"},{"location":"etc/ContactUs/#tatsuya-yamasaki","text":"yamacir-kit Software Engineer @ Tier IV, Inc. tatsuya.yamasaki@tier4.jp","title":"Tatsuya Yamasaki"},{"location":"package/About/","text":"Packages # Simulation Packages # Simulation API Package # Provide simulator API for scenario testing. Classes Namespaces Modules Files Pages Examples Scenario Simulator Package # Simulator for scenario testing. Classes Namespaces Modules Files Pages Examples OpenSCENARIO Packages # OpenSCENARIO Interpreter Package # Package for parsing .xosc file and send command to the simulator via Simulation API. Classes Namespaces Modules Files Pages Examples OpenSCENARIO Visualization Package # Package for visualizing the result of the simulation. Classes Namespaces Modules Files Pages Examples","title":"Package Details"},{"location":"package/About/#packages","text":"","title":"Packages"},{"location":"package/About/#simulation-packages","text":"","title":"Simulation Packages"},{"location":"package/About/#simulation-api-package","text":"Provide simulator API for scenario testing. Classes Namespaces Modules Files Pages Examples","title":"Simulation API Package"},{"location":"package/About/#scenario-simulator-package","text":"Simulator for scenario testing. Classes Namespaces Modules Files Pages Examples","title":"Scenario Simulator Package"},{"location":"package/About/#openscenario-packages","text":"","title":"OpenSCENARIO Packages"},{"location":"package/About/#openscenario-interpreter-package","text":"Package for parsing .xosc file and send command to the simulator via Simulation API. Classes Namespaces Modules Files Pages Examples","title":"OpenSCENARIO Interpreter Package"},{"location":"package/About/#openscenario-visualization-package","text":"Package for visualizing the result of the simulation. Classes Namespaces Modules Files Pages Examples","title":"OpenSCENARIO Visualization Package"},{"location":"package/openscenario_interpreter/markdown/Classes/","text":"Classes # namespace openscenario_interpreter struct ConnectionError struct Error struct Expression struct ImplementationFault class Interpreter class Pointer struct Binder struct Scope struct SemanticError struct SyntaxError struct Unspecified namespace concepts struct HasStreamOutputOperator struct HasStreamOutputOperator< T, void_t< decltype(std::declval< std::ostream & >()<< std::declval< const T & >())> > namespace console namespace background namespace foreground namespace functional namespace iterator namespace posix namespace reader namespace string namespace syntax struct AbsoluteTargetLane struct AbsoluteTargetSpeed struct AccelerationCondition struct AcquirePositionAction struct Act struct Action struct Actors struct AddEntityAction struct AdditionalAxle struct AssignControllerAction struct AssignRouteAction struct Axle struct Axles struct Boolean struct BoundingBox struct ByEntityCondition struct ByType struct ByValueCondition struct CatalogLocation struct CatalogLocations struct Center struct CollisionCondition struct Command struct Condition struct ConditionEdge struct ConditionGroup struct Controller struct ControllerAction struct CustomCommandAction struct DeleteEntityAction struct Dimensions struct Directory struct DistanceCondition struct Double struct DynamicsDimension struct DynamicsShape struct Entities struct EntityAction struct EntityCondition struct EntityObject struct EntityRef struct EntitySelection struct Event struct File struct FileHeader struct FrontAxle struct GlobalAction struct InfrastructureAction struct Init struct InitActions struct Integer struct LaneChangeAction struct LaneChangeTarget struct LanePosition struct LateralAction struct LongitudinalAction struct Maneuver struct ManeuverGroup struct ModifyRule struct ObjectController struct ObjectType struct OpenScenario struct Orientation struct OverrideControllerValueAction struct ParameterAction struct ParameterAddValueRule struct ParameterCondition struct ParameterDeclaration struct ParameterDeclarations struct ParameterModifyAction struct ParameterMultiplyByValueRule struct ParameterSetAction struct ParameterType struct Pedestrian struct PedestrianCategory struct Performance struct Phase struct Position struct Priority struct Private struct PrivateAction struct Properties struct Property struct ReachPositionCondition struct RearAxle struct ReferenceContext struct RelativeDistanceCondition struct RelativeDistanceType struct RelativeTargetSpeed struct RelativeWorldPosition struct RoadNetwork struct Route struct RouteStrategy struct RoutingAction struct Rule struct ScenarioDefinition struct ScenarioObject struct SelectedEntities struct SimulationTimeCondition struct SpeedAction struct SpeedActionTarget struct SpeedCondition struct SpeedTargetValueType struct StandStillCondition struct Story struct Storyboard class StoryboardElement struct StoryboardElementState struct StoryboardElementStateCondition struct StoryboardElementType struct TeleportAction struct TimeHeadwayCondition struct TrafficSignalAction struct TrafficSignalCondition struct TrafficSignalController struct TrafficSignalState struct TrafficSignalStateAction struct TrafficSignals struct TransitionDynamics struct Trigger struct TriggeringEntities struct TriggeringEntitiesRule struct UnsignedInteger struct UnsignedShort struct UserDefinedAction struct Vehicle struct VehicleCategory struct Waypoint struct WorldPosition struct equal_to struct equal_to< T, typename std::enable_if< std::is_floating_point< T >::value >::type > namespace type_traits struct HasMemberFunctionAccomplished struct HasMemberFunctionAccomplished< T, void_t< decltype(std::declval< T >().accomplished())> > struct HasMemberFunctionEvaluate struct HasMemberFunctionEvaluate< T, void_t< decltype(std::declval< T >().evaluate())> > struct HasMemberFunctionStart struct HasMemberFunctionStart< T, void_t< decltype(std::declval< T >().start())> > struct HasMemberFunctionState struct HasMemberFunctionState< T, void_t< decltype(std::declval< T >().state())> > struct IfHasMemberFunctionAccomplished struct IfHasMemberFunctionAccomplished< T, typename std::enable_if< HasMemberFunctionAccomplished< T >::value >::type > struct IfHasMemberFunctionEvaluate struct IfHasMemberFunctionEvaluate< T, typename std::enable_if< HasMemberFunctionEvaluate< T >::value >::type > struct IfHasMemberFunctionStart struct IfHasMemberFunctionStart< T, typename std::enable_if< HasMemberFunctionStart< T >::value >::type > struct IfHasMemberFunctionState struct IfHasMemberFunctionState< T, typename std::enable_if< HasMemberFunctionState< T >::value >::type > struct IfHasStreamOutputOperator struct IfHasStreamOutputOperator< T, typename std::enable_if< HasStreamOutputOperator< T >::value >::type > struct IfNotDefaultConstructible struct IfNotDefaultConstructible< T, typename std::enable_if< std::is_default_constructible< T >::value >::type > struct IfNotNothrowDefaultConstructible struct IfNotNothrowDefaultConstructible< T, typename std::enable_if< std::is_nothrow_default_constructible< T >::value >::type > namespace utility struct AttributeHighlighter struct Indent Updated on 7 April 2021 at 00:31:57 UTC","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Classes/#classes","text":"namespace openscenario_interpreter struct ConnectionError struct Error struct Expression struct ImplementationFault class Interpreter class Pointer struct Binder struct Scope struct SemanticError struct SyntaxError struct Unspecified namespace concepts struct HasStreamOutputOperator struct HasStreamOutputOperator< T, void_t< decltype(std::declval< std::ostream & >()<< std::declval< const T & >())> > namespace console namespace background namespace foreground namespace functional namespace iterator namespace posix namespace reader namespace string namespace syntax struct AbsoluteTargetLane struct AbsoluteTargetSpeed struct AccelerationCondition struct AcquirePositionAction struct Act struct Action struct Actors struct AddEntityAction struct AdditionalAxle struct AssignControllerAction struct AssignRouteAction struct Axle struct Axles struct Boolean struct BoundingBox struct ByEntityCondition struct ByType struct ByValueCondition struct CatalogLocation struct CatalogLocations struct Center struct CollisionCondition struct Command struct Condition struct ConditionEdge struct ConditionGroup struct Controller struct ControllerAction struct CustomCommandAction struct DeleteEntityAction struct Dimensions struct Directory struct DistanceCondition struct Double struct DynamicsDimension struct DynamicsShape struct Entities struct EntityAction struct EntityCondition struct EntityObject struct EntityRef struct EntitySelection struct Event struct File struct FileHeader struct FrontAxle struct GlobalAction struct InfrastructureAction struct Init struct InitActions struct Integer struct LaneChangeAction struct LaneChangeTarget struct LanePosition struct LateralAction struct LongitudinalAction struct Maneuver struct ManeuverGroup struct ModifyRule struct ObjectController struct ObjectType struct OpenScenario struct Orientation struct OverrideControllerValueAction struct ParameterAction struct ParameterAddValueRule struct ParameterCondition struct ParameterDeclaration struct ParameterDeclarations struct ParameterModifyAction struct ParameterMultiplyByValueRule struct ParameterSetAction struct ParameterType struct Pedestrian struct PedestrianCategory struct Performance struct Phase struct Position struct Priority struct Private struct PrivateAction struct Properties struct Property struct ReachPositionCondition struct RearAxle struct ReferenceContext struct RelativeDistanceCondition struct RelativeDistanceType struct RelativeTargetSpeed struct RelativeWorldPosition struct RoadNetwork struct Route struct RouteStrategy struct RoutingAction struct Rule struct ScenarioDefinition struct ScenarioObject struct SelectedEntities struct SimulationTimeCondition struct SpeedAction struct SpeedActionTarget struct SpeedCondition struct SpeedTargetValueType struct StandStillCondition struct Story struct Storyboard class StoryboardElement struct StoryboardElementState struct StoryboardElementStateCondition struct StoryboardElementType struct TeleportAction struct TimeHeadwayCondition struct TrafficSignalAction struct TrafficSignalCondition struct TrafficSignalController struct TrafficSignalState struct TrafficSignalStateAction struct TrafficSignals struct TransitionDynamics struct Trigger struct TriggeringEntities struct TriggeringEntitiesRule struct UnsignedInteger struct UnsignedShort struct UserDefinedAction struct Vehicle struct VehicleCategory struct Waypoint struct WorldPosition struct equal_to struct equal_to< T, typename std::enable_if< std::is_floating_point< T >::value >::type > namespace type_traits struct HasMemberFunctionAccomplished struct HasMemberFunctionAccomplished< T, void_t< decltype(std::declval< T >().accomplished())> > struct HasMemberFunctionEvaluate struct HasMemberFunctionEvaluate< T, void_t< decltype(std::declval< T >().evaluate())> > struct HasMemberFunctionStart struct HasMemberFunctionStart< T, void_t< decltype(std::declval< T >().start())> > struct HasMemberFunctionState struct HasMemberFunctionState< T, void_t< decltype(std::declval< T >().state())> > struct IfHasMemberFunctionAccomplished struct IfHasMemberFunctionAccomplished< T, typename std::enable_if< HasMemberFunctionAccomplished< T >::value >::type > struct IfHasMemberFunctionEvaluate struct IfHasMemberFunctionEvaluate< T, typename std::enable_if< HasMemberFunctionEvaluate< T >::value >::type > struct IfHasMemberFunctionStart struct IfHasMemberFunctionStart< T, typename std::enable_if< HasMemberFunctionStart< T >::value >::type > struct IfHasMemberFunctionState struct IfHasMemberFunctionState< T, typename std::enable_if< HasMemberFunctionState< T >::value >::type > struct IfHasStreamOutputOperator struct IfHasStreamOutputOperator< T, typename std::enable_if< HasStreamOutputOperator< T >::value >::type > struct IfNotDefaultConstructible struct IfNotDefaultConstructible< T, typename std::enable_if< std::is_default_constructible< T >::value >::type > struct IfNotNothrowDefaultConstructible struct IfNotNothrowDefaultConstructible< T, typename std::enable_if< std::is_nothrow_default_constructible< T >::value >::type > namespace utility struct AttributeHighlighter struct Indent Updated on 7 April 2021 at 00:31:57 UTC","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Interpreter/","text":"openscenario_interpreter::Interpreter # Inherits from LifecycleNode Public Types # Name using rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn Result Public Functions # Name Result on_shutdown (const rclcpp_lifecycle::State & ) override Result on_error (const rclcpp_lifecycle::State & ) override Result on_deactivate (const rclcpp_lifecycle::State & ) override Result on_configure (const rclcpp_lifecycle::State & ) override Result on_cleanup (const rclcpp_lifecycle::State & ) override Result on_activate (const rclcpp_lifecycle::State & ) override OPENSCENARIO_INTERPRETER_PUBLIC Interpreter (const rclcpp::NodeOptions & options) Public Types Documentation # using Result # using openscenario_interpreter :: Interpreter :: Result = rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn ; Public Functions Documentation # function on_shutdown # Result on_shutdown ( const rclcpp_lifecycle :: State & ) override function on_error # Result on_error ( const rclcpp_lifecycle :: State & ) override function on_deactivate # Result on_deactivate ( const rclcpp_lifecycle :: State & ) override function on_configure # Result on_configure ( const rclcpp_lifecycle :: State & ) override function on_cleanup # Result on_cleanup ( const rclcpp_lifecycle :: State & ) override function on_activate # Result on_activate ( const rclcpp_lifecycle :: State & ) override function Interpreter # explicit OPENSCENARIO_INTERPRETER_PUBLIC Interpreter ( const rclcpp :: NodeOptions & options ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::Interpreter"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Interpreter/#openscenario_interpreterinterpreter","text":"Inherits from LifecycleNode","title":"openscenario_interpreter::Interpreter"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Interpreter/#public-types","text":"Name using rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn Result","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Interpreter/#public-functions","text":"Name Result on_shutdown (const rclcpp_lifecycle::State & ) override Result on_error (const rclcpp_lifecycle::State & ) override Result on_deactivate (const rclcpp_lifecycle::State & ) override Result on_configure (const rclcpp_lifecycle::State & ) override Result on_cleanup (const rclcpp_lifecycle::State & ) override Result on_activate (const rclcpp_lifecycle::State & ) override OPENSCENARIO_INTERPRETER_PUBLIC Interpreter (const rclcpp::NodeOptions & options)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Interpreter/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Interpreter/#using-result","text":"using openscenario_interpreter :: Interpreter :: Result = rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn ;","title":"using Result"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Interpreter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Interpreter/#function-on_shutdown","text":"Result on_shutdown ( const rclcpp_lifecycle :: State & ) override","title":"function on_shutdown"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Interpreter/#function-on_error","text":"Result on_error ( const rclcpp_lifecycle :: State & ) override","title":"function on_error"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Interpreter/#function-on_deactivate","text":"Result on_deactivate ( const rclcpp_lifecycle :: State & ) override","title":"function on_deactivate"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Interpreter/#function-on_configure","text":"Result on_configure ( const rclcpp_lifecycle :: State & ) override","title":"function on_configure"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Interpreter/#function-on_cleanup","text":"Result on_cleanup ( const rclcpp_lifecycle :: State & ) override","title":"function on_cleanup"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Interpreter/#function-on_activate","text":"Result on_activate ( const rclcpp_lifecycle :: State & ) override","title":"function on_activate"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Interpreter/#function-interpreter","text":"explicit OPENSCENARIO_INTERPRETER_PUBLIC Interpreter ( const rclcpp :: NodeOptions & options ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function Interpreter"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Pointer/","text":"openscenario_interpreter::Pointer # More... Inherits from std::shared_ptr< T > Inherited by openscenario_interpreter::syntax::EntityAction , openscenario_interpreter::syntax::ModifyRule , openscenario_interpreter::syntax::ObjectController , openscenario_interpreter::syntax::PrivateAction , openscenario_interpreter::syntax::RoutingAction , openscenario_interpreter::syntax::SpeedActionTarget , openscenario_interpreter::syntax::TrafficSignalAction Public Functions # Name template \\<typename ... Ts> constexpr Pointer (Ts &&... xs) Detailed Description # template < typename T > class openscenario_interpreter :: Pointer ; Public Functions Documentation # function Pointer # template < typename ... Ts > inline explicit constexpr Pointer ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::Pointer"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Pointer/#openscenario_interpreterpointer","text":"More... Inherits from std::shared_ptr< T > Inherited by openscenario_interpreter::syntax::EntityAction , openscenario_interpreter::syntax::ModifyRule , openscenario_interpreter::syntax::ObjectController , openscenario_interpreter::syntax::PrivateAction , openscenario_interpreter::syntax::RoutingAction , openscenario_interpreter::syntax::SpeedActionTarget , openscenario_interpreter::syntax::TrafficSignalAction","title":"openscenario_interpreter::Pointer"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Pointer/#public-functions","text":"Name template \\<typename ... Ts> constexpr Pointer (Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Pointer/#detailed-description","text":"template < typename T > class openscenario_interpreter :: Pointer ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Pointer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1Pointer/#function-pointer","text":"template < typename ... Ts > inline explicit constexpr Pointer ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function Pointer"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/","text":"openscenario_interpreter::syntax::StoryboardElement # More... Public Functions # Name const auto & state () const Element override () auto evaluate () template \\<typename Boolean ,REQUIRES(std::is_convertible< Boolean, bool >) > auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) template \\<typename Boolean ,REQUIRES(std::is_convertible< Boolean, bool >) > decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) template \\<typename Predicate ,typename ... Ts,REQUIRES(std::is_function< Predicate >) > decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition ) Protected Functions # Name auto unique (const std::string & name) auto rename (const std::string & name) const template \\<typename U ,typename Node ,typename Scope ,typename ... Ts> decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs) Public Attributes # Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count Protected Attributes # Name std::unordered_set< std::string > names Detailed Description # template < typename T > class openscenario_interpreter :: syntax :: StoryboardElement ; Public Functions Documentation # function state # inline const auto & state () const function override # inline Element override () function evaluate # inline auto evaluate () function changeStateIf # template < typename Boolean , REQUIRES ( std :: is_convertible < Boolean , bool > ) > inline auto changeStateIf ( Boolean && test , const Element & consequent_state , const Element & alternate_state ) function changeStateIf # template < typename Boolean , REQUIRES ( std :: is_convertible < Boolean , bool > ) > inline decltype ( auto ) changeStateIf ( Boolean && test , const Element & consequent_state ) function changeStateIf # template < typename Predicate , typename ... Ts , REQUIRES ( std :: is_function < Predicate > ) > inline decltype ( auto ) changeStateIf ( Predicate && predicate , Ts && ... xs ) function StoryboardElement # inline explicit constexpr StoryboardElement ( std :: size_t maximum_execution_count = 1 ) function BOILERPLATE # BOILERPLATE ( standby , standbyState ) function BOILERPLATE # BOILERPLATE ( starting , startTransition ) function BOILERPLATE # BOILERPLATE ( running , runningState ) function BOILERPLATE # BOILERPLATE ( ending , endTransition ) function BOILERPLATE # BOILERPLATE ( complete , completeState ) function BOILERPLATE # BOILERPLATE ( stopping , stopTransition ) function BOILERPLATE # BOILERPLATE ( skipping , skipTransition ) Protected Functions Documentation # function unique # inline auto unique ( const std :: string & name ) function rename # inline auto rename ( const std :: string & name ) const function readStoryboardElement # template < typename U , typename Node , typename Scope , typename ... Ts > inline decltype ( auto ) readStoryboardElement ( const Node & node , Scope & inner_scope , Ts && ... xs ) Public Attributes Documentation # variable maximum_execution_count # const std :: size_t maximum_execution_count ; variable current_state # Element current_state ; variable current_execution_count # std :: size_t current_execution_count ; Protected Attributes Documentation # variable names # std :: unordered_set < std :: string > names ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::StoryboardElement"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#openscenario_interpretersyntaxstoryboardelement","text":"More...","title":"openscenario_interpreter::syntax::StoryboardElement"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#public-functions","text":"Name const auto & state () const Element override () auto evaluate () template \\<typename Boolean ,REQUIRES(std::is_convertible< Boolean, bool >) > auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) template \\<typename Boolean ,REQUIRES(std::is_convertible< Boolean, bool >) > decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) template \\<typename Predicate ,typename ... Ts,REQUIRES(std::is_function< Predicate >) > decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition )","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#protected-functions","text":"Name auto unique (const std::string & name) auto rename (const std::string & name) const template \\<typename U ,typename Node ,typename Scope ,typename ... Ts> decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs)","title":"Protected Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#public-attributes","text":"Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#protected-attributes","text":"Name std::unordered_set< std::string > names","title":"Protected Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#detailed-description","text":"template < typename T > class openscenario_interpreter :: syntax :: StoryboardElement ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-state","text":"inline const auto & state () const","title":"function state"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-override","text":"inline Element override ()","title":"function override"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-evaluate","text":"inline auto evaluate ()","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-changestateif","text":"template < typename Boolean , REQUIRES ( std :: is_convertible < Boolean , bool > ) > inline auto changeStateIf ( Boolean && test , const Element & consequent_state , const Element & alternate_state )","title":"function changeStateIf"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-changestateif_1","text":"template < typename Boolean , REQUIRES ( std :: is_convertible < Boolean , bool > ) > inline decltype ( auto ) changeStateIf ( Boolean && test , const Element & consequent_state )","title":"function changeStateIf"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-changestateif_2","text":"template < typename Predicate , typename ... Ts , REQUIRES ( std :: is_function < Predicate > ) > inline decltype ( auto ) changeStateIf ( Predicate && predicate , Ts && ... xs )","title":"function changeStateIf"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-storyboardelement","text":"inline explicit constexpr StoryboardElement ( std :: size_t maximum_execution_count = 1 )","title":"function StoryboardElement"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-boilerplate","text":"BOILERPLATE ( standby , standbyState )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-boilerplate_1","text":"BOILERPLATE ( starting , startTransition )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-boilerplate_2","text":"BOILERPLATE ( running , runningState )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-boilerplate_3","text":"BOILERPLATE ( ending , endTransition )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-boilerplate_4","text":"BOILERPLATE ( complete , completeState )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-boilerplate_5","text":"BOILERPLATE ( stopping , stopTransition )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-boilerplate_6","text":"BOILERPLATE ( skipping , skipTransition )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-unique","text":"inline auto unique ( const std :: string & name )","title":"function unique"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-rename","text":"inline auto rename ( const std :: string & name ) const","title":"function rename"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#function-readstoryboardelement","text":"template < typename U , typename Node , typename Scope , typename ... Ts > inline decltype ( auto ) readStoryboardElement ( const Node & node , Scope & inner_scope , Ts && ... xs )","title":"function readStoryboardElement"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#variable-maximum_execution_count","text":"const std :: size_t maximum_execution_count ;","title":"variable maximum_execution_count"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#variable-current_state","text":"Element current_state ;","title":"variable current_state"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#variable-current_execution_count","text":"std :: size_t current_execution_count ;","title":"variable current_execution_count"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/classopenscenario__interpreter_1_1syntax_1_1StoryboardElement/#variable-names","text":"std :: unordered_set < std :: string > names ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable names"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1ConnectionError/","text":"openscenario_interpreter::ConnectionError # Inherits from openscenario_interpreter::Error , runtime_error Public Functions # Name template \\<typename ... Ts> ConnectionError (Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Error Name Error (Ts &&... xs) Public Functions Documentation # function ConnectionError # template < typename ... Ts > inline explicit ConnectionError ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::ConnectionError"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1ConnectionError/#openscenario_interpreterconnectionerror","text":"Inherits from openscenario_interpreter::Error , runtime_error","title":"openscenario_interpreter::ConnectionError"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1ConnectionError/#public-functions","text":"Name template \\<typename ... Ts> ConnectionError (Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1ConnectionError/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Error Name Error (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1ConnectionError/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1ConnectionError/#function-connectionerror","text":"template < typename ... Ts > inline explicit ConnectionError ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function ConnectionError"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Error/","text":"openscenario_interpreter::Error # Inherits from runtime_error Inherited by openscenario_interpreter::ConnectionError , openscenario_interpreter::ImplementationFault , openscenario_interpreter::SemanticError , openscenario_interpreter::SyntaxError Public Functions # Name template \\<typename ... Ts> Error (Ts &&... xs) Public Functions Documentation # function Error # template < typename ... Ts > inline explicit Error ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::Error"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Error/#openscenario_interpretererror","text":"Inherits from runtime_error Inherited by openscenario_interpreter::ConnectionError , openscenario_interpreter::ImplementationFault , openscenario_interpreter::SemanticError , openscenario_interpreter::SyntaxError","title":"openscenario_interpreter::Error"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Error/#public-functions","text":"Name template \\<typename ... Ts> Error (Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Error/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Error/#function-error","text":"template < typename ... Ts > inline explicit Error ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function Error"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Expression/","text":"openscenario_interpreter::Expression # Public Functions # Name virtual std::ostream & write (std::ostream & os) const virtual const std::type_info & type () const virtual const Pointer < Expression > & state () const virtual void start () virtual Pointer < Expression > evaluate (const Pointer < Expression > & ) virtual bool accomplished () Public Functions Documentation # function write # inline virtual std :: ostream & write ( std :: ostream & os ) const function type # inline virtual const std :: type_info & type () const function state # inline virtual const Pointer < Expression > & state () const function start # inline virtual void start () function evaluate # inline virtual Pointer < Expression > evaluate ( const Pointer < Expression > & ) function accomplished # inline virtual bool accomplished () Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::Expression"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Expression/#openscenario_interpreterexpression","text":"","title":"openscenario_interpreter::Expression"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Expression/#public-functions","text":"Name virtual std::ostream & write (std::ostream & os) const virtual const std::type_info & type () const virtual const Pointer < Expression > & state () const virtual void start () virtual Pointer < Expression > evaluate (const Pointer < Expression > & ) virtual bool accomplished ()","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Expression/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Expression/#function-write","text":"inline virtual std :: ostream & write ( std :: ostream & os ) const","title":"function write"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Expression/#function-type","text":"inline virtual const std :: type_info & type () const","title":"function type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Expression/#function-state","text":"inline virtual const Pointer < Expression > & state () const","title":"function state"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Expression/#function-start","text":"inline virtual void start ()","title":"function start"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Expression/#function-evaluate","text":"inline virtual Pointer < Expression > evaluate ( const Pointer < Expression > & )","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Expression/#function-accomplished","text":"inline virtual bool accomplished () Updated on 7 April 2021 at 00:31:57 UTC","title":"function accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1ImplementationFault/","text":"openscenario_interpreter::ImplementationFault # Inherits from openscenario_interpreter::Error , runtime_error Public Functions # Name template \\<typename ... Ts> ImplementationFault (Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Error Name Error (Ts &&... xs) Public Functions Documentation # function ImplementationFault # template < typename ... Ts > inline explicit ImplementationFault ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::ImplementationFault"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1ImplementationFault/#openscenario_interpreterimplementationfault","text":"Inherits from openscenario_interpreter::Error , runtime_error","title":"openscenario_interpreter::ImplementationFault"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1ImplementationFault/#public-functions","text":"Name template \\<typename ... Ts> ImplementationFault (Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1ImplementationFault/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Error Name Error (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1ImplementationFault/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1ImplementationFault/#function-implementationfault","text":"template < typename ... Ts > inline explicit ImplementationFault ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function ImplementationFault"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Pointer_1_1Binder/","text":"openscenario_interpreter::Pointer::Binder # More... Inherits from T, Bound Public Types # Name using T top Public Functions # Name virtual ~Binder () =default const std::type_info & type () const override template \\<typename ... Ts> constexpr Binder (Ts &&... xs) Detailed Description # template < typename Bound > struct openscenario_interpreter :: Pointer :: Binder ; Public Types Documentation # using top # using openscenario_interpreter :: Pointer < T >:: Binder < Bound >:: top = T ; Public Functions Documentation # function ~Binder # virtual ~ Binder () = default function type # inline const std :: type_info & type () const override function Binder # template < typename ... Ts > inline explicit constexpr Binder ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::Pointer::Binder"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Pointer_1_1Binder/#openscenario_interpreterpointerbinder","text":"More... Inherits from T, Bound","title":"openscenario_interpreter::Pointer::Binder"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Pointer_1_1Binder/#public-types","text":"Name using T top","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Pointer_1_1Binder/#public-functions","text":"Name virtual ~Binder () =default const std::type_info & type () const override template \\<typename ... Ts> constexpr Binder (Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Pointer_1_1Binder/#detailed-description","text":"template < typename Bound > struct openscenario_interpreter :: Pointer :: Binder ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Pointer_1_1Binder/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Pointer_1_1Binder/#using-top","text":"using openscenario_interpreter :: Pointer < T >:: Binder < Bound >:: top = T ;","title":"using top"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Pointer_1_1Binder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Pointer_1_1Binder/#function-binder","text":"virtual ~ Binder () = default","title":"function ~Binder"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Pointer_1_1Binder/#function-type","text":"inline const std :: type_info & type () const override","title":"function type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Pointer_1_1Binder/#function-binder_1","text":"template < typename ... Ts > inline explicit constexpr Binder ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function Binder"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/","text":"openscenario_interpreter::Scope # Public Types # Name using std::vector< Actor > Actors using EntityRef Actor Public Functions # Name Scope () Scope ( Scope & ) =default Scope (const Scope & ) =default template \\<typename ... Ts> Scope (const std::string & scenario, Ts &&... xs) Public Attributes # Name std::unordered_map< String, Element > storyboard_elements boost::filesystem::path scene_graph_file const boost::filesystem::path scenario std::unordered_map< String, Element > parameters boost::filesystem::path logic_file std::unordered_map< String, Element > entities Actors actors Public Types Documentation # using Actors # using openscenario_interpreter :: Scope :: Actors = std :: vector < Actor > ; using Actor # using openscenario_interpreter :: Scope :: Actor = EntityRef ; Public Functions Documentation # function Scope # Scope () function Scope # explicit Scope ( Scope & ) = default function Scope # explicit Scope ( const Scope & ) = default function Scope # template < typename ... Ts > inline explicit Scope ( const std :: string & scenario , Ts && ... xs ) Public Attributes Documentation # variable storyboard_elements # std :: unordered_map < String , Element > storyboard_elements ; variable scene_graph_file # boost :: filesystem :: path scene_graph_file ; variable scenario # const boost :: filesystem :: path scenario ; variable parameters # std :: unordered_map < String , Element > parameters ; variable logic_file # boost :: filesystem :: path logic_file ; variable entities # std :: unordered_map < String , Element > entities ; variable actors # Actors actors ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::Scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#openscenario_interpreterscope","text":"","title":"openscenario_interpreter::Scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#public-types","text":"Name using std::vector< Actor > Actors using EntityRef Actor","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#public-functions","text":"Name Scope () Scope ( Scope & ) =default Scope (const Scope & ) =default template \\<typename ... Ts> Scope (const std::string & scenario, Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#public-attributes","text":"Name std::unordered_map< String, Element > storyboard_elements boost::filesystem::path scene_graph_file const boost::filesystem::path scenario std::unordered_map< String, Element > parameters boost::filesystem::path logic_file std::unordered_map< String, Element > entities Actors actors","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#using-actors","text":"using openscenario_interpreter :: Scope :: Actors = std :: vector < Actor > ;","title":"using Actors"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#using-actor","text":"using openscenario_interpreter :: Scope :: Actor = EntityRef ;","title":"using Actor"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#function-scope","text":"Scope ()","title":"function Scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#function-scope_1","text":"explicit Scope ( Scope & ) = default","title":"function Scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#function-scope_2","text":"explicit Scope ( const Scope & ) = default","title":"function Scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#function-scope_3","text":"template < typename ... Ts > inline explicit Scope ( const std :: string & scenario , Ts && ... xs )","title":"function Scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#variable-storyboard_elements","text":"std :: unordered_map < String , Element > storyboard_elements ;","title":"variable storyboard_elements"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#variable-scene_graph_file","text":"boost :: filesystem :: path scene_graph_file ;","title":"variable scene_graph_file"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#variable-scenario","text":"const boost :: filesystem :: path scenario ;","title":"variable scenario"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#variable-parameters","text":"std :: unordered_map < String , Element > parameters ;","title":"variable parameters"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#variable-logic_file","text":"boost :: filesystem :: path logic_file ;","title":"variable logic_file"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#variable-entities","text":"std :: unordered_map < String , Element > entities ;","title":"variable entities"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Scope/#variable-actors","text":"Actors actors ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable actors"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1SemanticError/","text":"openscenario_interpreter::SemanticError # Inherits from openscenario_interpreter::Error , runtime_error Public Functions # Name template \\<typename ... Ts> SemanticError (Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Error Name Error (Ts &&... xs) Public Functions Documentation # function SemanticError # template < typename ... Ts > inline explicit SemanticError ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::SemanticError"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1SemanticError/#openscenario_interpretersemanticerror","text":"Inherits from openscenario_interpreter::Error , runtime_error","title":"openscenario_interpreter::SemanticError"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1SemanticError/#public-functions","text":"Name template \\<typename ... Ts> SemanticError (Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1SemanticError/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Error Name Error (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1SemanticError/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1SemanticError/#function-semanticerror","text":"template < typename ... Ts > inline explicit SemanticError ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function SemanticError"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1SyntaxError/","text":"openscenario_interpreter::SyntaxError # Inherits from openscenario_interpreter::Error , runtime_error Public Functions # Name template \\<typename ... Ts> SyntaxError (Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Error Name Error (Ts &&... xs) Public Functions Documentation # function SyntaxError # template < typename ... Ts > inline explicit SyntaxError ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::SyntaxError"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1SyntaxError/#openscenario_interpretersyntaxerror","text":"Inherits from openscenario_interpreter::Error , runtime_error","title":"openscenario_interpreter::SyntaxError"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1SyntaxError/#public-functions","text":"Name template \\<typename ... Ts> SyntaxError (Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1SyntaxError/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Error Name Error (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1SyntaxError/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1SyntaxError/#function-syntaxerror","text":"template < typename ... Ts > inline explicit SyntaxError ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function SyntaxError"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Unspecified/","text":"openscenario_interpreter::Unspecified # Public Functions # Name decltype(auto) evaluate () const Public Functions Documentation # function evaluate # inline decltype ( auto ) evaluate () const Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::Unspecified"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Unspecified/#openscenario_interpreterunspecified","text":"","title":"openscenario_interpreter::Unspecified"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Unspecified/#public-functions","text":"Name decltype(auto) evaluate () const","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Unspecified/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1Unspecified/#function-evaluate","text":"inline decltype ( auto ) evaluate () const Updated on 7 April 2021 at 00:31:57 UTC","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1concepts_1_1HasStreamOutputOperator/","text":"openscenario_interpreter::concepts::HasStreamOutputOperator # More... Inherits from false_type Detailed Description # template < typename T , typename = void > struct openscenario_interpreter :: concepts :: HasStreamOutputOperator ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::concepts::HasStreamOutputOperator"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1concepts_1_1HasStreamOutputOperator/#openscenario_interpreterconceptshasstreamoutputoperator","text":"More... Inherits from false_type","title":"openscenario_interpreter::concepts::HasStreamOutputOperator"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1concepts_1_1HasStreamOutputOperator/#detailed-description","text":"template < typename T , typename = void > struct openscenario_interpreter :: concepts :: HasStreamOutputOperator ; Updated on 7 April 2021 at 00:31:57 UTC","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1concepts_1_1HasStreamOutputOperator_3_01T_00_01void__t_3_01dead479c2afca2fd44c2918207f9125367/","text":"openscenario_interpreter::concepts::HasStreamOutputOperator< T, void_t< decltype(std::declval< std::ostream & >()<< std::declval< const T & >())> > # More... Inherits from true_type Detailed Description # template < typename T > struct openscenario_interpreter :: concepts :: HasStreamOutputOperator < T , void_t < decltype ( std :: declval < std :: ostream & > () << std :: declval < const T & > ()) > > ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::concepts::HasStreamOutputOperator< T, void_t< decltype(std::declval< std::ostream & >()<< std::declval< const T & >())> >"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1concepts_1_1HasStreamOutputOperator_3_01T_00_01void__t_3_01dead479c2afca2fd44c2918207f9125367/#openscenario_interpreterconceptshasstreamoutputoperator-t-void_t-decltypestddeclval-stdostream-stddeclval-const-t","text":"More... Inherits from true_type","title":"openscenario_interpreter::concepts::HasStreamOutputOperator&lt; T, void_t&lt; decltype(std::declval&lt; std::ostream &amp; &gt;()&lt;&lt; std::declval&lt; const T &amp; &gt;())&gt; &gt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1concepts_1_1HasStreamOutputOperator_3_01T_00_01void__t_3_01dead479c2afca2fd44c2918207f9125367/#detailed-description","text":"template < typename T > struct openscenario_interpreter :: concepts :: HasStreamOutputOperator < T , void_t < decltype ( std :: declval < std :: ostream & > () << std :: declval < const T & > ()) > > ; Updated on 7 April 2021 at 00:31:57 UTC","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetLane/","text":"openscenario_interpreter::syntax::AbsoluteTargetLane # Public Functions # Name template \\<typename Node ,typename Scope > AbsoluteTargetLane (const Node & node, Scope & scope) Public Attributes # Name const String value Public Functions Documentation # function AbsoluteTargetLane # template < typename Node , typename Scope > inline explicit AbsoluteTargetLane ( const Node & node , Scope & scope ) Public Attributes Documentation # variable value # const String value ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::AbsoluteTargetLane"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetLane/#openscenario_interpretersyntaxabsolutetargetlane","text":"","title":"openscenario_interpreter::syntax::AbsoluteTargetLane"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetLane/#public-functions","text":"Name template \\<typename Node ,typename Scope > AbsoluteTargetLane (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetLane/#public-attributes","text":"Name const String value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetLane/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetLane/#function-absolutetargetlane","text":"template < typename Node , typename Scope > inline explicit AbsoluteTargetLane ( const Node & node , Scope & scope )","title":"function AbsoluteTargetLane"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetLane/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetLane/#variable-value","text":"const String value ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetSpeed/","text":"openscenario_interpreter::syntax::AbsoluteTargetSpeed # Public Functions # Name template \\<typename Node ,typename Scope > AbsoluteTargetSpeed (const Node & node, Scope & scope) Public Attributes # Name const Double value Public Functions Documentation # function AbsoluteTargetSpeed # template < typename Node , typename Scope > inline explicit AbsoluteTargetSpeed ( const Node & node , Scope & scope ) Public Attributes Documentation # variable value # const Double value ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::AbsoluteTargetSpeed"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetSpeed/#openscenario_interpretersyntaxabsolutetargetspeed","text":"","title":"openscenario_interpreter::syntax::AbsoluteTargetSpeed"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetSpeed/#public-functions","text":"Name template \\<typename Node ,typename Scope > AbsoluteTargetSpeed (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetSpeed/#public-attributes","text":"Name const Double value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetSpeed/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetSpeed/#function-absolutetargetspeed","text":"template < typename Node , typename Scope > inline explicit AbsoluteTargetSpeed ( const Node & node , Scope & scope )","title":"function AbsoluteTargetSpeed"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetSpeed/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AbsoluteTargetSpeed/#variable-value","text":"const Double value ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AccelerationCondition/","text":"openscenario_interpreter::syntax::AccelerationCondition # Public Functions # Name auto evaluate () const template \\<typename Node > AccelerationCondition (const Node & node, Scope & outer_scope, const TriggeringEntities & trigger) Public Attributes # Name const Double value const TriggeringEntities trigger const Rule compare Public Functions Documentation # function evaluate # inline auto evaluate () const function AccelerationCondition # template < typename Node > inline explicit AccelerationCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & trigger ) Public Attributes Documentation # variable value # const Double value ; variable trigger # const TriggeringEntities trigger ; variable compare # const Rule compare ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::AccelerationCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AccelerationCondition/#openscenario_interpretersyntaxaccelerationcondition","text":"","title":"openscenario_interpreter::syntax::AccelerationCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AccelerationCondition/#public-functions","text":"Name auto evaluate () const template \\<typename Node > AccelerationCondition (const Node & node, Scope & outer_scope, const TriggeringEntities & trigger)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AccelerationCondition/#public-attributes","text":"Name const Double value const TriggeringEntities trigger const Rule compare","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AccelerationCondition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AccelerationCondition/#function-evaluate","text":"inline auto evaluate () const","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AccelerationCondition/#function-accelerationcondition","text":"template < typename Node > inline explicit AccelerationCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & trigger )","title":"function AccelerationCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AccelerationCondition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AccelerationCondition/#variable-value","text":"const Double value ;","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AccelerationCondition/#variable-trigger","text":"const TriggeringEntities trigger ;","title":"variable trigger"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AccelerationCondition/#variable-compare","text":"const Rule compare ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable compare"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AcquirePositionAction/","text":"openscenario_interpreter::syntax::AcquirePositionAction # Public Functions # Name auto start () auto accomplished () template \\<typename Node > AcquirePositionAction (const Node & node, Scope & outer_scope) Public Attributes # Name const Position position Scope inner_scope std::unordered_map< std::string, Boolean > accomplishments Public Functions Documentation # function start # inline auto start () function accomplished # inline auto accomplished () function AcquirePositionAction # template < typename Node > inline explicit AcquirePositionAction ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable position # const Position position ; variable inner_scope # Scope inner_scope ; variable accomplishments # std :: unordered_map < std :: string , Boolean > accomplishments ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::AcquirePositionAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AcquirePositionAction/#openscenario_interpretersyntaxacquirepositionaction","text":"","title":"openscenario_interpreter::syntax::AcquirePositionAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AcquirePositionAction/#public-functions","text":"Name auto start () auto accomplished () template \\<typename Node > AcquirePositionAction (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AcquirePositionAction/#public-attributes","text":"Name const Position position Scope inner_scope std::unordered_map< std::string, Boolean > accomplishments","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AcquirePositionAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AcquirePositionAction/#function-start","text":"inline auto start ()","title":"function start"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AcquirePositionAction/#function-accomplished","text":"inline auto accomplished ()","title":"function accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AcquirePositionAction/#function-acquirepositionaction","text":"template < typename Node > inline explicit AcquirePositionAction ( const Node & node , Scope & outer_scope )","title":"function AcquirePositionAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AcquirePositionAction/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AcquirePositionAction/#variable-position","text":"const Position position ;","title":"variable position"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AcquirePositionAction/#variable-inner_scope","text":"Scope inner_scope ;","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AcquirePositionAction/#variable-accomplishments","text":"std :: unordered_map < std :: string , Boolean > accomplishments ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable accomplishments"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/","text":"openscenario_interpreter::syntax::Act # Inherits from openscenario_interpreter::syntax::StoryboardElement< Act > , Elements Public Functions # Name auto stopTriggered () const void stop () void run () auto ready () const auto accomplished () const template \\<typename Node > Act (const Node & node, Scope & outer_scope) Public Attributes # Name Element stop_trigger Element start_trigger const String name Scope inner_scope Additional inherited members # Public Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Act > Name const auto & state () const Element override () auto evaluate () auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition ) Protected Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Act > Name auto unique (const std::string & name) auto rename (const std::string & name) const decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs) Public Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Act > Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count Protected Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Act > Name std::unordered_set< std::string > names Public Functions Documentation # function stopTriggered # inline auto stopTriggered () const function stop # inline void stop () function run # inline void run () function ready # inline auto ready () const function accomplished # inline auto accomplished () const function Act # template < typename Node > inline explicit Act ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable stop_trigger # Element stop_trigger ; variable start_trigger # Element start_trigger ; variable name # const String name ; variable inner_scope # Scope inner_scope ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::Act"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#openscenario_interpretersyntaxact","text":"Inherits from openscenario_interpreter::syntax::StoryboardElement< Act > , Elements","title":"openscenario_interpreter::syntax::Act"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#public-functions","text":"Name auto stopTriggered () const void stop () void run () auto ready () const auto accomplished () const template \\<typename Node > Act (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#public-attributes","text":"Name Element stop_trigger Element start_trigger const String name Scope inner_scope","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Act > Name const auto & state () const Element override () auto evaluate () auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition ) Protected Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Act > Name auto unique (const std::string & name) auto rename (const std::string & name) const decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs) Public Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Act > Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count Protected Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Act > Name std::unordered_set< std::string > names","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#function-stoptriggered","text":"inline auto stopTriggered () const","title":"function stopTriggered"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#function-stop","text":"inline void stop ()","title":"function stop"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#function-run","text":"inline void run ()","title":"function run"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#function-ready","text":"inline auto ready () const","title":"function ready"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#function-accomplished","text":"inline auto accomplished () const","title":"function accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#function-act","text":"template < typename Node > inline explicit Act ( const Node & node , Scope & outer_scope )","title":"function Act"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#variable-stop_trigger","text":"Element stop_trigger ;","title":"variable stop_trigger"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#variable-start_trigger","text":"Element start_trigger ;","title":"variable start_trigger"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#variable-name","text":"const String name ;","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Act/#variable-inner_scope","text":"Scope inner_scope ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Action/","text":"openscenario_interpreter::syntax::Action # Inherits from openscenario_interpreter::syntax::StoryboardElement< Action > , openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name constexpr auto stopTriggered () void stop () template \\<typename ... Ts> decltype(auto) run (Ts &&... xs) auto ready () const template \\<typename Node ,typename Scope > Action (const Node & node, Scope & scope, std::size_t maximum_execution_count) Public Attributes # Name Boolean overridden const String name Additional inherited members # Public Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Action > Name const auto & state () const Element override () auto evaluate () auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition ) Protected Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Action > Name auto unique (const std::string & name) auto rename (const std::string & name) const decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs) Public Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Action > Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count Protected Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Action > Name std::unordered_set< std::string > names Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function stopTriggered # static inline constexpr auto stopTriggered () function stop # inline void stop () function run # template < typename ... Ts > inline decltype ( auto ) run ( Ts && ... xs ) function ready # inline auto ready () const function Action # template < typename Node , typename Scope > inline explicit Action ( const Node & node , Scope & scope , std :: size_t maximum_execution_count ) Public Attributes Documentation # variable overridden # Boolean overridden { false }; variable name # const String name ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::Action"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Action/#openscenario_interpretersyntaxaction","text":"Inherits from openscenario_interpreter::syntax::StoryboardElement< Action > , openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::Action"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Action/#public-functions","text":"Name constexpr auto stopTriggered () void stop () template \\<typename ... Ts> decltype(auto) run (Ts &&... xs) auto ready () const template \\<typename Node ,typename Scope > Action (const Node & node, Scope & scope, std::size_t maximum_execution_count)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Action/#public-attributes","text":"Name Boolean overridden const String name","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Action/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Action > Name const auto & state () const Element override () auto evaluate () auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition ) Protected Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Action > Name auto unique (const std::string & name) auto rename (const std::string & name) const decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs) Public Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Action > Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count Protected Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Action > Name std::unordered_set< std::string > names Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Action/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Action/#function-stoptriggered","text":"static inline constexpr auto stopTriggered ()","title":"function stopTriggered"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Action/#function-stop","text":"inline void stop ()","title":"function stop"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Action/#function-run","text":"template < typename ... Ts > inline decltype ( auto ) run ( Ts && ... xs )","title":"function run"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Action/#function-ready","text":"inline auto ready () const","title":"function ready"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Action/#function-action","text":"template < typename Node , typename Scope > inline explicit Action ( const Node & node , Scope & scope , std :: size_t maximum_execution_count )","title":"function Action"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Action/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Action/#variable-overridden","text":"Boolean overridden { false };","title":"variable overridden"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Action/#variable-name","text":"const String name ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Actors/","text":"openscenario_interpreter::syntax::Actors # Public Functions # Name template \\<typename Node ,typename Scope > Actors (const Node & node, Scope & scope) Public Attributes # Name const Boolean select_triggering_entities Public Functions Documentation # function Actors # template < typename Node , typename Scope > inline explicit Actors ( const Node & node , Scope & scope ) Public Attributes Documentation # variable select_triggering_entities # const Boolean select_triggering_entities ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::Actors"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Actors/#openscenario_interpretersyntaxactors","text":"","title":"openscenario_interpreter::syntax::Actors"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Actors/#public-functions","text":"Name template \\<typename Node ,typename Scope > Actors (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Actors/#public-attributes","text":"Name const Boolean select_triggering_entities","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Actors/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Actors/#function-actors","text":"template < typename Node , typename Scope > inline explicit Actors ( const Node & node , Scope & scope )","title":"function Actors"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Actors/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Actors/#variable-select_triggering_entities","text":"const Boolean select_triggering_entities ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable select_triggering_entities"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AddEntityAction/","text":"openscenario_interpreter::syntax::AddEntityAction # Public Functions # Name decltype(auto) operator() (const String & entity_ref) const template \\<typename Node ,typename Scope > AddEntityAction (const Node & node, Scope & outer_scope) Public Attributes # Name const Position position Public Functions Documentation # function operator() # inline decltype ( auto ) operator ()( const String & entity_ref ) const function AddEntityAction # template < typename Node , typename Scope > inline explicit AddEntityAction ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable position # const Position position ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::AddEntityAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AddEntityAction/#openscenario_interpretersyntaxaddentityaction","text":"","title":"openscenario_interpreter::syntax::AddEntityAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AddEntityAction/#public-functions","text":"Name decltype(auto) operator() (const String & entity_ref) const template \\<typename Node ,typename Scope > AddEntityAction (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AddEntityAction/#public-attributes","text":"Name const Position position","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AddEntityAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AddEntityAction/#function-operator","text":"inline decltype ( auto ) operator ()( const String & entity_ref ) const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AddEntityAction/#function-addentityaction","text":"template < typename Node , typename Scope > inline explicit AddEntityAction ( const Node & node , Scope & outer_scope )","title":"function AddEntityAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AddEntityAction/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AddEntityAction/#variable-position","text":"const Position position ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable position"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AdditionalAxle/","text":"openscenario_interpreter::syntax::AdditionalAxle # Inherits from openscenario_interpreter::syntax::Axle Additional inherited members # Public Functions inherited from openscenario_interpreter::syntax::Axle Name Axle () =default Axle (const Node & node, Scope & scope) Public Attributes inherited from openscenario_interpreter::syntax::Axle Name const Double wheel_diameter const Double track_width const Double position_z const Double position_x const Double max_steering Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::AdditionalAxle"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AdditionalAxle/#openscenario_interpretersyntaxadditionalaxle","text":"Inherits from openscenario_interpreter::syntax::Axle","title":"openscenario_interpreter::syntax::AdditionalAxle"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AdditionalAxle/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::syntax::Axle Name Axle () =default Axle (const Node & node, Scope & scope) Public Attributes inherited from openscenario_interpreter::syntax::Axle Name const Double wheel_diameter const Double track_width const Double position_z const Double position_x const Double max_steering Updated on 7 April 2021 at 00:31:57 UTC","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignControllerAction/","text":"openscenario_interpreter::syntax::AssignControllerAction # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name void operator() () const template \\<typename Node > AssignControllerAction (const Node & node, Scope & outer_scope) Public Attributes # Name Scope inner_scope Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function operator() # inline void operator ()() const function AssignControllerAction # template < typename Node > inline explicit AssignControllerAction ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable inner_scope # Scope inner_scope ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::AssignControllerAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignControllerAction/#openscenario_interpretersyntaxassigncontrolleraction","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::AssignControllerAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignControllerAction/#public-functions","text":"Name void operator() () const template \\<typename Node > AssignControllerAction (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignControllerAction/#public-attributes","text":"Name Scope inner_scope","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignControllerAction/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignControllerAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignControllerAction/#function-operator","text":"inline void operator ()() const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignControllerAction/#function-assigncontrolleraction","text":"template < typename Node > inline explicit AssignControllerAction ( const Node & node , Scope & outer_scope )","title":"function AssignControllerAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignControllerAction/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignControllerAction/#variable-inner_scope","text":"Scope inner_scope ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignRouteAction/","text":"openscenario_interpreter::syntax::AssignRouteAction # Public Functions # Name auto start () decltype(auto) operator() (const Scope::Actor & actor) template \\<typename Node > AssignRouteAction (const Node & node, Scope & outer_scope) Public Attributes # Name Element route_or_catalog_reference Scope inner_scope const std::true_type accomplished Public Functions Documentation # function start # inline auto start () function operator() # inline decltype ( auto ) operator ()( const Scope :: Actor & actor ) function AssignRouteAction # template < typename Node > inline explicit AssignRouteAction ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable route_or_catalog_reference # Element route_or_catalog_reference ; variable inner_scope # Scope inner_scope ; variable accomplished # const std :: true_type accomplished {}; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::AssignRouteAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignRouteAction/#openscenario_interpretersyntaxassignrouteaction","text":"","title":"openscenario_interpreter::syntax::AssignRouteAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignRouteAction/#public-functions","text":"Name auto start () decltype(auto) operator() (const Scope::Actor & actor) template \\<typename Node > AssignRouteAction (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignRouteAction/#public-attributes","text":"Name Element route_or_catalog_reference Scope inner_scope const std::true_type accomplished","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignRouteAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignRouteAction/#function-start","text":"inline auto start ()","title":"function start"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignRouteAction/#function-operator","text":"inline decltype ( auto ) operator ()( const Scope :: Actor & actor )","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignRouteAction/#function-assignrouteaction","text":"template < typename Node > inline explicit AssignRouteAction ( const Node & node , Scope & outer_scope )","title":"function AssignRouteAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignRouteAction/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignRouteAction/#variable-route_or_catalog_reference","text":"Element route_or_catalog_reference ;","title":"variable route_or_catalog_reference"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignRouteAction/#variable-inner_scope","text":"Scope inner_scope ;","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1AssignRouteAction/#variable-accomplished","text":"const std :: true_type accomplished {}; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axle/","text":"openscenario_interpreter::syntax::Axle # Inherited by openscenario_interpreter::syntax::AdditionalAxle , openscenario_interpreter::syntax::FrontAxle , openscenario_interpreter::syntax::RearAxle Public Functions # Name Axle () =default template \\<typename Node ,typename Scope > Axle (const Node & node, Scope & scope) Public Attributes # Name const Double wheel_diameter const Double track_width const Double position_z const Double position_x const Double max_steering Public Functions Documentation # function Axle # Axle () = default function Axle # template < typename Node , typename Scope > inline explicit Axle ( const Node & node , Scope & scope ) Public Attributes Documentation # variable wheel_diameter # const Double wheel_diameter ; variable track_width # const Double track_width ; variable position_z # const Double position_z ; variable position_x # const Double position_x ; variable max_steering # const Double max_steering ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::Axle"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axle/#openscenario_interpretersyntaxaxle","text":"Inherited by openscenario_interpreter::syntax::AdditionalAxle , openscenario_interpreter::syntax::FrontAxle , openscenario_interpreter::syntax::RearAxle","title":"openscenario_interpreter::syntax::Axle"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axle/#public-functions","text":"Name Axle () =default template \\<typename Node ,typename Scope > Axle (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axle/#public-attributes","text":"Name const Double wheel_diameter const Double track_width const Double position_z const Double position_x const Double max_steering","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axle/#function-axle","text":"Axle () = default","title":"function Axle"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axle/#function-axle_1","text":"template < typename Node , typename Scope > inline explicit Axle ( const Node & node , Scope & scope )","title":"function Axle"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axle/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axle/#variable-wheel_diameter","text":"const Double wheel_diameter ;","title":"variable wheel_diameter"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axle/#variable-track_width","text":"const Double track_width ;","title":"variable track_width"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axle/#variable-position_z","text":"const Double position_z ;","title":"variable position_z"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axle/#variable-position_x","text":"const Double position_x ;","title":"variable position_x"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axle/#variable-max_steering","text":"const Double max_steering ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable max_steering"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axles/","text":"openscenario_interpreter::syntax::Axles # Public Functions # Name Axles () =default template \\<typename Node ,typename Scope > Axles (const Node & node, Scope & scope) Public Attributes # Name const RearAxle rear_axle const FrontAxle front_axle std::vector< AdditionalAxle > additional_axles Public Functions Documentation # function Axles # Axles () = default function Axles # template < typename Node , typename Scope > inline explicit Axles ( const Node & node , Scope & scope ) Public Attributes Documentation # variable rear_axle # const RearAxle rear_axle ; variable front_axle # const FrontAxle front_axle ; variable additional_axles # std :: vector < AdditionalAxle > additional_axles ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::Axles"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axles/#openscenario_interpretersyntaxaxles","text":"","title":"openscenario_interpreter::syntax::Axles"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axles/#public-functions","text":"Name Axles () =default template \\<typename Node ,typename Scope > Axles (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axles/#public-attributes","text":"Name const RearAxle rear_axle const FrontAxle front_axle std::vector< AdditionalAxle > additional_axles","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axles/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axles/#function-axles","text":"Axles () = default","title":"function Axles"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axles/#function-axles_1","text":"template < typename Node , typename Scope > inline explicit Axles ( const Node & node , Scope & scope )","title":"function Axles"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axles/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axles/#variable-rear_axle","text":"const RearAxle rear_axle ;","title":"variable rear_axle"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axles/#variable-front_axle","text":"const FrontAxle front_axle ;","title":"variable front_axle"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Axles/#variable-additional_axles","text":"std :: vector < AdditionalAxle > additional_axles ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable additional_axles"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Boolean/","text":"openscenario_interpreter::syntax::Boolean # Public Types # Name using bool value_type Public Functions # Name auto & operator= (const value_type & rhs) constexpr operator value_type () const constexpr Boolean (value_type value =false) Boolean (const std::string & target) Public Attributes # Name value_type data Public Types Documentation # using value_type # using openscenario_interpreter :: syntax :: Boolean :: value_type = bool ; Public Functions Documentation # function operator= # inline auto & operator = ( const value_type & rhs ) function operator value_type # inline constexpr operator value_type () const function Boolean # inline explicit constexpr Boolean ( value_type value = false ) function Boolean # inline explicit Boolean ( const std :: string & target ) Public Attributes Documentation # variable data # value_type data ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::Boolean"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Boolean/#openscenario_interpretersyntaxboolean","text":"","title":"openscenario_interpreter::syntax::Boolean"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Boolean/#public-types","text":"Name using bool value_type","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Boolean/#public-functions","text":"Name auto & operator= (const value_type & rhs) constexpr operator value_type () const constexpr Boolean (value_type value =false) Boolean (const std::string & target)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Boolean/#public-attributes","text":"Name value_type data","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Boolean/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Boolean/#using-value_type","text":"using openscenario_interpreter :: syntax :: Boolean :: value_type = bool ;","title":"using value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Boolean/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Boolean/#function-operator","text":"inline auto & operator = ( const value_type & rhs )","title":"function operator="},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Boolean/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Boolean/#function-boolean","text":"inline explicit constexpr Boolean ( value_type value = false )","title":"function Boolean"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Boolean/#function-boolean_1","text":"inline explicit Boolean ( const std :: string & target )","title":"function Boolean"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Boolean/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Boolean/#variable-data","text":"value_type data ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable data"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1BoundingBox/","text":"openscenario_interpreter::syntax::BoundingBox # Public Functions # Name BoundingBox () =default template \\<typename Node ,typename Scope > BoundingBox (const Node & node, Scope & scope) Public Attributes # Name const Dimensions dimensions const Center center Public Functions Documentation # function BoundingBox # BoundingBox () = default function BoundingBox # template < typename Node , typename Scope > inline explicit BoundingBox ( const Node & node , Scope & scope ) Public Attributes Documentation # variable dimensions # const Dimensions dimensions ; variable center # const Center center ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::BoundingBox"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1BoundingBox/#openscenario_interpretersyntaxboundingbox","text":"","title":"openscenario_interpreter::syntax::BoundingBox"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1BoundingBox/#public-functions","text":"Name BoundingBox () =default template \\<typename Node ,typename Scope > BoundingBox (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1BoundingBox/#public-attributes","text":"Name const Dimensions dimensions const Center center","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1BoundingBox/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1BoundingBox/#function-boundingbox","text":"BoundingBox () = default","title":"function BoundingBox"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1BoundingBox/#function-boundingbox_1","text":"template < typename Node , typename Scope > inline explicit BoundingBox ( const Node & node , Scope & scope )","title":"function BoundingBox"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1BoundingBox/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1BoundingBox/#variable-dimensions","text":"const Dimensions dimensions ;","title":"variable dimensions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1BoundingBox/#variable-center","text":"const Center center ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable center"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByEntityCondition/","text":"openscenario_interpreter::syntax::ByEntityCondition # Public Functions # Name template \\<typename ... Ts> auto evaluate (Ts &&... xs) const template \\<typename Node > ByEntityCondition (const Node & node, Scope & outer_scope) Public Attributes # Name Scope inner_scope const EntityCondition entity_condition Public Functions Documentation # function evaluate # template < typename ... Ts > inline auto evaluate ( Ts && ... xs ) const function ByEntityCondition # template < typename Node > inline explicit ByEntityCondition ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable inner_scope # Scope inner_scope ; variable entity_condition # const EntityCondition entity_condition ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::ByEntityCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByEntityCondition/#openscenario_interpretersyntaxbyentitycondition","text":"","title":"openscenario_interpreter::syntax::ByEntityCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByEntityCondition/#public-functions","text":"Name template \\<typename ... Ts> auto evaluate (Ts &&... xs) const template \\<typename Node > ByEntityCondition (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByEntityCondition/#public-attributes","text":"Name Scope inner_scope const EntityCondition entity_condition","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByEntityCondition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByEntityCondition/#function-evaluate","text":"template < typename ... Ts > inline auto evaluate ( Ts && ... xs ) const","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByEntityCondition/#function-byentitycondition","text":"template < typename Node > inline explicit ByEntityCondition ( const Node & node , Scope & outer_scope )","title":"function ByEntityCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByEntityCondition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByEntityCondition/#variable-inner_scope","text":"Scope inner_scope ;","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByEntityCondition/#variable-entity_condition","text":"const EntityCondition entity_condition ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable entity_condition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByType/","text":"openscenario_interpreter::syntax::ByType # Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::ByType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByType/#openscenario_interpretersyntaxbytype","text":"Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::ByType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByValueCondition/","text":"openscenario_interpreter::syntax::ByValueCondition # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name template \\<typename Node ,typename ... Ts> ByValueCondition (const Node & node, Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function ByValueCondition # template < typename Node , typename ... Ts > inline explicit ByValueCondition ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::ByValueCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByValueCondition/#openscenario_interpretersyntaxbyvaluecondition","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::ByValueCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByValueCondition/#public-functions","text":"Name template \\<typename Node ,typename ... Ts> ByValueCondition (const Node & node, Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByValueCondition/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByValueCondition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ByValueCondition/#function-byvaluecondition","text":"template < typename Node , typename ... Ts > inline explicit ByValueCondition ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function ByValueCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CatalogLocation/","text":"openscenario_interpreter::syntax::CatalogLocation # Public Functions # Name template \\<typename Node ,typename Scope > CatalogLocation (const Node & node, Scope & outer_scope) Public Attributes # Name const Directory directory Public Functions Documentation # function CatalogLocation # template < typename Node , typename Scope > inline explicit CatalogLocation ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable directory # const Directory directory ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::CatalogLocation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CatalogLocation/#openscenario_interpretersyntaxcataloglocation","text":"","title":"openscenario_interpreter::syntax::CatalogLocation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CatalogLocation/#public-functions","text":"Name template \\<typename Node ,typename Scope > CatalogLocation (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CatalogLocation/#public-attributes","text":"Name const Directory directory","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CatalogLocation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CatalogLocation/#function-cataloglocation","text":"template < typename Node , typename Scope > inline explicit CatalogLocation ( const Node & node , Scope & outer_scope )","title":"function CatalogLocation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CatalogLocation/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CatalogLocation/#variable-directory","text":"const Directory directory ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable directory"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CatalogLocations/","text":"openscenario_interpreter::syntax::CatalogLocations # Inherits from std::unordered_map< String, CatalogLocation > Public Functions # Name template \\<typename Node ,typename Scope > CatalogLocations (const Node & node, Scope & outer_scope) Public Functions Documentation # function CatalogLocations # template < typename Node , typename Scope > inline explicit CatalogLocations ( const Node & node , Scope & outer_scope ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::CatalogLocations"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CatalogLocations/#openscenario_interpretersyntaxcataloglocations","text":"Inherits from std::unordered_map< String, CatalogLocation >","title":"openscenario_interpreter::syntax::CatalogLocations"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CatalogLocations/#public-functions","text":"Name template \\<typename Node ,typename Scope > CatalogLocations (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CatalogLocations/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CatalogLocations/#function-cataloglocations","text":"template < typename Node , typename Scope > inline explicit CatalogLocations ( const Node & node , Scope & outer_scope ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function CatalogLocations"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Center/","text":"openscenario_interpreter::syntax::Center # Public Functions # Name Center () =default template \\<typename Node ,typename Scope > Center (const Node & node, Scope & scope) Public Attributes # Name const Double z const Double y const Double x Public Functions Documentation # function Center # Center () = default function Center # template < typename Node , typename Scope > inline explicit Center ( const Node & node , Scope & scope ) Public Attributes Documentation # variable z # const Double z ; variable y # const Double y ; variable x # const Double x ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::Center"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Center/#openscenario_interpretersyntaxcenter","text":"","title":"openscenario_interpreter::syntax::Center"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Center/#public-functions","text":"Name Center () =default template \\<typename Node ,typename Scope > Center (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Center/#public-attributes","text":"Name const Double z const Double y const Double x","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Center/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Center/#function-center","text":"Center () = default","title":"function Center"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Center/#function-center_1","text":"template < typename Node , typename Scope > inline explicit Center ( const Node & node , Scope & scope )","title":"function Center"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Center/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Center/#variable-z","text":"const Double z ;","title":"variable z"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Center/#variable-y","text":"const Double y ;","title":"variable y"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Center/#variable-x","text":"const Double x ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable x"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CollisionCondition/","text":"openscenario_interpreter::syntax::CollisionCondition # Public Functions # Name auto evaluate () const template \\<typename Node ,typename Scope > CollisionCondition (const Node & node, Scope & scope, const TriggeringEntities & triggering_entities) Public Attributes # Name const Element given const TriggeringEntities for_each Public Functions Documentation # function evaluate # inline auto evaluate () const function CollisionCondition # template < typename Node , typename Scope > inline explicit CollisionCondition ( const Node & node , Scope & scope , const TriggeringEntities & triggering_entities ) Public Attributes Documentation # variable given # const Element given ; variable for_each # const TriggeringEntities for_each ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::CollisionCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CollisionCondition/#openscenario_interpretersyntaxcollisioncondition","text":"","title":"openscenario_interpreter::syntax::CollisionCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CollisionCondition/#public-functions","text":"Name auto evaluate () const template \\<typename Node ,typename Scope > CollisionCondition (const Node & node, Scope & scope, const TriggeringEntities & triggering_entities)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CollisionCondition/#public-attributes","text":"Name const Element given const TriggeringEntities for_each","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CollisionCondition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CollisionCondition/#function-evaluate","text":"inline auto evaluate () const","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CollisionCondition/#function-collisioncondition","text":"template < typename Node , typename Scope > inline explicit CollisionCondition ( const Node & node , Scope & scope , const TriggeringEntities & triggering_entities )","title":"function CollisionCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CollisionCondition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CollisionCondition/#variable-given","text":"const Element given ;","title":"variable given"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CollisionCondition/#variable-for_each","text":"const TriggeringEntities for_each ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable for_each"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Command/","text":"openscenario_interpreter::syntax::Command # Public Types # Name enum value_type { print, nop, exitSuccess, exitFailure } Public Functions # Name decltype(auto) operator= (const value_type & rhs) constexpr operator value_type () const constexpr Command (value_type value ={}) Public Attributes # Name enum openscenario_interpreter::syntax::Command::value_type value Public Types Documentation # enum value_type # Enumerator Value Description print nop exitSuccess exitFailure Public Functions Documentation # function operator= # inline decltype ( auto ) operator = ( const value_type & rhs ) function operator value_type # inline constexpr operator value_type () const function Command # inline explicit constexpr Command ( value_type value = {} ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: Command :: value_type value ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::Command"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Command/#openscenario_interpretersyntaxcommand","text":"","title":"openscenario_interpreter::syntax::Command"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Command/#public-types","text":"Name enum value_type { print, nop, exitSuccess, exitFailure }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Command/#public-functions","text":"Name decltype(auto) operator= (const value_type & rhs) constexpr operator value_type () const constexpr Command (value_type value ={})","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Command/#public-attributes","text":"Name enum openscenario_interpreter::syntax::Command::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Command/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Command/#enum-value_type","text":"Enumerator Value Description print nop exitSuccess exitFailure","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Command/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Command/#function-operator","text":"inline decltype ( auto ) operator = ( const value_type & rhs )","title":"function operator="},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Command/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Command/#function-command","text":"inline explicit constexpr Command ( value_type value = {} )","title":"function Command"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Command/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Command/#variable-value","text":"enum openscenario_interpreter :: syntax :: Command :: value_type value ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Condition/","text":"openscenario_interpreter::syntax::Condition # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name const auto & evaluate () template \\<typename Node ,typename Scope > Condition (const Node & node, Scope & scope) Public Attributes # Name Element result const String name const Double delay const ConditionEdge condition_edge Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function evaluate # inline const auto & evaluate () function Condition # template < typename Node , typename Scope > inline explicit Condition ( const Node & node , Scope & scope ) Public Attributes Documentation # variable result # Element result = false_v ; variable name # const String name ; variable delay # const Double delay ; variable condition_edge # const ConditionEdge condition_edge ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::Condition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Condition/#openscenario_interpretersyntaxcondition","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::Condition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Condition/#public-functions","text":"Name const auto & evaluate () template \\<typename Node ,typename Scope > Condition (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Condition/#public-attributes","text":"Name Element result const String name const Double delay const ConditionEdge condition_edge","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Condition/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Condition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Condition/#function-evaluate","text":"inline const auto & evaluate ()","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Condition/#function-condition","text":"template < typename Node , typename Scope > inline explicit Condition ( const Node & node , Scope & scope )","title":"function Condition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Condition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Condition/#variable-result","text":"Element result = false_v ;","title":"variable result"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Condition/#variable-name","text":"const String name ;","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Condition/#variable-delay","text":"const Double delay ;","title":"variable delay"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Condition/#variable-condition_edge","text":"const ConditionEdge condition_edge ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable condition_edge"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionEdge/","text":"openscenario_interpreter::syntax::ConditionEdge # Public Types # Name enum value_type { sticky, risingOrFalling, rising, none, falling } Public Functions # Name operator value_type () const constexpr ConditionEdge (const value_type value ={}) Public Attributes # Name enum openscenario_interpreter::syntax::ConditionEdge::value_type value Public Types Documentation # enum value_type # Enumerator Value Description sticky risingOrFalling rising none falling Public Functions Documentation # function operator value_type # inline operator value_type () const function ConditionEdge # inline explicit constexpr ConditionEdge ( const value_type value = {} ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: ConditionEdge :: value_type value ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::ConditionEdge"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionEdge/#openscenario_interpretersyntaxconditionedge","text":"","title":"openscenario_interpreter::syntax::ConditionEdge"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionEdge/#public-types","text":"Name enum value_type { sticky, risingOrFalling, rising, none, falling }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionEdge/#public-functions","text":"Name operator value_type () const constexpr ConditionEdge (const value_type value ={})","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionEdge/#public-attributes","text":"Name enum openscenario_interpreter::syntax::ConditionEdge::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionEdge/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionEdge/#enum-value_type","text":"Enumerator Value Description sticky risingOrFalling rising none falling","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionEdge/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionEdge/#function-operator-value_type","text":"inline operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionEdge/#function-conditionedge","text":"inline explicit constexpr ConditionEdge ( const value_type value = {} )","title":"function ConditionEdge"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionEdge/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionEdge/#variable-value","text":"enum openscenario_interpreter :: syntax :: ConditionEdge :: value_type value ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionGroup/","text":"openscenario_interpreter::syntax::ConditionGroup # Inherits from std::vector< Condition > Public Functions # Name auto evaluate () template \\<typename Node ,typename Scope > ConditionGroup (const Node & node, Scope & scope) Public Functions Documentation # function evaluate # inline auto evaluate () function ConditionGroup # template < typename Node , typename Scope > inline explicit ConditionGroup ( const Node & node , Scope & scope ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::ConditionGroup"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionGroup/#openscenario_interpretersyntaxconditiongroup","text":"Inherits from std::vector< Condition >","title":"openscenario_interpreter::syntax::ConditionGroup"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionGroup/#public-functions","text":"Name auto evaluate () template \\<typename Node ,typename Scope > ConditionGroup (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionGroup/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionGroup/#function-evaluate","text":"inline auto evaluate ()","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ConditionGroup/#function-conditiongroup","text":"template < typename Node , typename Scope > inline explicit ConditionGroup ( const Node & node , Scope & scope ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function ConditionGroup"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/","text":"openscenario_interpreter::syntax::Controller # Public Types # Name using String Name Public Functions # Name template \\<typename ... Ts> decltype(auto) operator[] (Ts &&... xs) operator openscenario_msgs::msg::DriverModel () template \\<typename Node ,typename Scope > Controller (const Node & node, Scope & outer_scope) Public Attributes # Name Properties properties const ParameterDeclarations parameter_declarations const Name name Scope inner_scope Public Types Documentation # using Name # using openscenario_interpreter :: syntax :: Controller :: Name = String ; Public Functions Documentation # function operator[] # template < typename ... Ts > inline decltype ( auto ) operator []( Ts && ... xs ) function operator openscenario_msgs::msg::DriverModel # inline operator openscenario_msgs :: msg :: DriverModel () function Controller # template < typename Node , typename Scope > inline explicit Controller ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable properties # Properties properties ; variable parameter_declarations # const ParameterDeclarations parameter_declarations ; variable name # const Name name ; variable inner_scope # Scope inner_scope ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::Controller"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/#openscenario_interpretersyntaxcontroller","text":"","title":"openscenario_interpreter::syntax::Controller"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/#public-types","text":"Name using String Name","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/#public-functions","text":"Name template \\<typename ... Ts> decltype(auto) operator[] (Ts &&... xs) operator openscenario_msgs::msg::DriverModel () template \\<typename Node ,typename Scope > Controller (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/#public-attributes","text":"Name Properties properties const ParameterDeclarations parameter_declarations const Name name Scope inner_scope","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/#using-name","text":"using openscenario_interpreter :: syntax :: Controller :: Name = String ;","title":"using Name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/#function-operator","text":"template < typename ... Ts > inline decltype ( auto ) operator []( Ts && ... xs )","title":"function operator[]"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/#function-operator-openscenario_msgsmsgdrivermodel","text":"inline operator openscenario_msgs :: msg :: DriverModel ()","title":"function operator openscenario_msgs::msg::DriverModel"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/#function-controller","text":"template < typename Node , typename Scope > inline explicit Controller ( const Node & node , Scope & outer_scope )","title":"function Controller"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/#variable-properties","text":"Properties properties ;","title":"variable properties"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/#variable-parameter_declarations","text":"const ParameterDeclarations parameter_declarations ;","title":"variable parameter_declarations"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/#variable-name","text":"const Name name ;","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Controller/#variable-inner_scope","text":"Scope inner_scope ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ControllerAction/","text":"openscenario_interpreter::syntax::ControllerAction # Public Functions # Name void start () const template \\<typename Node ,typename Scope > ControllerAction (const Node & node, Scope & outer_scope) Public Attributes # Name const OverrideControllerValueAction override_controller_value_action const AssignControllerAction assignController const std::true_type accomplished Public Functions Documentation # function start # inline void start () const function ControllerAction # template < typename Node , typename Scope > inline explicit ControllerAction ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable override_controller_value_action # const OverrideControllerValueAction override_controller_value_action ; variable assignController # const AssignControllerAction assignController ; variable accomplished # const std :: true_type accomplished {}; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::ControllerAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ControllerAction/#openscenario_interpretersyntaxcontrolleraction","text":"","title":"openscenario_interpreter::syntax::ControllerAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ControllerAction/#public-functions","text":"Name void start () const template \\<typename Node ,typename Scope > ControllerAction (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ControllerAction/#public-attributes","text":"Name const OverrideControllerValueAction override_controller_value_action const AssignControllerAction assignController const std::true_type accomplished","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ControllerAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ControllerAction/#function-start","text":"inline void start () const","title":"function start"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ControllerAction/#function-controlleraction","text":"template < typename Node , typename Scope > inline explicit ControllerAction ( const Node & node , Scope & outer_scope )","title":"function ControllerAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ControllerAction/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ControllerAction/#variable-override_controller_value_action","text":"const OverrideControllerValueAction override_controller_value_action ;","title":"variable override_controller_value_action"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ControllerAction/#variable-assigncontroller","text":"const AssignControllerAction assignController ;","title":"variable assignController"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ControllerAction/#variable-accomplished","text":"const std :: true_type accomplished {}; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/","text":"openscenario_interpreter::syntax::CustomCommandAction # Public Functions # Name int walkStraightAction (const std::vector< std::string > & actors, const Scope & current_scope) int test (const std::vector< std::string > & args, const Scope & ) auto split (const std::string & s) int segv (const std::vector< std::string > & , const Scope & ) int exitSuccess (const std::vector< std::string > & , const Scope & ) int exitFailure (const std::vector< std::string > & , const Scope & ) auto evaluate () int error (const std::vector< std::string > & , const Scope & ) template \\<typename Node > CustomCommandAction (const Node & node, const Scope & outer_scope) Public Attributes # Name const String type Scope inner_scope const String content const std::unordered_map< std::string, std::function< int(const std::vector< std::string > &, const Scope &)> > builtins const std::true_type accomplished Friends # Name std::ostream & operator<< (std::ostream & os, const CustomCommandAction & action) Public Functions Documentation # function walkStraightAction # static inline int walkStraightAction ( const std :: vector < std :: string > & actors , const Scope & current_scope ) function test # static inline int test ( const std :: vector < std :: string > & args , const Scope & ) function split # static inline auto split ( const std :: string & s ) function segv # static inline int segv ( const std :: vector < std :: string > & , const Scope & ) function exitSuccess # static inline int exitSuccess ( const std :: vector < std :: string > & , const Scope & ) function exitFailure # static inline int exitFailure ( const std :: vector < std :: string > & , const Scope & ) function evaluate # inline auto evaluate () function error # static inline int error ( const std :: vector < std :: string > & , const Scope & ) function CustomCommandAction # template < typename Node > inline explicit CustomCommandAction ( const Node & node , const Scope & outer_scope ) Public Attributes Documentation # variable type # const String type ; variable inner_scope # Scope inner_scope ; variable content # const String content ; variable builtins # const std :: unordered_map < std :: string , std :: function < int ( const std :: vector < std :: string > & , const Scope & ) > > builtins { std :: make_pair ( \"WalkStraightAction\" , walkStraightAction ), std :: make_pair ( \"error\" , error ), std :: make_pair ( \"exitFailure\" , exitFailure ), std :: make_pair ( \"exitSuccess\" , exitSuccess ), std :: make_pair ( \"sigsegv\" , segv ), std :: make_pair ( \"test\" , test ), }; variable accomplished # const std :: true_type accomplished {}; Friends # friend operator<< # friend std :: ostream & operator << ( std :: ostream & os , const CustomCommandAction & action ); Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::CustomCommandAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#openscenario_interpretersyntaxcustomcommandaction","text":"","title":"openscenario_interpreter::syntax::CustomCommandAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#public-functions","text":"Name int walkStraightAction (const std::vector< std::string > & actors, const Scope & current_scope) int test (const std::vector< std::string > & args, const Scope & ) auto split (const std::string & s) int segv (const std::vector< std::string > & , const Scope & ) int exitSuccess (const std::vector< std::string > & , const Scope & ) int exitFailure (const std::vector< std::string > & , const Scope & ) auto evaluate () int error (const std::vector< std::string > & , const Scope & ) template \\<typename Node > CustomCommandAction (const Node & node, const Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#public-attributes","text":"Name const String type Scope inner_scope const String content const std::unordered_map< std::string, std::function< int(const std::vector< std::string > &, const Scope &)> > builtins const std::true_type accomplished","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#friends","text":"Name std::ostream & operator<< (std::ostream & os, const CustomCommandAction & action)","title":"Friends"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#function-walkstraightaction","text":"static inline int walkStraightAction ( const std :: vector < std :: string > & actors , const Scope & current_scope )","title":"function walkStraightAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#function-test","text":"static inline int test ( const std :: vector < std :: string > & args , const Scope & )","title":"function test"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#function-split","text":"static inline auto split ( const std :: string & s )","title":"function split"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#function-segv","text":"static inline int segv ( const std :: vector < std :: string > & , const Scope & )","title":"function segv"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#function-exitsuccess","text":"static inline int exitSuccess ( const std :: vector < std :: string > & , const Scope & )","title":"function exitSuccess"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#function-exitfailure","text":"static inline int exitFailure ( const std :: vector < std :: string > & , const Scope & )","title":"function exitFailure"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#function-evaluate","text":"inline auto evaluate ()","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#function-error","text":"static inline int error ( const std :: vector < std :: string > & , const Scope & )","title":"function error"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#function-customcommandaction","text":"template < typename Node > inline explicit CustomCommandAction ( const Node & node , const Scope & outer_scope )","title":"function CustomCommandAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#variable-type","text":"const String type ;","title":"variable type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#variable-inner_scope","text":"Scope inner_scope ;","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#variable-content","text":"const String content ;","title":"variable content"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#variable-builtins","text":"const std :: unordered_map < std :: string , std :: function < int ( const std :: vector < std :: string > & , const Scope & ) > > builtins { std :: make_pair ( \"WalkStraightAction\" , walkStraightAction ), std :: make_pair ( \"error\" , error ), std :: make_pair ( \"exitFailure\" , exitFailure ), std :: make_pair ( \"exitSuccess\" , exitSuccess ), std :: make_pair ( \"sigsegv\" , segv ), std :: make_pair ( \"test\" , test ), };","title":"variable builtins"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#variable-accomplished","text":"const std :: true_type accomplished {};","title":"variable accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#friends_1","text":"","title":"Friends"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1CustomCommandAction/#friend-operator","text":"friend std :: ostream & operator << ( std :: ostream & os , const CustomCommandAction & action ); Updated on 7 April 2021 at 00:31:57 UTC","title":"friend operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DeleteEntityAction/","text":"openscenario_interpreter::syntax::DeleteEntityAction # Public Functions # Name decltype(auto) operator() (const String & entity_ref) const template \\<typename ... Ts> DeleteEntityAction (Ts && ...) Public Functions Documentation # function operator() # inline decltype ( auto ) operator ()( const String & entity_ref ) const function DeleteEntityAction # template < typename ... Ts > inline explicit DeleteEntityAction ( Ts && ... ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::DeleteEntityAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DeleteEntityAction/#openscenario_interpretersyntaxdeleteentityaction","text":"","title":"openscenario_interpreter::syntax::DeleteEntityAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DeleteEntityAction/#public-functions","text":"Name decltype(auto) operator() (const String & entity_ref) const template \\<typename ... Ts> DeleteEntityAction (Ts && ...)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DeleteEntityAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DeleteEntityAction/#function-operator","text":"inline decltype ( auto ) operator ()( const String & entity_ref ) const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DeleteEntityAction/#function-deleteentityaction","text":"template < typename ... Ts > inline explicit DeleteEntityAction ( Ts && ... ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function DeleteEntityAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Dimensions/","text":"openscenario_interpreter::syntax::Dimensions # Public Functions # Name Dimensions () =default template \\<typename Node ,typename Scope > Dimensions (const Node & node, Scope & scope) Public Attributes # Name const Double width const Double length const Double height Public Functions Documentation # function Dimensions # Dimensions () = default function Dimensions # template < typename Node , typename Scope > inline explicit Dimensions ( const Node & node , Scope & scope ) Public Attributes Documentation # variable width # const Double width ; variable length # const Double length ; variable height # const Double height ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::Dimensions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Dimensions/#openscenario_interpretersyntaxdimensions","text":"","title":"openscenario_interpreter::syntax::Dimensions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Dimensions/#public-functions","text":"Name Dimensions () =default template \\<typename Node ,typename Scope > Dimensions (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Dimensions/#public-attributes","text":"Name const Double width const Double length const Double height","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Dimensions/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Dimensions/#function-dimensions","text":"Dimensions () = default","title":"function Dimensions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Dimensions/#function-dimensions_1","text":"template < typename Node , typename Scope > inline explicit Dimensions ( const Node & node , Scope & scope )","title":"function Dimensions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Dimensions/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Dimensions/#variable-width","text":"const Double width ;","title":"variable width"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Dimensions/#variable-length","text":"const Double length ;","title":"variable length"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Dimensions/#variable-height","text":"const Double height ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable height"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Directory/","text":"openscenario_interpreter::syntax::Directory # Public Functions # Name template \\<typename Node ,typename Scope > Directory (const Node & node, Scope & outer_scope) Public Attributes # Name const String path Public Functions Documentation # function Directory # template < typename Node , typename Scope > inline explicit Directory ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable path # const String path ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::Directory"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Directory/#openscenario_interpretersyntaxdirectory","text":"","title":"openscenario_interpreter::syntax::Directory"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Directory/#public-functions","text":"Name template \\<typename Node ,typename Scope > Directory (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Directory/#public-attributes","text":"Name const String path","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Directory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Directory/#function-directory","text":"template < typename Node , typename Scope > inline explicit Directory ( const Node & node , Scope & outer_scope )","title":"function Directory"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Directory/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Directory/#variable-path","text":"const String path ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable path"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DistanceCondition/","text":"openscenario_interpreter::syntax::DistanceCondition # Public Functions # Name auto evaluate () template \\<typename Node > DistanceCondition (const Node & node, Scope & outer_scope, const TriggeringEntities & triggering_entities) Public Attributes # Name const Double value const Position position const Boolean freespace const TriggeringEntities for_each const Rule compare const Boolean along_route Public Functions Documentation # function evaluate # inline auto evaluate () function DistanceCondition # template < typename Node > inline explicit DistanceCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & triggering_entities ) Public Attributes Documentation # variable value # const Double value ; variable position # const Position position ; variable freespace # const Boolean freespace ; variable for_each # const TriggeringEntities for_each ; variable compare # const Rule compare ; variable along_route # const Boolean along_route ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::DistanceCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DistanceCondition/#openscenario_interpretersyntaxdistancecondition","text":"","title":"openscenario_interpreter::syntax::DistanceCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DistanceCondition/#public-functions","text":"Name auto evaluate () template \\<typename Node > DistanceCondition (const Node & node, Scope & outer_scope, const TriggeringEntities & triggering_entities)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DistanceCondition/#public-attributes","text":"Name const Double value const Position position const Boolean freespace const TriggeringEntities for_each const Rule compare const Boolean along_route","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DistanceCondition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DistanceCondition/#function-evaluate","text":"inline auto evaluate ()","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DistanceCondition/#function-distancecondition","text":"template < typename Node > inline explicit DistanceCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & triggering_entities )","title":"function DistanceCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DistanceCondition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DistanceCondition/#variable-value","text":"const Double value ;","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DistanceCondition/#variable-position","text":"const Position position ;","title":"variable position"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DistanceCondition/#variable-freespace","text":"const Boolean freespace ;","title":"variable freespace"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DistanceCondition/#variable-for_each","text":"const TriggeringEntities for_each ;","title":"variable for_each"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DistanceCondition/#variable-compare","text":"const Rule compare ;","title":"variable compare"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DistanceCondition/#variable-along_route","text":"const Boolean along_route ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable along_route"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Double/","text":"openscenario_interpreter::syntax::Double # Inherits from Float64 Public Types # Name using decltype(std_msgs::msg::Float64::data) value_type Public Functions # Name auto & operator+= (const double & rhs) auto & operator*= (const double & rhs) constexpr operator value_type () const auto infinity () Double (value_type value ={}) Double (const std::string & s) Public Types Documentation # using value_type # using openscenario_interpreter :: syntax :: Double :: value_type = decltype ( std_msgs :: msg :: Float64 :: data ); Public Functions Documentation # function operator+= # inline auto & operator += ( const double & rhs ) function operator*= # inline auto & operator *= ( const double & rhs ) function operator value_type # inline constexpr operator value_type () const function infinity # static inline auto infinity () function Double # inline explicit Double ( value_type value = {} ) function Double # inline explicit Double ( const std :: string & s ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::Double"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Double/#openscenario_interpretersyntaxdouble","text":"Inherits from Float64","title":"openscenario_interpreter::syntax::Double"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Double/#public-types","text":"Name using decltype(std_msgs::msg::Float64::data) value_type","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Double/#public-functions","text":"Name auto & operator+= (const double & rhs) auto & operator*= (const double & rhs) constexpr operator value_type () const auto infinity () Double (value_type value ={}) Double (const std::string & s)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Double/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Double/#using-value_type","text":"using openscenario_interpreter :: syntax :: Double :: value_type = decltype ( std_msgs :: msg :: Float64 :: data );","title":"using value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Double/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Double/#function-operator","text":"inline auto & operator += ( const double & rhs )","title":"function operator+="},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Double/#function-operator_1","text":"inline auto & operator *= ( const double & rhs )","title":"function operator*="},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Double/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Double/#function-infinity","text":"static inline auto infinity ()","title":"function infinity"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Double/#function-double","text":"inline explicit Double ( value_type value = {} )","title":"function Double"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Double/#function-double_1","text":"inline explicit Double ( const std :: string & s ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function Double"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsDimension/","text":"openscenario_interpreter::syntax::DynamicsDimension # Public Types # Name enum value_type { time, rate, distance } Public Functions # Name constexpr operator value_type () const constexpr DynamicsDimension (value_type value ={}) Public Attributes # Name enum openscenario_interpreter::syntax::DynamicsDimension::value_type value Public Types Documentation # enum value_type # Enumerator Value Description time rate distance Public Functions Documentation # function operator value_type # inline constexpr operator value_type () const function DynamicsDimension # inline constexpr DynamicsDimension ( value_type value = {} ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: DynamicsDimension :: value_type value ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::DynamicsDimension"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsDimension/#openscenario_interpretersyntaxdynamicsdimension","text":"","title":"openscenario_interpreter::syntax::DynamicsDimension"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsDimension/#public-types","text":"Name enum value_type { time, rate, distance }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsDimension/#public-functions","text":"Name constexpr operator value_type () const constexpr DynamicsDimension (value_type value ={})","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsDimension/#public-attributes","text":"Name enum openscenario_interpreter::syntax::DynamicsDimension::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsDimension/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsDimension/#enum-value_type","text":"Enumerator Value Description time rate distance","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsDimension/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsDimension/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsDimension/#function-dynamicsdimension","text":"inline constexpr DynamicsDimension ( value_type value = {} )","title":"function DynamicsDimension"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsDimension/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsDimension/#variable-value","text":"enum openscenario_interpreter :: syntax :: DynamicsDimension :: value_type value ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsShape/","text":"openscenario_interpreter::syntax::DynamicsShape # Public Types # Name enum value_type { step, sinusoidal, linear, cubic } Public Functions # Name constexpr operator value_type () const constexpr DynamicsShape (value_type value ={}) Public Attributes # Name enum openscenario_interpreter::syntax::DynamicsShape::value_type value Public Types Documentation # enum value_type # Enumerator Value Description step sinusoidal linear cubic Public Functions Documentation # function operator value_type # inline constexpr operator value_type () const function DynamicsShape # inline constexpr DynamicsShape ( value_type value = {} ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: DynamicsShape :: value_type value ; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::DynamicsShape"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsShape/#openscenario_interpretersyntaxdynamicsshape","text":"","title":"openscenario_interpreter::syntax::DynamicsShape"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsShape/#public-types","text":"Name enum value_type { step, sinusoidal, linear, cubic }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsShape/#public-functions","text":"Name constexpr operator value_type () const constexpr DynamicsShape (value_type value ={})","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsShape/#public-attributes","text":"Name enum openscenario_interpreter::syntax::DynamicsShape::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsShape/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsShape/#enum-value_type","text":"Enumerator Value Description step sinusoidal linear cubic","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsShape/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsShape/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsShape/#function-dynamicsshape","text":"inline constexpr DynamicsShape ( value_type value = {} )","title":"function DynamicsShape"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsShape/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1DynamicsShape/#variable-value","text":"enum openscenario_interpreter :: syntax :: DynamicsShape :: value_type value ; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Entities/","text":"openscenario_interpreter::syntax::Entities # Public Functions # Name template \\<typename Node ,typename Scope > Entities (const Node & node, Scope & outer_scope) Public Functions Documentation # function Entities # template < typename Node , typename Scope > inline explicit Entities ( const Node & node , Scope & outer_scope ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::Entities"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Entities/#openscenario_interpretersyntaxentities","text":"","title":"openscenario_interpreter::syntax::Entities"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Entities/#public-functions","text":"Name template \\<typename Node ,typename Scope > Entities (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Entities/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Entities/#function-entities","text":"template < typename Node , typename Scope > inline explicit Entities ( const Node & node , Scope & outer_scope ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function Entities"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityAction/","text":"openscenario_interpreter::syntax::EntityAction # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name decltype(auto) evaluate () const template \\<typename Node ,typename Scope > EntityAction (const Node & node, Scope & outer_scope) Public Attributes # Name const String entity_ref const std::true_type accomplished Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function evaluate # inline decltype ( auto ) evaluate () const function EntityAction # template < typename Node , typename Scope > inline explicit EntityAction ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable entity_ref # const String entity_ref ; variable accomplished # const std :: true_type accomplished {}; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::EntityAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityAction/#openscenario_interpretersyntaxentityaction","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::EntityAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityAction/#public-functions","text":"Name decltype(auto) evaluate () const template \\<typename Node ,typename Scope > EntityAction (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityAction/#public-attributes","text":"Name const String entity_ref const std::true_type accomplished","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityAction/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityAction/#function-evaluate","text":"inline decltype ( auto ) evaluate () const","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityAction/#function-entityaction","text":"template < typename Node , typename Scope > inline explicit EntityAction ( const Node & node , Scope & outer_scope )","title":"function EntityAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityAction/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityAction/#variable-entity_ref","text":"const String entity_ref ;","title":"variable entity_ref"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityAction/#variable-accomplished","text":"const std :: true_type accomplished {}; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityCondition/","text":"openscenario_interpreter::syntax::EntityCondition # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name template \\<typename Node ,typename ... Ts> EntityCondition (const Node & node, Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function EntityCondition # template < typename Node , typename ... Ts > inline explicit EntityCondition ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::EntityCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityCondition/#openscenario_interpretersyntaxentitycondition","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::EntityCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityCondition/#public-functions","text":"Name template \\<typename Node ,typename ... Ts> EntityCondition (const Node & node, Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityCondition/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityCondition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityCondition/#function-entitycondition","text":"template < typename Node , typename ... Ts > inline explicit EntityCondition ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function EntityCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityObject/","text":"openscenario_interpreter::syntax::EntityObject # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Inherited by openscenario_interpreter::syntax::ScenarioObject Public Functions # Name template \\<typename Node ,typename ... Ts> EntityObject (const Node & node, Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function EntityObject # template < typename Node , typename ... Ts > inline explicit EntityObject ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::EntityObject"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityObject/#openscenario_interpretersyntaxentityobject","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Inherited by openscenario_interpreter::syntax::ScenarioObject","title":"openscenario_interpreter::syntax::EntityObject"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityObject/#public-functions","text":"Name template \\<typename Node ,typename ... Ts> EntityObject (const Node & node, Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityObject/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityObject/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityObject/#function-entityobject","text":"template < typename Node , typename ... Ts > inline explicit EntityObject ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function EntityObject"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityRef/","text":"openscenario_interpreter::syntax::EntityRef # Inherits from String Public Functions # Name template \\<typename ... Ts> constexpr EntityRef (Ts &&... xs) template \\<typename Node ,typename Scope > EntityRef (const Node & node, Scope & scope) Public Functions Documentation # function EntityRef # template < typename ... Ts > inline explicit constexpr EntityRef ( Ts && ... xs ) function EntityRef # template < typename Node , typename Scope > inline explicit EntityRef ( const Node & node , Scope & scope ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::EntityRef"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityRef/#openscenario_interpretersyntaxentityref","text":"Inherits from String","title":"openscenario_interpreter::syntax::EntityRef"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityRef/#public-functions","text":"Name template \\<typename ... Ts> constexpr EntityRef (Ts &&... xs) template \\<typename Node ,typename Scope > EntityRef (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityRef/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityRef/#function-entityref","text":"template < typename ... Ts > inline explicit constexpr EntityRef ( Ts && ... xs )","title":"function EntityRef"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntityRef/#function-entityref_1","text":"template < typename Node , typename Scope > inline explicit EntityRef ( const Node & node , Scope & scope ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function EntityRef"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntitySelection/","text":"openscenario_interpreter::syntax::EntitySelection # Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::EntitySelection"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1EntitySelection/#openscenario_interpretersyntaxentityselection","text":"Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::syntax::EntitySelection"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/","text":"openscenario_interpreter::syntax::Event # Inherits from openscenario_interpreter::syntax::StoryboardElement< Event > , Elements Public Functions # Name constexpr auto stopTriggered () void stop () void run () auto ready () auto accomplished () const template \\<typename XML > Event (const XML & node, Scope & outer_scope) Public Attributes # Name Trigger start_trigger const Priority priority const String name Scope inner_scope Additional inherited members # Public Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Event > Name const auto & state () const Element override () auto evaluate () auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition ) Protected Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Event > Name auto unique (const std::string & name) auto rename (const std::string & name) const decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs) Public Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Event > Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count Protected Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Event > Name std::unordered_set< std::string > names Public Functions Documentation # function stopTriggered # static inline constexpr auto stopTriggered () function stop # inline void stop () function run # inline void run () function ready # inline auto ready () function accomplished # inline auto accomplished () const function Event # template < typename XML > inline explicit Event ( const XML & node , Scope & outer_scope ) Public Attributes Documentation # variable start_trigger # Trigger start_trigger ; variable priority # const Priority priority ; variable name # const String name ; variable inner_scope # Scope inner_scope ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Event"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#openscenario_interpretersyntaxevent","text":"Inherits from openscenario_interpreter::syntax::StoryboardElement< Event > , Elements","title":"openscenario_interpreter::syntax::Event"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#public-functions","text":"Name constexpr auto stopTriggered () void stop () void run () auto ready () auto accomplished () const template \\<typename XML > Event (const XML & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#public-attributes","text":"Name Trigger start_trigger const Priority priority const String name Scope inner_scope","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Event > Name const auto & state () const Element override () auto evaluate () auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition ) Protected Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Event > Name auto unique (const std::string & name) auto rename (const std::string & name) const decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs) Public Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Event > Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count Protected Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Event > Name std::unordered_set< std::string > names","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#function-stoptriggered","text":"static inline constexpr auto stopTriggered ()","title":"function stopTriggered"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#function-stop","text":"inline void stop ()","title":"function stop"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#function-run","text":"inline void run ()","title":"function run"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#function-ready","text":"inline auto ready ()","title":"function ready"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#function-accomplished","text":"inline auto accomplished () const","title":"function accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#function-event","text":"template < typename XML > inline explicit Event ( const XML & node , Scope & outer_scope )","title":"function Event"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#variable-start_trigger","text":"Trigger start_trigger ;","title":"variable start_trigger"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#variable-priority","text":"const Priority priority ;","title":"variable priority"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#variable-name","text":"const String name ;","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Event/#variable-inner_scope","text":"Scope inner_scope ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1File/","text":"openscenario_interpreter::syntax::File # Public Types # Name using String FilePath Public Functions # Name operator String () const File () template \\<typename ... Ts> File (Ts &&... xs) Public Attributes # Name const FilePath filepath Public Types Documentation # using FilePath # using openscenario_interpreter :: syntax :: File :: FilePath = String ; Public Functions Documentation # function operator String # inline operator String () const function File # inline File () function File # template < typename ... Ts > inline explicit File ( Ts && ... xs ) Public Attributes Documentation # variable filepath # const FilePath filepath ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::File"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1File/#openscenario_interpretersyntaxfile","text":"","title":"openscenario_interpreter::syntax::File"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1File/#public-types","text":"Name using String FilePath","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1File/#public-functions","text":"Name operator String () const File () template \\<typename ... Ts> File (Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1File/#public-attributes","text":"Name const FilePath filepath","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1File/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1File/#using-filepath","text":"using openscenario_interpreter :: syntax :: File :: FilePath = String ;","title":"using FilePath"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1File/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1File/#function-operator-string","text":"inline operator String () const","title":"function operator String"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1File/#function-file","text":"inline File ()","title":"function File"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1File/#function-file_1","text":"template < typename ... Ts > inline explicit File ( Ts && ... xs )","title":"function File"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1File/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1File/#variable-filepath","text":"const FilePath filepath ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable filepath"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1FileHeader/","text":"openscenario_interpreter::syntax::FileHeader # Public Functions # Name template \\<typename Node ,typename Scope > FileHeader (const Node & node, Scope & outer_scope) Public Attributes # Name const UnsignedShort revMinor const UnsignedShort revMajor const String description const String date const String author Public Functions Documentation # function FileHeader # template < typename Node , typename Scope > inline explicit FileHeader ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable revMinor # const UnsignedShort revMinor ; variable revMajor # const UnsignedShort revMajor ; variable description # const String description ; variable date # const String date ; variable author # const String author ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::FileHeader"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1FileHeader/#openscenario_interpretersyntaxfileheader","text":"","title":"openscenario_interpreter::syntax::FileHeader"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1FileHeader/#public-functions","text":"Name template \\<typename Node ,typename Scope > FileHeader (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1FileHeader/#public-attributes","text":"Name const UnsignedShort revMinor const UnsignedShort revMajor const String description const String date const String author","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1FileHeader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1FileHeader/#function-fileheader","text":"template < typename Node , typename Scope > inline explicit FileHeader ( const Node & node , Scope & outer_scope )","title":"function FileHeader"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1FileHeader/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1FileHeader/#variable-revminor","text":"const UnsignedShort revMinor ;","title":"variable revMinor"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1FileHeader/#variable-revmajor","text":"const UnsignedShort revMajor ;","title":"variable revMajor"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1FileHeader/#variable-description","text":"const String description ;","title":"variable description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1FileHeader/#variable-date","text":"const String date ;","title":"variable date"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1FileHeader/#variable-author","text":"const String author ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable author"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1FrontAxle/","text":"openscenario_interpreter::syntax::FrontAxle # Inherits from openscenario_interpreter::syntax::Axle Additional inherited members # Public Functions inherited from openscenario_interpreter::syntax::Axle Name Axle () =default Axle (const Node & node, Scope & scope) Public Attributes inherited from openscenario_interpreter::syntax::Axle Name const Double wheel_diameter const Double track_width const Double position_z const Double position_x const Double max_steering Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::FrontAxle"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1FrontAxle/#openscenario_interpretersyntaxfrontaxle","text":"Inherits from openscenario_interpreter::syntax::Axle","title":"openscenario_interpreter::syntax::FrontAxle"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1FrontAxle/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::syntax::Axle Name Axle () =default Axle (const Node & node, Scope & scope) Public Attributes inherited from openscenario_interpreter::syntax::Axle Name const Double wheel_diameter const Double track_width const Double position_z const Double position_x const Double max_steering Updated on 7 April 2021 at 00:31:56 UTC","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1GlobalAction/","text":"openscenario_interpreter::syntax::GlobalAction # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name template \\<typename Node ,typename ... Ts> GlobalAction (const Node & node, Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function GlobalAction # template < typename Node , typename ... Ts > inline explicit GlobalAction ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::GlobalAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1GlobalAction/#openscenario_interpretersyntaxglobalaction","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::GlobalAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1GlobalAction/#public-functions","text":"Name template \\<typename Node ,typename ... Ts> GlobalAction (const Node & node, Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1GlobalAction/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1GlobalAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1GlobalAction/#function-globalaction","text":"template < typename Node , typename ... Ts > inline explicit GlobalAction ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function GlobalAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1InfrastructureAction/","text":"openscenario_interpreter::syntax::InfrastructureAction # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name template \\<typename Node ,typename Scope > InfrastructureAction (const Node & node, Scope & outer_scope) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function InfrastructureAction # template < typename Node , typename Scope > inline explicit InfrastructureAction ( const Node & node , Scope & outer_scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::InfrastructureAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1InfrastructureAction/#openscenario_interpretersyntaxinfrastructureaction","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::InfrastructureAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1InfrastructureAction/#public-functions","text":"Name template \\<typename Node ,typename Scope > InfrastructureAction (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1InfrastructureAction/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1InfrastructureAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1InfrastructureAction/#function-infrastructureaction","text":"template < typename Node , typename Scope > inline explicit InfrastructureAction ( const Node & node , Scope & outer_scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function InfrastructureAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Init/","text":"openscenario_interpreter::syntax::Init # Inherits from openscenario_interpreter::syntax::InitActions , Elements Public Functions # Name template \\<typename Node ,typename Scope > Init (const Node & node, Scope & scope) Additional inherited members # Public Functions inherited from openscenario_interpreter::syntax::InitActions Name auto evaluate () const InitActions (const Node & node, Scope & scope) Public Functions Documentation # function Init # template < typename Node , typename Scope > inline explicit Init ( const Node & node , Scope & scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Init"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Init/#openscenario_interpretersyntaxinit","text":"Inherits from openscenario_interpreter::syntax::InitActions , Elements","title":"openscenario_interpreter::syntax::Init"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Init/#public-functions","text":"Name template \\<typename Node ,typename Scope > Init (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Init/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::syntax::InitActions Name auto evaluate () const InitActions (const Node & node, Scope & scope)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Init/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Init/#function-init","text":"template < typename Node , typename Scope > inline explicit Init ( const Node & node , Scope & scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function Init"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1InitActions/","text":"openscenario_interpreter::syntax::InitActions # Inherits from Elements Inherited by openscenario_interpreter::syntax::Init Public Functions # Name auto evaluate () const template \\<typename Node ,typename Scope > InitActions (const Node & node, Scope & scope) Public Functions Documentation # function evaluate # inline auto evaluate () const function InitActions # template < typename Node , typename Scope > inline explicit InitActions ( const Node & node , Scope & scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::InitActions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1InitActions/#openscenario_interpretersyntaxinitactions","text":"Inherits from Elements Inherited by openscenario_interpreter::syntax::Init","title":"openscenario_interpreter::syntax::InitActions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1InitActions/#public-functions","text":"Name auto evaluate () const template \\<typename Node ,typename Scope > InitActions (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1InitActions/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1InitActions/#function-evaluate","text":"inline auto evaluate () const","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1InitActions/#function-initactions","text":"template < typename Node , typename Scope > inline explicit InitActions ( const Node & node , Scope & scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function InitActions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Integer/","text":"openscenario_interpreter::syntax::Integer # Inherits from Int64 Public Types # Name using decltype(std_msgs::msg::Int64::data) value_type Public Functions # Name auto & operator+= (const double & rhs) auto & operator*= (const double & rhs) constexpr operator value_type () const Integer (value_type value ={}) Integer (const std::string & s) Public Types Documentation # using value_type # using openscenario_interpreter :: syntax :: Integer :: value_type = decltype ( std_msgs :: msg :: Int64 :: data ); Public Functions Documentation # function operator+= # inline auto & operator += ( const double & rhs ) function operator*= # inline auto & operator *= ( const double & rhs ) function operator value_type # inline constexpr operator value_type () const function Integer # inline explicit Integer ( value_type value = {} ) function Integer # inline explicit Integer ( const std :: string & s ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Integer"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Integer/#openscenario_interpretersyntaxinteger","text":"Inherits from Int64","title":"openscenario_interpreter::syntax::Integer"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Integer/#public-types","text":"Name using decltype(std_msgs::msg::Int64::data) value_type","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Integer/#public-functions","text":"Name auto & operator+= (const double & rhs) auto & operator*= (const double & rhs) constexpr operator value_type () const Integer (value_type value ={}) Integer (const std::string & s)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Integer/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Integer/#using-value_type","text":"using openscenario_interpreter :: syntax :: Integer :: value_type = decltype ( std_msgs :: msg :: Int64 :: data );","title":"using value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Integer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Integer/#function-operator","text":"inline auto & operator += ( const double & rhs )","title":"function operator+="},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Integer/#function-operator_1","text":"inline auto & operator *= ( const double & rhs )","title":"function operator*="},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Integer/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Integer/#function-integer","text":"inline explicit Integer ( value_type value = {} )","title":"function Integer"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Integer/#function-integer_1","text":"inline explicit Integer ( const std :: string & s ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function Integer"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeAction/","text":"openscenario_interpreter::syntax::LaneChangeAction # Public Functions # Name void start () auto accomplished () template \\<typename Node > LaneChangeAction (const Node & node, Scope & outer_scope) Public Attributes # Name const Double target_lane_offset const LaneChangeTarget lane_change_target const TransitionDynamics lane_change_action_dynamics Scope inner_scope std::unordered_map< std::string, Boolean > accomplishments Public Functions Documentation # function start # inline void start () function accomplished # inline auto accomplished () function LaneChangeAction # template < typename Node > inline explicit LaneChangeAction ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable target_lane_offset # const Double target_lane_offset ; variable lane_change_target # const LaneChangeTarget lane_change_target ; variable lane_change_action_dynamics # const TransitionDynamics lane_change_action_dynamics ; variable inner_scope # Scope inner_scope ; variable accomplishments # std :: unordered_map < std :: string , Boolean > accomplishments ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::LaneChangeAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeAction/#openscenario_interpretersyntaxlanechangeaction","text":"","title":"openscenario_interpreter::syntax::LaneChangeAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeAction/#public-functions","text":"Name void start () auto accomplished () template \\<typename Node > LaneChangeAction (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeAction/#public-attributes","text":"Name const Double target_lane_offset const LaneChangeTarget lane_change_target const TransitionDynamics lane_change_action_dynamics Scope inner_scope std::unordered_map< std::string, Boolean > accomplishments","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeAction/#function-start","text":"inline void start ()","title":"function start"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeAction/#function-accomplished","text":"inline auto accomplished ()","title":"function accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeAction/#function-lanechangeaction","text":"template < typename Node > inline explicit LaneChangeAction ( const Node & node , Scope & outer_scope )","title":"function LaneChangeAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeAction/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeAction/#variable-target_lane_offset","text":"const Double target_lane_offset ;","title":"variable target_lane_offset"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeAction/#variable-lane_change_target","text":"const LaneChangeTarget lane_change_target ;","title":"variable lane_change_target"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeAction/#variable-lane_change_action_dynamics","text":"const TransitionDynamics lane_change_action_dynamics ;","title":"variable lane_change_action_dynamics"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeAction/#variable-inner_scope","text":"Scope inner_scope ;","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeAction/#variable-accomplishments","text":"std :: unordered_map < std :: string , Boolean > accomplishments ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable accomplishments"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeTarget/","text":"openscenario_interpreter::syntax::LaneChangeTarget # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name template \\<typename Node ,typename ... Ts> LaneChangeTarget (const Node & node, Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function LaneChangeTarget # template < typename Node , typename ... Ts > inline explicit LaneChangeTarget ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::LaneChangeTarget"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeTarget/#openscenario_interpretersyntaxlanechangetarget","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::LaneChangeTarget"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeTarget/#public-functions","text":"Name template \\<typename Node ,typename ... Ts> LaneChangeTarget (const Node & node, Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeTarget/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeTarget/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LaneChangeTarget/#function-lanechangetarget","text":"template < typename Node , typename ... Ts > inline explicit LaneChangeTarget ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function LaneChangeTarget"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LanePosition/","text":"openscenario_interpreter::syntax::LanePosition # Public Functions # Name operator openscenario_msgs::msg::LaneletPose () const operator geometry_msgs::msg::Pose () const template \\<typename Node ,typename Scope > LanePosition (const Node & node, Scope & scope) Public Attributes # Name const Double s const String road_id const Orientation orientation const Double offset const String lane_id Public Functions Documentation # function operator openscenario_msgs::msg::LaneletPose # inline explicit operator openscenario_msgs :: msg :: LaneletPose () const function operator geometry_msgs::msg::Pose # inline explicit operator geometry_msgs :: msg :: Pose () const function LanePosition # template < typename Node , typename Scope > inline explicit LanePosition ( const Node & node , Scope & scope ) Public Attributes Documentation # variable s # const Double s ; variable road_id # const String road_id ; variable orientation # const Orientation orientation ; variable offset # const Double offset ; variable lane_id # const String lane_id ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::LanePosition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LanePosition/#openscenario_interpretersyntaxlaneposition","text":"","title":"openscenario_interpreter::syntax::LanePosition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LanePosition/#public-functions","text":"Name operator openscenario_msgs::msg::LaneletPose () const operator geometry_msgs::msg::Pose () const template \\<typename Node ,typename Scope > LanePosition (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LanePosition/#public-attributes","text":"Name const Double s const String road_id const Orientation orientation const Double offset const String lane_id","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LanePosition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LanePosition/#function-operator-openscenario_msgsmsglaneletpose","text":"inline explicit operator openscenario_msgs :: msg :: LaneletPose () const","title":"function operator openscenario_msgs::msg::LaneletPose"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LanePosition/#function-operator-geometry_msgsmsgpose","text":"inline explicit operator geometry_msgs :: msg :: Pose () const","title":"function operator geometry_msgs::msg::Pose"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LanePosition/#function-laneposition","text":"template < typename Node , typename Scope > inline explicit LanePosition ( const Node & node , Scope & scope )","title":"function LanePosition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LanePosition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LanePosition/#variable-s","text":"const Double s ;","title":"variable s"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LanePosition/#variable-road_id","text":"const String road_id ;","title":"variable road_id"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LanePosition/#variable-orientation","text":"const Orientation orientation ;","title":"variable orientation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LanePosition/#variable-offset","text":"const Double offset ;","title":"variable offset"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LanePosition/#variable-lane_id","text":"const String lane_id ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable lane_id"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LateralAction/","text":"openscenario_interpreter::syntax::LateralAction # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name template \\<typename Node ,typename Scope > LateralAction (const Node & node, Scope & scope) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function LateralAction # template < typename Node , typename Scope > inline explicit LateralAction ( const Node & node , Scope & scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::LateralAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LateralAction/#openscenario_interpretersyntaxlateralaction","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::LateralAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LateralAction/#public-functions","text":"Name template \\<typename Node ,typename Scope > LateralAction (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LateralAction/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LateralAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LateralAction/#function-lateralaction","text":"template < typename Node , typename Scope > inline explicit LateralAction ( const Node & node , Scope & scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function LateralAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LongitudinalAction/","text":"openscenario_interpreter::syntax::LongitudinalAction # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name template \\<typename Node ,typename ... Ts> LongitudinalAction (const Node & node, Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function LongitudinalAction # template < typename Node , typename ... Ts > inline explicit LongitudinalAction ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::LongitudinalAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LongitudinalAction/#openscenario_interpretersyntaxlongitudinalaction","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::LongitudinalAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LongitudinalAction/#public-functions","text":"Name template \\<typename Node ,typename ... Ts> LongitudinalAction (const Node & node, Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LongitudinalAction/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LongitudinalAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1LongitudinalAction/#function-longitudinalaction","text":"template < typename Node , typename ... Ts > inline explicit LongitudinalAction ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function LongitudinalAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Maneuver/","text":"openscenario_interpreter::syntax::Maneuver # Inherits from openscenario_interpreter::syntax::StoryboardElement< Maneuver > , Elements Public Functions # Name constexpr auto stopTriggered () void stop () void run () constexpr auto ready () auto accomplished () const template \\<typename Node ,typename Scope > Maneuver (const Node & node, Scope & outer_scope) Public Attributes # Name const String name Scope inner_scope Additional inherited members # Public Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Maneuver > Name const auto & state () const Element override () auto evaluate () auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition ) Protected Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Maneuver > Name auto unique (const std::string & name) auto rename (const std::string & name) const decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs) Public Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Maneuver > Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count Protected Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Maneuver > Name std::unordered_set< std::string > names Public Functions Documentation # function stopTriggered # static inline constexpr auto stopTriggered () function stop # inline void stop () function run # inline void run () function ready # static inline constexpr auto ready () function accomplished # inline auto accomplished () const function Maneuver # template < typename Node , typename Scope > inline explicit Maneuver ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable name # const String name ; variable inner_scope # Scope inner_scope ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Maneuver"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Maneuver/#openscenario_interpretersyntaxmaneuver","text":"Inherits from openscenario_interpreter::syntax::StoryboardElement< Maneuver > , Elements","title":"openscenario_interpreter::syntax::Maneuver"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Maneuver/#public-functions","text":"Name constexpr auto stopTriggered () void stop () void run () constexpr auto ready () auto accomplished () const template \\<typename Node ,typename Scope > Maneuver (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Maneuver/#public-attributes","text":"Name const String name Scope inner_scope","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Maneuver/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Maneuver > Name const auto & state () const Element override () auto evaluate () auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition ) Protected Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Maneuver > Name auto unique (const std::string & name) auto rename (const std::string & name) const decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs) Public Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Maneuver > Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count Protected Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Maneuver > Name std::unordered_set< std::string > names","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Maneuver/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Maneuver/#function-stoptriggered","text":"static inline constexpr auto stopTriggered ()","title":"function stopTriggered"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Maneuver/#function-stop","text":"inline void stop ()","title":"function stop"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Maneuver/#function-run","text":"inline void run ()","title":"function run"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Maneuver/#function-ready","text":"static inline constexpr auto ready ()","title":"function ready"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Maneuver/#function-accomplished","text":"inline auto accomplished () const","title":"function accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Maneuver/#function-maneuver","text":"template < typename Node , typename Scope > inline explicit Maneuver ( const Node & node , Scope & outer_scope )","title":"function Maneuver"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Maneuver/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Maneuver/#variable-name","text":"const String name ;","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Maneuver/#variable-inner_scope","text":"Scope inner_scope ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/","text":"openscenario_interpreter::syntax::ManeuverGroup # Inherits from openscenario_interpreter::syntax::StoryboardElement< ManeuverGroup > , Elements Public Functions # Name constexpr auto stopTriggered () void stop () void run () constexpr auto ready () auto accomplished () const template \\<typename Node ,typename Scope > ManeuverGroup (const Node & node, Scope & outer_scope) Public Attributes # Name const String name Scope inner_scope const Actors actors Additional inherited members # Public Functions inherited from openscenario_interpreter::syntax::StoryboardElement< ManeuverGroup > Name const auto & state () const Element override () auto evaluate () auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition ) Protected Functions inherited from openscenario_interpreter::syntax::StoryboardElement< ManeuverGroup > Name auto unique (const std::string & name) auto rename (const std::string & name) const decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs) Public Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< ManeuverGroup > Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count Protected Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< ManeuverGroup > Name std::unordered_set< std::string > names Public Functions Documentation # function stopTriggered # static inline constexpr auto stopTriggered () function stop # inline void stop () function run # inline void run () function ready # static inline constexpr auto ready () function accomplished # inline auto accomplished () const function ManeuverGroup # template < typename Node , typename Scope > inline explicit ManeuverGroup ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable name # const String name ; variable inner_scope # Scope inner_scope ; variable actors # const Actors actors ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ManeuverGroup"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/#openscenario_interpretersyntaxmaneuvergroup","text":"Inherits from openscenario_interpreter::syntax::StoryboardElement< ManeuverGroup > , Elements","title":"openscenario_interpreter::syntax::ManeuverGroup"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/#public-functions","text":"Name constexpr auto stopTriggered () void stop () void run () constexpr auto ready () auto accomplished () const template \\<typename Node ,typename Scope > ManeuverGroup (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/#public-attributes","text":"Name const String name Scope inner_scope const Actors actors","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::syntax::StoryboardElement< ManeuverGroup > Name const auto & state () const Element override () auto evaluate () auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition ) Protected Functions inherited from openscenario_interpreter::syntax::StoryboardElement< ManeuverGroup > Name auto unique (const std::string & name) auto rename (const std::string & name) const decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs) Public Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< ManeuverGroup > Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count Protected Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< ManeuverGroup > Name std::unordered_set< std::string > names","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/#function-stoptriggered","text":"static inline constexpr auto stopTriggered ()","title":"function stopTriggered"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/#function-stop","text":"inline void stop ()","title":"function stop"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/#function-run","text":"inline void run ()","title":"function run"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/#function-ready","text":"static inline constexpr auto ready ()","title":"function ready"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/#function-accomplished","text":"inline auto accomplished () const","title":"function accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/#function-maneuvergroup","text":"template < typename Node , typename Scope > inline explicit ManeuverGroup ( const Node & node , Scope & outer_scope )","title":"function ManeuverGroup"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/#variable-name","text":"const String name ;","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/#variable-inner_scope","text":"Scope inner_scope ;","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ManeuverGroup/#variable-actors","text":"const Actors actors ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable actors"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ModifyRule/","text":"openscenario_interpreter::syntax::ModifyRule # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name template \\<typename Node ,typename ... Ts> ModifyRule (const Node & node, Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function ModifyRule # template < typename Node , typename ... Ts > inline explicit ModifyRule ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ModifyRule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ModifyRule/#openscenario_interpretersyntaxmodifyrule","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::ModifyRule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ModifyRule/#public-functions","text":"Name template \\<typename Node ,typename ... Ts> ModifyRule (const Node & node, Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ModifyRule/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ModifyRule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ModifyRule/#function-modifyrule","text":"template < typename Node , typename ... Ts > inline explicit ModifyRule ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function ModifyRule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ObjectController/","text":"openscenario_interpreter::syntax::ObjectController # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name operator openscenario_msgs::msg::DriverModel () const bool isEgo () ObjectController () template \\<typename Node ,typename ... Ts> ObjectController (const Node & node, Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function operator openscenario_msgs::msg::DriverModel # inline operator openscenario_msgs :: msg :: DriverModel () const function isEgo # inline bool isEgo () function ObjectController # inline explicit ObjectController () function ObjectController # template < typename Node , typename ... Ts > inline explicit ObjectController ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ObjectController"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ObjectController/#openscenario_interpretersyntaxobjectcontroller","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::ObjectController"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ObjectController/#public-functions","text":"Name operator openscenario_msgs::msg::DriverModel () const bool isEgo () ObjectController () template \\<typename Node ,typename ... Ts> ObjectController (const Node & node, Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ObjectController/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ObjectController/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ObjectController/#function-operator-openscenario_msgsmsgdrivermodel","text":"inline operator openscenario_msgs :: msg :: DriverModel () const","title":"function operator openscenario_msgs::msg::DriverModel"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ObjectController/#function-isego","text":"inline bool isEgo ()","title":"function isEgo"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ObjectController/#function-objectcontroller","text":"inline explicit ObjectController ()","title":"function ObjectController"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ObjectController/#function-objectcontroller_1","text":"template < typename Node , typename ... Ts > inline explicit ObjectController ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function ObjectController"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ObjectType/","text":"openscenario_interpreter::syntax::ObjectType # Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ObjectType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ObjectType/#openscenario_interpretersyntaxobjecttype","text":"Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ObjectType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OpenScenario/","text":"openscenario_interpreter::syntax::OpenScenario # Inherits from xml_document Public Functions # Name template \\<typename ... Ts> decltype(auto) operator() (Ts &&... xs) const auto & load (const std::string & scenario) decltype(auto) load (const boost::filesystem::path & scenario) template \\<typename ... Ts> decltype(auto) evaluate (Ts &&... xs) template \\<typename ... Ts> decltype(auto) complete (Ts &&... xs) template \\<typename ... Ts> OpenScenario (Ts &&... xs) Public Attributes # Name Scope scope Element category Public Functions Documentation # function operator() # template < typename ... Ts > inline decltype ( auto ) operator ()( Ts && ... xs ) function load # inline const auto & load ( const std :: string & scenario ) function load # inline decltype ( auto ) load ( const boost :: filesystem :: path & scenario ) function evaluate # template < typename ... Ts > inline decltype ( auto ) evaluate ( Ts && ... xs ) function complete # template < typename ... Ts > inline decltype ( auto ) complete ( Ts && ... xs ) function OpenScenario # template < typename ... Ts > inline explicit OpenScenario ( Ts && ... xs ) Public Attributes Documentation # variable scope # Scope scope ; variable category # Element category ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::OpenScenario"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OpenScenario/#openscenario_interpretersyntaxopenscenario","text":"Inherits from xml_document","title":"openscenario_interpreter::syntax::OpenScenario"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OpenScenario/#public-functions","text":"Name template \\<typename ... Ts> decltype(auto) operator() (Ts &&... xs) const auto & load (const std::string & scenario) decltype(auto) load (const boost::filesystem::path & scenario) template \\<typename ... Ts> decltype(auto) evaluate (Ts &&... xs) template \\<typename ... Ts> decltype(auto) complete (Ts &&... xs) template \\<typename ... Ts> OpenScenario (Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OpenScenario/#public-attributes","text":"Name Scope scope Element category","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OpenScenario/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OpenScenario/#function-operator","text":"template < typename ... Ts > inline decltype ( auto ) operator ()( Ts && ... xs )","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OpenScenario/#function-load","text":"inline const auto & load ( const std :: string & scenario )","title":"function load"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OpenScenario/#function-load_1","text":"inline decltype ( auto ) load ( const boost :: filesystem :: path & scenario )","title":"function load"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OpenScenario/#function-evaluate","text":"template < typename ... Ts > inline decltype ( auto ) evaluate ( Ts && ... xs )","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OpenScenario/#function-complete","text":"template < typename ... Ts > inline decltype ( auto ) complete ( Ts && ... xs )","title":"function complete"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OpenScenario/#function-openscenario","text":"template < typename ... Ts > inline explicit OpenScenario ( Ts && ... xs )","title":"function OpenScenario"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OpenScenario/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OpenScenario/#variable-scope","text":"Scope scope ;","title":"variable scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OpenScenario/#variable-category","text":"Element category ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable category"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Orientation/","text":"openscenario_interpreter::syntax::Orientation # Public Functions # Name operator geometry_msgs::msg::Vector3 () const Orientation () =default template \\<typename Node ,typename Scope > Orientation (const Node & node, Scope & scope) Public Attributes # Name const ReferenceContext type const Double r const Double p const Double h Public Functions Documentation # function operator geometry_msgs::msg::Vector3 # inline operator geometry_msgs :: msg :: Vector3 () const function Orientation # Orientation () = default function Orientation # template < typename Node , typename Scope > inline explicit Orientation ( const Node & node , Scope & scope ) Public Attributes Documentation # variable type # const ReferenceContext type ; variable r # const Double r ; variable p # const Double p ; variable h # const Double h ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Orientation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Orientation/#openscenario_interpretersyntaxorientation","text":"","title":"openscenario_interpreter::syntax::Orientation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Orientation/#public-functions","text":"Name operator geometry_msgs::msg::Vector3 () const Orientation () =default template \\<typename Node ,typename Scope > Orientation (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Orientation/#public-attributes","text":"Name const ReferenceContext type const Double r const Double p const Double h","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Orientation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Orientation/#function-operator-geometry_msgsmsgvector3","text":"inline operator geometry_msgs :: msg :: Vector3 () const","title":"function operator geometry_msgs::msg::Vector3"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Orientation/#function-orientation","text":"Orientation () = default","title":"function Orientation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Orientation/#function-orientation_1","text":"template < typename Node , typename Scope > inline explicit Orientation ( const Node & node , Scope & scope )","title":"function Orientation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Orientation/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Orientation/#variable-type","text":"const ReferenceContext type ;","title":"variable type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Orientation/#variable-r","text":"const Double r ;","title":"variable r"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Orientation/#variable-p","text":"const Double p ;","title":"variable p"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Orientation/#variable-h","text":"const Double h ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable h"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OverrideControllerValueAction/","text":"openscenario_interpreter::syntax::OverrideControllerValueAction # Public Functions # Name template \\<typename Node ,typename Scope > OverrideControllerValueAction (const Node & , Scope & ) Public Functions Documentation # function OverrideControllerValueAction # template < typename Node , typename Scope > inline explicit OverrideControllerValueAction ( const Node & , Scope & ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::OverrideControllerValueAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OverrideControllerValueAction/#openscenario_interpretersyntaxoverridecontrollervalueaction","text":"","title":"openscenario_interpreter::syntax::OverrideControllerValueAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OverrideControllerValueAction/#public-functions","text":"Name template \\<typename Node ,typename Scope > OverrideControllerValueAction (const Node & , Scope & )","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OverrideControllerValueAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1OverrideControllerValueAction/#function-overridecontrollervalueaction","text":"template < typename Node , typename Scope > inline explicit OverrideControllerValueAction ( const Node & , Scope & ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function OverrideControllerValueAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterAction/","text":"openscenario_interpreter::syntax::ParameterAction # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name template \\<typename Node ,typename Scope > ParameterAction (const Node & parent, Scope & outer_scope) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function ParameterAction # template < typename Node , typename Scope > inline explicit ParameterAction ( const Node & parent , Scope & outer_scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ParameterAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterAction/#openscenario_interpretersyntaxparameteraction","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::ParameterAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterAction/#public-functions","text":"Name template \\<typename Node ,typename Scope > ParameterAction (const Node & parent, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterAction/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterAction/#function-parameteraction","text":"template < typename Node , typename Scope > inline explicit ParameterAction ( const Node & parent , Scope & outer_scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function ParameterAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterAddValueRule/","text":"openscenario_interpreter::syntax::ParameterAddValueRule # Public Functions # Name auto operator() (const Element & target) const template \\<typename ... Ts> ParameterAddValueRule (Ts &&... xs) Public Attributes # Name const Double value Public Functions Documentation # function operator() # inline auto operator ()( const Element & target ) const function ParameterAddValueRule # template < typename ... Ts > inline explicit ParameterAddValueRule ( Ts && ... xs ) Public Attributes Documentation # variable value # const Double value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ParameterAddValueRule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterAddValueRule/#openscenario_interpretersyntaxparameteraddvaluerule","text":"","title":"openscenario_interpreter::syntax::ParameterAddValueRule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterAddValueRule/#public-functions","text":"Name auto operator() (const Element & target) const template \\<typename ... Ts> ParameterAddValueRule (Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterAddValueRule/#public-attributes","text":"Name const Double value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterAddValueRule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterAddValueRule/#function-operator","text":"inline auto operator ()( const Element & target ) const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterAddValueRule/#function-parameteraddvaluerule","text":"template < typename ... Ts > inline explicit ParameterAddValueRule ( Ts && ... xs )","title":"function ParameterAddValueRule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterAddValueRule/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterAddValueRule/#variable-value","text":"const Double value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterCondition/","text":"openscenario_interpreter::syntax::ParameterCondition # Public Functions # Name auto evaluate () const template \\<typename Node > ParameterCondition (const Node & node, Scope & outer_scope) Public Attributes # Name const String value const String parameter_ref Scope inner_scope const Rule compare Public Functions Documentation # function evaluate # inline auto evaluate () const function ParameterCondition # template < typename Node > inline explicit ParameterCondition ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable value # const String value ; variable parameter_ref # const String parameter_ref ; variable inner_scope # Scope inner_scope ; variable compare # const Rule compare ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ParameterCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterCondition/#openscenario_interpretersyntaxparametercondition","text":"","title":"openscenario_interpreter::syntax::ParameterCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterCondition/#public-functions","text":"Name auto evaluate () const template \\<typename Node > ParameterCondition (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterCondition/#public-attributes","text":"Name const String value const String parameter_ref Scope inner_scope const Rule compare","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterCondition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterCondition/#function-evaluate","text":"inline auto evaluate () const","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterCondition/#function-parametercondition","text":"template < typename Node > inline explicit ParameterCondition ( const Node & node , Scope & outer_scope )","title":"function ParameterCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterCondition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterCondition/#variable-value","text":"const String value ;","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterCondition/#variable-parameter_ref","text":"const String parameter_ref ;","title":"variable parameter_ref"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterCondition/#variable-inner_scope","text":"Scope inner_scope ;","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterCondition/#variable-compare","text":"const Rule compare ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable compare"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclaration/","text":"openscenario_interpreter::syntax::ParameterDeclaration # Public Functions # Name auto includes (const std::string & name, const std::vector< char > & chars) Element evaluate () const ParameterDeclaration () =default template \\<typename Node ,typename Scope > ParameterDeclaration (const Node & node, Scope & scope) Public Attributes # Name const String value const ParameterType parameter_type const String name Public Functions Documentation # function includes # inline auto includes ( const std :: string & name , const std :: vector < char > & chars ) function evaluate # inline Element evaluate () const function ParameterDeclaration # ParameterDeclaration () = default function ParameterDeclaration # template < typename Node , typename Scope > inline explicit ParameterDeclaration ( const Node & node , Scope & scope ) Public Attributes Documentation # variable value # const String value ; variable parameter_type # const ParameterType parameter_type ; variable name # const String name ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ParameterDeclaration"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclaration/#openscenario_interpretersyntaxparameterdeclaration","text":"","title":"openscenario_interpreter::syntax::ParameterDeclaration"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclaration/#public-functions","text":"Name auto includes (const std::string & name, const std::vector< char > & chars) Element evaluate () const ParameterDeclaration () =default template \\<typename Node ,typename Scope > ParameterDeclaration (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclaration/#public-attributes","text":"Name const String value const ParameterType parameter_type const String name","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclaration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclaration/#function-includes","text":"inline auto includes ( const std :: string & name , const std :: vector < char > & chars )","title":"function includes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclaration/#function-evaluate","text":"inline Element evaluate () const","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclaration/#function-parameterdeclaration","text":"ParameterDeclaration () = default","title":"function ParameterDeclaration"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclaration/#function-parameterdeclaration_1","text":"template < typename Node , typename Scope > inline explicit ParameterDeclaration ( const Node & node , Scope & scope )","title":"function ParameterDeclaration"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclaration/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclaration/#variable-value","text":"const String value ;","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclaration/#variable-parameter_type","text":"const ParameterType parameter_type ;","title":"variable parameter_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclaration/#variable-name","text":"const String name ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclarations/","text":"openscenario_interpreter::syntax::ParameterDeclarations # Inherits from std::vector< ParameterDeclaration > Public Functions # Name ParameterDeclarations () =default template \\<typename Node ,typename Scope > ParameterDeclarations (const Node & node, Scope & outer_scope) Public Functions Documentation # function ParameterDeclarations # ParameterDeclarations () = default function ParameterDeclarations # template < typename Node , typename Scope > inline explicit ParameterDeclarations ( const Node & node , Scope & outer_scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ParameterDeclarations"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclarations/#openscenario_interpretersyntaxparameterdeclarations","text":"Inherits from std::vector< ParameterDeclaration >","title":"openscenario_interpreter::syntax::ParameterDeclarations"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclarations/#public-functions","text":"Name ParameterDeclarations () =default template \\<typename Node ,typename Scope > ParameterDeclarations (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclarations/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclarations/#function-parameterdeclarations","text":"ParameterDeclarations () = default","title":"function ParameterDeclarations"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterDeclarations/#function-parameterdeclarations_1","text":"template < typename Node , typename Scope > inline explicit ParameterDeclarations ( const Node & node , Scope & outer_scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function ParameterDeclarations"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterModifyAction/","text":"openscenario_interpreter::syntax::ParameterModifyAction # Public Functions # Name auto evaluate () template \\<typename Node > ParameterModifyAction (const Node & node, Scope & outer_scope, const String & parameter_ref) Public Attributes # Name const ModifyRule rule const String parameter_ref Scope inner_scope const std::true_type accomplished Public Functions Documentation # function evaluate # inline auto evaluate () function ParameterModifyAction # template < typename Node > inline explicit ParameterModifyAction ( const Node & node , Scope & outer_scope , const String & parameter_ref ) Public Attributes Documentation # variable rule # const ModifyRule rule ; variable parameter_ref # const String parameter_ref ; variable inner_scope # Scope inner_scope ; variable accomplished # const std :: true_type accomplished {}; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ParameterModifyAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterModifyAction/#openscenario_interpretersyntaxparametermodifyaction","text":"","title":"openscenario_interpreter::syntax::ParameterModifyAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterModifyAction/#public-functions","text":"Name auto evaluate () template \\<typename Node > ParameterModifyAction (const Node & node, Scope & outer_scope, const String & parameter_ref)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterModifyAction/#public-attributes","text":"Name const ModifyRule rule const String parameter_ref Scope inner_scope const std::true_type accomplished","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterModifyAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterModifyAction/#function-evaluate","text":"inline auto evaluate ()","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterModifyAction/#function-parametermodifyaction","text":"template < typename Node > inline explicit ParameterModifyAction ( const Node & node , Scope & outer_scope , const String & parameter_ref )","title":"function ParameterModifyAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterModifyAction/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterModifyAction/#variable-rule","text":"const ModifyRule rule ;","title":"variable rule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterModifyAction/#variable-parameter_ref","text":"const String parameter_ref ;","title":"variable parameter_ref"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterModifyAction/#variable-inner_scope","text":"Scope inner_scope ;","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterModifyAction/#variable-accomplished","text":"const std :: true_type accomplished {}; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterMultiplyByValueRule/","text":"openscenario_interpreter::syntax::ParameterMultiplyByValueRule # Public Functions # Name auto operator() (const Element & target) const template \\<typename ... Ts> ParameterMultiplyByValueRule (Ts &&... xs) Public Attributes # Name const Double value Public Functions Documentation # function operator() # inline auto operator ()( const Element & target ) const function ParameterMultiplyByValueRule # template < typename ... Ts > inline explicit ParameterMultiplyByValueRule ( Ts && ... xs ) Public Attributes Documentation # variable value # const Double value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ParameterMultiplyByValueRule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterMultiplyByValueRule/#openscenario_interpretersyntaxparametermultiplybyvaluerule","text":"","title":"openscenario_interpreter::syntax::ParameterMultiplyByValueRule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterMultiplyByValueRule/#public-functions","text":"Name auto operator() (const Element & target) const template \\<typename ... Ts> ParameterMultiplyByValueRule (Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterMultiplyByValueRule/#public-attributes","text":"Name const Double value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterMultiplyByValueRule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterMultiplyByValueRule/#function-operator","text":"inline auto operator ()( const Element & target ) const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterMultiplyByValueRule/#function-parametermultiplybyvaluerule","text":"template < typename ... Ts > inline explicit ParameterMultiplyByValueRule ( Ts && ... xs )","title":"function ParameterMultiplyByValueRule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterMultiplyByValueRule/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterMultiplyByValueRule/#variable-value","text":"const Double value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterSetAction/","text":"openscenario_interpreter::syntax::ParameterSetAction # Public Functions # Name auto evaluate () const template \\<typename Node ,typename Scope > ParameterSetAction (const Node & node, Scope & outer_scope, const String & parameter_ref) Public Attributes # Name const String value const String parameter_ref Scope inner_scope const std::true_type accomplished Public Functions Documentation # function evaluate # inline auto evaluate () const function ParameterSetAction # template < typename Node , typename Scope > inline explicit ParameterSetAction ( const Node & node , Scope & outer_scope , const String & parameter_ref ) Public Attributes Documentation # variable value # const String value ; variable parameter_ref # const String parameter_ref ; variable inner_scope # Scope inner_scope ; variable accomplished # const std :: true_type accomplished {}; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ParameterSetAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterSetAction/#openscenario_interpretersyntaxparametersetaction","text":"","title":"openscenario_interpreter::syntax::ParameterSetAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterSetAction/#public-functions","text":"Name auto evaluate () const template \\<typename Node ,typename Scope > ParameterSetAction (const Node & node, Scope & outer_scope, const String & parameter_ref)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterSetAction/#public-attributes","text":"Name const String value const String parameter_ref Scope inner_scope const std::true_type accomplished","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterSetAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterSetAction/#function-evaluate","text":"inline auto evaluate () const","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterSetAction/#function-parametersetaction","text":"template < typename Node , typename Scope > inline explicit ParameterSetAction ( const Node & node , Scope & outer_scope , const String & parameter_ref )","title":"function ParameterSetAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterSetAction/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterSetAction/#variable-value","text":"const String value ;","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterSetAction/#variable-parameter_ref","text":"const String parameter_ref ;","title":"variable parameter_ref"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterSetAction/#variable-inner_scope","text":"Scope inner_scope ;","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterSetAction/#variable-accomplished","text":"const std :: true_type accomplished {}; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterType/","text":"openscenario_interpreter::syntax::ParameterType # Public Types # Name enum value_type { UNSIGNED_SHORT, UNSIGNED_INT, STRING, INTEGER, DOUBLE, DATE_TIME, BOOLEAN } Public Functions # Name constexpr operator value_type () const constexpr ParameterType (value_type value ={}) Public Attributes # Name enum openscenario_interpreter::syntax::ParameterType::value_type value Public Types Documentation # enum value_type # Enumerator Value Description UNSIGNED_SHORT UNSIGNED_INT STRING INTEGER DOUBLE DATE_TIME BOOLEAN Public Functions Documentation # function operator value_type # inline constexpr operator value_type () const function ParameterType # inline explicit constexpr ParameterType ( value_type value = {} ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: ParameterType :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ParameterType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterType/#openscenario_interpretersyntaxparametertype","text":"","title":"openscenario_interpreter::syntax::ParameterType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterType/#public-types","text":"Name enum value_type { UNSIGNED_SHORT, UNSIGNED_INT, STRING, INTEGER, DOUBLE, DATE_TIME, BOOLEAN }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterType/#public-functions","text":"Name constexpr operator value_type () const constexpr ParameterType (value_type value ={})","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterType/#public-attributes","text":"Name enum openscenario_interpreter::syntax::ParameterType::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterType/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterType/#enum-value_type","text":"Enumerator Value Description UNSIGNED_SHORT UNSIGNED_INT STRING INTEGER DOUBLE DATE_TIME BOOLEAN","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterType/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterType/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterType/#function-parametertype","text":"inline explicit constexpr ParameterType ( value_type value = {} )","title":"function ParameterType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterType/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ParameterType/#variable-value","text":"enum openscenario_interpreter :: syntax :: ParameterType :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Pedestrian/","text":"openscenario_interpreter::syntax::Pedestrian # Public Functions # Name template \\<typename Node ,typename Scope > Pedestrian (const Node & node, Scope & outer_scope) Public Attributes # Name const Properties properties const PedestrianCategory pedestrian_category const ParameterDeclarations parameter_declarations const String name const String model const Double mass Scope inner_scope const BoundingBox bounding_box Public Functions Documentation # function Pedestrian # template < typename Node , typename Scope > inline explicit Pedestrian ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable properties # const Properties properties ; variable pedestrian_category # const PedestrianCategory pedestrian_category ; variable parameter_declarations # const ParameterDeclarations parameter_declarations ; variable name # const String name ; variable model # const String model ; variable mass # const Double mass ; variable inner_scope # Scope inner_scope ; variable bounding_box # const BoundingBox bounding_box ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Pedestrian"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Pedestrian/#openscenario_interpretersyntaxpedestrian","text":"","title":"openscenario_interpreter::syntax::Pedestrian"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Pedestrian/#public-functions","text":"Name template \\<typename Node ,typename Scope > Pedestrian (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Pedestrian/#public-attributes","text":"Name const Properties properties const PedestrianCategory pedestrian_category const ParameterDeclarations parameter_declarations const String name const String model const Double mass Scope inner_scope const BoundingBox bounding_box","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Pedestrian/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Pedestrian/#function-pedestrian","text":"template < typename Node , typename Scope > inline explicit Pedestrian ( const Node & node , Scope & outer_scope )","title":"function Pedestrian"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Pedestrian/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Pedestrian/#variable-properties","text":"const Properties properties ;","title":"variable properties"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Pedestrian/#variable-pedestrian_category","text":"const PedestrianCategory pedestrian_category ;","title":"variable pedestrian_category"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Pedestrian/#variable-parameter_declarations","text":"const ParameterDeclarations parameter_declarations ;","title":"variable parameter_declarations"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Pedestrian/#variable-name","text":"const String name ;","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Pedestrian/#variable-model","text":"const String model ;","title":"variable model"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Pedestrian/#variable-mass","text":"const Double mass ;","title":"variable mass"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Pedestrian/#variable-inner_scope","text":"Scope inner_scope ;","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Pedestrian/#variable-bounding_box","text":"const BoundingBox bounding_box ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable bounding_box"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PedestrianCategory/","text":"openscenario_interpreter::syntax::PedestrianCategory # Public Types # Name enum value_type { wheelchair, pedestrian, animal } Public Functions # Name constexpr operator value_type () const constexpr PedestrianCategory (value_type value ={}) Public Attributes # Name enum openscenario_interpreter::syntax::PedestrianCategory::value_type value Public Types Documentation # enum value_type # Enumerator Value Description wheelchair pedestrian animal Public Functions Documentation # function operator value_type # inline constexpr operator value_type () const function PedestrianCategory # inline explicit constexpr PedestrianCategory ( value_type value = {} ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: PedestrianCategory :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::PedestrianCategory"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PedestrianCategory/#openscenario_interpretersyntaxpedestriancategory","text":"","title":"openscenario_interpreter::syntax::PedestrianCategory"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PedestrianCategory/#public-types","text":"Name enum value_type { wheelchair, pedestrian, animal }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PedestrianCategory/#public-functions","text":"Name constexpr operator value_type () const constexpr PedestrianCategory (value_type value ={})","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PedestrianCategory/#public-attributes","text":"Name enum openscenario_interpreter::syntax::PedestrianCategory::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PedestrianCategory/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PedestrianCategory/#enum-value_type","text":"Enumerator Value Description wheelchair pedestrian animal","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PedestrianCategory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PedestrianCategory/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PedestrianCategory/#function-pedestriancategory","text":"inline explicit constexpr PedestrianCategory ( value_type value = {} )","title":"function PedestrianCategory"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PedestrianCategory/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PedestrianCategory/#variable-value","text":"enum openscenario_interpreter :: syntax :: PedestrianCategory :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Performance/","text":"openscenario_interpreter::syntax::Performance # Public Functions # Name Performance () =default template \\<typename Node ,typename Scope > Performance (const Node & node, Scope & scope) Public Attributes # Name const Double max_speed const Double max_deceleration const Double max_acceleration Public Functions Documentation # function Performance # Performance () = default function Performance # template < typename Node , typename Scope > inline explicit Performance ( const Node & node , Scope & scope ) Public Attributes Documentation # variable max_speed # const Double max_speed ; variable max_deceleration # const Double max_deceleration ; variable max_acceleration # const Double max_acceleration ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Performance"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Performance/#openscenario_interpretersyntaxperformance","text":"","title":"openscenario_interpreter::syntax::Performance"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Performance/#public-functions","text":"Name Performance () =default template \\<typename Node ,typename Scope > Performance (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Performance/#public-attributes","text":"Name const Double max_speed const Double max_deceleration const Double max_acceleration","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Performance/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Performance/#function-performance","text":"Performance () = default","title":"function Performance"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Performance/#function-performance_1","text":"template < typename Node , typename Scope > inline explicit Performance ( const Node & node , Scope & scope )","title":"function Performance"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Performance/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Performance/#variable-max_speed","text":"const Double max_speed ;","title":"variable max_speed"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Performance/#variable-max_deceleration","text":"const Double max_deceleration ;","title":"variable max_deceleration"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Performance/#variable-max_acceleration","text":"const Double max_acceleration ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable max_acceleration"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Phase/","text":"openscenario_interpreter::syntax::Phase # Public Functions # Name template \\<typename Node ,typename Scope > Phase (const Node & node, Scope & outer_scope) Public Attributes # Name const TrafficSignalState state const String name const Double duration Public Functions Documentation # function Phase # template < typename Node , typename Scope > inline explicit Phase ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable state # const TrafficSignalState state ; variable name # const String name ; variable duration # const Double duration ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Phase"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Phase/#openscenario_interpretersyntaxphase","text":"","title":"openscenario_interpreter::syntax::Phase"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Phase/#public-functions","text":"Name template \\<typename Node ,typename Scope > Phase (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Phase/#public-attributes","text":"Name const TrafficSignalState state const String name const Double duration","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Phase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Phase/#function-phase","text":"template < typename Node , typename Scope > inline explicit Phase ( const Node & node , Scope & outer_scope )","title":"function Phase"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Phase/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Phase/#variable-state","text":"const TrafficSignalState state ;","title":"variable state"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Phase/#variable-name","text":"const String name ;","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Phase/#variable-duration","text":"const Double duration ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable duration"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Position/","text":"openscenario_interpreter::syntax::Position # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name operator geometry_msgs::msg::Pose () const template \\<typename XML ,typename ... Ts> Position (const XML & node, Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function operator geometry_msgs::msg::Pose # inline explicit operator geometry_msgs :: msg :: Pose () const function Position # template < typename XML , typename ... Ts > inline explicit Position ( const XML & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Position"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Position/#openscenario_interpretersyntaxposition","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::Position"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Position/#public-functions","text":"Name operator geometry_msgs::msg::Pose () const template \\<typename XML ,typename ... Ts> Position (const XML & node, Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Position/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Position/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Position/#function-operator-geometry_msgsmsgpose","text":"inline explicit operator geometry_msgs :: msg :: Pose () const","title":"function operator geometry_msgs::msg::Pose"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Position/#function-position","text":"template < typename XML , typename ... Ts > inline explicit Position ( const XML & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function Position"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Priority/","text":"openscenario_interpreter::syntax::Priority # Public Types # Name enum value_type { skip, parallel, overwrite } Public Functions # Name constexpr operator value_type () const constexpr Priority (value_type value ={}) Public Attributes # Name enum openscenario_interpreter::syntax::Priority::value_type value Public Types Documentation # enum value_type # Enumerator Value Description skip parallel overwrite Public Functions Documentation # function operator value_type # inline constexpr operator value_type () const function Priority # inline explicit constexpr Priority ( value_type value = {} ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: Priority :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Priority"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Priority/#openscenario_interpretersyntaxpriority","text":"","title":"openscenario_interpreter::syntax::Priority"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Priority/#public-types","text":"Name enum value_type { skip, parallel, overwrite }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Priority/#public-functions","text":"Name constexpr operator value_type () const constexpr Priority (value_type value ={})","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Priority/#public-attributes","text":"Name enum openscenario_interpreter::syntax::Priority::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Priority/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Priority/#enum-value_type","text":"Enumerator Value Description skip parallel overwrite","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Priority/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Priority/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Priority/#function-priority","text":"inline explicit constexpr Priority ( value_type value = {} )","title":"function Priority"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Priority/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Priority/#variable-value","text":"enum openscenario_interpreter :: syntax :: Priority :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Private/","text":"openscenario_interpreter::syntax::Private # Inherits from std::vector< PrivateAction > Public Functions # Name auto evaluate () template \\<typename Node > Private (const Node & node, Scope & outer_scope) Public Attributes # Name Scope inner_scope Public Functions Documentation # function evaluate # inline auto evaluate () function Private # template < typename Node > inline explicit Private ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable inner_scope # Scope inner_scope ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Private"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Private/#openscenario_interpretersyntaxprivate","text":"Inherits from std::vector< PrivateAction >","title":"openscenario_interpreter::syntax::Private"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Private/#public-functions","text":"Name auto evaluate () template \\<typename Node > Private (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Private/#public-attributes","text":"Name Scope inner_scope","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Private/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Private/#function-evaluate","text":"inline auto evaluate ()","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Private/#function-private","text":"template < typename Node > inline explicit Private ( const Node & node , Scope & outer_scope )","title":"function Private"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Private/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Private/#variable-inner_scope","text":"Scope inner_scope ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PrivateAction/","text":"openscenario_interpreter::syntax::PrivateAction # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name template \\<typename Node ,typename ... Ts> PrivateAction (const Node & node, Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function PrivateAction # template < typename Node , typename ... Ts > inline explicit PrivateAction ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::PrivateAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PrivateAction/#openscenario_interpretersyntaxprivateaction","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::PrivateAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PrivateAction/#public-functions","text":"Name template \\<typename Node ,typename ... Ts> PrivateAction (const Node & node, Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PrivateAction/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PrivateAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1PrivateAction/#function-privateaction","text":"template < typename Node , typename ... Ts > inline explicit PrivateAction ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function PrivateAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Properties/","text":"openscenario_interpreter::syntax::Properties # Public Functions # Name template \\<typename ... Ts> decltype(auto) operator[] (Ts &&... xs) Properties () =default template \\<typename Node ,typename Scope > Properties (const Node & node, Scope & outer_scope) Public Attributes # Name std::unordered_map< Property::Name, Property > properties std::vector< File > files Public Functions Documentation # function operator[] # template < typename ... Ts > inline decltype ( auto ) operator []( Ts && ... xs ) function Properties # Properties () = default function Properties # template < typename Node , typename Scope > inline explicit Properties ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable properties # std :: unordered_map < Property :: Name , Property > properties ; variable files # std :: vector < File > files ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Properties"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Properties/#openscenario_interpretersyntaxproperties","text":"","title":"openscenario_interpreter::syntax::Properties"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Properties/#public-functions","text":"Name template \\<typename ... Ts> decltype(auto) operator[] (Ts &&... xs) Properties () =default template \\<typename Node ,typename Scope > Properties (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Properties/#public-attributes","text":"Name std::unordered_map< Property::Name, Property > properties std::vector< File > files","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Properties/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Properties/#function-operator","text":"template < typename ... Ts > inline decltype ( auto ) operator []( Ts && ... xs )","title":"function operator[]"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Properties/#function-properties","text":"Properties () = default","title":"function Properties"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Properties/#function-properties_1","text":"template < typename Node , typename Scope > inline explicit Properties ( const Node & node , Scope & outer_scope )","title":"function Properties"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Properties/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Properties/#variable-properties","text":"std :: unordered_map < Property :: Name , Property > properties ;","title":"variable properties"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Properties/#variable-files","text":"std :: vector < File > files ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable files"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Property/","text":"openscenario_interpreter::syntax::Property # Public Types # Name using String Value using String Name Public Functions # Name operator bool () const Property () =default template \\<typename Node ,typename Scope > Property (const Node & node, Scope & outer_scope) Public Attributes # Name const Value value const Name name Public Types Documentation # using Value # using openscenario_interpreter :: syntax :: Property :: Value = String ; using Name # using openscenario_interpreter :: syntax :: Property :: Name = String ; Public Functions Documentation # function operator bool # inline operator bool () const function Property # Property () = default function Property # template < typename Node , typename Scope > inline explicit Property ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable value # const Value value ; variable name # const Name name ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Property"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Property/#openscenario_interpretersyntaxproperty","text":"","title":"openscenario_interpreter::syntax::Property"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Property/#public-types","text":"Name using String Value using String Name","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Property/#public-functions","text":"Name operator bool () const Property () =default template \\<typename Node ,typename Scope > Property (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Property/#public-attributes","text":"Name const Value value const Name name","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Property/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Property/#using-value","text":"using openscenario_interpreter :: syntax :: Property :: Value = String ;","title":"using Value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Property/#using-name","text":"using openscenario_interpreter :: syntax :: Property :: Name = String ;","title":"using Name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Property/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Property/#function-operator-bool","text":"inline operator bool () const","title":"function operator bool"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Property/#function-property","text":"Property () = default","title":"function Property"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Property/#function-property_1","text":"template < typename Node , typename Scope > inline explicit Property ( const Node & node , Scope & outer_scope )","title":"function Property"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Property/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Property/#variable-value","text":"const Value value ;","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Property/#variable-name","text":"const Name name ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/","text":"openscenario_interpreter::syntax::ReachPositionCondition # Public Types # Name using TriggeringEntities::value_type TriggeringEntity Public Functions # Name decltype(auto) operator() (const WorldPosition & world_position, const TriggeringEntity & triggering_entity) const bool operator() (const RelativeWorldPosition & , const TriggeringEntity & ) const decltype(auto) operator() (const LanePosition & lane_position, const TriggeringEntity & triggering_entity) const auto evaluate () auto distance (const TriggeringEntity & name) template \\<typename Node > ReachPositionCondition (const Node & node, Scope & outer_scope, const TriggeringEntities & triggering_entities) Public Attributes # Name const Double tolerance const Position position const TriggeringEntities for_each Public Types Documentation # using TriggeringEntity # using openscenario_interpreter :: syntax :: ReachPositionCondition :: TriggeringEntity = TriggeringEntities :: value_type ; Public Functions Documentation # function operator() # inline decltype ( auto ) operator ()( const WorldPosition & world_position , const TriggeringEntity & triggering_entity ) const function operator() # inline bool operator ()( const RelativeWorldPosition & , const TriggeringEntity & ) const function operator() # inline decltype ( auto ) operator ()( const LanePosition & lane_position , const TriggeringEntity & triggering_entity ) const function evaluate # inline auto evaluate () function distance # inline auto distance ( const TriggeringEntity & name ) function ReachPositionCondition # template < typename Node > inline explicit ReachPositionCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & triggering_entities ) Public Attributes Documentation # variable tolerance # const Double tolerance ; variable position # const Position position ; variable for_each # const TriggeringEntities for_each ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ReachPositionCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#openscenario_interpretersyntaxreachpositioncondition","text":"","title":"openscenario_interpreter::syntax::ReachPositionCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#public-types","text":"Name using TriggeringEntities::value_type TriggeringEntity","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#public-functions","text":"Name decltype(auto) operator() (const WorldPosition & world_position, const TriggeringEntity & triggering_entity) const bool operator() (const RelativeWorldPosition & , const TriggeringEntity & ) const decltype(auto) operator() (const LanePosition & lane_position, const TriggeringEntity & triggering_entity) const auto evaluate () auto distance (const TriggeringEntity & name) template \\<typename Node > ReachPositionCondition (const Node & node, Scope & outer_scope, const TriggeringEntities & triggering_entities)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#public-attributes","text":"Name const Double tolerance const Position position const TriggeringEntities for_each","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#using-triggeringentity","text":"using openscenario_interpreter :: syntax :: ReachPositionCondition :: TriggeringEntity = TriggeringEntities :: value_type ;","title":"using TriggeringEntity"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#function-operator","text":"inline decltype ( auto ) operator ()( const WorldPosition & world_position , const TriggeringEntity & triggering_entity ) const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#function-operator_1","text":"inline bool operator ()( const RelativeWorldPosition & , const TriggeringEntity & ) const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#function-operator_2","text":"inline decltype ( auto ) operator ()( const LanePosition & lane_position , const TriggeringEntity & triggering_entity ) const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#function-evaluate","text":"inline auto evaluate ()","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#function-distance","text":"inline auto distance ( const TriggeringEntity & name )","title":"function distance"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#function-reachpositioncondition","text":"template < typename Node > inline explicit ReachPositionCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & triggering_entities )","title":"function ReachPositionCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#variable-tolerance","text":"const Double tolerance ;","title":"variable tolerance"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#variable-position","text":"const Position position ;","title":"variable position"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReachPositionCondition/#variable-for_each","text":"const TriggeringEntities for_each ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable for_each"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RearAxle/","text":"openscenario_interpreter::syntax::RearAxle # Inherits from openscenario_interpreter::syntax::Axle Additional inherited members # Public Functions inherited from openscenario_interpreter::syntax::Axle Name Axle () =default Axle (const Node & node, Scope & scope) Public Attributes inherited from openscenario_interpreter::syntax::Axle Name const Double wheel_diameter const Double track_width const Double position_z const Double position_x const Double max_steering Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::RearAxle"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RearAxle/#openscenario_interpretersyntaxrearaxle","text":"Inherits from openscenario_interpreter::syntax::Axle","title":"openscenario_interpreter::syntax::RearAxle"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RearAxle/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::syntax::Axle Name Axle () =default Axle (const Node & node, Scope & scope) Public Attributes inherited from openscenario_interpreter::syntax::Axle Name const Double wheel_diameter const Double track_width const Double position_z const Double position_x const Double max_steering Updated on 7 April 2021 at 00:31:56 UTC","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReferenceContext/","text":"openscenario_interpreter::syntax::ReferenceContext # Public Types # Name enum value_type { relative, absolute } Public Functions # Name constexpr operator value_type () const constexpr ReferenceContext (value_type value ={}) Public Attributes # Name enum openscenario_interpreter::syntax::ReferenceContext::value_type value Public Types Documentation # enum value_type # Enumerator Value Description relative absolute Public Functions Documentation # function operator value_type # inline constexpr operator value_type () const function ReferenceContext # inline constexpr ReferenceContext ( value_type value = {} ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: ReferenceContext :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ReferenceContext"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReferenceContext/#openscenario_interpretersyntaxreferencecontext","text":"","title":"openscenario_interpreter::syntax::ReferenceContext"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReferenceContext/#public-types","text":"Name enum value_type { relative, absolute }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReferenceContext/#public-functions","text":"Name constexpr operator value_type () const constexpr ReferenceContext (value_type value ={})","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReferenceContext/#public-attributes","text":"Name enum openscenario_interpreter::syntax::ReferenceContext::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReferenceContext/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReferenceContext/#enum-value_type","text":"Enumerator Value Description relative absolute","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReferenceContext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReferenceContext/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReferenceContext/#function-referencecontext","text":"inline constexpr ReferenceContext ( value_type value = {} )","title":"function ReferenceContext"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReferenceContext/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ReferenceContext/#variable-value","text":"enum openscenario_interpreter :: syntax :: ReferenceContext :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/","text":"openscenario_interpreter::syntax::RelativeDistanceCondition # Public Types # Name using TriggeringEntities::value_type TriggeringEntity Public Functions # Name template \\<typename ... Ts> auto operator() (Ts &&... xs) auto evaluate () auto distance (const TriggeringEntity & triggering_entity) template \\<typename Node ,typename Scope > RelativeDistanceCondition (const Node & node, Scope & outer_scope, const TriggeringEntities & triggering_entities) Public Attributes # Name const Double value const RelativeDistanceType relative_distance_type const Boolean freespace const TriggeringEntities for_each const String entity_ref const Rule compare Public Types Documentation # using TriggeringEntity # using openscenario_interpreter :: syntax :: RelativeDistanceCondition :: TriggeringEntity = TriggeringEntities :: value_type ; Public Functions Documentation # function operator() # template < typename ... Ts > inline auto operator ()( Ts && ... xs ) function evaluate # inline auto evaluate () function distance # inline auto distance ( const TriggeringEntity & triggering_entity ) function RelativeDistanceCondition # template < typename Node , typename Scope > inline explicit RelativeDistanceCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & triggering_entities ) Public Attributes Documentation # variable value # const Double value ; variable relative_distance_type # const RelativeDistanceType relative_distance_type ; variable freespace # const Boolean freespace ; variable for_each # const TriggeringEntities for_each ; variable entity_ref # const String entity_ref ; variable compare # const Rule compare ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::RelativeDistanceCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#openscenario_interpretersyntaxrelativedistancecondition","text":"","title":"openscenario_interpreter::syntax::RelativeDistanceCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#public-types","text":"Name using TriggeringEntities::value_type TriggeringEntity","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#public-functions","text":"Name template \\<typename ... Ts> auto operator() (Ts &&... xs) auto evaluate () auto distance (const TriggeringEntity & triggering_entity) template \\<typename Node ,typename Scope > RelativeDistanceCondition (const Node & node, Scope & outer_scope, const TriggeringEntities & triggering_entities)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#public-attributes","text":"Name const Double value const RelativeDistanceType relative_distance_type const Boolean freespace const TriggeringEntities for_each const String entity_ref const Rule compare","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#using-triggeringentity","text":"using openscenario_interpreter :: syntax :: RelativeDistanceCondition :: TriggeringEntity = TriggeringEntities :: value_type ;","title":"using TriggeringEntity"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#function-operator","text":"template < typename ... Ts > inline auto operator ()( Ts && ... xs )","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#function-evaluate","text":"inline auto evaluate ()","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#function-distance","text":"inline auto distance ( const TriggeringEntity & triggering_entity )","title":"function distance"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#function-relativedistancecondition","text":"template < typename Node , typename Scope > inline explicit RelativeDistanceCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & triggering_entities )","title":"function RelativeDistanceCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#variable-value","text":"const Double value ;","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#variable-relative_distance_type","text":"const RelativeDistanceType relative_distance_type ;","title":"variable relative_distance_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#variable-freespace","text":"const Boolean freespace ;","title":"variable freespace"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#variable-for_each","text":"const TriggeringEntities for_each ;","title":"variable for_each"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#variable-entity_ref","text":"const String entity_ref ;","title":"variable entity_ref"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceCondition/#variable-compare","text":"const Rule compare ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable compare"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceType/","text":"openscenario_interpreter::syntax::RelativeDistanceType # Public Types # Name enum value_type { longitudinal, lateral, cartesianDistance } Public Functions # Name constexpr operator value_type () const constexpr RelativeDistanceType (value_type value ={}) Public Attributes # Name enum openscenario_interpreter::syntax::RelativeDistanceType::value_type value Public Types Documentation # enum value_type # Enumerator Value Description longitudinal lateral cartesianDistance Public Functions Documentation # function operator value_type # inline constexpr operator value_type () const function RelativeDistanceType # inline explicit constexpr RelativeDistanceType ( value_type value = {} ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: RelativeDistanceType :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::RelativeDistanceType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceType/#openscenario_interpretersyntaxrelativedistancetype","text":"","title":"openscenario_interpreter::syntax::RelativeDistanceType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceType/#public-types","text":"Name enum value_type { longitudinal, lateral, cartesianDistance }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceType/#public-functions","text":"Name constexpr operator value_type () const constexpr RelativeDistanceType (value_type value ={})","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceType/#public-attributes","text":"Name enum openscenario_interpreter::syntax::RelativeDistanceType::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceType/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceType/#enum-value_type","text":"Enumerator Value Description longitudinal lateral cartesianDistance","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceType/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceType/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceType/#function-relativedistancetype","text":"inline explicit constexpr RelativeDistanceType ( value_type value = {} )","title":"function RelativeDistanceType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceType/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeDistanceType/#variable-value","text":"enum openscenario_interpreter :: syntax :: RelativeDistanceType :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeTargetSpeed/","text":"openscenario_interpreter::syntax::RelativeTargetSpeed # Public Functions # Name template \\<typename Node ,typename Scope > RelativeTargetSpeed (const Node & node, Scope & scope) Public Attributes # Name const Double value const SpeedTargetValueType speed_target_value_type const String entity_ref const Boolean continuous Public Functions Documentation # function RelativeTargetSpeed # template < typename Node , typename Scope > inline explicit RelativeTargetSpeed ( const Node & node , Scope & scope ) Public Attributes Documentation # variable value # const Double value ; variable speed_target_value_type # const SpeedTargetValueType speed_target_value_type ; variable entity_ref # const String entity_ref ; variable continuous # const Boolean continuous ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::RelativeTargetSpeed"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeTargetSpeed/#openscenario_interpretersyntaxrelativetargetspeed","text":"","title":"openscenario_interpreter::syntax::RelativeTargetSpeed"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeTargetSpeed/#public-functions","text":"Name template \\<typename Node ,typename Scope > RelativeTargetSpeed (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeTargetSpeed/#public-attributes","text":"Name const Double value const SpeedTargetValueType speed_target_value_type const String entity_ref const Boolean continuous","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeTargetSpeed/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeTargetSpeed/#function-relativetargetspeed","text":"template < typename Node , typename Scope > inline explicit RelativeTargetSpeed ( const Node & node , Scope & scope )","title":"function RelativeTargetSpeed"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeTargetSpeed/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeTargetSpeed/#variable-value","text":"const Double value ;","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeTargetSpeed/#variable-speed_target_value_type","text":"const SpeedTargetValueType speed_target_value_type ;","title":"variable speed_target_value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeTargetSpeed/#variable-entity_ref","text":"const String entity_ref ;","title":"variable entity_ref"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeTargetSpeed/#variable-continuous","text":"const Boolean continuous ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable continuous"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeWorldPosition/","text":"openscenario_interpreter::syntax::RelativeWorldPosition # Public Functions # Name operator openscenario_msgs::msg::LaneletPose () const operator geometry_msgs::msg::Point () const template \\<typename Node ,typename Scope > RelativeWorldPosition (const Node & node, Scope & scope) Public Attributes # Name const EntityRef reference const Orientation orientation const Double dz const Double dy const Double dx Public Functions Documentation # function operator openscenario_msgs::msg::LaneletPose # inline explicit operator openscenario_msgs :: msg :: LaneletPose () const function operator geometry_msgs::msg::Point # inline operator geometry_msgs :: msg :: Point () const function RelativeWorldPosition # template < typename Node , typename Scope > inline explicit RelativeWorldPosition ( const Node & node , Scope & scope ) Public Attributes Documentation # variable reference # const EntityRef reference ; variable orientation # const Orientation orientation ; variable dz # const Double dz ; variable dy # const Double dy ; variable dx # const Double dx ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::RelativeWorldPosition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeWorldPosition/#openscenario_interpretersyntaxrelativeworldposition","text":"","title":"openscenario_interpreter::syntax::RelativeWorldPosition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeWorldPosition/#public-functions","text":"Name operator openscenario_msgs::msg::LaneletPose () const operator geometry_msgs::msg::Point () const template \\<typename Node ,typename Scope > RelativeWorldPosition (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeWorldPosition/#public-attributes","text":"Name const EntityRef reference const Orientation orientation const Double dz const Double dy const Double dx","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeWorldPosition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeWorldPosition/#function-operator-openscenario_msgsmsglaneletpose","text":"inline explicit operator openscenario_msgs :: msg :: LaneletPose () const","title":"function operator openscenario_msgs::msg::LaneletPose"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeWorldPosition/#function-operator-geometry_msgsmsgpoint","text":"inline operator geometry_msgs :: msg :: Point () const","title":"function operator geometry_msgs::msg::Point"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeWorldPosition/#function-relativeworldposition","text":"template < typename Node , typename Scope > inline explicit RelativeWorldPosition ( const Node & node , Scope & scope )","title":"function RelativeWorldPosition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeWorldPosition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeWorldPosition/#variable-reference","text":"const EntityRef reference ;","title":"variable reference"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeWorldPosition/#variable-orientation","text":"const Orientation orientation ;","title":"variable orientation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeWorldPosition/#variable-dz","text":"const Double dz ;","title":"variable dz"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeWorldPosition/#variable-dy","text":"const Double dy ;","title":"variable dy"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RelativeWorldPosition/#variable-dx","text":"const Double dx ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable dx"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoadNetwork/","text":"openscenario_interpreter::syntax::RoadNetwork # Public Functions # Name template \\<typename Node ,typename Scope > RoadNetwork (const Node & node, Scope & outer_scope) Public Attributes # Name const TrafficSignals traffic_signals const File scene_graph_file const File logic_file Public Functions Documentation # function RoadNetwork # template < typename Node , typename Scope > inline explicit RoadNetwork ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable traffic_signals # const TrafficSignals traffic_signals ; variable scene_graph_file # const File scene_graph_file ; variable logic_file # const File logic_file ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::RoadNetwork"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoadNetwork/#openscenario_interpretersyntaxroadnetwork","text":"","title":"openscenario_interpreter::syntax::RoadNetwork"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoadNetwork/#public-functions","text":"Name template \\<typename Node ,typename Scope > RoadNetwork (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoadNetwork/#public-attributes","text":"Name const TrafficSignals traffic_signals const File scene_graph_file const File logic_file","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoadNetwork/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoadNetwork/#function-roadnetwork","text":"template < typename Node , typename Scope > inline explicit RoadNetwork ( const Node & node , Scope & outer_scope )","title":"function RoadNetwork"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoadNetwork/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoadNetwork/#variable-traffic_signals","text":"const TrafficSignals traffic_signals ;","title":"variable traffic_signals"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoadNetwork/#variable-scene_graph_file","text":"const File scene_graph_file ;","title":"variable scene_graph_file"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoadNetwork/#variable-logic_file","text":"const File logic_file ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable logic_file"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Route/","text":"openscenario_interpreter::syntax::Route # Public Functions # Name operator std::vector< openscenario_msgs::msg::LaneletPose > () const template \\<typename Node > Route (const Node & node, Scope & outer_scope) Public Attributes # Name std::vector< Waypoint > waypoints const String name Scope inner_scope const Boolean closed Public Functions Documentation # function operator std::vector< openscenario_msgs::msg::LaneletPose > # inline explicit operator std :: vector < openscenario_msgs :: msg :: LaneletPose > () const function Route # template < typename Node > inline explicit Route ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable waypoints # std :: vector < Waypoint > waypoints ; variable name # const String name ; variable inner_scope # Scope inner_scope ; variable closed # const Boolean closed ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Route"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Route/#openscenario_interpretersyntaxroute","text":"","title":"openscenario_interpreter::syntax::Route"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Route/#public-functions","text":"Name operator std::vector< openscenario_msgs::msg::LaneletPose > () const template \\<typename Node > Route (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Route/#public-attributes","text":"Name std::vector< Waypoint > waypoints const String name Scope inner_scope const Boolean closed","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Route/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Route/#function-operator-stdvector-openscenario_msgsmsglaneletpose","text":"inline explicit operator std :: vector < openscenario_msgs :: msg :: LaneletPose > () const","title":"function operator std::vector&lt; openscenario_msgs::msg::LaneletPose &gt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Route/#function-route","text":"template < typename Node > inline explicit Route ( const Node & node , Scope & outer_scope )","title":"function Route"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Route/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Route/#variable-waypoints","text":"std :: vector < Waypoint > waypoints ;","title":"variable waypoints"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Route/#variable-name","text":"const String name ;","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Route/#variable-inner_scope","text":"Scope inner_scope ;","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Route/#variable-closed","text":"const Boolean closed ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable closed"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RouteStrategy/","text":"openscenario_interpreter::syntax::RouteStrategy # Public Types # Name enum value_type { shortest, random, leastIntersections, fastest } Public Functions # Name constexpr operator value_type () const constexpr RouteStrategy (value_type value ={}) Public Attributes # Name enum openscenario_interpreter::syntax::RouteStrategy::value_type value Public Types Documentation # enum value_type # Enumerator Value Description shortest random leastIntersections fastest Public Functions Documentation # function operator value_type # inline constexpr operator value_type () const function RouteStrategy # inline explicit constexpr RouteStrategy ( value_type value = {} ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: RouteStrategy :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::RouteStrategy"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RouteStrategy/#openscenario_interpretersyntaxroutestrategy","text":"","title":"openscenario_interpreter::syntax::RouteStrategy"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RouteStrategy/#public-types","text":"Name enum value_type { shortest, random, leastIntersections, fastest }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RouteStrategy/#public-functions","text":"Name constexpr operator value_type () const constexpr RouteStrategy (value_type value ={})","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RouteStrategy/#public-attributes","text":"Name enum openscenario_interpreter::syntax::RouteStrategy::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RouteStrategy/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RouteStrategy/#enum-value_type","text":"Enumerator Value Description shortest random leastIntersections fastest","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RouteStrategy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RouteStrategy/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RouteStrategy/#function-routestrategy","text":"inline explicit constexpr RouteStrategy ( value_type value = {} )","title":"function RouteStrategy"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RouteStrategy/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RouteStrategy/#variable-value","text":"enum openscenario_interpreter :: syntax :: RouteStrategy :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoutingAction/","text":"openscenario_interpreter::syntax::RoutingAction # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name template \\<typename Node ,typename ... Ts> RoutingAction (const Node & node, Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function RoutingAction # template < typename Node , typename ... Ts > inline explicit RoutingAction ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::RoutingAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoutingAction/#openscenario_interpretersyntaxroutingaction","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::RoutingAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoutingAction/#public-functions","text":"Name template \\<typename Node ,typename ... Ts> RoutingAction (const Node & node, Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoutingAction/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoutingAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1RoutingAction/#function-routingaction","text":"template < typename Node , typename ... Ts > inline explicit RoutingAction ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function RoutingAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Rule/","text":"openscenario_interpreter::syntax::Rule # Public Types # Name enum value_type { lessThan, greaterThan, equalTo } Public Functions # Name template \\<typename T ,typename U =T> decltype(auto) constexpr operator() (const T & lhs, const U & rhs) const constexpr operator value_type () const constexpr Rule (value_type value ={}) Public Attributes # Name enum openscenario_interpreter::syntax::Rule::value_type value Public Types Documentation # enum value_type # Enumerator Value Description lessThan greaterThan equalTo Public Functions Documentation # function operator() # template < typename T , typename U = T > inline decltype ( auto ) constexpr operator ()( const T & lhs , const U & rhs ) const function operator value_type # inline constexpr operator value_type () const function Rule # inline explicit constexpr Rule ( value_type value = {} ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: Rule :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Rule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Rule/#openscenario_interpretersyntaxrule","text":"","title":"openscenario_interpreter::syntax::Rule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Rule/#public-types","text":"Name enum value_type { lessThan, greaterThan, equalTo }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Rule/#public-functions","text":"Name template \\<typename T ,typename U =T> decltype(auto) constexpr operator() (const T & lhs, const U & rhs) const constexpr operator value_type () const constexpr Rule (value_type value ={})","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Rule/#public-attributes","text":"Name enum openscenario_interpreter::syntax::Rule::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Rule/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Rule/#enum-value_type","text":"Enumerator Value Description lessThan greaterThan equalTo","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Rule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Rule/#function-operator","text":"template < typename T , typename U = T > inline decltype ( auto ) constexpr operator ()( const T & lhs , const U & rhs ) const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Rule/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Rule/#function-rule","text":"inline explicit constexpr Rule ( value_type value = {} )","title":"function Rule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Rule/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Rule/#variable-value","text":"enum openscenario_interpreter :: syntax :: Rule :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioDefinition/","text":"openscenario_interpreter::syntax::ScenarioDefinition # Public Functions # Name template \\<typename ... Ts> auto evaluate (Ts &&... xs) template \\<typename ... Ts> decltype(auto) complete (Ts &&... xs) template \\<typename Node ,typename Scope > ScenarioDefinition (const Node & node, Scope & outer_scope) Public Attributes # Name Element storyboard Public Functions Documentation # function evaluate # template < typename ... Ts > inline auto evaluate ( Ts && ... xs ) function complete # template < typename ... Ts > inline decltype ( auto ) complete ( Ts && ... xs ) function ScenarioDefinition # template < typename Node , typename Scope > inline explicit ScenarioDefinition ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable storyboard # Element storyboard ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ScenarioDefinition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioDefinition/#openscenario_interpretersyntaxscenariodefinition","text":"","title":"openscenario_interpreter::syntax::ScenarioDefinition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioDefinition/#public-functions","text":"Name template \\<typename ... Ts> auto evaluate (Ts &&... xs) template \\<typename ... Ts> decltype(auto) complete (Ts &&... xs) template \\<typename Node ,typename Scope > ScenarioDefinition (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioDefinition/#public-attributes","text":"Name Element storyboard","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioDefinition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioDefinition/#function-evaluate","text":"template < typename ... Ts > inline auto evaluate ( Ts && ... xs )","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioDefinition/#function-complete","text":"template < typename ... Ts > inline decltype ( auto ) complete ( Ts && ... xs )","title":"function complete"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioDefinition/#function-scenariodefinition","text":"template < typename Node , typename Scope > inline explicit ScenarioDefinition ( const Node & node , Scope & outer_scope )","title":"function ScenarioDefinition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioDefinition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioDefinition/#variable-storyboard","text":"Element storyboard ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable storyboard"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioObject/","text":"openscenario_interpreter::syntax::ScenarioObject # Inherits from openscenario_interpreter::syntax::EntityObject , openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Types # Name using String Name Public Functions # Name auto evaluate () template \\<typename Node ,typename Scope > ScenarioObject (const Node & node, Scope & outer_scope) Public Attributes # Name ObjectController object_controller const Name name Additional inherited members # Public Functions inherited from openscenario_interpreter::syntax::EntityObject Name EntityObject (const Node & node, Ts &&... xs) Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Types Documentation # using Name # using openscenario_interpreter :: syntax :: ScenarioObject :: Name = String ; Public Functions Documentation # function evaluate # inline auto evaluate () function ScenarioObject # template < typename Node , typename Scope > inline explicit ScenarioObject ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable object_controller # ObjectController object_controller ; variable name # const Name name ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::ScenarioObject"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioObject/#openscenario_interpretersyntaxscenarioobject","text":"Inherits from openscenario_interpreter::syntax::EntityObject , openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::ScenarioObject"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioObject/#public-types","text":"Name using String Name","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioObject/#public-functions","text":"Name auto evaluate () template \\<typename Node ,typename Scope > ScenarioObject (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioObject/#public-attributes","text":"Name ObjectController object_controller const Name name","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioObject/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::syntax::EntityObject Name EntityObject (const Node & node, Ts &&... xs) Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioObject/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioObject/#using-name","text":"using openscenario_interpreter :: syntax :: ScenarioObject :: Name = String ;","title":"using Name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioObject/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioObject/#function-evaluate","text":"inline auto evaluate ()","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioObject/#function-scenarioobject","text":"template < typename Node , typename Scope > inline explicit ScenarioObject ( const Node & node , Scope & outer_scope )","title":"function ScenarioObject"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioObject/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioObject/#variable-object_controller","text":"ObjectController object_controller ;","title":"variable object_controller"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1ScenarioObject/#variable-name","text":"const Name name ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SelectedEntities/","text":"openscenario_interpreter::syntax::SelectedEntities # Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::SelectedEntities"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SelectedEntities/#openscenario_interpretersyntaxselectedentities","text":"Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::SelectedEntities"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SimulationTimeCondition/","text":"openscenario_interpreter::syntax::SimulationTimeCondition # Public Functions # Name auto evaluate () template \\<typename Node ,typename Scope > SimulationTimeCondition (const Node & node, Scope & scope) Public Attributes # Name const Double value Element result const Rule compare Friends # Name std::ostream & operator<< (std::ostream & os, const SimulationTimeCondition & condition) Public Functions Documentation # function evaluate # inline auto evaluate () function SimulationTimeCondition # template < typename Node , typename Scope > inline explicit SimulationTimeCondition ( const Node & node , Scope & scope ) Public Attributes Documentation # variable value # const Double value ; variable result # Element result ; variable compare # const Rule compare ; Friends # friend operator<< # friend std :: ostream & operator << ( std :: ostream & os , const SimulationTimeCondition & condition ); Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::SimulationTimeCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SimulationTimeCondition/#openscenario_interpretersyntaxsimulationtimecondition","text":"","title":"openscenario_interpreter::syntax::SimulationTimeCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SimulationTimeCondition/#public-functions","text":"Name auto evaluate () template \\<typename Node ,typename Scope > SimulationTimeCondition (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SimulationTimeCondition/#public-attributes","text":"Name const Double value Element result const Rule compare","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SimulationTimeCondition/#friends","text":"Name std::ostream & operator<< (std::ostream & os, const SimulationTimeCondition & condition)","title":"Friends"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SimulationTimeCondition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SimulationTimeCondition/#function-evaluate","text":"inline auto evaluate ()","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SimulationTimeCondition/#function-simulationtimecondition","text":"template < typename Node , typename Scope > inline explicit SimulationTimeCondition ( const Node & node , Scope & scope )","title":"function SimulationTimeCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SimulationTimeCondition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SimulationTimeCondition/#variable-value","text":"const Double value ;","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SimulationTimeCondition/#variable-result","text":"Element result ;","title":"variable result"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SimulationTimeCondition/#variable-compare","text":"const Rule compare ;","title":"variable compare"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SimulationTimeCondition/#friends_1","text":"","title":"Friends"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SimulationTimeCondition/#friend-operator","text":"friend std :: ostream & operator << ( std :: ostream & os , const SimulationTimeCondition & condition ); Updated on 7 April 2021 at 00:31:56 UTC","title":"friend operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/","text":"openscenario_interpreter::syntax::SpeedAction # Public Functions # Name auto update () auto start () template \\<typename T > decltype(auto) setStepTransition (const Scope::Actor & actor, const T value) const template \\<typename T > decltype(auto) setLinearTransition (const Scope::Actor & actor, const T value) const auto reset () decltype(auto) operator() (const Scope::Actor & actor) const auto check (const String & actor) auto accomplished () template \\<typename Node > SpeedAction (const Node & node, Scope & outer_scope) Public Attributes # Name const SpeedActionTarget speed_action_target const TransitionDynamics speed_action_dynamics Scope inner_scope std::unordered_map< String, Boolean > accomplishments Public Functions Documentation # function update # inline auto update () function start # inline auto start () function setStepTransition # template < typename T > inline decltype ( auto ) setStepTransition ( const Scope :: Actor & actor , const T value ) const function setLinearTransition # template < typename T > inline decltype ( auto ) setLinearTransition ( const Scope :: Actor & actor , const T value ) const function reset # inline auto reset () function operator() # inline decltype ( auto ) operator ()( const Scope :: Actor & actor ) const function check # inline auto check ( const String & actor ) function accomplished # inline auto accomplished () function SpeedAction # template < typename Node > inline explicit SpeedAction ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable speed_action_target # const SpeedActionTarget speed_action_target ; variable speed_action_dynamics # const TransitionDynamics speed_action_dynamics ; variable inner_scope # Scope inner_scope ; variable accomplishments # std :: unordered_map < String , Boolean > accomplishments ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::SpeedAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#openscenario_interpretersyntaxspeedaction","text":"","title":"openscenario_interpreter::syntax::SpeedAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#public-functions","text":"Name auto update () auto start () template \\<typename T > decltype(auto) setStepTransition (const Scope::Actor & actor, const T value) const template \\<typename T > decltype(auto) setLinearTransition (const Scope::Actor & actor, const T value) const auto reset () decltype(auto) operator() (const Scope::Actor & actor) const auto check (const String & actor) auto accomplished () template \\<typename Node > SpeedAction (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#public-attributes","text":"Name const SpeedActionTarget speed_action_target const TransitionDynamics speed_action_dynamics Scope inner_scope std::unordered_map< String, Boolean > accomplishments","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#function-update","text":"inline auto update ()","title":"function update"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#function-start","text":"inline auto start ()","title":"function start"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#function-setsteptransition","text":"template < typename T > inline decltype ( auto ) setStepTransition ( const Scope :: Actor & actor , const T value ) const","title":"function setStepTransition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#function-setlineartransition","text":"template < typename T > inline decltype ( auto ) setLinearTransition ( const Scope :: Actor & actor , const T value ) const","title":"function setLinearTransition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#function-reset","text":"inline auto reset ()","title":"function reset"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#function-operator","text":"inline decltype ( auto ) operator ()( const Scope :: Actor & actor ) const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#function-check","text":"inline auto check ( const String & actor )","title":"function check"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#function-accomplished","text":"inline auto accomplished ()","title":"function accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#function-speedaction","text":"template < typename Node > inline explicit SpeedAction ( const Node & node , Scope & outer_scope )","title":"function SpeedAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#variable-speed_action_target","text":"const SpeedActionTarget speed_action_target ;","title":"variable speed_action_target"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#variable-speed_action_dynamics","text":"const TransitionDynamics speed_action_dynamics ;","title":"variable speed_action_dynamics"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#variable-inner_scope","text":"Scope inner_scope ;","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedAction/#variable-accomplishments","text":"std :: unordered_map < String , Boolean > accomplishments ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable accomplishments"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedActionTarget/","text":"openscenario_interpreter::syntax::SpeedActionTarget # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name template \\<typename Node ,typename ... Ts> SpeedActionTarget (const Node & node, Ts &&... xs) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function SpeedActionTarget # template < typename Node , typename ... Ts > inline explicit SpeedActionTarget ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::SpeedActionTarget"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedActionTarget/#openscenario_interpretersyntaxspeedactiontarget","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::SpeedActionTarget"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedActionTarget/#public-functions","text":"Name template \\<typename Node ,typename ... Ts> SpeedActionTarget (const Node & node, Ts &&... xs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedActionTarget/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedActionTarget/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedActionTarget/#function-speedactiontarget","text":"template < typename Node , typename ... Ts > inline explicit SpeedActionTarget ( const Node & node , Ts && ... xs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function SpeedActionTarget"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedCondition/","text":"openscenario_interpreter::syntax::SpeedCondition # Public Functions # Name auto evaluate () template \\<typename AST > SpeedCondition (const AST & node, Scope & outer_scope, const TriggeringEntities & triggering_entities) Public Attributes # Name const Double value const TriggeringEntities for_each const Rule compare Public Functions Documentation # function evaluate # inline auto evaluate () function SpeedCondition # template < typename AST > inline explicit SpeedCondition ( const AST & node , Scope & outer_scope , const TriggeringEntities & triggering_entities ) Public Attributes Documentation # variable value # const Double value ; variable for_each # const TriggeringEntities for_each ; variable compare # const Rule compare ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::SpeedCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedCondition/#openscenario_interpretersyntaxspeedcondition","text":"","title":"openscenario_interpreter::syntax::SpeedCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedCondition/#public-functions","text":"Name auto evaluate () template \\<typename AST > SpeedCondition (const AST & node, Scope & outer_scope, const TriggeringEntities & triggering_entities)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedCondition/#public-attributes","text":"Name const Double value const TriggeringEntities for_each const Rule compare","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedCondition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedCondition/#function-evaluate","text":"inline auto evaluate ()","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedCondition/#function-speedcondition","text":"template < typename AST > inline explicit SpeedCondition ( const AST & node , Scope & outer_scope , const TriggeringEntities & triggering_entities )","title":"function SpeedCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedCondition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedCondition/#variable-value","text":"const Double value ;","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedCondition/#variable-for_each","text":"const TriggeringEntities for_each ;","title":"variable for_each"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedCondition/#variable-compare","text":"const Rule compare ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable compare"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedTargetValueType/","text":"openscenario_interpreter::syntax::SpeedTargetValueType # Public Types # Name enum value_type { factor, delta } Public Functions # Name constexpr operator value_type () const constexpr SpeedTargetValueType (value_type value =delta) Public Attributes # Name enum openscenario_interpreter::syntax::SpeedTargetValueType::value_type value Public Types Documentation # enum value_type # Enumerator Value Description factor delta Public Functions Documentation # function operator value_type # inline constexpr operator value_type () const function SpeedTargetValueType # inline explicit constexpr SpeedTargetValueType ( value_type value = delta ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: SpeedTargetValueType :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::SpeedTargetValueType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedTargetValueType/#openscenario_interpretersyntaxspeedtargetvaluetype","text":"","title":"openscenario_interpreter::syntax::SpeedTargetValueType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedTargetValueType/#public-types","text":"Name enum value_type { factor, delta }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedTargetValueType/#public-functions","text":"Name constexpr operator value_type () const constexpr SpeedTargetValueType (value_type value =delta)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedTargetValueType/#public-attributes","text":"Name enum openscenario_interpreter::syntax::SpeedTargetValueType::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedTargetValueType/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedTargetValueType/#enum-value_type","text":"Enumerator Value Description factor delta","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedTargetValueType/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedTargetValueType/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedTargetValueType/#function-speedtargetvaluetype","text":"inline explicit constexpr SpeedTargetValueType ( value_type value = delta )","title":"function SpeedTargetValueType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedTargetValueType/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1SpeedTargetValueType/#variable-value","text":"enum openscenario_interpreter :: syntax :: SpeedTargetValueType :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StandStillCondition/","text":"openscenario_interpreter::syntax::StandStillCondition # Public Functions # Name auto evaluate () const template \\<typename Node > StandStillCondition (const Node & node, Scope & outer_scope, const TriggeringEntities & for_each) Public Attributes # Name const TriggeringEntities for_each const Double duration const Rule compare Public Functions Documentation # function evaluate # inline auto evaluate () const function StandStillCondition # template < typename Node > inline explicit StandStillCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & for_each ) Public Attributes Documentation # variable for_each # const TriggeringEntities for_each ; variable duration # const Double duration ; variable compare # const Rule compare ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::StandStillCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StandStillCondition/#openscenario_interpretersyntaxstandstillcondition","text":"","title":"openscenario_interpreter::syntax::StandStillCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StandStillCondition/#public-functions","text":"Name auto evaluate () const template \\<typename Node > StandStillCondition (const Node & node, Scope & outer_scope, const TriggeringEntities & for_each)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StandStillCondition/#public-attributes","text":"Name const TriggeringEntities for_each const Double duration const Rule compare","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StandStillCondition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StandStillCondition/#function-evaluate","text":"inline auto evaluate () const","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StandStillCondition/#function-standstillcondition","text":"template < typename Node > inline explicit StandStillCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & for_each )","title":"function StandStillCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StandStillCondition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StandStillCondition/#variable-for_each","text":"const TriggeringEntities for_each ;","title":"variable for_each"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StandStillCondition/#variable-duration","text":"const Double duration ;","title":"variable duration"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StandStillCondition/#variable-compare","text":"const Rule compare ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable compare"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Story/","text":"openscenario_interpreter::syntax::Story # Inherits from openscenario_interpreter::syntax::StoryboardElement< Story > , Elements Public Functions # Name constexpr auto stopTriggered () auto stop () void run () constexpr auto ready () auto accomplished () const template \\<typename Node > Story (const Node & node, Scope & outer_scope) Public Attributes # Name const String name Scope inner_scope Additional inherited members # Public Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Story > Name const auto & state () const Element override () auto evaluate () auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition ) Protected Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Story > Name auto unique (const std::string & name) auto rename (const std::string & name) const decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs) Public Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Story > Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count Protected Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Story > Name std::unordered_set< std::string > names Public Functions Documentation # function stopTriggered # static inline constexpr auto stopTriggered () function stop # inline auto stop () function run # inline void run () function ready # static inline constexpr auto ready () function accomplished # inline auto accomplished () const function Story # template < typename Node > inline explicit Story ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable name # const String name ; variable inner_scope # Scope inner_scope ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Story"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Story/#openscenario_interpretersyntaxstory","text":"Inherits from openscenario_interpreter::syntax::StoryboardElement< Story > , Elements","title":"openscenario_interpreter::syntax::Story"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Story/#public-functions","text":"Name constexpr auto stopTriggered () auto stop () void run () constexpr auto ready () auto accomplished () const template \\<typename Node > Story (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Story/#public-attributes","text":"Name const String name Scope inner_scope","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Story/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Story > Name const auto & state () const Element override () auto evaluate () auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition ) Protected Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Story > Name auto unique (const std::string & name) auto rename (const std::string & name) const decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs) Public Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Story > Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count Protected Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Story > Name std::unordered_set< std::string > names","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Story/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Story/#function-stoptriggered","text":"static inline constexpr auto stopTriggered ()","title":"function stopTriggered"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Story/#function-stop","text":"inline auto stop ()","title":"function stop"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Story/#function-run","text":"inline void run ()","title":"function run"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Story/#function-ready","text":"static inline constexpr auto ready ()","title":"function ready"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Story/#function-accomplished","text":"inline auto accomplished () const","title":"function accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Story/#function-story","text":"template < typename Node > inline explicit Story ( const Node & node , Scope & outer_scope )","title":"function Story"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Story/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Story/#variable-name","text":"const String name ;","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Story/#variable-inner_scope","text":"Scope inner_scope ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/","text":"openscenario_interpreter::syntax::Storyboard # Inherits from openscenario_interpreter::syntax::StoryboardElement< Storyboard > , Elements Public Functions # Name decltype(auto) stopTriggered () void stop () void start () auto run () auto accomplished () const template \\<typename Node ,typename Scope > Storyboard (const Node & node, Scope & outer_scope) Public Attributes # Name Trigger stop_trigger const std::true_type ready const String name Scope inner_scope Init init Additional inherited members # Public Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Storyboard > Name const auto & state () const Element override () auto evaluate () auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition ) Protected Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Storyboard > Name auto unique (const std::string & name) auto rename (const std::string & name) const decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs) Public Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Storyboard > Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count Protected Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Storyboard > Name std::unordered_set< std::string > names Public Functions Documentation # function stopTriggered # inline decltype ( auto ) stopTriggered () function stop # inline void stop () function start # inline void start () function run # inline auto run () function accomplished # inline auto accomplished () const function Storyboard # template < typename Node , typename Scope > inline explicit Storyboard ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable stop_trigger # Trigger stop_trigger ; variable ready # const std :: true_type ready {}; variable name # const String name { \"Storyboard\" }; variable inner_scope # Scope inner_scope ; variable init # Init init ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Storyboard"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#openscenario_interpretersyntaxstoryboard","text":"Inherits from openscenario_interpreter::syntax::StoryboardElement< Storyboard > , Elements","title":"openscenario_interpreter::syntax::Storyboard"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#public-functions","text":"Name decltype(auto) stopTriggered () void stop () void start () auto run () auto accomplished () const template \\<typename Node ,typename Scope > Storyboard (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#public-attributes","text":"Name Trigger stop_trigger const std::true_type ready const String name Scope inner_scope Init init","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Storyboard > Name const auto & state () const Element override () auto evaluate () auto changeStateIf ( Boolean && test, const Element & consequent_state, const Element & alternate_state) decltype(auto) changeStateIf ( Boolean && test, const Element & consequent_state) decltype(auto) changeStateIf (Predicate && predicate, Ts &&... xs) constexpr StoryboardElement (std::size_t maximum_execution_count =1) BOILERPLATE (standby , standbyState ) BOILERPLATE (starting , startTransition ) BOILERPLATE (running , runningState ) BOILERPLATE (ending , endTransition ) BOILERPLATE (complete , completeState ) BOILERPLATE (stopping , stopTransition ) BOILERPLATE (skipping , skipTransition ) Protected Functions inherited from openscenario_interpreter::syntax::StoryboardElement< Storyboard > Name auto unique (const std::string & name) auto rename (const std::string & name) const decltype(auto) readStoryboardElement (const Node & node, Scope & inner_scope, Ts &&... xs) Public Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Storyboard > Name const std::size_t maximum_execution_count Element current_state std::size_t current_execution_count Protected Attributes inherited from openscenario_interpreter::syntax::StoryboardElement< Storyboard > Name std::unordered_set< std::string > names","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#function-stoptriggered","text":"inline decltype ( auto ) stopTriggered ()","title":"function stopTriggered"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#function-stop","text":"inline void stop ()","title":"function stop"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#function-start","text":"inline void start ()","title":"function start"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#function-run","text":"inline auto run ()","title":"function run"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#function-accomplished","text":"inline auto accomplished () const","title":"function accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#function-storyboard","text":"template < typename Node , typename Scope > inline explicit Storyboard ( const Node & node , Scope & outer_scope )","title":"function Storyboard"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#variable-stop_trigger","text":"Trigger stop_trigger ;","title":"variable stop_trigger"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#variable-ready","text":"const std :: true_type ready {};","title":"variable ready"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#variable-name","text":"const String name { \"Storyboard\" };","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#variable-inner_scope","text":"Scope inner_scope ;","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Storyboard/#variable-init","text":"Init init ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable init"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState/","text":"openscenario_interpreter::syntax::StoryboardElementState # Public Types # Name enum value_type { stopTransition, startTransition, standbyState, skipTransition, runningState, endTransition, completeState } Public Functions # Name constexpr operator value_type () const constexpr StoryboardElementState (value_type value ={}) Public Attributes # Name enum openscenario_interpreter::syntax::StoryboardElementState::value_type value Public Types Documentation # enum value_type # Enumerator Value Description stopTransition startTransition standbyState skipTransition runningState endTransition completeState Public Functions Documentation # function operator value_type # inline constexpr operator value_type () const function StoryboardElementState # inline explicit constexpr StoryboardElementState ( value_type value = {} ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: StoryboardElementState :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::StoryboardElementState"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState/#openscenario_interpretersyntaxstoryboardelementstate","text":"","title":"openscenario_interpreter::syntax::StoryboardElementState"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState/#public-types","text":"Name enum value_type { stopTransition, startTransition, standbyState, skipTransition, runningState, endTransition, completeState }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState/#public-functions","text":"Name constexpr operator value_type () const constexpr StoryboardElementState (value_type value ={})","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState/#public-attributes","text":"Name enum openscenario_interpreter::syntax::StoryboardElementState::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState/#enum-value_type","text":"Enumerator Value Description stopTransition startTransition standbyState skipTransition runningState endTransition completeState","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState/#function-storyboardelementstate","text":"inline explicit constexpr StoryboardElementState ( value_type value = {} )","title":"function StoryboardElementState"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState/#variable-value","text":"enum openscenario_interpreter :: syntax :: StoryboardElementState :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementStateCondition/","text":"openscenario_interpreter::syntax::StoryboardElementStateCondition # Public Functions # Name auto evaluate () const auto compare (const Element & lhs, StoryboardElementState rhs) const template \\<typename Node ,typename Scope > StoryboardElementStateCondition (const Node & node, Scope & outer_scope) Public Attributes # Name const StoryboardElementType type const StoryboardElementState state const String name Scope inner_scope Public Functions Documentation # function evaluate # inline auto evaluate () const function compare # inline auto compare ( const Element & lhs , StoryboardElementState rhs ) const function StoryboardElementStateCondition # template < typename Node , typename Scope > inline explicit StoryboardElementStateCondition ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable type # const StoryboardElementType type ; variable state # const StoryboardElementState state ; variable name # const String name ; variable inner_scope # Scope inner_scope ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::StoryboardElementStateCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementStateCondition/#openscenario_interpretersyntaxstoryboardelementstatecondition","text":"","title":"openscenario_interpreter::syntax::StoryboardElementStateCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementStateCondition/#public-functions","text":"Name auto evaluate () const auto compare (const Element & lhs, StoryboardElementState rhs) const template \\<typename Node ,typename Scope > StoryboardElementStateCondition (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementStateCondition/#public-attributes","text":"Name const StoryboardElementType type const StoryboardElementState state const String name Scope inner_scope","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementStateCondition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementStateCondition/#function-evaluate","text":"inline auto evaluate () const","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementStateCondition/#function-compare","text":"inline auto compare ( const Element & lhs , StoryboardElementState rhs ) const","title":"function compare"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementStateCondition/#function-storyboardelementstatecondition","text":"template < typename Node , typename Scope > inline explicit StoryboardElementStateCondition ( const Node & node , Scope & outer_scope )","title":"function StoryboardElementStateCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementStateCondition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementStateCondition/#variable-type","text":"const StoryboardElementType type ;","title":"variable type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementStateCondition/#variable-state","text":"const StoryboardElementState state ;","title":"variable state"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementStateCondition/#variable-name","text":"const String name ;","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementStateCondition/#variable-inner_scope","text":"Scope inner_scope ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementType/","text":"openscenario_interpreter::syntax::StoryboardElementType # Public Types # Name enum value_type { story, maneuverGroup, maneuver, event, action, act } Public Functions # Name constexpr operator value_type () const constexpr StoryboardElementType (value_type value ={}) Public Attributes # Name enum openscenario_interpreter::syntax::StoryboardElementType::value_type value Public Types Documentation # enum value_type # Enumerator Value Description story maneuverGroup maneuver event action act Public Functions Documentation # function operator value_type # inline constexpr operator value_type () const function StoryboardElementType # inline explicit constexpr StoryboardElementType ( value_type value = {} ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: StoryboardElementType :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::StoryboardElementType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementType/#openscenario_interpretersyntaxstoryboardelementtype","text":"","title":"openscenario_interpreter::syntax::StoryboardElementType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementType/#public-types","text":"Name enum value_type { story, maneuverGroup, maneuver, event, action, act }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementType/#public-functions","text":"Name constexpr operator value_type () const constexpr StoryboardElementType (value_type value ={})","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementType/#public-attributes","text":"Name enum openscenario_interpreter::syntax::StoryboardElementType::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementType/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementType/#enum-value_type","text":"Enumerator Value Description story maneuverGroup maneuver event action act","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementType/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementType/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementType/#function-storyboardelementtype","text":"inline explicit constexpr StoryboardElementType ( value_type value = {} )","title":"function StoryboardElementType"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementType/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1StoryboardElementType/#variable-value","text":"enum openscenario_interpreter :: syntax :: StoryboardElementType :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TeleportAction/","text":"openscenario_interpreter::syntax::TeleportAction # Public Functions # Name void start () const decltype(auto) operator() (const WorldPosition & world_position, const Scope::Actor & actor) const decltype(auto) operator() (const LanePosition & lane_position, const Scope::Actor & actor) const decltype(auto) operator() (const RelativeWorldPosition & relative_world_position, const Scope::Actor & actor) const template \\<typename Node > TeleportAction (const Node & node, Scope & outer_scope) Public Attributes # Name const Position position Scope inner_scope const std::true_type accomplished Public Functions Documentation # function start # inline void start () const function operator() # inline decltype ( auto ) operator ()( const WorldPosition & world_position , const Scope :: Actor & actor ) const function operator() # inline decltype ( auto ) operator ()( const LanePosition & lane_position , const Scope :: Actor & actor ) const function operator() # inline decltype ( auto ) operator ()( const RelativeWorldPosition & relative_world_position , const Scope :: Actor & actor ) const function TeleportAction # template < typename Node > inline explicit TeleportAction ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable position # const Position position ; variable inner_scope # Scope inner_scope ; variable accomplished # const std :: true_type accomplished {}; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::TeleportAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TeleportAction/#openscenario_interpretersyntaxteleportaction","text":"","title":"openscenario_interpreter::syntax::TeleportAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TeleportAction/#public-functions","text":"Name void start () const decltype(auto) operator() (const WorldPosition & world_position, const Scope::Actor & actor) const decltype(auto) operator() (const LanePosition & lane_position, const Scope::Actor & actor) const decltype(auto) operator() (const RelativeWorldPosition & relative_world_position, const Scope::Actor & actor) const template \\<typename Node > TeleportAction (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TeleportAction/#public-attributes","text":"Name const Position position Scope inner_scope const std::true_type accomplished","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TeleportAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TeleportAction/#function-start","text":"inline void start () const","title":"function start"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TeleportAction/#function-operator","text":"inline decltype ( auto ) operator ()( const WorldPosition & world_position , const Scope :: Actor & actor ) const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TeleportAction/#function-operator_1","text":"inline decltype ( auto ) operator ()( const LanePosition & lane_position , const Scope :: Actor & actor ) const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TeleportAction/#function-operator_2","text":"inline decltype ( auto ) operator ()( const RelativeWorldPosition & relative_world_position , const Scope :: Actor & actor ) const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TeleportAction/#function-teleportaction","text":"template < typename Node > inline explicit TeleportAction ( const Node & node , Scope & outer_scope )","title":"function TeleportAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TeleportAction/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TeleportAction/#variable-position","text":"const Position position ;","title":"variable position"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TeleportAction/#variable-inner_scope","text":"Scope inner_scope ;","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TeleportAction/#variable-accomplished","text":"const std :: true_type accomplished {}; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable accomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TimeHeadwayCondition/","text":"openscenario_interpreter::syntax::TimeHeadwayCondition # Public Functions # Name auto evaluate () template \\<typename Node > TimeHeadwayCondition (const Node & node, Scope & outer_scope, const TriggeringEntities & trigger) Public Attributes # Name const Double value const TriggeringEntities trigger const Boolean freespace const String entity_ref const Rule compare const Boolean along_route Public Functions Documentation # function evaluate # inline auto evaluate () function TimeHeadwayCondition # template < typename Node > inline explicit TimeHeadwayCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & trigger ) Public Attributes Documentation # variable value # const Double value ; variable trigger # const TriggeringEntities trigger ; variable freespace # const Boolean freespace ; variable entity_ref # const String entity_ref ; variable compare # const Rule compare ; variable along_route # const Boolean along_route ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::TimeHeadwayCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TimeHeadwayCondition/#openscenario_interpretersyntaxtimeheadwaycondition","text":"","title":"openscenario_interpreter::syntax::TimeHeadwayCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TimeHeadwayCondition/#public-functions","text":"Name auto evaluate () template \\<typename Node > TimeHeadwayCondition (const Node & node, Scope & outer_scope, const TriggeringEntities & trigger)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TimeHeadwayCondition/#public-attributes","text":"Name const Double value const TriggeringEntities trigger const Boolean freespace const String entity_ref const Rule compare const Boolean along_route","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TimeHeadwayCondition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TimeHeadwayCondition/#function-evaluate","text":"inline auto evaluate ()","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TimeHeadwayCondition/#function-timeheadwaycondition","text":"template < typename Node > inline explicit TimeHeadwayCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & trigger )","title":"function TimeHeadwayCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TimeHeadwayCondition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TimeHeadwayCondition/#variable-value","text":"const Double value ;","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TimeHeadwayCondition/#variable-trigger","text":"const TriggeringEntities trigger ;","title":"variable trigger"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TimeHeadwayCondition/#variable-freespace","text":"const Boolean freespace ;","title":"variable freespace"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TimeHeadwayCondition/#variable-entity_ref","text":"const String entity_ref ;","title":"variable entity_ref"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TimeHeadwayCondition/#variable-compare","text":"const Rule compare ;","title":"variable compare"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TimeHeadwayCondition/#variable-along_route","text":"const Boolean along_route ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable along_route"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalAction/","text":"openscenario_interpreter::syntax::TrafficSignalAction # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name template \\<typename Node ,typename ... Ts> TrafficSignalAction (const Node & node, Ts && ...) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function TrafficSignalAction # template < typename Node , typename ... Ts > inline explicit TrafficSignalAction ( const Node & node , Ts && ... ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::TrafficSignalAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalAction/#openscenario_interpretersyntaxtrafficsignalaction","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::TrafficSignalAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalAction/#public-functions","text":"Name template \\<typename Node ,typename ... Ts> TrafficSignalAction (const Node & node, Ts && ...)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalAction/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalAction/#function-trafficsignalaction","text":"template < typename Node , typename ... Ts > inline explicit TrafficSignalAction ( const Node & node , Ts && ... ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function TrafficSignalAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalCondition/","text":"openscenario_interpreter::syntax::TrafficSignalCondition # Public Functions # Name template \\<typename Node ,typename Scope > TrafficSignalCondition (const Node & node, Scope & scope) Public Attributes # Name const String state const String name Public Functions Documentation # function TrafficSignalCondition # template < typename Node , typename Scope > inline explicit TrafficSignalCondition ( const Node & node , Scope & scope ) Public Attributes Documentation # variable state # const String state ; variable name # const String name ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::TrafficSignalCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalCondition/#openscenario_interpretersyntaxtrafficsignalcondition","text":"","title":"openscenario_interpreter::syntax::TrafficSignalCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalCondition/#public-functions","text":"Name template \\<typename Node ,typename Scope > TrafficSignalCondition (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalCondition/#public-attributes","text":"Name const String state const String name","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalCondition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalCondition/#function-trafficsignalcondition","text":"template < typename Node , typename Scope > inline explicit TrafficSignalCondition ( const Node & node , Scope & scope )","title":"function TrafficSignalCondition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalCondition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalCondition/#variable-state","text":"const String state ;","title":"variable state"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalCondition/#variable-name","text":"const String name ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalController/","text":"openscenario_interpreter::syntax::TrafficSignalController # Public Functions # Name template \\<typename Node ,typename Scope > TrafficSignalController (const Node & node, Scope & outer_scope) Public Attributes # Name const String reference const Phase phase const String name const Double delay Public Functions Documentation # function TrafficSignalController # template < typename Node , typename Scope > inline explicit TrafficSignalController ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable reference # const String reference ; variable phase # const Phase phase ; variable name # const String name ; variable delay # const Double delay ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::TrafficSignalController"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalController/#openscenario_interpretersyntaxtrafficsignalcontroller","text":"","title":"openscenario_interpreter::syntax::TrafficSignalController"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalController/#public-functions","text":"Name template \\<typename Node ,typename Scope > TrafficSignalController (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalController/#public-attributes","text":"Name const String reference const Phase phase const String name const Double delay","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalController/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalController/#function-trafficsignalcontroller","text":"template < typename Node , typename Scope > inline explicit TrafficSignalController ( const Node & node , Scope & outer_scope )","title":"function TrafficSignalController"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalController/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalController/#variable-reference","text":"const String reference ;","title":"variable reference"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalController/#variable-phase","text":"const Phase phase ;","title":"variable phase"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalController/#variable-name","text":"const String name ;","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalController/#variable-delay","text":"const Double delay ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable delay"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalState/","text":"openscenario_interpreter::syntax::TrafficSignalState # Public Functions # Name template \\<typename Node ,typename Scope > TrafficSignalState (const Node & node, Scope & scope) Public Attributes # Name const String traffic_signal_id const String state Public Functions Documentation # function TrafficSignalState # template < typename Node , typename Scope > inline explicit TrafficSignalState ( const Node & node , Scope & scope ) Public Attributes Documentation # variable traffic_signal_id # const String traffic_signal_id ; variable state # const String state ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::TrafficSignalState"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalState/#openscenario_interpretersyntaxtrafficsignalstate","text":"","title":"openscenario_interpreter::syntax::TrafficSignalState"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalState/#public-functions","text":"Name template \\<typename Node ,typename Scope > TrafficSignalState (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalState/#public-attributes","text":"Name const String traffic_signal_id const String state","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalState/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalState/#function-trafficsignalstate","text":"template < typename Node , typename Scope > inline explicit TrafficSignalState ( const Node & node , Scope & scope )","title":"function TrafficSignalState"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalState/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalState/#variable-traffic_signal_id","text":"const String traffic_signal_id ;","title":"variable traffic_signal_id"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalState/#variable-state","text":"const String state ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable state"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalStateAction/","text":"openscenario_interpreter::syntax::TrafficSignalStateAction # Public Functions # Name template \\<typename Node ,typename Scope > TrafficSignalStateAction (const Node & node, Scope & scope) Public Attributes # Name const String state const String name Public Functions Documentation # function TrafficSignalStateAction # template < typename Node , typename Scope > inline explicit TrafficSignalStateAction ( const Node & node , Scope & scope ) Public Attributes Documentation # variable state # const String state ; variable name # const String name ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::TrafficSignalStateAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalStateAction/#openscenario_interpretersyntaxtrafficsignalstateaction","text":"","title":"openscenario_interpreter::syntax::TrafficSignalStateAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalStateAction/#public-functions","text":"Name template \\<typename Node ,typename Scope > TrafficSignalStateAction (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalStateAction/#public-attributes","text":"Name const String state const String name","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalStateAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalStateAction/#function-trafficsignalstateaction","text":"template < typename Node , typename Scope > inline explicit TrafficSignalStateAction ( const Node & node , Scope & scope )","title":"function TrafficSignalStateAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalStateAction/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalStateAction/#variable-state","text":"const String state ;","title":"variable state"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignalStateAction/#variable-name","text":"const String name ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignals/","text":"openscenario_interpreter::syntax::TrafficSignals # Inherits from std::vector< TrafficSignalController > Public Functions # Name TrafficSignals () =default template \\<typename Node ,typename Scope > TrafficSignals (const Node & node, Scope & outer_scope) Public Functions Documentation # function TrafficSignals # TrafficSignals () = default function TrafficSignals # template < typename Node , typename Scope > inline explicit TrafficSignals ( const Node & node , Scope & outer_scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::TrafficSignals"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignals/#openscenario_interpretersyntaxtrafficsignals","text":"Inherits from std::vector< TrafficSignalController >","title":"openscenario_interpreter::syntax::TrafficSignals"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignals/#public-functions","text":"Name TrafficSignals () =default template \\<typename Node ,typename Scope > TrafficSignals (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignals/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignals/#function-trafficsignals","text":"TrafficSignals () = default","title":"function TrafficSignals"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TrafficSignals/#function-trafficsignals_1","text":"template < typename Node , typename Scope > inline explicit TrafficSignals ( const Node & node , Scope & outer_scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function TrafficSignals"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TransitionDynamics/","text":"openscenario_interpreter::syntax::TransitionDynamics # Public Functions # Name template \\<typename Node ,typename Scope > TransitionDynamics (const Node & node, Scope & scope) Public Attributes # Name const Double value const DynamicsShape dynamics_shape const DynamicsDimension dynamics_dimension Public Functions Documentation # function TransitionDynamics # template < typename Node , typename Scope > inline explicit TransitionDynamics ( const Node & node , Scope & scope ) Public Attributes Documentation # variable value # const Double value ; variable dynamics_shape # const DynamicsShape dynamics_shape ; variable dynamics_dimension # const DynamicsDimension dynamics_dimension ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::TransitionDynamics"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TransitionDynamics/#openscenario_interpretersyntaxtransitiondynamics","text":"","title":"openscenario_interpreter::syntax::TransitionDynamics"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TransitionDynamics/#public-functions","text":"Name template \\<typename Node ,typename Scope > TransitionDynamics (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TransitionDynamics/#public-attributes","text":"Name const Double value const DynamicsShape dynamics_shape const DynamicsDimension dynamics_dimension","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TransitionDynamics/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TransitionDynamics/#function-transitiondynamics","text":"template < typename Node , typename Scope > inline explicit TransitionDynamics ( const Node & node , Scope & scope )","title":"function TransitionDynamics"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TransitionDynamics/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TransitionDynamics/#variable-value","text":"const Double value ;","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TransitionDynamics/#variable-dynamics_shape","text":"const DynamicsShape dynamics_shape ;","title":"variable dynamics_shape"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TransitionDynamics/#variable-dynamics_dimension","text":"const DynamicsDimension dynamics_dimension ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable dynamics_dimension"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Trigger/","text":"openscenario_interpreter::syntax::Trigger # Inherits from std::vector< ConditionGroup > Public Functions # Name auto evaluate () template \\<typename Node ,typename Scope > Trigger (const Node & node, Scope & scope) Public Functions Documentation # function evaluate # inline auto evaluate () function Trigger # template < typename Node , typename Scope > inline explicit Trigger ( const Node & node , Scope & scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Trigger"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Trigger/#openscenario_interpretersyntaxtrigger","text":"Inherits from std::vector< ConditionGroup >","title":"openscenario_interpreter::syntax::Trigger"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Trigger/#public-functions","text":"Name auto evaluate () template \\<typename Node ,typename Scope > Trigger (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Trigger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Trigger/#function-evaluate","text":"inline auto evaluate ()","title":"function evaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Trigger/#function-trigger","text":"template < typename Node , typename Scope > inline explicit Trigger ( const Node & node , Scope & scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function Trigger"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntities/","text":"openscenario_interpreter::syntax::TriggeringEntities # Inherits from std::vector< EntityRef > Public Functions # Name template \\<typename ... Ts> decltype(auto) constexpr operator() (Ts &&... xs) const template \\<typename Node ,typename Scope > TriggeringEntities (const Node & node, Scope & scope) Public Attributes # Name const TriggeringEntitiesRule verify Public Functions Documentation # function operator() # template < typename ... Ts > inline decltype ( auto ) constexpr operator ()( Ts && ... xs ) const function TriggeringEntities # template < typename Node , typename Scope > inline explicit TriggeringEntities ( const Node & node , Scope & scope ) Public Attributes Documentation # variable verify # const TriggeringEntitiesRule verify ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::TriggeringEntities"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntities/#openscenario_interpretersyntaxtriggeringentities","text":"Inherits from std::vector< EntityRef >","title":"openscenario_interpreter::syntax::TriggeringEntities"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntities/#public-functions","text":"Name template \\<typename ... Ts> decltype(auto) constexpr operator() (Ts &&... xs) const template \\<typename Node ,typename Scope > TriggeringEntities (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntities/#public-attributes","text":"Name const TriggeringEntitiesRule verify","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntities/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntities/#function-operator","text":"template < typename ... Ts > inline decltype ( auto ) constexpr operator ()( Ts && ... xs ) const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntities/#function-triggeringentities","text":"template < typename Node , typename Scope > inline explicit TriggeringEntities ( const Node & node , Scope & scope )","title":"function TriggeringEntities"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntities/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntities/#variable-verify","text":"const TriggeringEntitiesRule verify ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable verify"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntitiesRule/","text":"openscenario_interpreter::syntax::TriggeringEntitiesRule # Public Types # Name enum value_type { none, any, all } Public Functions # Name template \\<typename ... Ts> decltype(auto) constexpr operator() (Ts &&... xs) const constexpr operator value_type () const constexpr TriggeringEntitiesRule (value_type value ={}) Public Attributes # Name enum openscenario_interpreter::syntax::TriggeringEntitiesRule::value_type value Public Types Documentation # enum value_type # Enumerator Value Description none any all Public Functions Documentation # function operator() # template < typename ... Ts > inline decltype ( auto ) constexpr operator ()( Ts && ... xs ) const function operator value_type # inline constexpr operator value_type () const function TriggeringEntitiesRule # inline explicit constexpr TriggeringEntitiesRule ( value_type value = {} ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: TriggeringEntitiesRule :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::TriggeringEntitiesRule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntitiesRule/#openscenario_interpretersyntaxtriggeringentitiesrule","text":"","title":"openscenario_interpreter::syntax::TriggeringEntitiesRule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntitiesRule/#public-types","text":"Name enum value_type { none, any, all }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntitiesRule/#public-functions","text":"Name template \\<typename ... Ts> decltype(auto) constexpr operator() (Ts &&... xs) const constexpr operator value_type () const constexpr TriggeringEntitiesRule (value_type value ={})","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntitiesRule/#public-attributes","text":"Name enum openscenario_interpreter::syntax::TriggeringEntitiesRule::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntitiesRule/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntitiesRule/#enum-value_type","text":"Enumerator Value Description none any all","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntitiesRule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntitiesRule/#function-operator","text":"template < typename ... Ts > inline decltype ( auto ) constexpr operator ()( Ts && ... xs ) const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntitiesRule/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntitiesRule/#function-triggeringentitiesrule","text":"inline explicit constexpr TriggeringEntitiesRule ( value_type value = {} )","title":"function TriggeringEntitiesRule"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntitiesRule/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1TriggeringEntitiesRule/#variable-value","text":"enum openscenario_interpreter :: syntax :: TriggeringEntitiesRule :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedInteger/","text":"openscenario_interpreter::syntax::UnsignedInteger # Inherits from UInt64 Public Types # Name using decltype(std_msgs::msg::UInt64::data) value_type Public Functions # Name auto & operator+= (const double & rhs) decltype(auto) operator++ () auto & operator*= (const double & rhs) constexpr operator value_type () const UnsignedInteger (value_type value ={}) UnsignedInteger (const std::string & s) Public Types Documentation # using value_type # using openscenario_interpreter :: syntax :: UnsignedInteger :: value_type = decltype ( std_msgs :: msg :: UInt64 :: data ); Public Functions Documentation # function operator+= # inline auto & operator += ( const double & rhs ) function operator++ # inline decltype ( auto ) operator ++ () function operator*= # inline auto & operator *= ( const double & rhs ) function operator value_type # inline constexpr operator value_type () const function UnsignedInteger # inline explicit UnsignedInteger ( value_type value = {} ) function UnsignedInteger # inline explicit UnsignedInteger ( const std :: string & s ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::UnsignedInteger"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedInteger/#openscenario_interpretersyntaxunsignedinteger","text":"Inherits from UInt64","title":"openscenario_interpreter::syntax::UnsignedInteger"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedInteger/#public-types","text":"Name using decltype(std_msgs::msg::UInt64::data) value_type","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedInteger/#public-functions","text":"Name auto & operator+= (const double & rhs) decltype(auto) operator++ () auto & operator*= (const double & rhs) constexpr operator value_type () const UnsignedInteger (value_type value ={}) UnsignedInteger (const std::string & s)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedInteger/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedInteger/#using-value_type","text":"using openscenario_interpreter :: syntax :: UnsignedInteger :: value_type = decltype ( std_msgs :: msg :: UInt64 :: data );","title":"using value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedInteger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedInteger/#function-operator","text":"inline auto & operator += ( const double & rhs )","title":"function operator+="},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedInteger/#function-operator_1","text":"inline decltype ( auto ) operator ++ ()","title":"function operator++"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedInteger/#function-operator_2","text":"inline auto & operator *= ( const double & rhs )","title":"function operator*="},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedInteger/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedInteger/#function-unsignedinteger","text":"inline explicit UnsignedInteger ( value_type value = {} )","title":"function UnsignedInteger"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedInteger/#function-unsignedinteger_1","text":"inline explicit UnsignedInteger ( const std :: string & s ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function UnsignedInteger"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedShort/","text":"openscenario_interpreter::syntax::UnsignedShort # Inherits from UInt16 Public Types # Name using decltype(std_msgs::msg::UInt16::data) value_type Public Functions # Name auto & operator+= (const double & rhs) decltype(auto) operator++ () auto & operator*= (const double & rhs) constexpr operator value_type () const UnsignedShort (value_type value ={}) UnsignedShort (const std::string & s) Public Types Documentation # using value_type # using openscenario_interpreter :: syntax :: UnsignedShort :: value_type = decltype ( std_msgs :: msg :: UInt16 :: data ); Public Functions Documentation # function operator+= # inline auto & operator += ( const double & rhs ) function operator++ # inline decltype ( auto ) operator ++ () function operator*= # inline auto & operator *= ( const double & rhs ) function operator value_type # inline constexpr operator value_type () const function UnsignedShort # inline explicit UnsignedShort ( value_type value = {} ) function UnsignedShort # inline explicit UnsignedShort ( const std :: string & s ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::UnsignedShort"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedShort/#openscenario_interpretersyntaxunsignedshort","text":"Inherits from UInt16","title":"openscenario_interpreter::syntax::UnsignedShort"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedShort/#public-types","text":"Name using decltype(std_msgs::msg::UInt16::data) value_type","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedShort/#public-functions","text":"Name auto & operator+= (const double & rhs) decltype(auto) operator++ () auto & operator*= (const double & rhs) constexpr operator value_type () const UnsignedShort (value_type value ={}) UnsignedShort (const std::string & s)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedShort/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedShort/#using-value_type","text":"using openscenario_interpreter :: syntax :: UnsignedShort :: value_type = decltype ( std_msgs :: msg :: UInt16 :: data );","title":"using value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedShort/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedShort/#function-operator","text":"inline auto & operator += ( const double & rhs )","title":"function operator+="},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedShort/#function-operator_1","text":"inline decltype ( auto ) operator ++ ()","title":"function operator++"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedShort/#function-operator_2","text":"inline auto & operator *= ( const double & rhs )","title":"function operator*="},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedShort/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedShort/#function-unsignedshort","text":"inline explicit UnsignedShort ( value_type value = {} )","title":"function UnsignedShort"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UnsignedShort/#function-unsignedshort_1","text":"inline explicit UnsignedShort ( const std :: string & s ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function UnsignedShort"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UserDefinedAction/","text":"openscenario_interpreter::syntax::UserDefinedAction # Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T > Public Functions # Name template \\<typename Node ,typename Scope > UserDefinedAction (const Node & node, Scope & scope) Additional inherited members # Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs) Public Functions Documentation # function UserDefinedAction # template < typename Node , typename Scope > inline explicit UserDefinedAction ( const Node & node , Scope & scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::UserDefinedAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UserDefinedAction/#openscenario_interpretersyntaxuserdefinedaction","text":"Inherits from openscenario_interpreter::Pointer< Expression > , std::shared_ptr< T >","title":"openscenario_interpreter::syntax::UserDefinedAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UserDefinedAction/#public-functions","text":"Name template \\<typename Node ,typename Scope > UserDefinedAction (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UserDefinedAction/#additional-inherited-members","text":"Public Functions inherited from openscenario_interpreter::Pointer< Expression > Name constexpr Pointer (Ts &&... xs)","title":"Additional inherited members"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UserDefinedAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1UserDefinedAction/#function-userdefinedaction","text":"template < typename Node , typename Scope > inline explicit UserDefinedAction ( const Node & node , Scope & scope ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function UserDefinedAction"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/","text":"openscenario_interpreter::syntax::Vehicle # Public Functions # Name template \\<typename ... Ts> decltype(auto) operator[] (Ts &&... xs) template \\<typename Node ,typename Scope > Vehicle (const Node & node, Scope & outer_scope) Public Attributes # Name const VehicleCategory vehicle_category Properties properties const Performance performance const ParameterDeclarations parameter_declarations const String name Scope inner_scope const BoundingBox bounding_box const Axles axles Public Functions Documentation # function operator[] # template < typename ... Ts > inline decltype ( auto ) operator []( Ts && ... xs ) function Vehicle # template < typename Node , typename Scope > inline explicit Vehicle ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable vehicle_category # const VehicleCategory vehicle_category ; variable properties # Properties properties ; variable performance # const Performance performance ; variable parameter_declarations # const ParameterDeclarations parameter_declarations ; variable name # const String name ; variable inner_scope # Scope inner_scope ; variable bounding_box # const BoundingBox bounding_box ; variable axles # const Axles axles ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Vehicle"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/#openscenario_interpretersyntaxvehicle","text":"","title":"openscenario_interpreter::syntax::Vehicle"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/#public-functions","text":"Name template \\<typename ... Ts> decltype(auto) operator[] (Ts &&... xs) template \\<typename Node ,typename Scope > Vehicle (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/#public-attributes","text":"Name const VehicleCategory vehicle_category Properties properties const Performance performance const ParameterDeclarations parameter_declarations const String name Scope inner_scope const BoundingBox bounding_box const Axles axles","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/#function-operator","text":"template < typename ... Ts > inline decltype ( auto ) operator []( Ts && ... xs )","title":"function operator[]"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/#function-vehicle","text":"template < typename Node , typename Scope > inline explicit Vehicle ( const Node & node , Scope & outer_scope )","title":"function Vehicle"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/#variable-vehicle_category","text":"const VehicleCategory vehicle_category ;","title":"variable vehicle_category"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/#variable-properties","text":"Properties properties ;","title":"variable properties"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/#variable-performance","text":"const Performance performance ;","title":"variable performance"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/#variable-parameter_declarations","text":"const ParameterDeclarations parameter_declarations ;","title":"variable parameter_declarations"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/#variable-name","text":"const String name ;","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/#variable-inner_scope","text":"Scope inner_scope ;","title":"variable inner_scope"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/#variable-bounding_box","text":"const BoundingBox bounding_box ;","title":"variable bounding_box"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Vehicle/#variable-axles","text":"const Axles axles ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable axles"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1VehicleCategory/","text":"openscenario_interpreter::syntax::VehicleCategory # Public Types # Name enum value_type { van, truck, tram, train, trailer, semitrailer, motorbike, car, bus, bicycle } Public Functions # Name constexpr operator value_type () const constexpr VehicleCategory (value_type value ={}) Public Attributes # Name enum openscenario_interpreter::syntax::VehicleCategory::value_type value Public Types Documentation # enum value_type # Enumerator Value Description van truck tram train trailer semitrailer motorbike car bus bicycle Public Functions Documentation # function operator value_type # inline constexpr operator value_type () const function VehicleCategory # inline explicit constexpr VehicleCategory ( value_type value = {} ) Public Attributes Documentation # variable value # enum openscenario_interpreter :: syntax :: VehicleCategory :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::VehicleCategory"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1VehicleCategory/#openscenario_interpretersyntaxvehiclecategory","text":"","title":"openscenario_interpreter::syntax::VehicleCategory"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1VehicleCategory/#public-types","text":"Name enum value_type { van, truck, tram, train, trailer, semitrailer, motorbike, car, bus, bicycle }","title":"Public Types"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1VehicleCategory/#public-functions","text":"Name constexpr operator value_type () const constexpr VehicleCategory (value_type value ={})","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1VehicleCategory/#public-attributes","text":"Name enum openscenario_interpreter::syntax::VehicleCategory::value_type value","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1VehicleCategory/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1VehicleCategory/#enum-value_type","text":"Enumerator Value Description van truck tram train trailer semitrailer motorbike car bus bicycle","title":"enum value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1VehicleCategory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1VehicleCategory/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1VehicleCategory/#function-vehiclecategory","text":"inline explicit constexpr VehicleCategory ( value_type value = {} )","title":"function VehicleCategory"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1VehicleCategory/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1VehicleCategory/#variable-value","text":"enum openscenario_interpreter :: syntax :: VehicleCategory :: value_type value ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Waypoint/","text":"openscenario_interpreter::syntax::Waypoint # Public Functions # Name operator openscenario_msgs::msg::LaneletPose () const template \\<typename Node ,typename Scope > Waypoint (const Node & node, Scope & outer_scope) Public Attributes # Name const RouteStrategy route_strategy const Position position Public Functions Documentation # function operator openscenario_msgs::msg::LaneletPose # inline explicit operator openscenario_msgs :: msg :: LaneletPose () const function Waypoint # template < typename Node , typename Scope > inline explicit Waypoint ( const Node & node , Scope & outer_scope ) Public Attributes Documentation # variable route_strategy # const RouteStrategy route_strategy ; variable position # const Position position ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::Waypoint"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Waypoint/#openscenario_interpretersyntaxwaypoint","text":"","title":"openscenario_interpreter::syntax::Waypoint"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Waypoint/#public-functions","text":"Name operator openscenario_msgs::msg::LaneletPose () const template \\<typename Node ,typename Scope > Waypoint (const Node & node, Scope & outer_scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Waypoint/#public-attributes","text":"Name const RouteStrategy route_strategy const Position position","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Waypoint/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Waypoint/#function-operator-openscenario_msgsmsglaneletpose","text":"inline explicit operator openscenario_msgs :: msg :: LaneletPose () const","title":"function operator openscenario_msgs::msg::LaneletPose"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Waypoint/#function-waypoint","text":"template < typename Node , typename Scope > inline explicit Waypoint ( const Node & node , Scope & outer_scope )","title":"function Waypoint"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Waypoint/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Waypoint/#variable-route_strategy","text":"const RouteStrategy route_strategy ;","title":"variable route_strategy"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1Waypoint/#variable-position","text":"const Position position ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable position"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1WorldPosition/","text":"openscenario_interpreter::syntax::WorldPosition # Public Functions # Name operator openscenario_msgs::msg::LaneletPose () const operator geometry_msgs::msg::Pose () const template \\<typename Node ,typename Scope > WorldPosition (const Node & node, Scope & scope) Public Attributes # Name const Double z const Double y const Double x const Double r const Double p const Double h Public Functions Documentation # function operator openscenario_msgs::msg::LaneletPose # inline explicit operator openscenario_msgs :: msg :: LaneletPose () const function operator geometry_msgs::msg::Pose # inline explicit operator geometry_msgs :: msg :: Pose () const function WorldPosition # template < typename Node , typename Scope > inline explicit WorldPosition ( const Node & node , Scope & scope ) Public Attributes Documentation # variable z # const Double z ; variable y # const Double y ; variable x # const Double x ; variable r # const Double r ; variable p # const Double p ; variable h # const Double h ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::WorldPosition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1WorldPosition/#openscenario_interpretersyntaxworldposition","text":"","title":"openscenario_interpreter::syntax::WorldPosition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1WorldPosition/#public-functions","text":"Name operator openscenario_msgs::msg::LaneletPose () const operator geometry_msgs::msg::Pose () const template \\<typename Node ,typename Scope > WorldPosition (const Node & node, Scope & scope)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1WorldPosition/#public-attributes","text":"Name const Double z const Double y const Double x const Double r const Double p const Double h","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1WorldPosition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1WorldPosition/#function-operator-openscenario_msgsmsglaneletpose","text":"inline explicit operator openscenario_msgs :: msg :: LaneletPose () const","title":"function operator openscenario_msgs::msg::LaneletPose"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1WorldPosition/#function-operator-geometry_msgsmsgpose","text":"inline explicit operator geometry_msgs :: msg :: Pose () const","title":"function operator geometry_msgs::msg::Pose"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1WorldPosition/#function-worldposition","text":"template < typename Node , typename Scope > inline explicit WorldPosition ( const Node & node , Scope & scope )","title":"function WorldPosition"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1WorldPosition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1WorldPosition/#variable-z","text":"const Double z ;","title":"variable z"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1WorldPosition/#variable-y","text":"const Double y ;","title":"variable y"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1WorldPosition/#variable-x","text":"const Double x ;","title":"variable x"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1WorldPosition/#variable-r","text":"const Double r ;","title":"variable r"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1WorldPosition/#variable-p","text":"const Double p ;","title":"variable p"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1WorldPosition/#variable-h","text":"const Double h ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable h"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1equal__to/","text":"openscenario_interpreter::syntax::equal_to # More... Inherits from std::equal_to< T > Detailed Description # template < typename T , typename = void > struct openscenario_interpreter :: syntax :: equal_to ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::equal_to"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1equal__to/#openscenario_interpretersyntaxequal_to","text":"More... Inherits from std::equal_to< T >","title":"openscenario_interpreter::syntax::equal_to"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1equal__to/#detailed-description","text":"template < typename T , typename = void > struct openscenario_interpreter :: syntax :: equal_to ; Updated on 7 April 2021 at 00:31:56 UTC","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1equal__to_3_01T_00_01typename_01std_1_1enable__if_36950e835545f4465da1ac88fcd135173/","text":"openscenario_interpreter::syntax::equal_to< T, typename std::enable_if< std::is_floating_point< T >::value >::type > # More... Public Functions # Name constexpr auto operator() (const T & lhs, const T & rhs) const Detailed Description # template < typename T > struct openscenario_interpreter :: syntax :: equal_to < T , typename std :: enable_if < std :: is_floating_point < T >:: value >:: type > ; Public Functions Documentation # function operator() # inline constexpr auto operator ()( const T & lhs , const T & rhs ) const Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax::equal_to< T, typename std::enable_if< std::is_floating_point< T >::value >::type >"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1equal__to_3_01T_00_01typename_01std_1_1enable__if_36950e835545f4465da1ac88fcd135173/#openscenario_interpretersyntaxequal_to-t-typename-stdenable_if-stdis_floating_point-t-value-type","text":"More...","title":"openscenario_interpreter::syntax::equal_to&lt; T, typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type &gt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1equal__to_3_01T_00_01typename_01std_1_1enable__if_36950e835545f4465da1ac88fcd135173/#public-functions","text":"Name constexpr auto operator() (const T & lhs, const T & rhs) const","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1equal__to_3_01T_00_01typename_01std_1_1enable__if_36950e835545f4465da1ac88fcd135173/#detailed-description","text":"template < typename T > struct openscenario_interpreter :: syntax :: equal_to < T , typename std :: enable_if < std :: is_floating_point < T >:: value >:: type > ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1equal__to_3_01T_00_01typename_01std_1_1enable__if_36950e835545f4465da1ac88fcd135173/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1syntax_1_1equal__to_3_01T_00_01typename_01std_1_1enable__if_36950e835545f4465da1ac88fcd135173/#function-operator","text":"inline constexpr auto operator ()( const T & lhs , const T & rhs ) const Updated on 7 April 2021 at 00:31:56 UTC","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionAccomplished/","text":"openscenario_interpreter::type_traits::HasMemberFunctionAccomplished # More... Inherits from false_type Detailed Description # template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: HasMemberFunctionAccomplished ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::HasMemberFunctionAccomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionAccomplished/#openscenario_interpretertype_traitshasmemberfunctionaccomplished","text":"More... Inherits from false_type","title":"openscenario_interpreter::type_traits::HasMemberFunctionAccomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionAccomplished/#detailed-description","text":"template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: HasMemberFunctionAccomplished ; Updated on 7 April 2021 at 00:31:56 UTC","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionAccomplished_3_01T_00_01void746c76b57bf3b1b36294c01f3faff05a/","text":"openscenario_interpreter::type_traits::HasMemberFunctionAccomplished< T, void_t< decltype(std::declval< T >().accomplished())> > # More... Inherits from true_type Detailed Description # template < typename T > struct openscenario_interpreter :: type_traits :: HasMemberFunctionAccomplished < T , void_t < decltype ( std :: declval < T > (). accomplished ()) > > ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::HasMemberFunctionAccomplished< T, void_t< decltype(std::declval< T >().accomplished())> >"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionAccomplished_3_01T_00_01void746c76b57bf3b1b36294c01f3faff05a/#openscenario_interpretertype_traitshasmemberfunctionaccomplished-t-void_t-decltypestddeclval-t-accomplished","text":"More... Inherits from true_type","title":"openscenario_interpreter::type_traits::HasMemberFunctionAccomplished&lt; T, void_t&lt; decltype(std::declval&lt; T &gt;().accomplished())&gt; &gt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionAccomplished_3_01T_00_01void746c76b57bf3b1b36294c01f3faff05a/#detailed-description","text":"template < typename T > struct openscenario_interpreter :: type_traits :: HasMemberFunctionAccomplished < T , void_t < decltype ( std :: declval < T > (). accomplished ()) > > ; Updated on 7 April 2021 at 00:31:56 UTC","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionEvaluate/","text":"openscenario_interpreter::type_traits::HasMemberFunctionEvaluate # More... Inherits from false_type Detailed Description # template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: HasMemberFunctionEvaluate ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::HasMemberFunctionEvaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionEvaluate/#openscenario_interpretertype_traitshasmemberfunctionevaluate","text":"More... Inherits from false_type","title":"openscenario_interpreter::type_traits::HasMemberFunctionEvaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionEvaluate/#detailed-description","text":"template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: HasMemberFunctionEvaluate ; Updated on 7 April 2021 at 00:31:56 UTC","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionEvaluate_3_01T_00_01void__t_3e491924934085df9a38b02db60a1354/","text":"openscenario_interpreter::type_traits::HasMemberFunctionEvaluate< T, void_t< decltype(std::declval< T >().evaluate())> > # More... Inherits from true_type Detailed Description # template < typename T > struct openscenario_interpreter :: type_traits :: HasMemberFunctionEvaluate < T , void_t < decltype ( std :: declval < T > (). evaluate ()) > > ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::HasMemberFunctionEvaluate< T, void_t< decltype(std::declval< T >().evaluate())> >"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionEvaluate_3_01T_00_01void__t_3e491924934085df9a38b02db60a1354/#openscenario_interpretertype_traitshasmemberfunctionevaluate-t-void_t-decltypestddeclval-t-evaluate","text":"More... Inherits from true_type","title":"openscenario_interpreter::type_traits::HasMemberFunctionEvaluate&lt; T, void_t&lt; decltype(std::declval&lt; T &gt;().evaluate())&gt; &gt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionEvaluate_3_01T_00_01void__t_3e491924934085df9a38b02db60a1354/#detailed-description","text":"template < typename T > struct openscenario_interpreter :: type_traits :: HasMemberFunctionEvaluate < T , void_t < decltype ( std :: declval < T > (). evaluate ()) > > ; Updated on 7 April 2021 at 00:31:56 UTC","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionStart/","text":"openscenario_interpreter::type_traits::HasMemberFunctionStart # More... Inherits from false_type Detailed Description # template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: HasMemberFunctionStart ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::HasMemberFunctionStart"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionStart/#openscenario_interpretertype_traitshasmemberfunctionstart","text":"More... Inherits from false_type","title":"openscenario_interpreter::type_traits::HasMemberFunctionStart"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionStart/#detailed-description","text":"template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: HasMemberFunctionStart ; Updated on 7 April 2021 at 00:31:56 UTC","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionStart_3_01T_00_01void__t_3_0752582ea00759e4de8b676c48113e6b0/","text":"openscenario_interpreter::type_traits::HasMemberFunctionStart< T, void_t< decltype(std::declval< T >().start())> > # More... Inherits from true_type Detailed Description # template < typename T > struct openscenario_interpreter :: type_traits :: HasMemberFunctionStart < T , void_t < decltype ( std :: declval < T > (). start ()) > > ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::HasMemberFunctionStart< T, void_t< decltype(std::declval< T >().start())> >"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionStart_3_01T_00_01void__t_3_0752582ea00759e4de8b676c48113e6b0/#openscenario_interpretertype_traitshasmemberfunctionstart-t-void_t-decltypestddeclval-t-start","text":"More... Inherits from true_type","title":"openscenario_interpreter::type_traits::HasMemberFunctionStart&lt; T, void_t&lt; decltype(std::declval&lt; T &gt;().start())&gt; &gt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionStart_3_01T_00_01void__t_3_0752582ea00759e4de8b676c48113e6b0/#detailed-description","text":"template < typename T > struct openscenario_interpreter :: type_traits :: HasMemberFunctionStart < T , void_t < decltype ( std :: declval < T > (). start ()) > > ; Updated on 7 April 2021 at 00:31:56 UTC","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionState/","text":"openscenario_interpreter::type_traits::HasMemberFunctionState # More... Inherits from false_type Detailed Description # template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: HasMemberFunctionState ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::HasMemberFunctionState"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionState/#openscenario_interpretertype_traitshasmemberfunctionstate","text":"More... Inherits from false_type","title":"openscenario_interpreter::type_traits::HasMemberFunctionState"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionState/#detailed-description","text":"template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: HasMemberFunctionState ; Updated on 7 April 2021 at 00:31:56 UTC","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionState_3_01T_00_01void__t_3_08de6a621edda57615ec6f7b5b032e9a2/","text":"openscenario_interpreter::type_traits::HasMemberFunctionState< T, void_t< decltype(std::declval< T >().state())> > # More... Inherits from true_type Detailed Description # template < typename T > struct openscenario_interpreter :: type_traits :: HasMemberFunctionState < T , void_t < decltype ( std :: declval < T > (). state ()) > > ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::HasMemberFunctionState< T, void_t< decltype(std::declval< T >().state())> >"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionState_3_01T_00_01void__t_3_08de6a621edda57615ec6f7b5b032e9a2/#openscenario_interpretertype_traitshasmemberfunctionstate-t-void_t-decltypestddeclval-t-state","text":"More... Inherits from true_type","title":"openscenario_interpreter::type_traits::HasMemberFunctionState&lt; T, void_t&lt; decltype(std::declval&lt; T &gt;().state())&gt; &gt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1HasMemberFunctionState_3_01T_00_01void__t_3_08de6a621edda57615ec6f7b5b032e9a2/#detailed-description","text":"template < typename T > struct openscenario_interpreter :: type_traits :: HasMemberFunctionState < T , void_t < decltype ( std :: declval < T > (). state ()) > > ; Updated on 7 April 2021 at 00:31:56 UTC","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionAccomplished/","text":"openscenario_interpreter::type_traits::IfHasMemberFunctionAccomplished # More... Public Functions # Name constexpr auto callIt (const T & ) Detailed Description # template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionAccomplished ; Public Functions Documentation # function callIt # static inline constexpr auto callIt ( const T & ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionAccomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionAccomplished/#openscenario_interpretertype_traitsifhasmemberfunctionaccomplished","text":"More...","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionAccomplished"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionAccomplished/#public-functions","text":"Name constexpr auto callIt (const T & )","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionAccomplished/#detailed-description","text":"template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionAccomplished ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionAccomplished/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionAccomplished/#function-callit","text":"static inline constexpr auto callIt ( const T & ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function callIt"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionAccomplished_3_01T_00_01ty41533d71338ff460af352505f8d80ca9/","text":"openscenario_interpreter::type_traits::IfHasMemberFunctionAccomplished< T, typename std::enable_if< HasMemberFunctionAccomplished< T >::value >::type > # More... Public Functions # Name decltype(auto) callIt (T & is) Detailed Description # template < typename T > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionAccomplished < T , typename std :: enable_if < HasMemberFunctionAccomplished < T >:: value >:: type > ; Public Functions Documentation # function callIt # static inline decltype ( auto ) callIt ( T & is ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionAccomplished< T, typename std::enable_if< HasMemberFunctionAccomplished< T >::value >::type >"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionAccomplished_3_01T_00_01ty41533d71338ff460af352505f8d80ca9/#openscenario_interpretertype_traitsifhasmemberfunctionaccomplished-t-typename-stdenable_if-hasmemberfunctionaccomplished-t-value-type","text":"More...","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionAccomplished&lt; T, typename std::enable_if&lt; HasMemberFunctionAccomplished&lt; T &gt;::value &gt;::type &gt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionAccomplished_3_01T_00_01ty41533d71338ff460af352505f8d80ca9/#public-functions","text":"Name decltype(auto) callIt (T & is)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionAccomplished_3_01T_00_01ty41533d71338ff460af352505f8d80ca9/#detailed-description","text":"template < typename T > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionAccomplished < T , typename std :: enable_if < HasMemberFunctionAccomplished < T >:: value >:: type > ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionAccomplished_3_01T_00_01ty41533d71338ff460af352505f8d80ca9/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionAccomplished_3_01T_00_01ty41533d71338ff460af352505f8d80ca9/#function-callit","text":"static inline decltype ( auto ) callIt ( T & is ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function callIt"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionEvaluate/","text":"openscenario_interpreter::type_traits::IfHasMemberFunctionEvaluate # More... Public Functions # Name template \\<typename Result > constexpr Result callIt (T & , const Result & as_self_evaluating) Detailed Description # template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionEvaluate ; Public Functions Documentation # function callIt # template < typename Result > static inline constexpr Result callIt ( T & , const Result & as_self_evaluating ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionEvaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionEvaluate/#openscenario_interpretertype_traitsifhasmemberfunctionevaluate","text":"More...","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionEvaluate"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionEvaluate/#public-functions","text":"Name template \\<typename Result > constexpr Result callIt (T & , const Result & as_self_evaluating)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionEvaluate/#detailed-description","text":"template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionEvaluate ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionEvaluate/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionEvaluate/#function-callit","text":"template < typename Result > static inline constexpr Result callIt ( T & , const Result & as_self_evaluating ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function callIt"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionEvaluate_3_01T_00_01typenac94e421386c5218cf6e385ba6234ba80/","text":"openscenario_interpreter::type_traits::IfHasMemberFunctionEvaluate< T, typename std::enable_if< HasMemberFunctionEvaluate< T >::value >::type > # More... Public Functions # Name template \\<typename Result > constexpr Result callIt (T & then, const Result & ) Detailed Description # template < typename T > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionEvaluate < T , typename std :: enable_if < HasMemberFunctionEvaluate < T >:: value >:: type > ; Public Functions Documentation # function callIt # template < typename Result > static inline constexpr Result callIt ( T & then , const Result & ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionEvaluate< T, typename std::enable_if< HasMemberFunctionEvaluate< T >::value >::type >"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionEvaluate_3_01T_00_01typenac94e421386c5218cf6e385ba6234ba80/#openscenario_interpretertype_traitsifhasmemberfunctionevaluate-t-typename-stdenable_if-hasmemberfunctionevaluate-t-value-type","text":"More...","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionEvaluate&lt; T, typename std::enable_if&lt; HasMemberFunctionEvaluate&lt; T &gt;::value &gt;::type &gt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionEvaluate_3_01T_00_01typenac94e421386c5218cf6e385ba6234ba80/#public-functions","text":"Name template \\<typename Result > constexpr Result callIt (T & then, const Result & )","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionEvaluate_3_01T_00_01typenac94e421386c5218cf6e385ba6234ba80/#detailed-description","text":"template < typename T > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionEvaluate < T , typename std :: enable_if < HasMemberFunctionEvaluate < T >:: value >:: type > ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionEvaluate_3_01T_00_01typenac94e421386c5218cf6e385ba6234ba80/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionEvaluate_3_01T_00_01typenac94e421386c5218cf6e385ba6234ba80/#function-callit","text":"template < typename Result > static inline constexpr Result callIt ( T & then , const Result & ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function callIt"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionStart/","text":"openscenario_interpreter::type_traits::IfHasMemberFunctionStart # More... Public Functions # Name constexpr void callIt (const T & ) Detailed Description # template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionStart ; Public Functions Documentation # function callIt # static inline constexpr void callIt ( const T & ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionStart"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionStart/#openscenario_interpretertype_traitsifhasmemberfunctionstart","text":"More...","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionStart"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionStart/#public-functions","text":"Name constexpr void callIt (const T & )","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionStart/#detailed-description","text":"template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionStart ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionStart/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionStart/#function-callit","text":"static inline constexpr void callIt ( const T & ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function callIt"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionStart_3_01T_00_01typename_0c9e1288955b9aeff14e6ade95b221ba/","text":"openscenario_interpreter::type_traits::IfHasMemberFunctionStart< T, typename std::enable_if< HasMemberFunctionStart< T >::value >::type > # More... Public Functions # Name decltype(auto) constexpr callIt (T & then) Detailed Description # template < typename T > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionStart < T , typename std :: enable_if < HasMemberFunctionStart < T >:: value >:: type > ; Public Functions Documentation # function callIt # static inline decltype ( auto ) constexpr callIt ( T & then ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionStart< T, typename std::enable_if< HasMemberFunctionStart< T >::value >::type >"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionStart_3_01T_00_01typename_0c9e1288955b9aeff14e6ade95b221ba/#openscenario_interpretertype_traitsifhasmemberfunctionstart-t-typename-stdenable_if-hasmemberfunctionstart-t-value-type","text":"More...","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionStart&lt; T, typename std::enable_if&lt; HasMemberFunctionStart&lt; T &gt;::value &gt;::type &gt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionStart_3_01T_00_01typename_0c9e1288955b9aeff14e6ade95b221ba/#public-functions","text":"Name decltype(auto) constexpr callIt (T & then)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionStart_3_01T_00_01typename_0c9e1288955b9aeff14e6ade95b221ba/#detailed-description","text":"template < typename T > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionStart < T , typename std :: enable_if < HasMemberFunctionStart < T >:: value >:: type > ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionStart_3_01T_00_01typename_0c9e1288955b9aeff14e6ade95b221ba/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionStart_3_01T_00_01typename_0c9e1288955b9aeff14e6ade95b221ba/#function-callit","text":"static inline decltype ( auto ) constexpr callIt ( T & then ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function callIt"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionState/","text":"openscenario_interpreter::type_traits::IfHasMemberFunctionState # More... Public Functions # Name template \\<typename Result > const Result & callIt (const T & ) Detailed Description # template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionState ; Public Functions Documentation # function callIt # template < typename Result > static inline const Result & callIt ( const T & ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionState"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionState/#openscenario_interpretertype_traitsifhasmemberfunctionstate","text":"More...","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionState"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionState/#public-functions","text":"Name template \\<typename Result > const Result & callIt (const T & )","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionState/#detailed-description","text":"template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionState ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionState/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionState/#function-callit","text":"template < typename Result > static inline const Result & callIt ( const T & ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function callIt"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionState_3_01T_00_01typename_0ff35771ae8461e6a5e03b26e0fcf72a/","text":"openscenario_interpreter::type_traits::IfHasMemberFunctionState< T, typename std::enable_if< HasMemberFunctionState< T >::value >::type > # More... Public Functions # Name template \\<typename Result > const Result & callIt (const T & callee) Detailed Description # template < typename T > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionState < T , typename std :: enable_if < HasMemberFunctionState < T >:: value >:: type > ; Public Functions Documentation # function callIt # template < typename Result > static inline const Result & callIt ( const T & callee ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionState< T, typename std::enable_if< HasMemberFunctionState< T >::value >::type >"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionState_3_01T_00_01typename_0ff35771ae8461e6a5e03b26e0fcf72a/#openscenario_interpretertype_traitsifhasmemberfunctionstate-t-typename-stdenable_if-hasmemberfunctionstate-t-value-type","text":"More...","title":"openscenario_interpreter::type_traits::IfHasMemberFunctionState&lt; T, typename std::enable_if&lt; HasMemberFunctionState&lt; T &gt;::value &gt;::type &gt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionState_3_01T_00_01typename_0ff35771ae8461e6a5e03b26e0fcf72a/#public-functions","text":"Name template \\<typename Result > const Result & callIt (const T & callee)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionState_3_01T_00_01typename_0ff35771ae8461e6a5e03b26e0fcf72a/#detailed-description","text":"template < typename T > struct openscenario_interpreter :: type_traits :: IfHasMemberFunctionState < T , typename std :: enable_if < HasMemberFunctionState < T >:: value >:: type > ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionState_3_01T_00_01typename_0ff35771ae8461e6a5e03b26e0fcf72a/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasMemberFunctionState_3_01T_00_01typename_0ff35771ae8461e6a5e03b26e0fcf72a/#function-callit","text":"template < typename Result > static inline const Result & callIt ( const T & callee ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function callIt"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasStreamOutputOperator/","text":"openscenario_interpreter::type_traits::IfHasStreamOutputOperator # More... Public Functions # Name std::ostream & applyIt (std::ostream & os, const T & ) Detailed Description # template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: IfHasStreamOutputOperator ; Public Functions Documentation # function applyIt # static inline std :: ostream & applyIt ( std :: ostream & os , const T & ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::IfHasStreamOutputOperator"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasStreamOutputOperator/#openscenario_interpretertype_traitsifhasstreamoutputoperator","text":"More...","title":"openscenario_interpreter::type_traits::IfHasStreamOutputOperator"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasStreamOutputOperator/#public-functions","text":"Name std::ostream & applyIt (std::ostream & os, const T & )","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasStreamOutputOperator/#detailed-description","text":"template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: IfHasStreamOutputOperator ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasStreamOutputOperator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasStreamOutputOperator/#function-applyit","text":"static inline std :: ostream & applyIt ( std :: ostream & os , const T & ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function applyIt"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasStreamOutputOperator_3_01T_00_01typename6dd8cb9d972ee8d8f2f38c0833776195/","text":"openscenario_interpreter::type_traits::IfHasStreamOutputOperator< T, typename std::enable_if< HasStreamOutputOperator< T >::value >::type > # More... Public Functions # Name std::ostream & applyIt (std::ostream & os, const T & rhs) Detailed Description # template < typename T > struct openscenario_interpreter :: type_traits :: IfHasStreamOutputOperator < T , typename std :: enable_if < HasStreamOutputOperator < T >:: value >:: type > ; Public Functions Documentation # function applyIt # static inline std :: ostream & applyIt ( std :: ostream & os , const T & rhs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::IfHasStreamOutputOperator< T, typename std::enable_if< HasStreamOutputOperator< T >::value >::type >"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasStreamOutputOperator_3_01T_00_01typename6dd8cb9d972ee8d8f2f38c0833776195/#openscenario_interpretertype_traitsifhasstreamoutputoperator-t-typename-stdenable_if-hasstreamoutputoperator-t-value-type","text":"More...","title":"openscenario_interpreter::type_traits::IfHasStreamOutputOperator&lt; T, typename std::enable_if&lt; HasStreamOutputOperator&lt; T &gt;::value &gt;::type &gt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasStreamOutputOperator_3_01T_00_01typename6dd8cb9d972ee8d8f2f38c0833776195/#public-functions","text":"Name std::ostream & applyIt (std::ostream & os, const T & rhs)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasStreamOutputOperator_3_01T_00_01typename6dd8cb9d972ee8d8f2f38c0833776195/#detailed-description","text":"template < typename T > struct openscenario_interpreter :: type_traits :: IfHasStreamOutputOperator < T , typename std :: enable_if < HasStreamOutputOperator < T >:: value >:: type > ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasStreamOutputOperator_3_01T_00_01typename6dd8cb9d972ee8d8f2f38c0833776195/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfHasStreamOutputOperator_3_01T_00_01typename6dd8cb9d972ee8d8f2f38c0833776195/#function-applyit","text":"static inline std :: ostream & applyIt ( std :: ostream & os , const T & rhs ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function applyIt"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotDefaultConstructible/","text":"openscenario_interpreter::type_traits::IfNotDefaultConstructible # More... Public Functions # Name T error (const std::string & parent_name, const std::string & child_name) Detailed Description # template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: IfNotDefaultConstructible ; Public Functions Documentation # function error # static inline T error ( const std :: string & parent_name , const std :: string & child_name ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::IfNotDefaultConstructible"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotDefaultConstructible/#openscenario_interpretertype_traitsifnotdefaultconstructible","text":"More...","title":"openscenario_interpreter::type_traits::IfNotDefaultConstructible"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotDefaultConstructible/#public-functions","text":"Name T error (const std::string & parent_name, const std::string & child_name)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotDefaultConstructible/#detailed-description","text":"template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: IfNotDefaultConstructible ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotDefaultConstructible/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotDefaultConstructible/#function-error","text":"static inline T error ( const std :: string & parent_name , const std :: string & child_name ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function error"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotDefaultConstructible_3_01T_00_01typenamebb0cd5b30531f79b8eb9acdb8c54d9aa/","text":"openscenario_interpreter::type_traits::IfNotDefaultConstructible< T, typename std::enable_if< std::is_default_constructible< T >::value >::type > # More... Public Functions # Name template \\<typename ... Ts> T error (Ts && ...) Detailed Description # template < typename T > struct openscenario_interpreter :: type_traits :: IfNotDefaultConstructible < T , typename std :: enable_if < std :: is_default_constructible < T >:: value >:: type > ; Public Functions Documentation # function error # template < typename ... Ts > static inline T error ( Ts && ... ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::IfNotDefaultConstructible< T, typename std::enable_if< std::is_default_constructible< T >::value >::type >"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotDefaultConstructible_3_01T_00_01typenamebb0cd5b30531f79b8eb9acdb8c54d9aa/#openscenario_interpretertype_traitsifnotdefaultconstructible-t-typename-stdenable_if-stdis_default_constructible-t-value-type","text":"More...","title":"openscenario_interpreter::type_traits::IfNotDefaultConstructible&lt; T, typename std::enable_if&lt; std::is_default_constructible&lt; T &gt;::value &gt;::type &gt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotDefaultConstructible_3_01T_00_01typenamebb0cd5b30531f79b8eb9acdb8c54d9aa/#public-functions","text":"Name template \\<typename ... Ts> T error (Ts && ...)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotDefaultConstructible_3_01T_00_01typenamebb0cd5b30531f79b8eb9acdb8c54d9aa/#detailed-description","text":"template < typename T > struct openscenario_interpreter :: type_traits :: IfNotDefaultConstructible < T , typename std :: enable_if < std :: is_default_constructible < T >:: value >:: type > ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotDefaultConstructible_3_01T_00_01typenamebb0cd5b30531f79b8eb9acdb8c54d9aa/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotDefaultConstructible_3_01T_00_01typenamebb0cd5b30531f79b8eb9acdb8c54d9aa/#function-error","text":"template < typename ... Ts > static inline T error ( Ts && ... ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function error"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotNothrowDefaultConstructible/","text":"openscenario_interpreter::type_traits::IfNotNothrowDefaultConstructible # More... Public Functions # Name T error (const std::string & parent_name, const std::string & child_name) Detailed Description # template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: IfNotNothrowDefaultConstructible ; Public Functions Documentation # function error # static inline T error ( const std :: string & parent_name , const std :: string & child_name ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::IfNotNothrowDefaultConstructible"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotNothrowDefaultConstructible/#openscenario_interpretertype_traitsifnotnothrowdefaultconstructible","text":"More...","title":"openscenario_interpreter::type_traits::IfNotNothrowDefaultConstructible"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotNothrowDefaultConstructible/#public-functions","text":"Name T error (const std::string & parent_name, const std::string & child_name)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotNothrowDefaultConstructible/#detailed-description","text":"template < typename T , typename = void > struct openscenario_interpreter :: type_traits :: IfNotNothrowDefaultConstructible ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotNothrowDefaultConstructible/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotNothrowDefaultConstructible/#function-error","text":"static inline T error ( const std :: string & parent_name , const std :: string & child_name ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function error"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotNothrowDefaultConstructible_3_01T_00_01t81372c977a96666f991b25dcb702ce35/","text":"openscenario_interpreter::type_traits::IfNotNothrowDefaultConstructible< T, typename std::enable_if< std::is_nothrow_default_constructible< T >::value >::type > # More... Public Functions # Name template \\<typename ... Ts> T error (Ts && ...) Detailed Description # template < typename T > struct openscenario_interpreter :: type_traits :: IfNotNothrowDefaultConstructible < T , typename std :: enable_if < std :: is_nothrow_default_constructible < T >:: value >:: type > ; Public Functions Documentation # function error # template < typename ... Ts > static inline T error ( Ts && ... ) Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits::IfNotNothrowDefaultConstructible< T, typename std::enable_if< std::is_nothrow_default_constructible< T >::value >::type >"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotNothrowDefaultConstructible_3_01T_00_01t81372c977a96666f991b25dcb702ce35/#openscenario_interpretertype_traitsifnotnothrowdefaultconstructible-t-typename-stdenable_if-stdis_nothrow_default_constructible-t-value-type","text":"More...","title":"openscenario_interpreter::type_traits::IfNotNothrowDefaultConstructible&lt; T, typename std::enable_if&lt; std::is_nothrow_default_constructible&lt; T &gt;::value &gt;::type &gt;"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotNothrowDefaultConstructible_3_01T_00_01t81372c977a96666f991b25dcb702ce35/#public-functions","text":"Name template \\<typename ... Ts> T error (Ts && ...)","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotNothrowDefaultConstructible_3_01T_00_01t81372c977a96666f991b25dcb702ce35/#detailed-description","text":"template < typename T > struct openscenario_interpreter :: type_traits :: IfNotNothrowDefaultConstructible < T , typename std :: enable_if < std :: is_nothrow_default_constructible < T >:: value >:: type > ;","title":"Detailed Description"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotNothrowDefaultConstructible_3_01T_00_01t81372c977a96666f991b25dcb702ce35/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1type__traits_1_1IfNotNothrowDefaultConstructible_3_01T_00_01t81372c977a96666f991b25dcb702ce35/#function-error","text":"template < typename ... Ts > static inline T error ( Ts && ... ) Updated on 7 April 2021 at 00:31:56 UTC","title":"function error"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1AttributeHighlighter/","text":"openscenario_interpreter::utility::AttributeHighlighter # Public Functions # Name template \\<typename ... Ts> decltype(auto) operator() (std::basic_ostream< Ts... > & os) const Public Attributes # Name const std::string value const std::string name Public Functions Documentation # function operator() # template < typename ... Ts > inline decltype ( auto ) operator ()( std :: basic_ostream < Ts ... > & os ) const Public Attributes Documentation # variable value # const std :: string value ; variable name # const std :: string name ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::utility::AttributeHighlighter"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1AttributeHighlighter/#openscenario_interpreterutilityattributehighlighter","text":"","title":"openscenario_interpreter::utility::AttributeHighlighter"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1AttributeHighlighter/#public-functions","text":"Name template \\<typename ... Ts> decltype(auto) operator() (std::basic_ostream< Ts... > & os) const","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1AttributeHighlighter/#public-attributes","text":"Name const std::string value const std::string name","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1AttributeHighlighter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1AttributeHighlighter/#function-operator","text":"template < typename ... Ts > inline decltype ( auto ) operator ()( std :: basic_ostream < Ts ... > & os ) const","title":"function operator()"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1AttributeHighlighter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1AttributeHighlighter/#variable-value","text":"const std :: string value ;","title":"variable value"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1AttributeHighlighter/#variable-name","text":"const std :: string name ; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable name"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1Indent/","text":"openscenario_interpreter::utility::Indent # Public Functions # Name auto & reset () auto & operator-- () auto operator-- (int ) auto & operator++ () auto operator++ (int ) Public Attributes # Name std::size_t width std::size_t depth Public Functions Documentation # function reset # inline auto & reset () function operator-- # inline auto & operator -- () function operator-- # inline auto operator -- ( int ) function operator++ # inline auto & operator ++ () function operator++ # inline auto operator ++ ( int ) Public Attributes Documentation # variable width # std :: size_t width { 2 }; variable depth # std :: size_t depth { 0 }; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::utility::Indent"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1Indent/#openscenario_interpreterutilityindent","text":"","title":"openscenario_interpreter::utility::Indent"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1Indent/#public-functions","text":"Name auto & reset () auto & operator-- () auto operator-- (int ) auto & operator++ () auto operator++ (int )","title":"Public Functions"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1Indent/#public-attributes","text":"Name std::size_t width std::size_t depth","title":"Public Attributes"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1Indent/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1Indent/#function-reset","text":"inline auto & reset ()","title":"function reset"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1Indent/#function-operator-","text":"inline auto & operator -- ()","title":"function operator--"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1Indent/#function-operator-_1","text":"inline auto operator -- ( int )","title":"function operator--"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1Indent/#function-operator","text":"inline auto & operator ++ ()","title":"function operator++"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1Indent/#function-operator_1","text":"inline auto operator ++ ( int )","title":"function operator++"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1Indent/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1Indent/#variable-width","text":"std :: size_t width { 2 };","title":"variable width"},{"location":"package/openscenario_interpreter/markdown/Classes/structopenscenario__interpreter_1_1utility_1_1Indent/#variable-depth","text":"std :: size_t depth { 0 }; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable depth"},{"location":"package/openscenario_interpreter/markdown/Examples/","text":"Examples # Updated on 7 April 2021 at 00:31:57 UTC","title":"Examples"},{"location":"package/openscenario_interpreter/markdown/Examples/#examples","text":"Updated on 7 April 2021 at 00:31:57 UTC","title":"Examples"},{"location":"package/openscenario_interpreter/markdown/Files/","text":"Files # dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console/escape_sequence.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console/is_console.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional/equal_to.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional/fold.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/iterator file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/iterator/size.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/posix file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/posix/fork_exec.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/attribute.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/content.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/element.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string/cat.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string/split.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/absolute_target_lane.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/absolute_target_speed.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/acceleration_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/acquire_position_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/act.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/actors.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/add_entity_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/assign_controller_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/assign_route_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/axle.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/axles.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/boolean.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/bounding_box.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_entity_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_type.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_value_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/catalog_location.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/catalog_locations.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/center.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/collision_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/command.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition_edge.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition_group.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/controller.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/controller_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/custom_command_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/delete_entity_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dimensions.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/directory.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/distance_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/double.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dynamics_dimension.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dynamics_shape.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entities.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_object.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_ref.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_selection.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/event.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/file.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/file_header.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/global_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/infrastructure_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/init.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/init_actions.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/integer.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_change_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_change_target.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_position.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lateral_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/longitudinal_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/maneuver.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/maneuver_group.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/modify_rule.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/object_controller.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/object_type.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/openscenario.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/orientation.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/override_controller_value_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_add_value_rule.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_declaration.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_declarations.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_modify_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_multiply_by_value_rule.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_set_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_type.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/pedestrian.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/pedestrian_category.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/performance.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/position.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/priority.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/private.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/private_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/properties.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/property.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/reach_position_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/reference_context.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_distance_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_distance_type.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_target_speed.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_world_position.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/road_network.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/route.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/route_strategy.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/routing_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/rule.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/scenario_object.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/selected_entities.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/simulation_time_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_action_target.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_target_value_type.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/stand_still_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/story.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_state.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_state_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_type.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/string.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/teleport_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/time_headway_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_state_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signals.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/transition_dynamics.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/trigger.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/triggering_entities.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/triggering_entities_rule.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/unsigned_integer.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/unsigned_short.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/user_defined_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/vehicle.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/vehicle_category.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/waypoint.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/world_position.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_accomplished.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_evaluate.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_start.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_state.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_stream_output_operator.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_accomplished.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_evaluate.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_start.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_state.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_stream_output_operator.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_not_default_constructible.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_not_nothrow_default_constructible.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/void_t.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/assertion_auxiliary.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/highlighter.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/indent.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/pair.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/pugi_extension.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/verbose.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/visibility.h file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/error.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/expression.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/object.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/openscenario_interpreter.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/pointer.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/procedure.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/scope.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/object.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/openscenario_interpreter.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/openscenario_interpreter_node.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/procedure.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/test file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/test/test_syntax.cpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_interpreter/markdown/Files/#files","text":"dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console/escape_sequence.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console/is_console.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional/equal_to.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional/fold.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/iterator file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/iterator/size.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/posix file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/posix/fork_exec.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/attribute.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/content.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/element.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string/cat.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string/split.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/absolute_target_lane.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/absolute_target_speed.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/acceleration_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/acquire_position_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/act.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/actors.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/add_entity_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/assign_controller_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/assign_route_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/axle.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/axles.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/boolean.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/bounding_box.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_entity_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_type.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_value_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/catalog_location.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/catalog_locations.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/center.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/collision_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/command.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition_edge.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition_group.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/controller.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/controller_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/custom_command_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/delete_entity_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dimensions.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/directory.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/distance_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/double.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dynamics_dimension.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dynamics_shape.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entities.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_object.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_ref.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_selection.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/event.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/file.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/file_header.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/global_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/infrastructure_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/init.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/init_actions.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/integer.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_change_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_change_target.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_position.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lateral_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/longitudinal_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/maneuver.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/maneuver_group.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/modify_rule.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/object_controller.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/object_type.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/openscenario.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/orientation.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/override_controller_value_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_add_value_rule.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_declaration.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_declarations.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_modify_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_multiply_by_value_rule.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_set_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_type.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/pedestrian.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/pedestrian_category.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/performance.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/position.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/priority.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/private.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/private_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/properties.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/property.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/reach_position_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/reference_context.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_distance_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_distance_type.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_target_speed.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_world_position.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/road_network.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/route.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/route_strategy.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/routing_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/rule.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/scenario_object.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/selected_entities.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/simulation_time_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_action_target.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_target_value_type.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/stand_still_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/story.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_state.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_state_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_type.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/string.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/teleport_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/time_headway_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_condition.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_state_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signals.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/transition_dynamics.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/trigger.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/triggering_entities.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/triggering_entities_rule.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/unsigned_integer.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/unsigned_short.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/user_defined_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/vehicle.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/vehicle_category.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/waypoint.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/world_position.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_accomplished.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_evaluate.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_start.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_state.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_stream_output_operator.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_accomplished.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_evaluate.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_start.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_state.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_stream_output_operator.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_not_default_constructible.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_not_nothrow_default_constructible.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/void_t.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/assertion_auxiliary.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/highlighter.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/indent.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/pair.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/pugi_extension.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/verbose.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/visibility.h file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/error.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/expression.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/object.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/openscenario_interpreter.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/pointer.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/procedure.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/scope.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/object.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/openscenario_interpreter.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/openscenario_interpreter_node.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/procedure.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/test file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/test/test_syntax.cpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_interpreter/markdown/Files/absolute__target__lane_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/absolute_target_lane.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::AbsoluteTargetLane Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ABSOLUTE_TARGET_LANE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ABSOLUTE_TARGET_LANE_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== AbsoluteTargetLane =================================================== * * <xsd:complexType name=\"AbsoluteTargetLane\"> * <xsd:attribute name=\"value\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct AbsoluteTargetLane { const String value ; template < typename Node , typename Scope > explicit AbsoluteTargetLane ( const Node & node , Scope & scope ) : value { readAttribute < String > ( \"value\" , node , scope )} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ABSOLUTE_TARGET_LANE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/absolute_target_lane.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/absolute__target__lane_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxabsolute_target_lanehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/absolute_target_lane.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/absolute__target__lane_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/absolute__target__lane_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::AbsoluteTargetLane","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/absolute__target__lane_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ABSOLUTE_TARGET_LANE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ABSOLUTE_TARGET_LANE_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== AbsoluteTargetLane =================================================== * * <xsd:complexType name=\"AbsoluteTargetLane\"> * <xsd:attribute name=\"value\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct AbsoluteTargetLane { const String value ; template < typename Node , typename Scope > explicit AbsoluteTargetLane ( const Node & node , Scope & scope ) : value { readAttribute < String > ( \"value\" , node , scope )} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ABSOLUTE_TARGET_LANE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/absolute__target__speed_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/absolute_target_speed.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::AbsoluteTargetSpeed Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ABSOLUTE_TARGET_SPEED_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ABSOLUTE_TARGET_SPEED_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== AbsoluteTargetSpeed ==================================================== * * <xsd:complexType name=\"AbsoluteTargetSpeed\"> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * ========================================================================== */ struct AbsoluteTargetSpeed { const Double value ; template < typename Node , typename Scope > explicit AbsoluteTargetSpeed ( const Node & node , Scope & scope ) : value { readAttribute < Double > ( \"value\" , node , scope )} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ABSOLUTE_TARGET_SPEED_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/absolute_target_speed.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/absolute__target__speed_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxabsolute_target_speedhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/absolute_target_speed.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/absolute__target__speed_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/absolute__target__speed_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::AbsoluteTargetSpeed","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/absolute__target__speed_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ABSOLUTE_TARGET_SPEED_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ABSOLUTE_TARGET_SPEED_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== AbsoluteTargetSpeed ==================================================== * * <xsd:complexType name=\"AbsoluteTargetSpeed\"> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * ========================================================================== */ struct AbsoluteTargetSpeed { const Double value ; template < typename Node , typename Scope > explicit AbsoluteTargetSpeed ( const Node & node , Scope & scope ) : value { readAttribute < Double > ( \"value\" , node , scope )} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ABSOLUTE_TARGET_SPEED_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/acceleration__condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/acceleration_condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::AccelerationCondition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ACCELERATION_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ACCELERATION_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/rule.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- AccelerationCondition -------------------------------------------------- * * <xsd:complexType name=\"AccelerationCondition\"> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"rule\" type=\"Rule\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct AccelerationCondition { const Double value ; const Rule compare ; const TriggeringEntities trigger ; template < typename Node > explicit AccelerationCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & trigger ) : value ( readAttribute < Double > ( \"value\" , node , outer_scope )), compare ( readAttribute < Rule > ( \"rule\" , node , outer_scope )), trigger ( trigger ) {} auto evaluate () const { return asBoolean ( trigger ( [ & ]( auto && entity ) { return compare ( getEntityStatus ( entity ). action_status . accel . linear . x , value ); })); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ACCELERATION_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/acceleration_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/acceleration__condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxacceleration_conditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/acceleration_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/acceleration__condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/acceleration__condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::AccelerationCondition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/acceleration__condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ACCELERATION_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ACCELERATION_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/rule.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- AccelerationCondition -------------------------------------------------- * * <xsd:complexType name=\"AccelerationCondition\"> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"rule\" type=\"Rule\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct AccelerationCondition { const Double value ; const Rule compare ; const TriggeringEntities trigger ; template < typename Node > explicit AccelerationCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & trigger ) : value ( readAttribute < Double > ( \"value\" , node , outer_scope )), compare ( readAttribute < Rule > ( \"rule\" , node , outer_scope )), trigger ( trigger ) {} auto evaluate () const { return asBoolean ( trigger ( [ & ]( auto && entity ) { return compare ( getEntityStatus ( entity ). action_status . accel . linear . x , value ); })); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ACCELERATION_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/acquire__position__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/acquire_position_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::AcquirePositionAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ACQUIRE_POSITION_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ACQUIRE_POSITION_ACTION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/position.hpp> #include <simulation_api/helper/helper.hpp> #include <string> #include <unordered_map> namespace openscenario_interpreter { inline namespace syntax { /* ---- AcquirePositionAction -------------------------------------------------- * * <xsd:complexType name=\"AcquirePositionAction\"> * <xsd:all> * <xsd:element name=\"Position\" type=\"Position\"/> * </xsd:all> * </xsd:complexType> * * TODO REMOVE EXTENSION * * -------------------------------------------------------------------------- */ struct AcquirePositionAction { Scope inner_scope ; const Position position ; template < typename Node > explicit AcquirePositionAction ( const Node & node , Scope & outer_scope ) : inner_scope ( outer_scope ), position ( readElement < Position > ( \"Position\" , node , inner_scope )) {} std :: unordered_map < std :: string , Boolean > accomplishments ; auto start () { accomplishments . clear (); if ( position . is < LanePosition > ()) { for ( const auto & actor : inner_scope . actors ) { accomplishments . emplace ( actor , false ); requestAcquirePosition ( actor , static_cast < openscenario_msgs :: msg :: LaneletPose > ( position . as < LanePosition > ())); } } else { THROW ( ImplementationFault ); } } #ifndef OPENSCENARIO_INTERPRETER_NO_EXTENSION auto accomplished () { if ( position . is < LanePosition > ()) { for ( auto && each : accomplishments ) { if ( ! cdr ( each )) { cdr ( each ) = isReachedPosition ( car ( each ), static_cast < openscenario_msgs :: msg :: LaneletPose > ( position . as < LanePosition > ()), 5.0 ); } } return std :: all_of ( std :: begin ( accomplishments ), std :: end ( accomplishments ), cdr ); } else { THROW ( ImplementationFault ); } } #else const std :: true_type accomplished {}; #endif }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ACQUIRE_POSITION_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/acquire_position_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/acquire__position__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxacquire_position_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/acquire_position_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/acquire__position__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/acquire__position__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::AcquirePositionAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/acquire__position__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ACQUIRE_POSITION_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ACQUIRE_POSITION_ACTION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/position.hpp> #include <simulation_api/helper/helper.hpp> #include <string> #include <unordered_map> namespace openscenario_interpreter { inline namespace syntax { /* ---- AcquirePositionAction -------------------------------------------------- * * <xsd:complexType name=\"AcquirePositionAction\"> * <xsd:all> * <xsd:element name=\"Position\" type=\"Position\"/> * </xsd:all> * </xsd:complexType> * * TODO REMOVE EXTENSION * * -------------------------------------------------------------------------- */ struct AcquirePositionAction { Scope inner_scope ; const Position position ; template < typename Node > explicit AcquirePositionAction ( const Node & node , Scope & outer_scope ) : inner_scope ( outer_scope ), position ( readElement < Position > ( \"Position\" , node , inner_scope )) {} std :: unordered_map < std :: string , Boolean > accomplishments ; auto start () { accomplishments . clear (); if ( position . is < LanePosition > ()) { for ( const auto & actor : inner_scope . actors ) { accomplishments . emplace ( actor , false ); requestAcquirePosition ( actor , static_cast < openscenario_msgs :: msg :: LaneletPose > ( position . as < LanePosition > ())); } } else { THROW ( ImplementationFault ); } } #ifndef OPENSCENARIO_INTERPRETER_NO_EXTENSION auto accomplished () { if ( position . is < LanePosition > ()) { for ( auto && each : accomplishments ) { if ( ! cdr ( each )) { cdr ( each ) = isReachedPosition ( car ( each ), static_cast < openscenario_msgs :: msg :: LaneletPose > ( position . as < LanePosition > ()), 5.0 ); } } return std :: all_of ( std :: begin ( accomplishments ), std :: end ( accomplishments ), cdr ); } else { THROW ( ImplementationFault ); } } #else const std :: true_type accomplished {}; #endif }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ACQUIRE_POSITION_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/act_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/act.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Act Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ACT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ACT_HPP_ #include <openscenario_interpreter/syntax/maneuver_group.hpp> #include <openscenario_interpreter/syntax/storyboard_element.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- Act -------------------------------------------------------------------- * * <xsd:complexType name=\"Act\"> * <xsd:sequence> * <xsd:element name=\"ManeuverGroup\" maxOccurs=\"unbounded\" type=\"ManeuverGroup\"/> * <xsd:element name=\"StartTrigger\" type=\"Trigger\"/> * <xsd:element name=\"StopTrigger\" minOccurs=\"0\" type=\"Trigger\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Act : public StoryboardElement < Act > , public Elements { const String name ; Scope inner_scope ; Element start_trigger , stop_trigger ; template < typename Node > explicit Act ( const Node & node , Scope & outer_scope ) : name ( readAttribute < String > ( \"name\" , node , outer_scope )), inner_scope ( outer_scope ) { callWithElements ( node , \"ManeuverGroup\" , 1 , unbounded , [ & ]( auto && node ) { return push_back ( readStoryboardElement < ManeuverGroup > ( node , inner_scope )); }); callWithElements ( node , \"StartTrigger\" , 1 , 1 , [ & ]( auto && node ) { return start_trigger . rebind < Trigger > ( node , inner_scope ); }); callWithElements ( node , \"StopTrigger\" , 0 , 1 , [ & ]( auto && node ) { return stop_trigger . rebind < Trigger > ( node , inner_scope ); }); } auto ready () const { return start_trigger . evaluate (). as < Boolean > (); } auto stopTriggered () const { return stop_trigger && stop_trigger . evaluate (). as < Boolean > (); } /* ------------------------------------------------------------------------- * * A ManeuverGroup's goal is accomplished when all its Maneuvers are in the * completeState. * * ---------------------------------------------------------------------- */ auto accomplished () const { return std :: all_of ( std :: begin ( * this ), std :: end ( * this ), [ & ]( const Element & each ) { return each . as < ManeuverGroup > (). complete (); }); } void stop () { for ( auto && each : * this ) { each . as < ManeuverGroup > (). override (); each . evaluate (); } } using StoryboardElement :: evaluate ; void run () { for ( auto && each : * this ) { each . evaluate (); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ACT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/act.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/act_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxacthpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/act.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/act_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/act_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Act","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/act_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ACT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ACT_HPP_ #include <openscenario_interpreter/syntax/maneuver_group.hpp> #include <openscenario_interpreter/syntax/storyboard_element.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- Act -------------------------------------------------------------------- * * <xsd:complexType name=\"Act\"> * <xsd:sequence> * <xsd:element name=\"ManeuverGroup\" maxOccurs=\"unbounded\" type=\"ManeuverGroup\"/> * <xsd:element name=\"StartTrigger\" type=\"Trigger\"/> * <xsd:element name=\"StopTrigger\" minOccurs=\"0\" type=\"Trigger\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Act : public StoryboardElement < Act > , public Elements { const String name ; Scope inner_scope ; Element start_trigger , stop_trigger ; template < typename Node > explicit Act ( const Node & node , Scope & outer_scope ) : name ( readAttribute < String > ( \"name\" , node , outer_scope )), inner_scope ( outer_scope ) { callWithElements ( node , \"ManeuverGroup\" , 1 , unbounded , [ & ]( auto && node ) { return push_back ( readStoryboardElement < ManeuverGroup > ( node , inner_scope )); }); callWithElements ( node , \"StartTrigger\" , 1 , 1 , [ & ]( auto && node ) { return start_trigger . rebind < Trigger > ( node , inner_scope ); }); callWithElements ( node , \"StopTrigger\" , 0 , 1 , [ & ]( auto && node ) { return stop_trigger . rebind < Trigger > ( node , inner_scope ); }); } auto ready () const { return start_trigger . evaluate (). as < Boolean > (); } auto stopTriggered () const { return stop_trigger && stop_trigger . evaluate (). as < Boolean > (); } /* ------------------------------------------------------------------------- * * A ManeuverGroup's goal is accomplished when all its Maneuvers are in the * completeState. * * ---------------------------------------------------------------------- */ auto accomplished () const { return std :: all_of ( std :: begin ( * this ), std :: end ( * this ), [ & ]( const Element & each ) { return each . as < ManeuverGroup > (). complete (); }); } void stop () { for ( auto && each : * this ) { each . as < ManeuverGroup > (). override (); each . evaluate (); } } using StoryboardElement :: evaluate ; void run () { for ( auto && each : * this ) { each . evaluate (); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ACT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Action Defines # Name ELEMENT (NAME) Macro Documentation # define ELEMENT # #define ELEMENT( NAME ) std :: make_pair ( \\ #NAME, [&](auto && node) \\ { \\ return make<NAME>(node, scope); \\ }) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ACTION_HPP_ #include <openscenario_interpreter/syntax/global_action.hpp> #include <openscenario_interpreter/syntax/private_action.hpp> #include <openscenario_interpreter/syntax/storyboard_element.hpp> #include <openscenario_interpreter/syntax/user_defined_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- Action ----------------------------------------------------------------- * * <xsd:complexType name=\"Action\"> * <xsd:choice> * <xsd:element name=\"GlobalAction\" type=\"GlobalAction\"/> * <xsd:element name=\"UserDefinedAction\" type=\"UserDefinedAction\"/> * <xsd:element name=\"PrivateAction\" type=\"PrivateAction\"/> * </xsd:choice> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(NAME) \\ std::make_pair( \\ #NAME, [&](auto && node) \\ { \\ return make<NAME>(node, scope); \\ }) struct Action : public StoryboardElement < Action > , public Element { const String name ; template < typename Node , typename Scope > explicit Action ( const Node & node , Scope & scope , std :: size_t maximum_execution_count ) : StoryboardElement ( maximum_execution_count ), Element ( choice ( node , ELEMENT ( GlobalAction ), ELEMENT ( UserDefinedAction ), ELEMENT ( PrivateAction ))), name ( readAttribute < String > ( \"name\" , node , scope )) {} auto ready () const { return static_cast < bool > ( * this ); } static constexpr auto stopTriggered () noexcept { return false ; } using Element :: start ; /* ------------------------------------------------------------------------- * * Action * An Action's goal is a function of the Action type and cannot be * generalized. Accomplishing an Action's goal will involve meeting some * arbitrary prerequisites related with the Action type (for example, a * SpeedAction accomplishes its goal when the considered Entity is * travelling at the prescribed speed). If an Action is acting on an * EntitySelection, all instances of Entity within the selection have to * complete in order to reach the completeState of the Action. * * ---------------------------------------------------------------------- */ using Element :: accomplished ; using StoryboardElement :: evaluate ; Boolean overridden { false }; void stop () { if ( overridden ) { current_state = complete_state ; } else { overridden = true ; } } template < typename ... Ts > decltype ( auto ) run ( Ts && ... xs ) { return Element :: evaluate ( std :: forward < decltype ( xs ) > ( xs )...); } }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxactionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Action","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/action_8hpp/#defines","text":"Name ELEMENT (NAME)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/action_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/action_8hpp/#define-element","text":"#define ELEMENT( NAME ) std :: make_pair ( \\ #NAME, [&](auto && node) \\ { \\ return make<NAME>(node, scope); \\ })","title":"define ELEMENT"},{"location":"package/openscenario_interpreter/markdown/Files/action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ACTION_HPP_ #include <openscenario_interpreter/syntax/global_action.hpp> #include <openscenario_interpreter/syntax/private_action.hpp> #include <openscenario_interpreter/syntax/storyboard_element.hpp> #include <openscenario_interpreter/syntax/user_defined_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- Action ----------------------------------------------------------------- * * <xsd:complexType name=\"Action\"> * <xsd:choice> * <xsd:element name=\"GlobalAction\" type=\"GlobalAction\"/> * <xsd:element name=\"UserDefinedAction\" type=\"UserDefinedAction\"/> * <xsd:element name=\"PrivateAction\" type=\"PrivateAction\"/> * </xsd:choice> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(NAME) \\ std::make_pair( \\ #NAME, [&](auto && node) \\ { \\ return make<NAME>(node, scope); \\ }) struct Action : public StoryboardElement < Action > , public Element { const String name ; template < typename Node , typename Scope > explicit Action ( const Node & node , Scope & scope , std :: size_t maximum_execution_count ) : StoryboardElement ( maximum_execution_count ), Element ( choice ( node , ELEMENT ( GlobalAction ), ELEMENT ( UserDefinedAction ), ELEMENT ( PrivateAction ))), name ( readAttribute < String > ( \"name\" , node , scope )) {} auto ready () const { return static_cast < bool > ( * this ); } static constexpr auto stopTriggered () noexcept { return false ; } using Element :: start ; /* ------------------------------------------------------------------------- * * Action * An Action's goal is a function of the Action type and cannot be * generalized. Accomplishing an Action's goal will involve meeting some * arbitrary prerequisites related with the Action type (for example, a * SpeedAction accomplishes its goal when the considered Entity is * travelling at the prescribed speed). If an Action is acting on an * EntitySelection, all instances of Entity within the selection have to * complete in order to reach the completeState of the Action. * * ---------------------------------------------------------------------- */ using Element :: accomplished ; using StoryboardElement :: evaluate ; Boolean overridden { false }; void stop () { if ( overridden ) { current_state = complete_state ; } else { overridden = true ; } } template < typename ... Ts > decltype ( auto ) run ( Ts && ... xs ) { return Element :: evaluate ( std :: forward < decltype ( xs ) > ( xs )...); } }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/actors_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/actors.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Actors Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ACTORS_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ACTORS_HPP_ #include <openscenario_interpreter/syntax/entity_ref.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Actors =============================================================== * * <xsd:complexType name=\"Actors\"> * <xsd:sequence> * <xsd:element name=\"EntityRef\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"EntityRef\"/> * </xsd:sequence> * <xsd:attribute name=\"selectTriggeringEntities\" type=\"Boolean\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Actors { // Indicates whether the triggering entities are considered actors. const Boolean select_triggering_entities ; template < typename Node , typename Scope > explicit Actors ( const Node & node , Scope & scope ) : select_triggering_entities { readAttribute < Boolean > ( \"selectTriggeringEntities\" , node , scope , Boolean ())} { callWithElements ( node , \"EntityRef\" , 0 , unbounded , [ & ]( auto && node ) { scope . actors . emplace_back ( node , scope ); }); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ACTORS_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/actors.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/actors_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxactorshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/actors.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/actors_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/actors_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Actors","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/actors_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ACTORS_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ACTORS_HPP_ #include <openscenario_interpreter/syntax/entity_ref.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Actors =============================================================== * * <xsd:complexType name=\"Actors\"> * <xsd:sequence> * <xsd:element name=\"EntityRef\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"EntityRef\"/> * </xsd:sequence> * <xsd:attribute name=\"selectTriggeringEntities\" type=\"Boolean\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Actors { // Indicates whether the triggering entities are considered actors. const Boolean select_triggering_entities ; template < typename Node , typename Scope > explicit Actors ( const Node & node , Scope & scope ) : select_triggering_entities { readAttribute < Boolean > ( \"selectTriggeringEntities\" , node , scope , Boolean ())} { callWithElements ( node , \"EntityRef\" , 0 , unbounded , [ & ]( auto && node ) { scope . actors . emplace_back ( node , scope ); }); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ACTORS_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/add__entity__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/add_entity_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::AddEntityAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ADD_ENTITY_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ADD_ENTITY_ACTION_HPP_ #include <openscenario_interpreter/reader/element.hpp> #include <openscenario_interpreter/syntax/position.hpp> #include <openscenario_interpreter/syntax/string.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- AddEntityAction -------------------------------------------------------- * * <xsd:complexType name=\"AddEntityAction\"> * <xsd:all> * <xsd:element name=\"Position\" type=\"Position\"/> * </xsd:all> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct AddEntityAction { const Position position ; template < typename Node , typename Scope > explicit AddEntityAction ( const Node & node , Scope & outer_scope ) : position ( readElement < Position > ( \"Position\" , node , outer_scope )) {} decltype ( auto ) operator ()( const String & entity_ref ) const { std :: cout << \"AddEntityAction: \" << entity_ref << std :: endl ; return unspecified ; } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ADD_ENTITY_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/add_entity_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/add__entity__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxadd_entity_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/add_entity_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/add__entity__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/add__entity__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::AddEntityAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/add__entity__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ADD_ENTITY_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ADD_ENTITY_ACTION_HPP_ #include <openscenario_interpreter/reader/element.hpp> #include <openscenario_interpreter/syntax/position.hpp> #include <openscenario_interpreter/syntax/string.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- AddEntityAction -------------------------------------------------------- * * <xsd:complexType name=\"AddEntityAction\"> * <xsd:all> * <xsd:element name=\"Position\" type=\"Position\"/> * </xsd:all> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct AddEntityAction { const Position position ; template < typename Node , typename Scope > explicit AddEntityAction ( const Node & node , Scope & outer_scope ) : position ( readElement < Position > ( \"Position\" , node , outer_scope )) {} decltype ( auto ) operator ()( const String & entity_ref ) const { std :: cout << \"AddEntityAction: \" << entity_ref << std :: endl ; return unspecified ; } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ADD_ENTITY_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/assertion__auxiliary_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/assertion_auxiliary.hpp # Namespaces # Name openscenario_interpreter::utility openscenario_interpreter Defines # Name ASSERT_DEFAULT_CONSTRUCTIBLE (TYPE) Macro Documentation # define ASSERT_DEFAULT_CONSTRUCTIBLE # #define ASSERT_DEFAULT_CONSTRUCTIBLE( TYPE ) static_assert ( \\ std :: is_default_constructible < TYPE >:: value , \\ \"OpenSCENARIO specification uses type '\" # TYPE \"' as optional element (as minOccurs= \\\" 0 \\\" ), \" \\ \"thus type '\" # TYPE \"' must be met concept DefaultConstructible.\" ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__UTILITY__ASSERTION_AUXILIARY_HPP_ #define OPENSCENARIO_INTERPRETER__UTILITY__ASSERTION_AUXILIARY_HPP_ #include <utility> namespace openscenario_interpreter { inline namespace utility { #define ASSERT_DEFAULT_CONSTRUCTIBLE(TYPE) \\ static_assert( \\ std::is_default_constructible<TYPE>::value, \\ \"OpenSCENARIO specification uses type '\" #TYPE \"' as optional element (as minOccurs=\\\"0\\\"), \" \\ \"thus type '\" #TYPE \"' must be met concept DefaultConstructible.\") } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__UTILITY__ASSERTION_AUXILIARY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/assertion_auxiliary.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/assertion__auxiliary_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterutilityassertion_auxiliaryhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/assertion_auxiliary.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/assertion__auxiliary_8hpp/#namespaces","text":"Name openscenario_interpreter::utility openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/assertion__auxiliary_8hpp/#defines","text":"Name ASSERT_DEFAULT_CONSTRUCTIBLE (TYPE)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/assertion__auxiliary_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/assertion__auxiliary_8hpp/#define-assert_default_constructible","text":"#define ASSERT_DEFAULT_CONSTRUCTIBLE( TYPE ) static_assert ( \\ std :: is_default_constructible < TYPE >:: value , \\ \"OpenSCENARIO specification uses type '\" # TYPE \"' as optional element (as minOccurs= \\\" 0 \\\" ), \" \\ \"thus type '\" # TYPE \"' must be met concept DefaultConstructible.\" )","title":"define ASSERT_DEFAULT_CONSTRUCTIBLE"},{"location":"package/openscenario_interpreter/markdown/Files/assertion__auxiliary_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__UTILITY__ASSERTION_AUXILIARY_HPP_ #define OPENSCENARIO_INTERPRETER__UTILITY__ASSERTION_AUXILIARY_HPP_ #include <utility> namespace openscenario_interpreter { inline namespace utility { #define ASSERT_DEFAULT_CONSTRUCTIBLE(TYPE) \\ static_assert( \\ std::is_default_constructible<TYPE>::value, \\ \"OpenSCENARIO specification uses type '\" #TYPE \"' as optional element (as minOccurs=\\\"0\\\"), \" \\ \"thus type '\" #TYPE \"' must be met concept DefaultConstructible.\") } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__UTILITY__ASSERTION_AUXILIARY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/assign__controller__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/assign_controller_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::AssignControllerAction Defines # Name ELEMENT (TYPE) Macro Documentation # define ELEMENT # #define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, outer_scope); \\ }) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ASSIGN_CONTROLLER_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ASSIGN_CONTROLLER_ACTION_HPP_ #include <openscenario_interpreter/syntax/controller.hpp> #include <openscenario_interpreter/procedure.hpp> #include <type_traits> #include <utility> namespace openscenario_interpreter { inline namespace syntax { #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, outer_scope); \\ }) /* ---- AssignControllerAction ------------------------------------------------- * * This action assigns a controller to the given entity defined in the * enclosing PrivateAction. Controllers could be defined inline or by using a * catalog reference. * * <xsd:complexType name=\"AssignControllerAction\"> * <xsd:choice> * <xsd:element name=\"Controller\" type=\"Controller\"/> * <xsd:element name=\"CatalogReference\" type=\"CatalogReference\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct AssignControllerAction : public ComplexType { Scope inner_scope ; template < typename Node > explicit AssignControllerAction ( const Node & node , Scope & outer_scope ) : ComplexType ( choice ( node , ELEMENT ( Controller ), std :: make_pair ( \"CatalogReference\" , UNSUPPORTED ()))), inner_scope ( outer_scope ) {} void operator ()() const { for ( const auto & actor : inner_scope . actors ) { setController ( actor , ( * this ). as < Controller > ()); } } }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ASSIGN_CONTROLLER_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/assign_controller_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/assign__controller__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxassign_controller_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/assign_controller_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/assign__controller__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/assign__controller__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::AssignControllerAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/assign__controller__action_8hpp/#defines","text":"Name ELEMENT (TYPE)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/assign__controller__action_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/assign__controller__action_8hpp/#define-element","text":"#define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, outer_scope); \\ })","title":"define ELEMENT"},{"location":"package/openscenario_interpreter/markdown/Files/assign__controller__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ASSIGN_CONTROLLER_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ASSIGN_CONTROLLER_ACTION_HPP_ #include <openscenario_interpreter/syntax/controller.hpp> #include <openscenario_interpreter/procedure.hpp> #include <type_traits> #include <utility> namespace openscenario_interpreter { inline namespace syntax { #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, outer_scope); \\ }) /* ---- AssignControllerAction ------------------------------------------------- * * This action assigns a controller to the given entity defined in the * enclosing PrivateAction. Controllers could be defined inline or by using a * catalog reference. * * <xsd:complexType name=\"AssignControllerAction\"> * <xsd:choice> * <xsd:element name=\"Controller\" type=\"Controller\"/> * <xsd:element name=\"CatalogReference\" type=\"CatalogReference\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct AssignControllerAction : public ComplexType { Scope inner_scope ; template < typename Node > explicit AssignControllerAction ( const Node & node , Scope & outer_scope ) : ComplexType ( choice ( node , ELEMENT ( Controller ), std :: make_pair ( \"CatalogReference\" , UNSUPPORTED ()))), inner_scope ( outer_scope ) {} void operator ()() const { for ( const auto & actor : inner_scope . actors ) { setController ( actor , ( * this ). as < Controller > ()); } } }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ASSIGN_CONTROLLER_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/assign__route__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/assign_route_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::AssignRouteAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ASSIGN_ROUTE_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ASSIGN_ROUTE_ACTION_HPP_ #include <openscenario_interpreter/syntax/route.hpp> #include <type_traits> #include <unordered_map> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- AssignRouteAction ------------------------------------------------------ * * <xsd:complexType name=\"AssignRouteAction\"> * <xsd:choice> * <xsd:element name=\"Route\" type=\"Route\"/> * <xsd:element name=\"CatalogReference\" type=\"CatalogReference\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct AssignRouteAction { Scope inner_scope ; Element route_or_catalog_reference ; template < typename Node > explicit AssignRouteAction ( const Node & node , Scope & outer_scope ) : inner_scope ( outer_scope ), route_or_catalog_reference ( choice ( node , std :: make_pair ( \"Route\" , [ & ]( auto && node ) { return make < Route > ( node , inner_scope ); }), std :: make_pair ( \"CatalogReference\" , UNSUPPORTED ()))) {} const std :: true_type accomplished {}; decltype ( auto ) operator ()( const Scope :: Actor & actor ) { return requestAssignRoute ( actor , static_cast < std :: vector < openscenario_msgs :: msg :: LaneletPose > > ( route_or_catalog_reference . as < const Route > ())); } auto start () { for ( const auto & actor : inner_scope . actors ) { ( * this )( actor ); } } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ASSIGN_ROUTE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/assign_route_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/assign__route__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxassign_route_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/assign_route_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/assign__route__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/assign__route__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::AssignRouteAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/assign__route__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ASSIGN_ROUTE_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ASSIGN_ROUTE_ACTION_HPP_ #include <openscenario_interpreter/syntax/route.hpp> #include <type_traits> #include <unordered_map> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- AssignRouteAction ------------------------------------------------------ * * <xsd:complexType name=\"AssignRouteAction\"> * <xsd:choice> * <xsd:element name=\"Route\" type=\"Route\"/> * <xsd:element name=\"CatalogReference\" type=\"CatalogReference\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct AssignRouteAction { Scope inner_scope ; Element route_or_catalog_reference ; template < typename Node > explicit AssignRouteAction ( const Node & node , Scope & outer_scope ) : inner_scope ( outer_scope ), route_or_catalog_reference ( choice ( node , std :: make_pair ( \"Route\" , [ & ]( auto && node ) { return make < Route > ( node , inner_scope ); }), std :: make_pair ( \"CatalogReference\" , UNSUPPORTED ()))) {} const std :: true_type accomplished {}; decltype ( auto ) operator ()( const Scope :: Actor & actor ) { return requestAssignRoute ( actor , static_cast < std :: vector < openscenario_msgs :: msg :: LaneletPose > > ( route_or_catalog_reference . as < const Route > ())); } auto start () { for ( const auto & actor : inner_scope . actors ) { ( * this )( actor ); } } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ASSIGN_ROUTE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/attribute_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/attribute.hpp # Namespaces # Name openscenario_interpreter::reader openscenario_interpreter Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__READER__ATTRIBUTE_HPP_ #define OPENSCENARIO_INTERPRETER__READER__ATTRIBUTE_HPP_ #include <ament_index_cpp/get_package_share_directory.hpp> #include <openscenario_interpreter/syntax/parameter_type.hpp> #include <openscenario_interpreter/utility/highlighter.hpp> #include <openscenario_interpreter/utility/pugi_extension.hpp> #include <functional> #include <regex> #include <string> #include <unordered_map> namespace openscenario_interpreter { inline namespace reader { /* ---- Dynamic Configuration -------------------------------------------------- * * See https://design.ros2.org/articles/roslaunch_xml.html#dynamic-configuration * * -------------------------------------------------------------------------- */ template < typename Scope > auto substitute ( std :: string attribute , Scope & scope ) { static const std :: regex substitution_syntax { R \" ( (.*)\\$\\((([\\w-]+)\\s?([^\\)]*))\\)(.*) ) \" }; std :: smatch match {}; while ( std :: regex_match ( attribute , match , substitution_syntax )) { // std::cout << \"match 1: \" << match.str(1) << std::endl; // std::cout << \"match 2: \" << match.str(2) << std::endl; // std::cout << \"match 3: \" << match.str(3) << std::endl; // std::cout << \"match 4: \" << match.str(4) << std::endl; // std::cout << \"match 5: \" << match.str(5) << std::endl; static const std :: unordered_map < std :: string , std :: function < std :: string ( const std :: string & , Scope & ) > > substitutions { { \"find-pkg-share\" , []( auto && package_name , auto && ) { return ament_index_cpp :: get_package_share_directory ( package_name ); } }, { \"var\" , []( auto && name , auto && scope ) -> String { const auto iter { scope . parameters . find ( name ) }; if ( iter != std :: end ( scope . parameters )) { return boost :: lexical_cast < String > ( std :: get < 1 > ( * iter )); } else { return \"\" ; } } }, { \"dirname\" , []( auto && , auto && scope ) { return scope . scenario . parent_path (). string (); } } }; // std::cout << \"Substitute: \" << cyan << attribute << reset << \" => \"; const auto iter { substitutions . find ( match . str ( 3 )) }; if ( iter != std :: end ( substitutions )) { attribute = match . str ( 1 ) + std :: get < 1 > ( * iter )( match . str ( 4 ), scope ) + match . str ( 5 ); } else { std :: stringstream ss {}; ss << \"Unknown substitution '\" << match . str ( 3 ) << \"' specified.\" ; throw SyntaxError ( ss . str ()); } // std::cout << cyan << attribute << reset << std::endl; } return attribute ; } template < typename T , typename Node , typename Scope > T readAttribute ( const std :: string & name , const Node & node , const Scope & scope ) { if ( const auto & attribute { node . attribute ( name . c_str ()) }) { std :: string value { substitute ( attribute . value (), scope ) }; if ( value . empty ()) { #ifndef OPENSCENARIO_INTERPRETER_ALLOW_ATTRIBUTES_TO_BE_BLANK std :: stringstream ss {}; ss << \"Blank is not allowed for the value of attribute \\' \" << name << \" \\' of class \\' \" << node . name () << \" \\' \" ; throw SyntaxError { ss . str ()}; #else return T {}; #endif } else if ( value . front () == '$' ) { const auto iter { scope . parameters . find ( value . substr ( 1 )) }; if ( iter != std :: end ( scope . parameters )) { return boost :: lexical_cast < T > ( boost :: lexical_cast < String > ( cdr ( * iter ))); } else { std :: stringstream ss {}; ss << \"There is no parameter named '\" << value . substr ( 1 ) << \"' (Attribute \\' \" << name ; ss << \" \\' of class \\' \" << node . name () << \" \\' references this parameter)\" ; throw SyntaxError ( ss . str ()); } } else { try { return boost :: lexical_cast < T > ( value ); } catch ( const boost :: bad_lexical_cast & ) { std :: stringstream ss {}; ss << \"Value \\\" \" << value << \" \\\" specified for attribute \\' \" << name ; ss << \" \\' is invalid (Is not value of type \" << typeid ( T ). name () << \")\" ; throw SyntaxError ( ss . str ()); } } } else { std :: stringstream ss {}; ss << \"Required attribute \\' \" << name << \" \\' not specified for class \\' \" << node . name () << \" \\' \" ; throw SyntaxError { ss . str ()}; } } template < typename T , typename Node , typename Scope > T readAttribute ( const std :: string & name , const Node & node , const Scope & scope , T && value ) { if ( node . attribute ( name . c_str ())) { return readAttribute < T > ( name , node , scope ); } else { return value ; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__READER__ATTRIBUTE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/attribute.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/attribute_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterreaderattributehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/attribute.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/attribute_8hpp/#namespaces","text":"Name openscenario_interpreter::reader openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/attribute_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__READER__ATTRIBUTE_HPP_ #define OPENSCENARIO_INTERPRETER__READER__ATTRIBUTE_HPP_ #include <ament_index_cpp/get_package_share_directory.hpp> #include <openscenario_interpreter/syntax/parameter_type.hpp> #include <openscenario_interpreter/utility/highlighter.hpp> #include <openscenario_interpreter/utility/pugi_extension.hpp> #include <functional> #include <regex> #include <string> #include <unordered_map> namespace openscenario_interpreter { inline namespace reader { /* ---- Dynamic Configuration -------------------------------------------------- * * See https://design.ros2.org/articles/roslaunch_xml.html#dynamic-configuration * * -------------------------------------------------------------------------- */ template < typename Scope > auto substitute ( std :: string attribute , Scope & scope ) { static const std :: regex substitution_syntax { R \" ( (.*)\\$\\((([\\w-]+)\\s?([^\\)]*))\\)(.*) ) \" }; std :: smatch match {}; while ( std :: regex_match ( attribute , match , substitution_syntax )) { // std::cout << \"match 1: \" << match.str(1) << std::endl; // std::cout << \"match 2: \" << match.str(2) << std::endl; // std::cout << \"match 3: \" << match.str(3) << std::endl; // std::cout << \"match 4: \" << match.str(4) << std::endl; // std::cout << \"match 5: \" << match.str(5) << std::endl; static const std :: unordered_map < std :: string , std :: function < std :: string ( const std :: string & , Scope & ) > > substitutions { { \"find-pkg-share\" , []( auto && package_name , auto && ) { return ament_index_cpp :: get_package_share_directory ( package_name ); } }, { \"var\" , []( auto && name , auto && scope ) -> String { const auto iter { scope . parameters . find ( name ) }; if ( iter != std :: end ( scope . parameters )) { return boost :: lexical_cast < String > ( std :: get < 1 > ( * iter )); } else { return \"\" ; } } }, { \"dirname\" , []( auto && , auto && scope ) { return scope . scenario . parent_path (). string (); } } }; // std::cout << \"Substitute: \" << cyan << attribute << reset << \" => \"; const auto iter { substitutions . find ( match . str ( 3 )) }; if ( iter != std :: end ( substitutions )) { attribute = match . str ( 1 ) + std :: get < 1 > ( * iter )( match . str ( 4 ), scope ) + match . str ( 5 ); } else { std :: stringstream ss {}; ss << \"Unknown substitution '\" << match . str ( 3 ) << \"' specified.\" ; throw SyntaxError ( ss . str ()); } // std::cout << cyan << attribute << reset << std::endl; } return attribute ; } template < typename T , typename Node , typename Scope > T readAttribute ( const std :: string & name , const Node & node , const Scope & scope ) { if ( const auto & attribute { node . attribute ( name . c_str ()) }) { std :: string value { substitute ( attribute . value (), scope ) }; if ( value . empty ()) { #ifndef OPENSCENARIO_INTERPRETER_ALLOW_ATTRIBUTES_TO_BE_BLANK std :: stringstream ss {}; ss << \"Blank is not allowed for the value of attribute \\' \" << name << \" \\' of class \\' \" << node . name () << \" \\' \" ; throw SyntaxError { ss . str ()}; #else return T {}; #endif } else if ( value . front () == '$' ) { const auto iter { scope . parameters . find ( value . substr ( 1 )) }; if ( iter != std :: end ( scope . parameters )) { return boost :: lexical_cast < T > ( boost :: lexical_cast < String > ( cdr ( * iter ))); } else { std :: stringstream ss {}; ss << \"There is no parameter named '\" << value . substr ( 1 ) << \"' (Attribute \\' \" << name ; ss << \" \\' of class \\' \" << node . name () << \" \\' references this parameter)\" ; throw SyntaxError ( ss . str ()); } } else { try { return boost :: lexical_cast < T > ( value ); } catch ( const boost :: bad_lexical_cast & ) { std :: stringstream ss {}; ss << \"Value \\\" \" << value << \" \\\" specified for attribute \\' \" << name ; ss << \" \\' is invalid (Is not value of type \" << typeid ( T ). name () << \")\" ; throw SyntaxError ( ss . str ()); } } } else { std :: stringstream ss {}; ss << \"Required attribute \\' \" << name << \" \\' not specified for class \\' \" << node . name () << \" \\' \" ; throw SyntaxError { ss . str ()}; } } template < typename T , typename Node , typename Scope > T readAttribute ( const std :: string & name , const Node & node , const Scope & scope , T && value ) { if ( node . attribute ( name . c_str ())) { return readAttribute < T > ( name , node , scope ); } else { return value ; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__READER__ATTRIBUTE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/axle_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/axle.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::RearAxle struct openscenario_interpreter::syntax::FrontAxle struct openscenario_interpreter::syntax::Axle struct openscenario_interpreter::syntax::AdditionalAxle Defines # Name BOILERPLATE (TYPENAME) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( TYPENAME ) template < typename ... Ts > \\ std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const TYPENAME & rhs ) \\ { \\ return os << indent << blue << \"<\" # TYPENAME << \" \" << \\ highlight ( \"maxSteering\" , rhs . max_steering ) \\ << \" \" << highlight ( \"wheelDiameter\" , rhs . wheel_diameter ) \\ << \" \" << highlight ( \"trackWidth\" , rhs . track_width ) \\ << \" \" << highlight ( \"positionX\" , rhs . position_x ) \\ << \" \" << highlight ( \"positionZ\" , rhs . position_z ) << blue << \"/>\" << reset ; \\ } \\ static_assert ( true , \"\" ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__AXLE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__AXLE_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/reader/element.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Axle ================================================================= * * <xsd:complexType name=\"Axle\"> * <xsd:attribute name=\"maxSteering\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"wheelDiameter\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"trackWidth\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"positionX\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"positionZ\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Axle { const Double max_steering , wheel_diameter , track_width , position_x , position_z ; Axle () = default ; template < typename Node , typename Scope > explicit Axle ( const Node & node , Scope & scope ) : max_steering { readAttribute < Double > ( \"maxSteering\" , node , scope )}, wheel_diameter { readAttribute < Double > ( \"wheelDiameter\" , node , scope )}, track_width { readAttribute < Double > ( \"trackWidth\" , node , scope )}, position_x { readAttribute < Double > ( \"positionX\" , node , scope )}, position_z { readAttribute < Double > ( \"positionZ\" , node , scope )} {} }; #define BOILERPLATE(TYPENAME) \\ template<typename ... Ts> \\ std::basic_ostream<Ts...> & operator<<(std::basic_ostream<Ts...> & os, const TYPENAME & rhs) \\ { \\ return os << indent << blue << \"<\" #TYPENAME << \" \" << \\ highlight(\"maxSteering\", rhs.max_steering) \\ << \" \" << highlight(\"wheelDiameter\", rhs.wheel_diameter) \\ << \" \" << highlight(\"trackWidth\", rhs.track_width) \\ << \" \" << highlight(\"positionX\", rhs.position_x) \\ << \" \" << highlight(\"positionZ\", rhs.position_z) << blue << \"/>\" << reset; \\ } \\ static_assert(true, \"\") BOILERPLATE ( Axle ); // NOTE: DON'T REWRITE THIS STRUCT LIKE `using FrontAxle = Axle` (for Clang) struct FrontAxle : public Axle { using Axle :: Axle ; }; BOILERPLATE ( FrontAxle ); // NOTE: DON'T REWRITE THIS STRUCT LIKE `using RearAxle = Axle` (for Clang) struct RearAxle : public Axle { using Axle :: Axle ; }; BOILERPLATE ( RearAxle ); // NOTE: DON'T REWRITE THIS STRUCT LIKE `using AdditionalAxle = Axle` (for Clang) struct AdditionalAxle : public Axle { using Axle :: Axle ; }; BOILERPLATE ( AdditionalAxle ); #undef BOILERPLATE } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__AXLE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/axle.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/axle_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxaxlehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/axle.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/axle_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/axle_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::RearAxle struct openscenario_interpreter::syntax::FrontAxle struct openscenario_interpreter::syntax::Axle struct openscenario_interpreter::syntax::AdditionalAxle","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/axle_8hpp/#defines","text":"Name BOILERPLATE (TYPENAME)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/axle_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/axle_8hpp/#define-boilerplate","text":"#define BOILERPLATE( TYPENAME ) template < typename ... Ts > \\ std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const TYPENAME & rhs ) \\ { \\ return os << indent << blue << \"<\" # TYPENAME << \" \" << \\ highlight ( \"maxSteering\" , rhs . max_steering ) \\ << \" \" << highlight ( \"wheelDiameter\" , rhs . wheel_diameter ) \\ << \" \" << highlight ( \"trackWidth\" , rhs . track_width ) \\ << \" \" << highlight ( \"positionX\" , rhs . position_x ) \\ << \" \" << highlight ( \"positionZ\" , rhs . position_z ) << blue << \"/>\" << reset ; \\ } \\ static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/axle_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__AXLE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__AXLE_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/reader/element.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Axle ================================================================= * * <xsd:complexType name=\"Axle\"> * <xsd:attribute name=\"maxSteering\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"wheelDiameter\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"trackWidth\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"positionX\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"positionZ\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Axle { const Double max_steering , wheel_diameter , track_width , position_x , position_z ; Axle () = default ; template < typename Node , typename Scope > explicit Axle ( const Node & node , Scope & scope ) : max_steering { readAttribute < Double > ( \"maxSteering\" , node , scope )}, wheel_diameter { readAttribute < Double > ( \"wheelDiameter\" , node , scope )}, track_width { readAttribute < Double > ( \"trackWidth\" , node , scope )}, position_x { readAttribute < Double > ( \"positionX\" , node , scope )}, position_z { readAttribute < Double > ( \"positionZ\" , node , scope )} {} }; #define BOILERPLATE(TYPENAME) \\ template<typename ... Ts> \\ std::basic_ostream<Ts...> & operator<<(std::basic_ostream<Ts...> & os, const TYPENAME & rhs) \\ { \\ return os << indent << blue << \"<\" #TYPENAME << \" \" << \\ highlight(\"maxSteering\", rhs.max_steering) \\ << \" \" << highlight(\"wheelDiameter\", rhs.wheel_diameter) \\ << \" \" << highlight(\"trackWidth\", rhs.track_width) \\ << \" \" << highlight(\"positionX\", rhs.position_x) \\ << \" \" << highlight(\"positionZ\", rhs.position_z) << blue << \"/>\" << reset; \\ } \\ static_assert(true, \"\") BOILERPLATE ( Axle ); // NOTE: DON'T REWRITE THIS STRUCT LIKE `using FrontAxle = Axle` (for Clang) struct FrontAxle : public Axle { using Axle :: Axle ; }; BOILERPLATE ( FrontAxle ); // NOTE: DON'T REWRITE THIS STRUCT LIKE `using RearAxle = Axle` (for Clang) struct RearAxle : public Axle { using Axle :: Axle ; }; BOILERPLATE ( RearAxle ); // NOTE: DON'T REWRITE THIS STRUCT LIKE `using AdditionalAxle = Axle` (for Clang) struct AdditionalAxle : public Axle { using Axle :: Axle ; }; BOILERPLATE ( AdditionalAxle ); #undef BOILERPLATE } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__AXLE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/axles_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/axles.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Axles Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__AXLES_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__AXLES_HPP_ #include <openscenario_interpreter/syntax/axle.hpp> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ==== Axles ================================================================ * * <xsd:complexType name=\"Axles\"> * <xsd:sequence> * <xsd:element name=\"FrontAxle\" type=\"Axle\"/> * <xsd:element name=\"RearAxle\" type=\"Axle\"/> * <xsd:element name=\"AdditionalAxle\" type=\"Axle\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> * </xsd:sequence> * </xsd:complexType> * * ======================================================================== */ struct Axles { const FrontAxle front_axle ; const RearAxle rear_axle ; std :: vector < AdditionalAxle > additional_axles ; Axles () = default ; template < typename Node , typename Scope > explicit Axles ( const Node & node , Scope & scope ) : front_axle { readElement < FrontAxle > ( \"FrontAxle\" , node , scope )}, rear_axle { readElement < RearAxle > ( \"RearAxle\" , node , scope )} { callWithElements ( node , \"AdditionalAxle\" , 0 , unbounded , [ & ]( auto && node ) { additional_axles . emplace_back ( node , scope ); }); } }; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Axles & rhs ) { os << ( indent ++ ) << blue << \"<Axles> \\n \" << reset << rhs . front_axle << \" \\n \" << rhs . rear_axle << \" \\n \" ; for ( const auto & each : rhs . additional_axles ) { os << each << \" \\n \" ; } return os << ( -- indent ) << blue << \"</Axles>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__AXLES_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/axles.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/axles_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxaxleshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/axles.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/axles_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/axles_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Axles","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/axles_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__AXLES_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__AXLES_HPP_ #include <openscenario_interpreter/syntax/axle.hpp> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ==== Axles ================================================================ * * <xsd:complexType name=\"Axles\"> * <xsd:sequence> * <xsd:element name=\"FrontAxle\" type=\"Axle\"/> * <xsd:element name=\"RearAxle\" type=\"Axle\"/> * <xsd:element name=\"AdditionalAxle\" type=\"Axle\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> * </xsd:sequence> * </xsd:complexType> * * ======================================================================== */ struct Axles { const FrontAxle front_axle ; const RearAxle rear_axle ; std :: vector < AdditionalAxle > additional_axles ; Axles () = default ; template < typename Node , typename Scope > explicit Axles ( const Node & node , Scope & scope ) : front_axle { readElement < FrontAxle > ( \"FrontAxle\" , node , scope )}, rear_axle { readElement < RearAxle > ( \"RearAxle\" , node , scope )} { callWithElements ( node , \"AdditionalAxle\" , 0 , unbounded , [ & ]( auto && node ) { additional_axles . emplace_back ( node , scope ); }); } }; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Axles & rhs ) { os << ( indent ++ ) << blue << \"<Axles> \\n \" << reset << rhs . front_axle << \" \\n \" << rhs . rear_axle << \" \\n \" ; for ( const auto & each : rhs . additional_axles ) { os << each << \" \\n \" ; } return os << ( -- indent ) << blue << \"</Axles>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__AXLES_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/boolean_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/boolean.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Boolean Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__BOOLEAN_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__BOOLEAN_HPP_ #include <boost/io/ios_state.hpp> #include <openscenario_interpreter/object.hpp> #include <iomanip> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ---- Boolean ---------------------------------------------------------------- * * * -------------------------------------------------------------------------- */ struct Boolean { using value_type = bool ; value_type data ; explicit constexpr Boolean ( value_type value = false ) noexcept : data { value } {} explicit Boolean ( const std :: string & target ) { std :: stringstream interpreter {}; if ( ! ( interpreter << target && interpreter >> std :: boolalpha >> data )) { std :: stringstream ss {}; ss << \"can't treat value \" << std :: quoted ( target ) << \" as type Boolean\" ; throw SyntaxError { ss . str ()}; } } auto & operator = ( const value_type & rhs ) noexcept { data = rhs ; return * this ; } constexpr operator value_type () const noexcept { return data ; } }; std :: ostream & operator << ( std :: ostream & os , const Boolean & boolean ) { boost :: io :: ios_flags_saver saver { os }; return os << std :: boolalpha << boolean . data ; } std :: istream & operator >> ( std :: istream & is , Boolean & boolean ) { boost :: io :: ios_flags_saver saver { is }; return is >> std :: boolalpha >> boolean . data ; } static const auto true_v = make < Boolean > ( true ); static const auto false_v = make < Boolean > ( false ); auto asBoolean ( bool value ) { return value ? true_v : false_v ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__BOOLEAN_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/boolean.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/boolean_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxbooleanhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/boolean.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/boolean_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/boolean_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Boolean","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/boolean_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__BOOLEAN_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__BOOLEAN_HPP_ #include <boost/io/ios_state.hpp> #include <openscenario_interpreter/object.hpp> #include <iomanip> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ---- Boolean ---------------------------------------------------------------- * * * -------------------------------------------------------------------------- */ struct Boolean { using value_type = bool ; value_type data ; explicit constexpr Boolean ( value_type value = false ) noexcept : data { value } {} explicit Boolean ( const std :: string & target ) { std :: stringstream interpreter {}; if ( ! ( interpreter << target && interpreter >> std :: boolalpha >> data )) { std :: stringstream ss {}; ss << \"can't treat value \" << std :: quoted ( target ) << \" as type Boolean\" ; throw SyntaxError { ss . str ()}; } } auto & operator = ( const value_type & rhs ) noexcept { data = rhs ; return * this ; } constexpr operator value_type () const noexcept { return data ; } }; std :: ostream & operator << ( std :: ostream & os , const Boolean & boolean ) { boost :: io :: ios_flags_saver saver { os }; return os << std :: boolalpha << boolean . data ; } std :: istream & operator >> ( std :: istream & is , Boolean & boolean ) { boost :: io :: ios_flags_saver saver { is }; return is >> std :: boolalpha >> boolean . data ; } static const auto true_v = make < Boolean > ( true ); static const auto false_v = make < Boolean > ( false ); auto asBoolean ( bool value ) { return value ? true_v : false_v ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__BOOLEAN_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/bounding__box_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/bounding_box.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::BoundingBox Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__BOUNDING_BOX_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__BOUNDING_BOX_HPP_ #include <openscenario_interpreter/syntax/center.hpp> #include <openscenario_interpreter/syntax/dimensions.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== BoundingBox ========================================================== * * <xsd:complexType name=\"BoundingBox\"> * <xsd:all> * <xsd:element name=\"Center\" type=\"Center\"/> * <xsd:element name=\"Dimensions\" type=\"Dimensions\"/> * </xsd:all> * </xsd:complexType> * * ======================================================================== */ struct BoundingBox { const Center center ; const Dimensions dimensions ; BoundingBox () = default ; template < typename Node , typename Scope > explicit BoundingBox ( const Node & node , Scope & scope ) : center { readElement < Center > ( \"Center\" , node , scope )}, dimensions { readElement < Dimensions > ( \"Dimensions\" , node , scope )} {} }; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const BoundingBox & rhs ) { return os << ( indent ++ ) << blue << \"<BoundingBox> \\n \" << reset << rhs . center << \" \\n \" << rhs . dimensions << \" \\n \" << ( -- indent ) << blue << \"</BoundingBox>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__BOUNDING_BOX_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/bounding_box.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/bounding__box_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxbounding_boxhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/bounding_box.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/bounding__box_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/bounding__box_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::BoundingBox","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/bounding__box_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__BOUNDING_BOX_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__BOUNDING_BOX_HPP_ #include <openscenario_interpreter/syntax/center.hpp> #include <openscenario_interpreter/syntax/dimensions.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== BoundingBox ========================================================== * * <xsd:complexType name=\"BoundingBox\"> * <xsd:all> * <xsd:element name=\"Center\" type=\"Center\"/> * <xsd:element name=\"Dimensions\" type=\"Dimensions\"/> * </xsd:all> * </xsd:complexType> * * ======================================================================== */ struct BoundingBox { const Center center ; const Dimensions dimensions ; BoundingBox () = default ; template < typename Node , typename Scope > explicit BoundingBox ( const Node & node , Scope & scope ) : center { readElement < Center > ( \"Center\" , node , scope )}, dimensions { readElement < Dimensions > ( \"Dimensions\" , node , scope )} {} }; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const BoundingBox & rhs ) { return os << ( indent ++ ) << blue << \"<BoundingBox> \\n \" << reset << rhs . center << \" \\n \" << rhs . dimensions << \" \\n \" << ( -- indent ) << blue << \"</BoundingBox>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__BOUNDING_BOX_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/by__entity__condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_entity_condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ByEntityCondition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__BY_ENTITY_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__BY_ENTITY_CONDITION_HPP_ #include <openscenario_interpreter/syntax/entity_condition.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ByEntityCondition ------------------------------------------------------ * * <xsd:complexType name=\"ByEntityCondition\"> * <xsd:all> * <xsd:element name=\"TriggeringEntities\" type=\"TriggeringEntities\"/> * <xsd:element name=\"EntityCondition\" type=\"EntityCondition\"/> * </xsd:all> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ByEntityCondition { Scope inner_scope ; const EntityCondition entity_condition ; template < typename Node > explicit ByEntityCondition ( const Node & node , Scope & outer_scope ) : inner_scope ( outer_scope ), entity_condition ( readElement < EntityCondition > ( \"EntityCondition\" , node , inner_scope , readElement < TriggeringEntities > ( \"TriggeringEntities\" , node , inner_scope ))) {} template < typename ... Ts > auto evaluate ( Ts && ... xs ) const { return entity_condition . evaluate ( std :: forward < decltype ( xs ) > ( xs )...); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__BY_ENTITY_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_entity_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/by__entity__condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxby_entity_conditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_entity_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/by__entity__condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/by__entity__condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ByEntityCondition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/by__entity__condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__BY_ENTITY_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__BY_ENTITY_CONDITION_HPP_ #include <openscenario_interpreter/syntax/entity_condition.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ByEntityCondition ------------------------------------------------------ * * <xsd:complexType name=\"ByEntityCondition\"> * <xsd:all> * <xsd:element name=\"TriggeringEntities\" type=\"TriggeringEntities\"/> * <xsd:element name=\"EntityCondition\" type=\"EntityCondition\"/> * </xsd:all> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ByEntityCondition { Scope inner_scope ; const EntityCondition entity_condition ; template < typename Node > explicit ByEntityCondition ( const Node & node , Scope & outer_scope ) : inner_scope ( outer_scope ), entity_condition ( readElement < EntityCondition > ( \"EntityCondition\" , node , inner_scope , readElement < TriggeringEntities > ( \"TriggeringEntities\" , node , inner_scope ))) {} template < typename ... Ts > auto evaluate ( Ts && ... xs ) const { return entity_condition . evaluate ( std :: forward < decltype ( xs ) > ( xs )...); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__BY_ENTITY_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/by__type_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_type.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ByType Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__BY_TYPE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__BY_TYPE_HPP_ #include <openscenario_interpreter/syntax/object_type.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== ByType =============================================================== * * <xsd:complexType name=\"ByType\"> * <xsd:attribute name=\"objectType\" type=\"ObjectType\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct ByType {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__BY_TYPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_type.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/by__type_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxby_typehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_type.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/by__type_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/by__type_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ByType","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/by__type_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__BY_TYPE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__BY_TYPE_HPP_ #include <openscenario_interpreter/syntax/object_type.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== ByType =============================================================== * * <xsd:complexType name=\"ByType\"> * <xsd:attribute name=\"objectType\" type=\"ObjectType\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct ByType {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__BY_TYPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/by__value__condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_value_condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ByValueCondition Defines # Name ELEMENT (TYPE) Macro Documentation # define ELEMENT # #define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__BY_VALUE_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__BY_VALUE_CONDITION_HPP_ #include <openscenario_interpreter/syntax/simulation_time_condition.hpp> #include <openscenario_interpreter/syntax/storyboard_element_state_condition.hpp> #include <openscenario_interpreter/syntax/traffic_signal_condition.hpp> #include <openscenario_interpreter/syntax/parameter_condition.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ByValueCondition ------------------------------------------------------- * * <xsd:complexType name=\"ByValueCondition\"> * <xsd:choice> * <xsd:element name=\"ParameterCondition\" type=\"ParameterCondition\"/> * <xsd:element name=\"TimeOfDayCondition\" type=\"TimeOfDayCondition\"/> * <xsd:element name=\"SimulationTimeCondition\" type=\"SimulationTimeCondition\"/> * <xsd:element name=\"StoryboardElementStateCondition\" type=\"StoryboardElementStateCondition\"/> * <xsd:element name=\"UserDefinedValueCondition\" type=\"UserDefinedValueCondition\"/> * <xsd:element name=\"TrafficSignalCondition\" type=\"TrafficSignalCondition\"/> * <xsd:element name=\"TrafficSignalControllerCondition\" type=\"TrafficSignalControllerCondition\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) struct ByValueCondition : public Element { template < typename Node , typename ... Ts > explicit ByValueCondition ( const Node & node , Ts && ... xs ) : Element ( choice ( node , ELEMENT ( ParameterCondition ), std :: make_pair ( \"TimeOfDayCondition\" , UNSUPPORTED ()), ELEMENT ( SimulationTimeCondition ), ELEMENT ( StoryboardElementStateCondition ), std :: make_pair ( \"UserDefinedValueCondition\" , UNSUPPORTED ()), ELEMENT ( TrafficSignalCondition ), std :: make_pair ( \"TrafficSignalControllerCondition\" , UNSUPPORTED ()))) {} }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__BY_VALUE_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_value_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/by__value__condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxby_value_conditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_value_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/by__value__condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/by__value__condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ByValueCondition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/by__value__condition_8hpp/#defines","text":"Name ELEMENT (TYPE)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/by__value__condition_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/by__value__condition_8hpp/#define-element","text":"#define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ })","title":"define ELEMENT"},{"location":"package/openscenario_interpreter/markdown/Files/by__value__condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__BY_VALUE_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__BY_VALUE_CONDITION_HPP_ #include <openscenario_interpreter/syntax/simulation_time_condition.hpp> #include <openscenario_interpreter/syntax/storyboard_element_state_condition.hpp> #include <openscenario_interpreter/syntax/traffic_signal_condition.hpp> #include <openscenario_interpreter/syntax/parameter_condition.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ByValueCondition ------------------------------------------------------- * * <xsd:complexType name=\"ByValueCondition\"> * <xsd:choice> * <xsd:element name=\"ParameterCondition\" type=\"ParameterCondition\"/> * <xsd:element name=\"TimeOfDayCondition\" type=\"TimeOfDayCondition\"/> * <xsd:element name=\"SimulationTimeCondition\" type=\"SimulationTimeCondition\"/> * <xsd:element name=\"StoryboardElementStateCondition\" type=\"StoryboardElementStateCondition\"/> * <xsd:element name=\"UserDefinedValueCondition\" type=\"UserDefinedValueCondition\"/> * <xsd:element name=\"TrafficSignalCondition\" type=\"TrafficSignalCondition\"/> * <xsd:element name=\"TrafficSignalControllerCondition\" type=\"TrafficSignalControllerCondition\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) struct ByValueCondition : public Element { template < typename Node , typename ... Ts > explicit ByValueCondition ( const Node & node , Ts && ... xs ) : Element ( choice ( node , ELEMENT ( ParameterCondition ), std :: make_pair ( \"TimeOfDayCondition\" , UNSUPPORTED ()), ELEMENT ( SimulationTimeCondition ), ELEMENT ( StoryboardElementStateCondition ), std :: make_pair ( \"UserDefinedValueCondition\" , UNSUPPORTED ()), ELEMENT ( TrafficSignalCondition ), std :: make_pair ( \"TrafficSignalControllerCondition\" , UNSUPPORTED ()))) {} }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__BY_VALUE_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/cat_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string/cat.hpp # Namespaces # Name openscenario_interpreter::string openscenario_interpreter Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__STRING__CAT_HPP_ #define OPENSCENARIO_INTERPRETER__STRING__CAT_HPP_ #include <openscenario_interpreter/functional/fold.hpp> #include <sstream> #include <string> #include <utility> namespace openscenario_interpreter { inline namespace string { auto cat = []( auto && ... xs ) { std :: stringstream ss {}; auto write = []( auto && os , auto && x ) { os . get () << x ; return std :: forward < decltype ( os ) > ( os ); }; fold_left ( write , std :: ref ( ss ), std :: forward < decltype ( xs ) > ( xs )...); return ss . str (); }; } // namespace string } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__STRING__CAT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string/cat.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/cat_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterstringcathpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string/cat.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/cat_8hpp/#namespaces","text":"Name openscenario_interpreter::string openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/cat_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__STRING__CAT_HPP_ #define OPENSCENARIO_INTERPRETER__STRING__CAT_HPP_ #include <openscenario_interpreter/functional/fold.hpp> #include <sstream> #include <string> #include <utility> namespace openscenario_interpreter { inline namespace string { auto cat = []( auto && ... xs ) { std :: stringstream ss {}; auto write = []( auto && os , auto && x ) { os . get () << x ; return std :: forward < decltype ( os ) > ( os ); }; fold_left ( write , std :: ref ( ss ), std :: forward < decltype ( xs ) > ( xs )...); return ss . str (); }; } // namespace string } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__STRING__CAT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/catalog__location_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/catalog_location.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::CatalogLocation Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CATALOG_LOCATION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CATALOG_LOCATION_HPP_ #include <openscenario_interpreter/reader/element.hpp> #include <openscenario_interpreter/syntax/directory.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== CatalogLocation ====================================================== * * <xsd:complexType name=\"VehicleCatalogLocation\"> * <xsd:all> * <xsd:element name=\"Directory\" type=\"Directory\"/> * </xsd:all> * </xsd:complexType> * * ======================================================================== */ struct CatalogLocation { const Directory directory ; template < typename Node , typename Scope > explicit CatalogLocation ( const Node & node , Scope & outer_scope ) : directory { readElement < Directory > ( \"Directory\" , node , outer_scope )} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CATALOG_LOCATION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/catalog_location.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/catalog__location_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxcatalog_locationhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/catalog_location.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/catalog__location_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/catalog__location_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::CatalogLocation","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/catalog__location_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CATALOG_LOCATION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CATALOG_LOCATION_HPP_ #include <openscenario_interpreter/reader/element.hpp> #include <openscenario_interpreter/syntax/directory.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== CatalogLocation ====================================================== * * <xsd:complexType name=\"VehicleCatalogLocation\"> * <xsd:all> * <xsd:element name=\"Directory\" type=\"Directory\"/> * </xsd:all> * </xsd:complexType> * * ======================================================================== */ struct CatalogLocation { const Directory directory ; template < typename Node , typename Scope > explicit CatalogLocation ( const Node & node , Scope & outer_scope ) : directory { readElement < Directory > ( \"Directory\" , node , outer_scope )} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CATALOG_LOCATION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/catalog__locations_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/catalog_locations.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::CatalogLocations Defines # Name ELEMENT (TYPE) Macro Documentation # define ELEMENT # #define ELEMENT( TYPE ) callWithElements ( \\ node , # TYPE \"Catalog\" , 0 , 1 , [ & ]( auto && node ) \\ { \\ return emplace ( # TYPE \"Catalog\" , CatalogLocation ( node , outer_scope )); \\ }) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CATALOG_LOCATIONS_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CATALOG_LOCATIONS_HPP_ #include <openscenario_interpreter/syntax/catalog_location.hpp> #include <unordered_map> namespace openscenario_interpreter { inline namespace syntax { /* ---- CatalogLocations ------------------------------------------------------- * * <xsd:complexType name=\"CatalogLocations\"> * <xsd:all> * <xsd:element name=\"VehicleCatalog\" minOccurs=\"0\" type=\"VehicleCatalogLocation\"/> * <xsd:element name=\"ControllerCatalog\" minOccurs=\"0\" type=\"ControllerCatalogLocation\"/> * <xsd:element name=\"PedestrianCatalog\" minOccurs=\"0\" type=\"PedestrianCatalogLocation\"/> * <xsd:element name=\"MiscObjectCatalog\" minOccurs=\"0\" type=\"MiscObjectCatalogLocation\"/> * <xsd:element name=\"EnvironmentCatalog\" minOccurs=\"0\" type=\"EnvironmentCatalogLocation\"/> * <xsd:element name=\"ManeuverCatalog\" minOccurs=\"0\" type=\"ManeuverCatalogLocation\"/> * <xsd:element name=\"TrajectoryCatalog\" minOccurs=\"0\" type=\"TrajectoryCatalogLocation\"/> * <xsd:element name=\"RouteCatalog\" minOccurs=\"0\" type=\"RouteCatalogLocation\"/> * </xsd:all> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ callWithElements( \\ node, #TYPE \"Catalog\", 0, 1, [&](auto && node) \\ { \\ return emplace(#TYPE \"Catalog\", CatalogLocation(node, outer_scope)); \\ }) struct CatalogLocations : public std :: unordered_map < String , CatalogLocation > { template < typename Node , typename Scope > explicit CatalogLocations ( const Node & node , Scope & outer_scope ) { ELEMENT ( Vehicle ); ELEMENT ( Controller ); ELEMENT ( Pedestrian ); ELEMENT ( MiscObject ); ELEMENT ( Environment ); ELEMENT ( Maneuver ); ELEMENT ( Trajectory ); ELEMENT ( Route ); } }; #undef ELEMENT } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CATALOG_LOCATIONS_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/catalog_locations.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/catalog__locations_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxcatalog_locationshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/catalog_locations.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/catalog__locations_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/catalog__locations_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::CatalogLocations","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/catalog__locations_8hpp/#defines","text":"Name ELEMENT (TYPE)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/catalog__locations_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/catalog__locations_8hpp/#define-element","text":"#define ELEMENT( TYPE ) callWithElements ( \\ node , # TYPE \"Catalog\" , 0 , 1 , [ & ]( auto && node ) \\ { \\ return emplace ( # TYPE \"Catalog\" , CatalogLocation ( node , outer_scope )); \\ })","title":"define ELEMENT"},{"location":"package/openscenario_interpreter/markdown/Files/catalog__locations_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CATALOG_LOCATIONS_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CATALOG_LOCATIONS_HPP_ #include <openscenario_interpreter/syntax/catalog_location.hpp> #include <unordered_map> namespace openscenario_interpreter { inline namespace syntax { /* ---- CatalogLocations ------------------------------------------------------- * * <xsd:complexType name=\"CatalogLocations\"> * <xsd:all> * <xsd:element name=\"VehicleCatalog\" minOccurs=\"0\" type=\"VehicleCatalogLocation\"/> * <xsd:element name=\"ControllerCatalog\" minOccurs=\"0\" type=\"ControllerCatalogLocation\"/> * <xsd:element name=\"PedestrianCatalog\" minOccurs=\"0\" type=\"PedestrianCatalogLocation\"/> * <xsd:element name=\"MiscObjectCatalog\" minOccurs=\"0\" type=\"MiscObjectCatalogLocation\"/> * <xsd:element name=\"EnvironmentCatalog\" minOccurs=\"0\" type=\"EnvironmentCatalogLocation\"/> * <xsd:element name=\"ManeuverCatalog\" minOccurs=\"0\" type=\"ManeuverCatalogLocation\"/> * <xsd:element name=\"TrajectoryCatalog\" minOccurs=\"0\" type=\"TrajectoryCatalogLocation\"/> * <xsd:element name=\"RouteCatalog\" minOccurs=\"0\" type=\"RouteCatalogLocation\"/> * </xsd:all> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ callWithElements( \\ node, #TYPE \"Catalog\", 0, 1, [&](auto && node) \\ { \\ return emplace(#TYPE \"Catalog\", CatalogLocation(node, outer_scope)); \\ }) struct CatalogLocations : public std :: unordered_map < String , CatalogLocation > { template < typename Node , typename Scope > explicit CatalogLocations ( const Node & node , Scope & outer_scope ) { ELEMENT ( Vehicle ); ELEMENT ( Controller ); ELEMENT ( Pedestrian ); ELEMENT ( MiscObject ); ELEMENT ( Environment ); ELEMENT ( Maneuver ); ELEMENT ( Trajectory ); ELEMENT ( Route ); } }; #undef ELEMENT } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CATALOG_LOCATIONS_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/center_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/center.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Center Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CENTER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CENTER_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/reader/element.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Center =============================================================== * * <xsd:complexType name=\"Center\"> * <xsd:attribute name=\"x\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"y\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"z\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Center { const Double x , y , z ; Center () = default ; template < typename Node , typename Scope > explicit Center ( const Node & node , Scope & scope ) : x { readAttribute < Double > ( \"x\" , node , scope )}, y { readAttribute < Double > ( \"y\" , node , scope )}, z { readAttribute < Double > ( \"z\" , node , scope )} {} }; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Center & rhs ) { return os << indent << blue << \"<Center\" << \" \" << highlight ( \"x\" , rhs . x ) << \" \" << highlight ( \"y\" , rhs . y ) << \" \" << highlight ( \"z\" , rhs . z ) << blue << \"/>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CENTER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/center.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/center_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxcenterhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/center.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/center_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/center_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Center","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/center_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CENTER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CENTER_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/reader/element.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Center =============================================================== * * <xsd:complexType name=\"Center\"> * <xsd:attribute name=\"x\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"y\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"z\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Center { const Double x , y , z ; Center () = default ; template < typename Node , typename Scope > explicit Center ( const Node & node , Scope & scope ) : x { readAttribute < Double > ( \"x\" , node , scope )}, y { readAttribute < Double > ( \"y\" , node , scope )}, z { readAttribute < Double > ( \"z\" , node , scope )} {} }; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Center & rhs ) { return os << indent << blue << \"<Center\" << \" \" << highlight ( \"x\" , rhs . x ) << \" \" << highlight ( \"y\" , rhs . y ) << \" \" << highlight ( \"z\" , rhs . z ) << blue << \"/>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CENTER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/collision__condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/collision_condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::CollisionCondition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__COLLISION_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__COLLISION_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/entity_ref.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- CollisionCondition ----------------------------------------------------- * * Condition becomes true when the triggering entity/entities collide with * another given entity or any entity of a specific type. * * <xsd:complexType name=\"CollisionCondition\"> * <xsd:choice> * <xsd:element name=\"EntityRef\" type=\"EntityRef\"/> * <xsd:element name=\"ByType\" type=\"ByObjectType\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct CollisionCondition { const Element given ; const TriggeringEntities for_each ; template < typename Node , typename Scope > explicit CollisionCondition ( const Node & node , Scope & scope , const TriggeringEntities & triggering_entities ) : given ( choice ( node , std :: make_pair ( \"EntityRef\" , [ & ]( auto && node ) { return make < EntityRef > ( node , scope ); }), std :: make_pair ( \"ByType\" , UNSUPPORTED ()))), for_each ( triggering_entities ) {} auto evaluate () const noexcept { if ( given . is < EntityRef > ()) { return asBoolean ( for_each ( [ & ]( auto && triggering_entity ) { return checkCollision ( triggering_entity , given . as < EntityRef > ()); })); } else { return false_v ; } } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__COLLISION_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/collision_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/collision__condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxcollision_conditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/collision_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/collision__condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/collision__condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::CollisionCondition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/collision__condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__COLLISION_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__COLLISION_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/entity_ref.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- CollisionCondition ----------------------------------------------------- * * Condition becomes true when the triggering entity/entities collide with * another given entity or any entity of a specific type. * * <xsd:complexType name=\"CollisionCondition\"> * <xsd:choice> * <xsd:element name=\"EntityRef\" type=\"EntityRef\"/> * <xsd:element name=\"ByType\" type=\"ByObjectType\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct CollisionCondition { const Element given ; const TriggeringEntities for_each ; template < typename Node , typename Scope > explicit CollisionCondition ( const Node & node , Scope & scope , const TriggeringEntities & triggering_entities ) : given ( choice ( node , std :: make_pair ( \"EntityRef\" , [ & ]( auto && node ) { return make < EntityRef > ( node , scope ); }), std :: make_pair ( \"ByType\" , UNSUPPORTED ()))), for_each ( triggering_entities ) {} auto evaluate () const noexcept { if ( given . is < EntityRef > ()) { return asBoolean ( for_each ( [ & ]( auto && triggering_entity ) { return checkCollision ( triggering_entity , given . as < EntityRef > ()); })); } else { return false_v ; } } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__COLLISION_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/command_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/command.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Command Defines # Name BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ command = Command :: IDENTIFIER ; \\ return is ; \\ } define BOILERPLATE # #define BOILERPLATE( NAME ) case Command :: NAME : return os << # NAME ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__COMMAND_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__COMMAND_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== Command ============================================================== * * TODO * * ======================================================================== */ struct Command { enum value_type { exitFailure , exitSuccess , nop , print , } value ; explicit constexpr Command ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } decltype ( auto ) operator = ( const value_type & rhs ) { value = rhs ; return * this ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , Command & command ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ command = Command::IDENTIFIER; \\ return is; \\ } BOILERPLATE ( exitFailure ); BOILERPLATE ( exitSuccess ); BOILERPLATE ( nop ); BOILERPLATE ( print ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type Command\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Command & command ) { switch ( command ) { #define BOILERPLATE(NAME) case Command::NAME: return os << #NAME; BOILERPLATE ( exitFailure ); BOILERPLATE ( exitSuccess ); BOILERPLATE ( nop ); BOILERPLATE ( print ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class Command holds unexpected value \" << static_cast < Command :: value_type > ( command ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__COMMAND_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/command.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/command_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxcommandhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/command.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/command_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/command_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Command","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/command_8hpp/#defines","text":"Name BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/command_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/command_8hpp/#define-boilerplate","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ command = Command :: IDENTIFIER ; \\ return is ; \\ }","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/command_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( NAME ) case Command :: NAME : return os << # NAME ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/command_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__COMMAND_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__COMMAND_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== Command ============================================================== * * TODO * * ======================================================================== */ struct Command { enum value_type { exitFailure , exitSuccess , nop , print , } value ; explicit constexpr Command ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } decltype ( auto ) operator = ( const value_type & rhs ) { value = rhs ; return * this ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , Command & command ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ command = Command::IDENTIFIER; \\ return is; \\ } BOILERPLATE ( exitFailure ); BOILERPLATE ( exitSuccess ); BOILERPLATE ( nop ); BOILERPLATE ( print ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type Command\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Command & command ) { switch ( command ) { #define BOILERPLATE(NAME) case Command::NAME: return os << #NAME; BOILERPLATE ( exitFailure ); BOILERPLATE ( exitSuccess ); BOILERPLATE ( nop ); BOILERPLATE ( print ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class Command holds unexpected value \" << static_cast < Command :: value_type > ( command ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__COMMAND_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Condition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_HPP_ #include <openscenario_interpreter/syntax/by_entity_condition.hpp> #include <openscenario_interpreter/syntax/by_value_condition.hpp> #include <openscenario_interpreter/syntax/condition_edge.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- Condition -------------------------------------------------------------- * * <xsd:complexType name=\"Condition\"> * <xsd:choice> * <xsd:element name=\"ByEntityCondition\" type=\"ByEntityCondition\"/> * <xsd:element name=\"ByValueCondition\" type=\"ByValueCondition\"/> * </xsd:choice> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"delay\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"conditionEdge\" type=\"ConditionEdge\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Condition : public Element { const String name ; const Double delay ; const ConditionEdge condition_edge ; template < typename Node , typename Scope > explicit Condition ( const Node & node , Scope & scope ) : Element ( choice ( node , std :: make_pair ( \"ByEntityCondition\" , [ & ]( auto && node ) { return make < ByEntityCondition > ( node , scope ); }), std :: make_pair ( \"ByValueCondition\" , [ & ]( auto && node ) { return make < ByValueCondition > ( node , scope ); }))), name ( readAttribute < String > ( \"name\" , node , scope )), delay ( readAttribute < Double > ( \"delay\" , node , scope , Double ())), condition_edge ( readAttribute < ConditionEdge > ( \"conditionEdge\" , node , scope )) {} Element result = false_v ; const auto & evaluate () { if ( condition_edge == ConditionEdge :: sticky && result . as < Boolean > ()) { return result ; } else { return result = Element :: evaluate (); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxconditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Condition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_HPP_ #include <openscenario_interpreter/syntax/by_entity_condition.hpp> #include <openscenario_interpreter/syntax/by_value_condition.hpp> #include <openscenario_interpreter/syntax/condition_edge.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- Condition -------------------------------------------------------------- * * <xsd:complexType name=\"Condition\"> * <xsd:choice> * <xsd:element name=\"ByEntityCondition\" type=\"ByEntityCondition\"/> * <xsd:element name=\"ByValueCondition\" type=\"ByValueCondition\"/> * </xsd:choice> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"delay\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"conditionEdge\" type=\"ConditionEdge\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Condition : public Element { const String name ; const Double delay ; const ConditionEdge condition_edge ; template < typename Node , typename Scope > explicit Condition ( const Node & node , Scope & scope ) : Element ( choice ( node , std :: make_pair ( \"ByEntityCondition\" , [ & ]( auto && node ) { return make < ByEntityCondition > ( node , scope ); }), std :: make_pair ( \"ByValueCondition\" , [ & ]( auto && node ) { return make < ByValueCondition > ( node , scope ); }))), name ( readAttribute < String > ( \"name\" , node , scope )), delay ( readAttribute < Double > ( \"delay\" , node , scope , Double ())), condition_edge ( readAttribute < ConditionEdge > ( \"conditionEdge\" , node , scope )) {} Element result = false_v ; const auto & evaluate () { if ( condition_edge == ConditionEdge :: sticky && result . as < Boolean > ()) { return result ; } else { return result = Element :: evaluate (); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/condition__edge_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition_edge.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ConditionEdge Defines # Name BOILERPLATE (IDENTIFIER) BOILERPLATE (ID) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ edge . value = ConditionEdge :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( ID ) case ConditionEdge :: ID : return os << # ID ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_EDGE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_EDGE_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ---- ConditionEdge ---------------------------------------------------------- * * <xsd:simpleType name=\"ConditionEdge\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"rising\"/> * <xsd:enumeration value=\"falling\"/> * <xsd:enumeration value=\"risingOrFalling\"/> * <xsd:enumeration value=\"none\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * Tier IV Extension: * - Add enumuration <xsd.enumeration value=\"sticky\"/> * * -------------------------------------------------------------------------- */ struct ConditionEdge { enum value_type { /* ---- Rising ------------------------------------------------------------- * * A condition defined with a rising edge shall return true at discrete * time t if its logical expression is true at discrete time t and its * logical expression was false at discrete time t-ts, where ts is the * simulation sampling time. * * ---------------------------------------------------------------------- */ rising , /* ---- Falling ------------------------------------------------------------ * * A condition defined with a falling edge shall return true at discrete * time t if its logical expression is false at discrete time t and its * logical expression was true at discrete time t-ts, where ts is the * simulation sampling time. * * ---------------------------------------------------------------------- */ falling , /* ---- Rising or Falling -------------------------------------------------- * * A condition defined with a 'risingOrFalling' edge shall return true at * discrete time t if its logical expression is true at discrete time t * and its logical expression was false at discrete time t-ts OR if its * logical expression is false at discrete time t and its logical * expression was true at discrete time t-ts. ts is the simulation * sampling time. * * ---------------------------------------------------------------------- */ risingOrFalling , /* ---- None --------------------------------------------------------------- * * A condition defined with a 'none' edge shall return true at discrete * time t if its logical expression is true at discrete time t. * * ---------------------------------------------------------------------- */ none , /* ---- Sticky (Tier IV Extension) ----------------------------------------- * * A condition defined by a 'sticky' edge returns true at discrete time * t + k (0 < k) if its logical expression evaluates to true at discrete * time t. This edge is provided for simply defining assertions such as * \"Did the Ego car pass over checkpoint X? * * This edge is a non-OpenSCEANRIO 1.0.0 standard feature. * * ---------------------------------------------------------------------- */ sticky , } value ; explicit constexpr ConditionEdge ( const value_type value = {}) : value ( value ) {} operator value_type () const noexcept { return value ; } }; std :: istream & operator >> ( std :: istream & is , ConditionEdge & edge ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ edge.value = ConditionEdge::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( rising ); BOILERPLATE ( falling ); BOILERPLATE ( risingOrFalling ); BOILERPLATE ( none ); BOILERPLATE ( sticky ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type ConditionEdge\" ; throw SyntaxError ( ss . str ()); } std :: ostream & operator << ( std :: ostream & os , const ConditionEdge & edge ) { switch ( edge ) { #define BOILERPLATE(ID) case ConditionEdge::ID: return os << #ID; BOILERPLATE ( rising ); BOILERPLATE ( falling ); BOILERPLATE ( risingOrFalling ); BOILERPLATE ( none ); BOILERPLATE ( sticky ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class ConditionEdge holds unexpected value \" << static_cast < ConditionEdge :: value_type > ( edge . value ); throw ImplementationFault ( ss . str ()); } } } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_EDGE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition_edge.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/condition__edge_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxcondition_edgehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition_edge.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/condition__edge_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/condition__edge_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ConditionEdge","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/condition__edge_8hpp/#defines","text":"Name BOILERPLATE (IDENTIFIER) BOILERPLATE (ID)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/condition__edge_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/condition__edge_8hpp/#define-boilerplate","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ edge . value = ConditionEdge :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/condition__edge_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( ID ) case ConditionEdge :: ID : return os << # ID ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/condition__edge_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_EDGE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_EDGE_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ---- ConditionEdge ---------------------------------------------------------- * * <xsd:simpleType name=\"ConditionEdge\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"rising\"/> * <xsd:enumeration value=\"falling\"/> * <xsd:enumeration value=\"risingOrFalling\"/> * <xsd:enumeration value=\"none\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * Tier IV Extension: * - Add enumuration <xsd.enumeration value=\"sticky\"/> * * -------------------------------------------------------------------------- */ struct ConditionEdge { enum value_type { /* ---- Rising ------------------------------------------------------------- * * A condition defined with a rising edge shall return true at discrete * time t if its logical expression is true at discrete time t and its * logical expression was false at discrete time t-ts, where ts is the * simulation sampling time. * * ---------------------------------------------------------------------- */ rising , /* ---- Falling ------------------------------------------------------------ * * A condition defined with a falling edge shall return true at discrete * time t if its logical expression is false at discrete time t and its * logical expression was true at discrete time t-ts, where ts is the * simulation sampling time. * * ---------------------------------------------------------------------- */ falling , /* ---- Rising or Falling -------------------------------------------------- * * A condition defined with a 'risingOrFalling' edge shall return true at * discrete time t if its logical expression is true at discrete time t * and its logical expression was false at discrete time t-ts OR if its * logical expression is false at discrete time t and its logical * expression was true at discrete time t-ts. ts is the simulation * sampling time. * * ---------------------------------------------------------------------- */ risingOrFalling , /* ---- None --------------------------------------------------------------- * * A condition defined with a 'none' edge shall return true at discrete * time t if its logical expression is true at discrete time t. * * ---------------------------------------------------------------------- */ none , /* ---- Sticky (Tier IV Extension) ----------------------------------------- * * A condition defined by a 'sticky' edge returns true at discrete time * t + k (0 < k) if its logical expression evaluates to true at discrete * time t. This edge is provided for simply defining assertions such as * \"Did the Ego car pass over checkpoint X? * * This edge is a non-OpenSCEANRIO 1.0.0 standard feature. * * ---------------------------------------------------------------------- */ sticky , } value ; explicit constexpr ConditionEdge ( const value_type value = {}) : value ( value ) {} operator value_type () const noexcept { return value ; } }; std :: istream & operator >> ( std :: istream & is , ConditionEdge & edge ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ edge.value = ConditionEdge::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( rising ); BOILERPLATE ( falling ); BOILERPLATE ( risingOrFalling ); BOILERPLATE ( none ); BOILERPLATE ( sticky ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type ConditionEdge\" ; throw SyntaxError ( ss . str ()); } std :: ostream & operator << ( std :: ostream & os , const ConditionEdge & edge ) { switch ( edge ) { #define BOILERPLATE(ID) case ConditionEdge::ID: return os << #ID; BOILERPLATE ( rising ); BOILERPLATE ( falling ); BOILERPLATE ( risingOrFalling ); BOILERPLATE ( none ); BOILERPLATE ( sticky ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class ConditionEdge holds unexpected value \" << static_cast < ConditionEdge :: value_type > ( edge . value ); throw ImplementationFault ( ss . str ()); } } } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_EDGE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/condition__group_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition_group.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ConditionGroup Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_GROUP_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_GROUP_HPP_ #include <openscenario_interpreter/syntax/condition.hpp> #include <numeric> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- ConditionGroup --------------------------------------------------------- * * A condition group is an association of conditions that is assessed during * simulation time and signals true when all associated conditions are * evaluated to true. * * <xsd:complexType name=\"ConditionGroup\"> * <xsd:sequence> * <xsd:element name=\"Condition\" type=\"Condition\" maxOccurs=\"unbounded\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ConditionGroup : public std :: vector < Condition > { template < typename Node , typename Scope > explicit ConditionGroup ( const Node & node , Scope & scope ) { callWithElements ( node , \"Condition\" , 1 , unbounded , [ & ]( auto && node ) { emplace_back ( node , scope ); }); } auto evaluate () { return asBoolean ( // NOTE: Don't use std::all_of; Intentionally does not short-circuit evaluation. std :: accumulate ( std :: begin ( * this ), std :: end ( * this ), true , [ & ]( auto && lhs , Condition & condition ) { const auto rhs = condition . evaluate (); return lhs && rhs . as < Boolean > (); })); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_GROUP_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition_group.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/condition__group_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxcondition_grouphpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition_group.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/condition__group_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/condition__group_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ConditionGroup","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/condition__group_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_GROUP_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_GROUP_HPP_ #include <openscenario_interpreter/syntax/condition.hpp> #include <numeric> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- ConditionGroup --------------------------------------------------------- * * A condition group is an association of conditions that is assessed during * simulation time and signals true when all associated conditions are * evaluated to true. * * <xsd:complexType name=\"ConditionGroup\"> * <xsd:sequence> * <xsd:element name=\"Condition\" type=\"Condition\" maxOccurs=\"unbounded\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ConditionGroup : public std :: vector < Condition > { template < typename Node , typename Scope > explicit ConditionGroup ( const Node & node , Scope & scope ) { callWithElements ( node , \"Condition\" , 1 , unbounded , [ & ]( auto && node ) { emplace_back ( node , scope ); }); } auto evaluate () { return asBoolean ( // NOTE: Don't use std::all_of; Intentionally does not short-circuit evaluation. std :: accumulate ( std :: begin ( * this ), std :: end ( * this ), true , [ & ]( auto && lhs , Condition & condition ) { const auto rhs = condition . evaluate (); return lhs && rhs . as < Boolean > (); })); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CONDITION_GROUP_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/content_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/content.hpp # Namespaces # Name openscenario_interpreter::reader openscenario_interpreter Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__READER__CONTENT_HPP_ #define OPENSCENARIO_INTERPRETER__READER__CONTENT_HPP_ #include <boost/algorithm/string/trim.hpp> #include <openscenario_interpreter/syntax/parameter_type.hpp> #include <openscenario_interpreter/utility/pugi_extension.hpp> #include <string> namespace openscenario_interpreter { inline namespace reader { template < typename T , typename Node , typename Scope > T readContent ( const Node & node , const Scope & ) { const std :: string text { node . text (). get ()}; return boost :: lexical_cast < T > ( boost :: algorithm :: trim_copy ( text )); } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__READER__CONTENT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/content.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/content_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterreadercontenthpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/content.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/content_8hpp/#namespaces","text":"Name openscenario_interpreter::reader openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/content_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__READER__CONTENT_HPP_ #define OPENSCENARIO_INTERPRETER__READER__CONTENT_HPP_ #include <boost/algorithm/string/trim.hpp> #include <openscenario_interpreter/syntax/parameter_type.hpp> #include <openscenario_interpreter/utility/pugi_extension.hpp> #include <string> namespace openscenario_interpreter { inline namespace reader { template < typename T , typename Node , typename Scope > T readContent ( const Node & node , const Scope & ) { const std :: string text { node . text (). get ()}; return boost :: lexical_cast < T > ( boost :: algorithm :: trim_copy ( text )); } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__READER__CONTENT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/controller_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/controller.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Controller Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CONTROLLER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CONTROLLER_HPP_ #include <openscenario_interpreter/syntax/parameter_declarations.hpp> #include <openscenario_interpreter/syntax/properties.hpp> #include <openscenario_interpreter/syntax/string.hpp> #include <openscenario_msgs/msg/driver_model.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- Controller ------------------------------------------------------------- * * Defines a controller type and parameters for the controller. * * Used in: * AssignControllerAction, * Catalog * ControllerDistributionEntry, * ObjectController, * * <xsd:complexType name=\"Controller\"> * <xsd:all> * <xsd:element name=\"ParameterDeclarations\" type=\"ParameterDeclarations\" minOccurs=\"0\"/> * <xsd:element name=\"Properties\" type=\"Properties\"/> * </xsd:all> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ using DefaultController = Properties ; struct Controller { /* ---- name ----------------------------------------------------------------- * * Name of the controller type. * * ------------------------------------------------------------------------ */ using Name = String ; const Name name ; Scope inner_scope ; /* ---- ParameterDeclarations ------------------------------------------------ * * Definition of additional parameters. * * ------------------------------------------------------------------------ */ const ParameterDeclarations parameter_declarations ; /* ---- Properties ----------------------------------------------------------- * * Describing properties for the controller. * * ------------------------------------------------------------------------ */ Properties properties ; template < typename Node , typename Scope > explicit Controller ( const Node & node , Scope & outer_scope ) : name ( readAttribute < String > ( \"name\" , node , outer_scope )), inner_scope ( outer_scope ), parameter_declarations ( readElement < ParameterDeclarations > ( \"ParameterDeclarations\" , node , inner_scope )), properties ( readElement < Properties > ( \"Properties\" , node , inner_scope )) {} template < typename ... Ts > decltype ( auto ) operator []( Ts && ... xs ) { return properties . operator []( std :: forward < decltype ( xs ) > ( xs )...); } operator openscenario_msgs :: msg :: DriverModel () { openscenario_msgs :: msg :: DriverModel controller ; { controller . see_around = ! ( * this )[ \"isBlind\" ]; } return controller ; } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CONTROLLER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/controller.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/controller_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxcontrollerhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/controller.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/controller_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/controller_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Controller","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/controller_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CONTROLLER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CONTROLLER_HPP_ #include <openscenario_interpreter/syntax/parameter_declarations.hpp> #include <openscenario_interpreter/syntax/properties.hpp> #include <openscenario_interpreter/syntax/string.hpp> #include <openscenario_msgs/msg/driver_model.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- Controller ------------------------------------------------------------- * * Defines a controller type and parameters for the controller. * * Used in: * AssignControllerAction, * Catalog * ControllerDistributionEntry, * ObjectController, * * <xsd:complexType name=\"Controller\"> * <xsd:all> * <xsd:element name=\"ParameterDeclarations\" type=\"ParameterDeclarations\" minOccurs=\"0\"/> * <xsd:element name=\"Properties\" type=\"Properties\"/> * </xsd:all> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ using DefaultController = Properties ; struct Controller { /* ---- name ----------------------------------------------------------------- * * Name of the controller type. * * ------------------------------------------------------------------------ */ using Name = String ; const Name name ; Scope inner_scope ; /* ---- ParameterDeclarations ------------------------------------------------ * * Definition of additional parameters. * * ------------------------------------------------------------------------ */ const ParameterDeclarations parameter_declarations ; /* ---- Properties ----------------------------------------------------------- * * Describing properties for the controller. * * ------------------------------------------------------------------------ */ Properties properties ; template < typename Node , typename Scope > explicit Controller ( const Node & node , Scope & outer_scope ) : name ( readAttribute < String > ( \"name\" , node , outer_scope )), inner_scope ( outer_scope ), parameter_declarations ( readElement < ParameterDeclarations > ( \"ParameterDeclarations\" , node , inner_scope )), properties ( readElement < Properties > ( \"Properties\" , node , inner_scope )) {} template < typename ... Ts > decltype ( auto ) operator []( Ts && ... xs ) { return properties . operator []( std :: forward < decltype ( xs ) > ( xs )...); } operator openscenario_msgs :: msg :: DriverModel () { openscenario_msgs :: msg :: DriverModel controller ; { controller . see_around = ! ( * this )[ \"isBlind\" ]; } return controller ; } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CONTROLLER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/controller__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/controller_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ControllerAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CONTROLLER_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CONTROLLER_ACTION_HPP_ #include <openscenario_interpreter/syntax/assign_controller_action.hpp> #include <openscenario_interpreter/syntax/override_controller_value_action.hpp> #include <type_traits> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ControllerAction ------------------------------------------------------- * * Action that assigns a new controller or overrides an existing one. * * <xsd:complexType name=\"ControllerAction\"> * <xsd:all> * <xsd:element name=\"AssignControllerAction\" type=\"AssignControllerAction\"/> * <xsd:element name=\"OverrideControllerValueAction\" type=\"OverrideControllerValueAction\"/> * </xsd:all> * </xsd:complexType> * * ------------------------------------------------------------------------ */ struct ControllerAction { /* ---- AssignControllerAction ----------------------------------------------- * * Assign a controller to an entity. * * ------------------------------------------------------------------------ */ const AssignControllerAction assignController ; /* ---- OverrideControllerValueAction ---------------------------------------- * * Values for throttle, brake, clutch, parking brake, steering wheel or gear. * * NOTE: OverrideControllerValueAction is ignored. * * ------------------------------------------------------------------------ */ const OverrideControllerValueAction override_controller_value_action ; template < typename Node , typename Scope > explicit ControllerAction ( const Node & node , Scope & outer_scope ) : assignController ( readElement < AssignControllerAction > ( \"AssignControllerAction\" , node , outer_scope )), override_controller_value_action ( readElement < OverrideControllerValueAction > ( \"OverrideControllerValueAction\" , node , outer_scope )) // NOTE: DUMMY IMPLEMENTAION {} void start () const { assignController (); } const std :: true_type accomplished {}; }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CONTROLLER_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/controller_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/controller__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxcontroller_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/controller_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/controller__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/controller__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ControllerAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/controller__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CONTROLLER_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CONTROLLER_ACTION_HPP_ #include <openscenario_interpreter/syntax/assign_controller_action.hpp> #include <openscenario_interpreter/syntax/override_controller_value_action.hpp> #include <type_traits> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ControllerAction ------------------------------------------------------- * * Action that assigns a new controller or overrides an existing one. * * <xsd:complexType name=\"ControllerAction\"> * <xsd:all> * <xsd:element name=\"AssignControllerAction\" type=\"AssignControllerAction\"/> * <xsd:element name=\"OverrideControllerValueAction\" type=\"OverrideControllerValueAction\"/> * </xsd:all> * </xsd:complexType> * * ------------------------------------------------------------------------ */ struct ControllerAction { /* ---- AssignControllerAction ----------------------------------------------- * * Assign a controller to an entity. * * ------------------------------------------------------------------------ */ const AssignControllerAction assignController ; /* ---- OverrideControllerValueAction ---------------------------------------- * * Values for throttle, brake, clutch, parking brake, steering wheel or gear. * * NOTE: OverrideControllerValueAction is ignored. * * ------------------------------------------------------------------------ */ const OverrideControllerValueAction override_controller_value_action ; template < typename Node , typename Scope > explicit ControllerAction ( const Node & node , Scope & outer_scope ) : assignController ( readElement < AssignControllerAction > ( \"AssignControllerAction\" , node , outer_scope )), override_controller_value_action ( readElement < OverrideControllerValueAction > ( \"OverrideControllerValueAction\" , node , outer_scope )) // NOTE: DUMMY IMPLEMENTAION {} void start () const { assignController (); } const std :: true_type accomplished {}; }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CONTROLLER_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/custom__command__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/custom_command_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::CustomCommandAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CUSTOM_COMMAND_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CUSTOM_COMMAND_ACTION_HPP_ #include <openscenario_interpreter/posix/fork_exec.hpp> #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/reader/content.hpp> #include <openscenario_interpreter/string/cat.hpp> #include <iterator> // std::distance #include <stdexcept> // std::runtime_error #include <string> #include <type_traits> // std::true_type #include <unordered_map> #include <utility> // std::make_pair #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- CustomCommandAction ---------------------------------------------------- * * <xsd:complexType name=\"CustomCommandAction\"> * <xsd:simpleContent> * <xsd:extension base=\"xsd:string\"> * <xsd:attribute name=\"type\" type=\"String\" use=\"required\"/> * </xsd:extension> * </xsd:simpleContent> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct CustomCommandAction { Scope inner_scope ; const String type ; const String content ; template < typename Node > explicit CustomCommandAction ( const Node & node , const Scope & outer_scope ) : inner_scope ( outer_scope ), type ( readAttribute < String > ( \"type\" , node , inner_scope )), content ( readContent < String > ( node , inner_scope )) {} const std :: true_type accomplished {}; static int walkStraightAction ( const std :: vector < std :: string > & actors , const Scope & current_scope ) { for ( const auto & actor : actors ) { requestWalkStraight ( actor ); } for ( const auto actor : current_scope . actors ) { requestWalkStraight ( actor ); } return current_scope . actors . size (); } static int exitSuccess ( const std :: vector < std :: string > & , const Scope & ) { throw EXIT_SUCCESS ; } static int exitFailure ( const std :: vector < std :: string > & , const Scope & ) { throw EXIT_FAILURE ; } static int error ( const std :: vector < std :: string > & , const Scope & ) { throw std :: runtime_error ( cat ( __FILE__ , \":\" , __LINE__ )); } static int segv ( const std :: vector < std :: string > & , const Scope & ) { return * reinterpret_cast < std :: add_pointer < int >:: type > ( 0 ); } static int test ( const std :: vector < std :: string > & args , const Scope & ) { std :: cout << \"test\" << std :: endl ; for ( auto iter = std :: cbegin ( args ); iter != std :: cend ( args ); ++ iter ) { std :: cout << \" args[\" << std :: distance ( std :: cbegin ( args ), iter ) << \"] = \" << * iter << std :: endl ; } return args . size (); } const std :: unordered_map < std :: string , std :: function < int ( const std :: vector < std :: string > & , const Scope & ) >> builtins { std :: make_pair ( \"WalkStraightAction\" , walkStraightAction ), std :: make_pair ( \"error\" , error ), std :: make_pair ( \"exitFailure\" , exitFailure ), std :: make_pair ( \"exitSuccess\" , exitSuccess ), std :: make_pair ( \"sigsegv\" , segv ), // Deprecated std :: make_pair ( \"test\" , test ), }; static auto split ( const std :: string & s ) { static const std :: regex pattern { R \" ( ([^\\(\"\\s,\\)]+|\\\"[^\"]*\\\"),?\\s* ) \" }; std :: vector < std :: string > args {}; for ( std :: sregex_iterator iter { std :: begin ( s ), std :: end ( s ), pattern }, end ; iter != end ; ++ iter ) { args . emplace_back (( * iter )[ 1 ]); } return args ; } auto evaluate () { /* ---- NOTE --------------------------------------------------------------- * * <CustomCommandAction type=\"function(hoge, &quot;hello, world!&quot;, 3.14)\"/> * * result[0] = function(hoge, \"hello, world!\", 3.14) * result[1] = function * result[2] = (hoge, \"hello, world!\", 3.14) * result[3] = hoge, \"hello, world!\", 3.14 * * ---------------------------------------------------------------------- */ static const std :: regex pattern { R \" ( ^(\\w+)(\\(((?:(?:[^\\(\"\\s,\\)]+|\\\"[^\"]*\\\"),?\\s*)*)\\))?$ ) \" }; std :: smatch result {}; if ( std :: regex_match ( type , result , pattern ) && builtins . find ( result [ 1 ]) != std :: end ( builtins )) { builtins . at ( result [ 1 ])( split ( result [ 3 ]), inner_scope ); } else { fork_exec ( type , content ); } return unspecified ; } friend std :: ostream & operator << ( std :: ostream & os , const CustomCommandAction & action ) { os << indent << blue << \"<CustomCommandAction\" << \" \" << highlight ( \"type\" , action . type ); if ( action . content . empty ()) { return os << blue << \"/>\" << reset ; } else { return os << blue << \">\" << reset << action . content << blue << \"</CustomCommandAction>\" << reset ; } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CUSTOM_COMMAND_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/custom_command_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/custom__command__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxcustom_command_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/custom_command_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/custom__command__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/custom__command__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::CustomCommandAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/custom__command__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__CUSTOM_COMMAND_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__CUSTOM_COMMAND_ACTION_HPP_ #include <openscenario_interpreter/posix/fork_exec.hpp> #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/reader/content.hpp> #include <openscenario_interpreter/string/cat.hpp> #include <iterator> // std::distance #include <stdexcept> // std::runtime_error #include <string> #include <type_traits> // std::true_type #include <unordered_map> #include <utility> // std::make_pair #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- CustomCommandAction ---------------------------------------------------- * * <xsd:complexType name=\"CustomCommandAction\"> * <xsd:simpleContent> * <xsd:extension base=\"xsd:string\"> * <xsd:attribute name=\"type\" type=\"String\" use=\"required\"/> * </xsd:extension> * </xsd:simpleContent> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct CustomCommandAction { Scope inner_scope ; const String type ; const String content ; template < typename Node > explicit CustomCommandAction ( const Node & node , const Scope & outer_scope ) : inner_scope ( outer_scope ), type ( readAttribute < String > ( \"type\" , node , inner_scope )), content ( readContent < String > ( node , inner_scope )) {} const std :: true_type accomplished {}; static int walkStraightAction ( const std :: vector < std :: string > & actors , const Scope & current_scope ) { for ( const auto & actor : actors ) { requestWalkStraight ( actor ); } for ( const auto actor : current_scope . actors ) { requestWalkStraight ( actor ); } return current_scope . actors . size (); } static int exitSuccess ( const std :: vector < std :: string > & , const Scope & ) { throw EXIT_SUCCESS ; } static int exitFailure ( const std :: vector < std :: string > & , const Scope & ) { throw EXIT_FAILURE ; } static int error ( const std :: vector < std :: string > & , const Scope & ) { throw std :: runtime_error ( cat ( __FILE__ , \":\" , __LINE__ )); } static int segv ( const std :: vector < std :: string > & , const Scope & ) { return * reinterpret_cast < std :: add_pointer < int >:: type > ( 0 ); } static int test ( const std :: vector < std :: string > & args , const Scope & ) { std :: cout << \"test\" << std :: endl ; for ( auto iter = std :: cbegin ( args ); iter != std :: cend ( args ); ++ iter ) { std :: cout << \" args[\" << std :: distance ( std :: cbegin ( args ), iter ) << \"] = \" << * iter << std :: endl ; } return args . size (); } const std :: unordered_map < std :: string , std :: function < int ( const std :: vector < std :: string > & , const Scope & ) >> builtins { std :: make_pair ( \"WalkStraightAction\" , walkStraightAction ), std :: make_pair ( \"error\" , error ), std :: make_pair ( \"exitFailure\" , exitFailure ), std :: make_pair ( \"exitSuccess\" , exitSuccess ), std :: make_pair ( \"sigsegv\" , segv ), // Deprecated std :: make_pair ( \"test\" , test ), }; static auto split ( const std :: string & s ) { static const std :: regex pattern { R \" ( ([^\\(\"\\s,\\)]+|\\\"[^\"]*\\\"),?\\s* ) \" }; std :: vector < std :: string > args {}; for ( std :: sregex_iterator iter { std :: begin ( s ), std :: end ( s ), pattern }, end ; iter != end ; ++ iter ) { args . emplace_back (( * iter )[ 1 ]); } return args ; } auto evaluate () { /* ---- NOTE --------------------------------------------------------------- * * <CustomCommandAction type=\"function(hoge, &quot;hello, world!&quot;, 3.14)\"/> * * result[0] = function(hoge, \"hello, world!\", 3.14) * result[1] = function * result[2] = (hoge, \"hello, world!\", 3.14) * result[3] = hoge, \"hello, world!\", 3.14 * * ---------------------------------------------------------------------- */ static const std :: regex pattern { R \" ( ^(\\w+)(\\(((?:(?:[^\\(\"\\s,\\)]+|\\\"[^\"]*\\\"),?\\s*)*)\\))?$ ) \" }; std :: smatch result {}; if ( std :: regex_match ( type , result , pattern ) && builtins . find ( result [ 1 ]) != std :: end ( builtins )) { builtins . at ( result [ 1 ])( split ( result [ 3 ]), inner_scope ); } else { fork_exec ( type , content ); } return unspecified ; } friend std :: ostream & operator << ( std :: ostream & os , const CustomCommandAction & action ) { os << indent << blue << \"<CustomCommandAction\" << \" \" << highlight ( \"type\" , action . type ); if ( action . content . empty ()) { return os << blue << \"/>\" << reset ; } else { return os << blue << \">\" << reset << action . content << blue << \"</CustomCommandAction>\" << reset ; } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__CUSTOM_COMMAND_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/delete__entity__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/delete_entity_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::DeleteEntityAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__DELETE_ENTITY_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__DELETE_ENTITY_ACTION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/string.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- DeleteEntityAction ----------------------------------------------------- * * <xsd:complexType name=\"DeleteEntityAction\"/> * * -------------------------------------------------------------------------- */ struct DeleteEntityAction { template < typename ... Ts > explicit DeleteEntityAction ( Ts && ...) {} decltype ( auto ) operator ()( const String & entity_ref ) const { despawn ( entity_ref ); return unspecified ; } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__DELETE_ENTITY_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/delete_entity_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/delete__entity__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxdelete_entity_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/delete_entity_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/delete__entity__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/delete__entity__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::DeleteEntityAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/delete__entity__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__DELETE_ENTITY_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__DELETE_ENTITY_ACTION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/string.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- DeleteEntityAction ----------------------------------------------------- * * <xsd:complexType name=\"DeleteEntityAction\"/> * * -------------------------------------------------------------------------- */ struct DeleteEntityAction { template < typename ... Ts > explicit DeleteEntityAction ( Ts && ...) {} decltype ( auto ) operator ()( const String & entity_ref ) const { despawn ( entity_ref ); return unspecified ; } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__DELETE_ENTITY_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/dimensions_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dimensions.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Dimensions Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__DIMENSIONS_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__DIMENSIONS_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/reader/element.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Dimensions =========================================================== * * <xsd:complexType name=\"Dimensionss\"> * <xsd:attribute name=\"width\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"length\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"height\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Dimensions { const Double width , length , height ; Dimensions () = default ; template < typename Node , typename Scope > explicit Dimensions ( const Node & node , Scope & scope ) : width { readAttribute < Double > ( \"width\" , node , scope )}, length { readAttribute < Double > ( \"length\" , node , scope )}, height { readAttribute < Double > ( \"height\" , node , scope )} {} }; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Dimensions & rhs ) { return os << indent << blue << \"<Dimensions\" << \" \" << highlight ( \"width\" , rhs . width ) << \" \" << highlight ( \"length\" , rhs . length ) << \" \" << highlight ( \"height\" , rhs . height ) << blue << \"/>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__DIMENSIONS_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dimensions.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/dimensions_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxdimensionshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dimensions.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/dimensions_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/dimensions_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Dimensions","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/dimensions_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__DIMENSIONS_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__DIMENSIONS_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/reader/element.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Dimensions =========================================================== * * <xsd:complexType name=\"Dimensionss\"> * <xsd:attribute name=\"width\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"length\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"height\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Dimensions { const Double width , length , height ; Dimensions () = default ; template < typename Node , typename Scope > explicit Dimensions ( const Node & node , Scope & scope ) : width { readAttribute < Double > ( \"width\" , node , scope )}, length { readAttribute < Double > ( \"length\" , node , scope )}, height { readAttribute < Double > ( \"height\" , node , scope )} {} }; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Dimensions & rhs ) { return os << indent << blue << \"<Dimensions\" << \" \" << highlight ( \"width\" , rhs . width ) << \" \" << highlight ( \"length\" , rhs . length ) << \" \" << highlight ( \"height\" , rhs . height ) << blue << \"/>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__DIMENSIONS_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/dir_09071dff9eb6ad4fdd36ac9762cd8a2e/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/test # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/test/test_syntax.cpp Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/test"},{"location":"package/openscenario_interpreter/markdown/Files/dir_09071dff9eb6ad4fdd36ac9762cd8a2e/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpretertest","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/test"},{"location":"package/openscenario_interpreter/markdown/Files/dir_09071dff9eb6ad4fdd36ac9762cd8a2e/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/test/test_syntax.cpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_interpreter/markdown/Files/dir_14bc9668c3ff0737e5dec5ed226e27a1/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string/split.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string/cat.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string"},{"location":"package/openscenario_interpreter/markdown/Files/dir_14bc9668c3ff0737e5dec5ed226e27a1/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterstring","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string"},{"location":"package/openscenario_interpreter/markdown/Files/dir_14bc9668c3ff0737e5dec5ed226e27a1/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string/split.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string/cat.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_interpreter/markdown/Files/dir_2f3c5ab4a00f972ff4a9e57884e587d3/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/posix # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/posix/fork_exec.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/posix"},{"location":"package/openscenario_interpreter/markdown/Files/dir_2f3c5ab4a00f972ff4a9e57884e587d3/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterposix","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/posix"},{"location":"package/openscenario_interpreter/markdown/Files/dir_2f3c5ab4a00f972ff4a9e57884e587d3/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/posix/fork_exec.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_interpreter/markdown/Files/dir_34604202bc2af69aa4412421ef91e181/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console/is_console.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console/escape_sequence.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console"},{"location":"package/openscenario_interpreter/markdown/Files/dir_34604202bc2af69aa4412421ef91e181/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterconsole","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console"},{"location":"package/openscenario_interpreter/markdown/Files/dir_34604202bc2af69aa4412421ef91e181/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console/is_console.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console/escape_sequence.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_interpreter/markdown/Files/dir_4f65ede5137f122f5689f52e7d708823/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/test /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter"},{"location":"package/openscenario_interpreter/markdown/Files/dir_4f65ede5137f122f5689f52e7d708823/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreter","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter"},{"location":"package/openscenario_interpreter/markdown/Files/dir_4f65ede5137f122f5689f52e7d708823/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/test /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include Updated on 7 April 2021 at 00:31:57 UTC","title":"Directories"},{"location":"package/openscenario_interpreter/markdown/Files/dir_4f7917b31dd1db761ba61083fab58d00/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/world_position.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/waypoint.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/vehicle_category.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/vehicle.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/user_defined_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/unsigned_short.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/unsigned_integer.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/triggering_entities_rule.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/triggering_entities.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/trigger.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/transition_dynamics.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signals.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_state_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/time_headway_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/teleport_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/string.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_type.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_state_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_state.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/story.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/stand_still_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_target_value_type.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_action_target.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/simulation_time_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/selected_entities.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/scenario_object.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/rule.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/routing_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/route_strategy.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/route.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/road_network.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_world_position.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_target_speed.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_distance_type.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_distance_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/reference_context.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/reach_position_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/property.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/properties.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/private_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/private.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/priority.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/position.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/performance.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/pedestrian_category.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/pedestrian.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_type.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_set_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_multiply_by_value_rule.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_modify_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_declarations.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_declaration.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_add_value_rule.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/override_controller_value_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/orientation.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/openscenario.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/object_type.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/object_controller.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/modify_rule.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/maneuver_group.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/maneuver.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/longitudinal_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lateral_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_position.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_change_target.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_change_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/integer.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/init_actions.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/init.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/infrastructure_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/global_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/file_header.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/file.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/event.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_selection.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_ref.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_object.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entities.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dynamics_shape.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dynamics_dimension.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/double.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/distance_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/directory.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dimensions.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/delete_entity_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/custom_command_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/controller_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/controller.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition_group.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition_edge.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/command.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/collision_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/center.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/catalog_locations.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/catalog_location.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_value_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_type.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_entity_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/bounding_box.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/boolean.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/axles.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/axle.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/assign_route_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/assign_controller_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/add_entity_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/actors.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/act.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/acquire_position_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/acceleration_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/absolute_target_speed.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/absolute_target_lane.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax"},{"location":"package/openscenario_interpreter/markdown/Files/dir_4f7917b31dd1db761ba61083fab58d00/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntax","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax"},{"location":"package/openscenario_interpreter/markdown/Files/dir_4f7917b31dd1db761ba61083fab58d00/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/world_position.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/waypoint.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/vehicle_category.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/vehicle.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/user_defined_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/unsigned_short.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/unsigned_integer.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/triggering_entities_rule.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/triggering_entities.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/trigger.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/transition_dynamics.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signals.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_state_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/time_headway_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/teleport_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/string.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_type.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_state_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_state.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/story.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/stand_still_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_target_value_type.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_action_target.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/simulation_time_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/selected_entities.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/scenario_object.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/rule.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/routing_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/route_strategy.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/route.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/road_network.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_world_position.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_target_speed.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_distance_type.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_distance_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/reference_context.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/reach_position_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/property.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/properties.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/private_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/private.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/priority.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/position.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/performance.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/pedestrian_category.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/pedestrian.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_type.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_set_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_multiply_by_value_rule.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_modify_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_declarations.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_declaration.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_add_value_rule.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/override_controller_value_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/orientation.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/openscenario.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/object_type.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/object_controller.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/modify_rule.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/maneuver_group.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/maneuver.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/longitudinal_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lateral_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_position.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_change_target.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_change_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/integer.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/init_actions.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/init.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/infrastructure_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/global_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/file_header.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/file.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/event.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_selection.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_ref.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_object.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entities.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dynamics_shape.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dynamics_dimension.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/double.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/distance_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/directory.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dimensions.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/delete_entity_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/custom_command_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/controller_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/controller.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition_group.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition_edge.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/command.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/collision_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/center.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/catalog_locations.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/catalog_location.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_value_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_type.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/by_entity_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/bounding_box.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/boolean.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/axles.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/axle.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/assign_route_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/assign_controller_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/add_entity_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/actors.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/act.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/acquire_position_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/acceleration_condition.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/absolute_target_speed.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/absolute_target_lane.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_interpreter/markdown/Files/dir_5ce21a9c3ec08105f3f456d5834371c5/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional/fold.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional/equal_to.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional"},{"location":"package/openscenario_interpreter/markdown/Files/dir_5ce21a9c3ec08105f3f456d5834371c5/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterfunctional","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional"},{"location":"package/openscenario_interpreter/markdown/Files/dir_5ce21a9c3ec08105f3f456d5834371c5/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional/fold.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional/equal_to.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_interpreter/markdown/Files/dir_6988bc231860fb13cbb012f0b42a04db/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/iterator # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/iterator/size.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/iterator"},{"location":"package/openscenario_interpreter/markdown/Files/dir_6988bc231860fb13cbb012f0b42a04db/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreteriterator","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/iterator"},{"location":"package/openscenario_interpreter/markdown/Files/dir_6988bc231860fb13cbb012f0b42a04db/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/iterator/size.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_interpreter/markdown/Files/dir_6de2657a40e22c7ccd1926844cb2b11f/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/posix /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/iterator /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/scope.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/procedure.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/pointer.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/openscenario_interpreter.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/object.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/expression.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/error.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter"},{"location":"package/openscenario_interpreter/markdown/Files/dir_6de2657a40e22c7ccd1926844cb2b11f/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreter","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter"},{"location":"package/openscenario_interpreter/markdown/Files/dir_6de2657a40e22c7ccd1926844cb2b11f/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/posix /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/iterator /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console","title":"Directories"},{"location":"package/openscenario_interpreter/markdown/Files/dir_6de2657a40e22c7ccd1926844cb2b11f/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/scope.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/procedure.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/pointer.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/openscenario_interpreter.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/object.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/expression.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/error.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_interpreter/markdown/Files/dir_97d4e6120a0c4d65d7e5e2da9e1d2679/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/element.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/content.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/attribute.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader"},{"location":"package/openscenario_interpreter/markdown/Files/dir_97d4e6120a0c4d65d7e5e2da9e1d2679/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterreader","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader"},{"location":"package/openscenario_interpreter/markdown/Files/dir_97d4e6120a0c4d65d7e5e2da9e1d2679/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/element.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/content.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/attribute.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_interpreter/markdown/Files/dir_9f265af1b380e9a97afccaac33694834/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/void_t.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_not_nothrow_default_constructible.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_not_default_constructible.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_stream_output_operator.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_state.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_start.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_evaluate.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_accomplished.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_stream_output_operator.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_state.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_start.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_evaluate.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_accomplished.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits"},{"location":"package/openscenario_interpreter/markdown/Files/dir_9f265af1b380e9a97afccaac33694834/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretertype_traits","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits"},{"location":"package/openscenario_interpreter/markdown/Files/dir_9f265af1b380e9a97afccaac33694834/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/void_t.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_not_nothrow_default_constructible.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_not_default_constructible.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_stream_output_operator.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_state.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_start.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_evaluate.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_accomplished.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_stream_output_operator.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_state.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_start.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_evaluate.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_accomplished.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_interpreter/markdown/Files/dir_aca88c6fc222440536a8c79c5da09263/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/visibility.h /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/verbose.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/pugi_extension.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/pair.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/indent.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/highlighter.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/assertion_auxiliary.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility"},{"location":"package/openscenario_interpreter/markdown/Files/dir_aca88c6fc222440536a8c79c5da09263/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterutility","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility"},{"location":"package/openscenario_interpreter/markdown/Files/dir_aca88c6fc222440536a8c79c5da09263/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/visibility.h /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/verbose.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/pugi_extension.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/pair.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/indent.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/highlighter.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/assertion_auxiliary.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_interpreter/markdown/Files/dir_b7e95a849abe11b669c96455e8cd78a9/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario"},{"location":"package/openscenario_interpreter/markdown/Files/dir_b7e95a849abe11b669c96455e8cd78a9/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenario","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario"},{"location":"package/openscenario_interpreter/markdown/Files/dir_b7e95a849abe11b669c96455e8cd78a9/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter Updated on 7 April 2021 at 00:31:57 UTC","title":"Directories"},{"location":"package/openscenario_interpreter/markdown/Files/dir_dbae053f1b8b45c8c786fe2fbb23b168/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include"},{"location":"package/openscenario_interpreter/markdown/Files/dir_dbae053f1b8b45c8c786fe2fbb23b168/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterinclude","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include"},{"location":"package/openscenario_interpreter/markdown/Files/dir_dbae053f1b8b45c8c786fe2fbb23b168/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter Updated on 7 April 2021 at 00:31:57 UTC","title":"Directories"},{"location":"package/openscenario_interpreter/markdown/Files/dir_e42f44aa35b90393636188db7c290176/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/procedure.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/openscenario_interpreter_node.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/openscenario_interpreter.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/object.cpp Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src"},{"location":"package/openscenario_interpreter/markdown/Files/dir_e42f44aa35b90393636188db7c290176/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpretersrc","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src"},{"location":"package/openscenario_interpreter/markdown/Files/dir_e42f44aa35b90393636188db7c290176/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/procedure.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/openscenario_interpreter_node.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/openscenario_interpreter.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/object.cpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_interpreter/markdown/Files/directory_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/directory.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Directory Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__DIRECTORY_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__DIRECTORY_HPP_ #include <openscenario_interpreter/scope.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Directory ============================================================ * * <xsd:complexType name=\"Directory\"> * <xsd:attribute name=\"path\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Directory { const String path ; template < typename Node , typename Scope > explicit Directory ( const Node & node , Scope & outer_scope ) : path { readAttribute < String > ( \"path\" , node , outer_scope )} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__DIRECTORY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/directory.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/directory_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxdirectoryhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/directory.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/directory_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/directory_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Directory","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/directory_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__DIRECTORY_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__DIRECTORY_HPP_ #include <openscenario_interpreter/scope.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Directory ============================================================ * * <xsd:complexType name=\"Directory\"> * <xsd:attribute name=\"path\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Directory { const String path ; template < typename Node , typename Scope > explicit Directory ( const Node & node , Scope & outer_scope ) : path { readAttribute < String > ( \"path\" , node , outer_scope )} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__DIRECTORY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/distance__condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/distance_condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::DistanceCondition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__DISTANCE_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__DISTANCE_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/boolean.hpp> #include <openscenario_interpreter/syntax/double.hpp> #include <openscenario_interpreter/syntax/position.hpp> #include <openscenario_interpreter/syntax/rule.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> #include <cmath> namespace openscenario_interpreter { inline namespace syntax { /* ---- DistanceCondition ------------------------------------------------------ * * The current distance between an entity and a reference entity is compared to * a given distance (less, greater, equal). Several additional parameters like * free space etc. can be defined. * * <xsd:complexType name=\"DistanceCondition\"> * <xsd:all> * <xsd:element name=\"Position\" type=\"Position\"/> * </xsd:all> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"freespace\" type=\"Boolean\" use=\"required\"/> * <xsd:attribute name=\"alongRoute\" type=\"Boolean\" use=\"required\"/> * <xsd:attribute name=\"rule\" type=\"Rule\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct DistanceCondition { /* ---- value ---------------------------------------------------------------- * * The distance value. Unit: s; Range: [0..inf[. * * ------------------------------------------------------------------------ */ const Double value ; /* ---- freespace ------------------------------------------------------------ * * True: distance is measured between closest bounding box points. * * False: reference point distance is used. * * ------------------------------------------------------------------------ */ const Boolean freespace ; /* ---- alongRoute ----------------------------------------------------------- * * True: routing is taken into account, e.g. turns will increase distance. * * False: straight line distance is used. * * ------------------------------------------------------------------------ */ const Boolean along_route ; /* ---- rule ----------------------------------------------------------------- * * The operator (less, greater, equal). * * ------------------------------------------------------------------------ */ const Rule compare ; /* ---- Position ------------------------------------------------------------- * * The given position the distance is related to. * * ------------------------------------------------------------------------ */ const Position position ; template < typename Node > explicit DistanceCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & triggering_entities ) : value ( readAttribute < Double > ( \"value\" , node , outer_scope )), freespace ( readAttribute < Boolean > ( \"freespace\" , node , outer_scope )), along_route ( readAttribute < Boolean > ( \"alongRoute\" , node , outer_scope )), compare ( readAttribute < Rule > ( \"rule\" , node , outer_scope )), position ( readElement < Position > ( \"Position\" , node , outer_scope )), for_each ( triggering_entities ) {} const TriggeringEntities for_each ; auto evaluate () { return asBoolean ( for_each ( [ & ]( auto && triggering_entity ) { const auto pose = getRelativePose ( triggering_entity , static_cast < geometry_msgs :: msg :: Pose > ( position )); return compare ( std :: hypot ( pose . position . x , pose . position . y ), value ); })); } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__DISTANCE_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/distance_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/distance__condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxdistance_conditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/distance_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/distance__condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/distance__condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::DistanceCondition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/distance__condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__DISTANCE_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__DISTANCE_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/boolean.hpp> #include <openscenario_interpreter/syntax/double.hpp> #include <openscenario_interpreter/syntax/position.hpp> #include <openscenario_interpreter/syntax/rule.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> #include <cmath> namespace openscenario_interpreter { inline namespace syntax { /* ---- DistanceCondition ------------------------------------------------------ * * The current distance between an entity and a reference entity is compared to * a given distance (less, greater, equal). Several additional parameters like * free space etc. can be defined. * * <xsd:complexType name=\"DistanceCondition\"> * <xsd:all> * <xsd:element name=\"Position\" type=\"Position\"/> * </xsd:all> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"freespace\" type=\"Boolean\" use=\"required\"/> * <xsd:attribute name=\"alongRoute\" type=\"Boolean\" use=\"required\"/> * <xsd:attribute name=\"rule\" type=\"Rule\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct DistanceCondition { /* ---- value ---------------------------------------------------------------- * * The distance value. Unit: s; Range: [0..inf[. * * ------------------------------------------------------------------------ */ const Double value ; /* ---- freespace ------------------------------------------------------------ * * True: distance is measured between closest bounding box points. * * False: reference point distance is used. * * ------------------------------------------------------------------------ */ const Boolean freespace ; /* ---- alongRoute ----------------------------------------------------------- * * True: routing is taken into account, e.g. turns will increase distance. * * False: straight line distance is used. * * ------------------------------------------------------------------------ */ const Boolean along_route ; /* ---- rule ----------------------------------------------------------------- * * The operator (less, greater, equal). * * ------------------------------------------------------------------------ */ const Rule compare ; /* ---- Position ------------------------------------------------------------- * * The given position the distance is related to. * * ------------------------------------------------------------------------ */ const Position position ; template < typename Node > explicit DistanceCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & triggering_entities ) : value ( readAttribute < Double > ( \"value\" , node , outer_scope )), freespace ( readAttribute < Boolean > ( \"freespace\" , node , outer_scope )), along_route ( readAttribute < Boolean > ( \"alongRoute\" , node , outer_scope )), compare ( readAttribute < Rule > ( \"rule\" , node , outer_scope )), position ( readElement < Position > ( \"Position\" , node , outer_scope )), for_each ( triggering_entities ) {} const TriggeringEntities for_each ; auto evaluate () { return asBoolean ( for_each ( [ & ]( auto && triggering_entity ) { const auto pose = getRelativePose ( triggering_entity , static_cast < geometry_msgs :: msg :: Pose > ( position )); return compare ( std :: hypot ( pose . position . x , pose . position . y ), value ); })); } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__DISTANCE_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/double_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/double.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Double Defines # Name OPENSCENARIO_INTERPRETER_DOUBLE_INFINITY Macro Documentation # define OPENSCENARIO_INTERPRETER_DOUBLE_INFINITY # #define OPENSCENARIO_INTERPRETER_DOUBLE_INFINITY max Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__DOUBLE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__DOUBLE_HPP_ #include <boost/lexical_cast.hpp> #include <std_msgs/msg/float64.hpp> #include <limits> #include <regex> #include <string> namespace openscenario_interpreter { inline namespace syntax { struct Double : public std_msgs :: msg :: Float64 { using value_type = decltype ( std_msgs :: msg :: Float64 :: data ); explicit Double ( value_type value = {}) { data = value ; } explicit Double ( const std :: string & s ) try { data = boost :: lexical_cast < value_type > ( s ); } catch ( const boost :: bad_lexical_cast & ) { std :: stringstream ss {}; ss << \"can't treat value \\\" \" << s << \" \\\" as type Double\" ; throw SyntaxError { ss . str ()}; } constexpr operator value_type () const noexcept { return data ; } static auto infinity () noexcept { return static_cast < Double > ( std :: numeric_limits < value_type >:: infinity ()); } auto & operator += ( const double & rhs ) { data += rhs ; return * this ; } auto & operator *= ( const double & rhs ) { data *= rhs ; return * this ; } }; std :: ostream & operator << ( std :: ostream & os , const Double & rhs ) { return os << std :: fixed << rhs . data ; } std :: istream & operator >> ( std :: istream & is , Double & rhs ) { std :: string token {}; is >> token ; static const std :: regex infinity { R \" ( [+-]?INF ) \" }; std :: smatch result {}; if ( std :: regex_match ( token , result , infinity )) { #ifndef OPENSCENARIO_INTERPRETER_ALLOW_INFINITY #define OPENSCENARIO_INTERPRETER_DOUBLE_INFINITY max #else #define OPENSCENARIO_INTERPRETER_DOUBLE_INFINITY infinity #endif rhs . data = ( result . str ( 1 ) == \"-\" ? -1 : 1 ) * std :: numeric_limits < Double :: value_type >:: OPENSCENARIO_INTERPRETER_DOUBLE_INFINITY (); #undef OPENSCENARIO_INTERPRETER_DOUBLE_INFINITY } else { rhs . data = boost :: lexical_cast < Double :: value_type > ( token ); } return is ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__DOUBLE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/double.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/double_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxdoublehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/double.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/double_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/double_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Double","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/double_8hpp/#defines","text":"Name OPENSCENARIO_INTERPRETER_DOUBLE_INFINITY","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/double_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/double_8hpp/#define-openscenario_interpreter_double_infinity","text":"#define OPENSCENARIO_INTERPRETER_DOUBLE_INFINITY max","title":"define OPENSCENARIO_INTERPRETER_DOUBLE_INFINITY"},{"location":"package/openscenario_interpreter/markdown/Files/double_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__DOUBLE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__DOUBLE_HPP_ #include <boost/lexical_cast.hpp> #include <std_msgs/msg/float64.hpp> #include <limits> #include <regex> #include <string> namespace openscenario_interpreter { inline namespace syntax { struct Double : public std_msgs :: msg :: Float64 { using value_type = decltype ( std_msgs :: msg :: Float64 :: data ); explicit Double ( value_type value = {}) { data = value ; } explicit Double ( const std :: string & s ) try { data = boost :: lexical_cast < value_type > ( s ); } catch ( const boost :: bad_lexical_cast & ) { std :: stringstream ss {}; ss << \"can't treat value \\\" \" << s << \" \\\" as type Double\" ; throw SyntaxError { ss . str ()}; } constexpr operator value_type () const noexcept { return data ; } static auto infinity () noexcept { return static_cast < Double > ( std :: numeric_limits < value_type >:: infinity ()); } auto & operator += ( const double & rhs ) { data += rhs ; return * this ; } auto & operator *= ( const double & rhs ) { data *= rhs ; return * this ; } }; std :: ostream & operator << ( std :: ostream & os , const Double & rhs ) { return os << std :: fixed << rhs . data ; } std :: istream & operator >> ( std :: istream & is , Double & rhs ) { std :: string token {}; is >> token ; static const std :: regex infinity { R \" ( [+-]?INF ) \" }; std :: smatch result {}; if ( std :: regex_match ( token , result , infinity )) { #ifndef OPENSCENARIO_INTERPRETER_ALLOW_INFINITY #define OPENSCENARIO_INTERPRETER_DOUBLE_INFINITY max #else #define OPENSCENARIO_INTERPRETER_DOUBLE_INFINITY infinity #endif rhs . data = ( result . str ( 1 ) == \"-\" ? -1 : 1 ) * std :: numeric_limits < Double :: value_type >:: OPENSCENARIO_INTERPRETER_DOUBLE_INFINITY (); #undef OPENSCENARIO_INTERPRETER_DOUBLE_INFINITY } else { rhs . data = boost :: lexical_cast < Double :: value_type > ( token ); } return is ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__DOUBLE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__dimension_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dynamics_dimension.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::DynamicsDimension Defines # Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ dimension = DynamicsDimension :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ dimension = DynamicsDimension :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( NAME ) case DynamicsDimension :: NAME : return os << # NAME ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__DYNAMICS_DIMENSION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__DYNAMICS_DIMENSION_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ---- DynamicsDimension ------------------------------------------------------ * * <xsd:simpleType name=\"DynamicsDimension\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"rate\"/> * <xsd:enumeration value=\"time\"/> * <xsd:enumeration value=\"distance\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * -------------------------------------------------------------------------- */ struct DynamicsDimension { enum value_type { // A predefined constant rate is used to acquire the target value. rate , // A predefined time (duration) is used to acquire the target value. time , // A predefined distance used to acquire the target value. distance , } value ; constexpr DynamicsDimension ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , DynamicsDimension & dimension ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ dimension = DynamicsDimension::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( rate ); BOILERPLATE ( time ); BOILERPLATE ( distance ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" << buffer << \\ \"\\' is valid OpenSCENARIO value of type DynamicsDimension, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type DynamicsDimension\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const DynamicsDimension & dimension ) { switch ( dimension ) { #define BOILERPLATE(NAME) case DynamicsDimension::NAME: return os << #NAME; BOILERPLATE ( rate ); BOILERPLATE ( time ); BOILERPLATE ( distance ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class DynamicsDimension holds unexpected value \" << static_cast < DynamicsDimension :: value_type > ( dimension ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__DYNAMICS_DIMENSION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dynamics_dimension.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__dimension_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxdynamics_dimensionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dynamics_dimension.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__dimension_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__dimension_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::DynamicsDimension","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__dimension_8hpp/#defines","text":"Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__dimension_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__dimension_8hpp/#define-boilerplate","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ dimension = DynamicsDimension :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__dimension_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ dimension = DynamicsDimension :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__dimension_8hpp/#define-boilerplate_2","text":"#define BOILERPLATE( NAME ) case DynamicsDimension :: NAME : return os << # NAME ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__dimension_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__DYNAMICS_DIMENSION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__DYNAMICS_DIMENSION_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ---- DynamicsDimension ------------------------------------------------------ * * <xsd:simpleType name=\"DynamicsDimension\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"rate\"/> * <xsd:enumeration value=\"time\"/> * <xsd:enumeration value=\"distance\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * -------------------------------------------------------------------------- */ struct DynamicsDimension { enum value_type { // A predefined constant rate is used to acquire the target value. rate , // A predefined time (duration) is used to acquire the target value. time , // A predefined distance used to acquire the target value. distance , } value ; constexpr DynamicsDimension ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , DynamicsDimension & dimension ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ dimension = DynamicsDimension::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( rate ); BOILERPLATE ( time ); BOILERPLATE ( distance ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" << buffer << \\ \"\\' is valid OpenSCENARIO value of type DynamicsDimension, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type DynamicsDimension\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const DynamicsDimension & dimension ) { switch ( dimension ) { #define BOILERPLATE(NAME) case DynamicsDimension::NAME: return os << #NAME; BOILERPLATE ( rate ); BOILERPLATE ( time ); BOILERPLATE ( distance ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class DynamicsDimension holds unexpected value \" << static_cast < DynamicsDimension :: value_type > ( dimension ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__DYNAMICS_DIMENSION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__shape_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dynamics_shape.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::DynamicsShape Defines # Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ shape = DynamicsShape :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ shape = DynamicsShape :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( NAME ) case DynamicsShape :: NAME : return os << # NAME ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__DYNAMICS_SHAPE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__DYNAMICS_SHAPE_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ---- DynamicsShape ---------------------------------------------------------- * * <xsd:simpleType name=\"DynamicsShape\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"linear\"/> * <xsd:enumeration value=\"cubic\"/> * <xsd:enumeration value=\"sinusoidal\"/> * <xsd:enumeration value=\"step\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * -------------------------------------------------------------------------- */ struct DynamicsShape { enum value_type { // Value changes in a linear function: f(x) = f_0 + rate * x. linear , // Cubical transition f(x)=A*x^3+B*x^2+C*x+D with the constraint that the // gradient must be zero at start and end. cubic , // Sinusoidal transition f(x)=A*sin(x)+B with the constraint that the // gradient must be zero at start and end. sinusoidal , // Step transition. step , } value ; constexpr DynamicsShape ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , DynamicsShape & shape ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ shape = DynamicsShape::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( linear ); BOILERPLATE ( step ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" << buffer << \\ \"\\' is valid OpenSCENARIO value of type DynamicsShape, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") BOILERPLATE ( cubic ); BOILERPLATE ( sinusoidal ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type DynamicsShape\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const DynamicsShape & shape ) { switch ( shape ) { #define BOILERPLATE(NAME) case DynamicsShape::NAME: return os << #NAME; BOILERPLATE ( linear ); BOILERPLATE ( cubic ); BOILERPLATE ( sinusoidal ); BOILERPLATE ( step ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class DynamicsShape holds unexpected value \" << static_cast < DynamicsShape :: value_type > ( shape ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__DYNAMICS_SHAPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dynamics_shape.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__shape_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxdynamics_shapehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/dynamics_shape.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__shape_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__shape_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::DynamicsShape","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__shape_8hpp/#defines","text":"Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__shape_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__shape_8hpp/#define-boilerplate","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ shape = DynamicsShape :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__shape_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ shape = DynamicsShape :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__shape_8hpp/#define-boilerplate_2","text":"#define BOILERPLATE( NAME ) case DynamicsShape :: NAME : return os << # NAME ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/dynamics__shape_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__DYNAMICS_SHAPE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__DYNAMICS_SHAPE_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ---- DynamicsShape ---------------------------------------------------------- * * <xsd:simpleType name=\"DynamicsShape\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"linear\"/> * <xsd:enumeration value=\"cubic\"/> * <xsd:enumeration value=\"sinusoidal\"/> * <xsd:enumeration value=\"step\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * -------------------------------------------------------------------------- */ struct DynamicsShape { enum value_type { // Value changes in a linear function: f(x) = f_0 + rate * x. linear , // Cubical transition f(x)=A*x^3+B*x^2+C*x+D with the constraint that the // gradient must be zero at start and end. cubic , // Sinusoidal transition f(x)=A*sin(x)+B with the constraint that the // gradient must be zero at start and end. sinusoidal , // Step transition. step , } value ; constexpr DynamicsShape ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , DynamicsShape & shape ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ shape = DynamicsShape::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( linear ); BOILERPLATE ( step ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" << buffer << \\ \"\\' is valid OpenSCENARIO value of type DynamicsShape, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") BOILERPLATE ( cubic ); BOILERPLATE ( sinusoidal ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type DynamicsShape\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const DynamicsShape & shape ) { switch ( shape ) { #define BOILERPLATE(NAME) case DynamicsShape::NAME: return os << #NAME; BOILERPLATE ( linear ); BOILERPLATE ( cubic ); BOILERPLATE ( sinusoidal ); BOILERPLATE ( step ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class DynamicsShape holds unexpected value \" << static_cast < DynamicsShape :: value_type > ( shape ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__DYNAMICS_SHAPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/element_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/element.hpp # Namespaces # Name openscenario_interpreter::reader openscenario_interpreter Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__READER__ELEMENT_HPP_ #define OPENSCENARIO_INTERPRETER__READER__ELEMENT_HPP_ #include <openscenario_interpreter/iterator/size.hpp> #include <openscenario_interpreter/object.hpp> #include <openscenario_interpreter/type_traits/if_not_default_constructible.hpp> #include <openscenario_interpreter/utility/pugi_extension.hpp> #include <functional> #include <iterator> #include <limits> #include <string> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace reader { constexpr auto unbounded { std :: numeric_limits < typename std :: iterator_traits < typename pugi :: xml_node :: iterator >:: difference_type >:: max () }; template < typename T , typename Node , typename ... Ts > auto readElement ( const std :: string & name , const Node & parent , Ts && ... xs ) { if ( const auto child = parent . child ( name . c_str ())) { return T ( child , std :: forward < decltype ( xs ) > ( xs )...); } else { return IfNotDefaultConstructible < T >:: error ( parent . name (), name ); } } template < typename Node , typename Callee > void callWithElements ( const Node & parent , const std :: string & name , typename std :: iterator_traits < typename Node :: iterator >:: difference_type min_occurs , typename std :: iterator_traits < typename Node :: iterator >:: difference_type max_occurs , Callee && call_with ) { const auto children = parent . children ( name . c_str ()); if ( const auto size = iterator :: size ( children )) { if ( min_occurs != 0 && size < min_occurs ) { std :: stringstream ss {}; ss << parent . name () << \" requires class \" << name ; ss << \" at least \" << min_occurs << \" element\" << ( 1 < min_occurs ? \"s\" : \"\" ); ss << \", but \" << size << \" element\" << ( 1 < size ? \"s\" : \"\" ) << \" specified\" ; throw SyntaxError ( ss . str ()); } else if ( max_occurs < size ) { std :: stringstream ss {}; ss << parent . name () << \" requires class \" << name ; ss << \" at most \" << max_occurs << \" element\" << ( 1 < max_occurs ? \"s\" : \"\" ); ss << \", but \" << size << \" element\" << ( 1 < size ? \"s\" : \"\" ) << \" specified\" ; throw SyntaxError ( ss . str ()); } else { for ( const auto & child : children ) { call_with ( child ); } } } else if ( min_occurs != 0 ) { std :: stringstream ss {}; ss << parent . name () << \" requires class \" << name ; ss << \" at least \" << min_occurs << \" element\" << ( 1 < min_occurs ? \"s\" : \"\" ); ss << \", but there is no specification\" ; throw SyntaxError ( ss . str ()); } } template < typename Node , typename ... Ts > decltype ( auto ) choice ( const Node & node , Ts && ... xs ) { const std :: unordered_map < std :: string , std :: function < Element ( const Node & ) >> callees { std :: forward < decltype ( xs ) > ( xs )... }; std :: unordered_map < std :: string , Node > specs {}; for ( const auto & each : callees ) { if ( const auto child { node . child ( std :: get < 0 > ( each ). c_str ())}) { specs . emplace ( std :: get < 0 > ( each ), child ); } } auto print_keys_to = [ & ]( auto & os , const auto & xs ) -> decltype ( auto ) { if ( ! xs . empty ()) { for ( auto iter { std :: begin ( xs )}; iter != std :: end ( xs ); ++ iter ) { os << std :: get < 0 > ( * iter ); switch ( std :: distance ( iter , std :: end ( xs ))) { case 1 : return os ; case 2 : os << \" and \" ; break ; default : os << \", \" ; break ; } } } return os ; }; if ( specs . empty ()) { std :: stringstream ss {}; ss << \"Class \" << node . name () << \" requires one of following elements: \" ; print_keys_to ( ss , callees ); ss << \". But no element specified\" ; throw SyntaxError ( ss . str ()); } else if ( 1 < specs . size ()) { std :: stringstream ss {}; ss << \"Class \" << node . name () << \" requires just one of following elements: \" ; print_keys_to ( ss , callees ); ss << \". But \" << specs . size () << \" element\" << ( 1 < specs . size () ? \"s\" : \"\" ) << \" (\" ; print_keys_to ( ss , specs ); ss << \") specified\" ; throw SyntaxError ( ss . str ()); } else { const auto iter { std :: cbegin ( specs )}; return callees . at ( std :: get < 0 > ( * iter ))( std :: get < 1 > ( * iter )); } } template < typename Callee > decltype ( auto ) callWithElement ( const pugi :: xml_node & parent , const std :: string & name , Callee && call_with ) { return callWithElements ( parent , name , 1 , 1 , std :: forward < decltype ( call_with ) > ( call_with )); } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__READER__ELEMENT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/element.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/element_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterreaderelementhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/reader/element.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/element_8hpp/#namespaces","text":"Name openscenario_interpreter::reader openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/element_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__READER__ELEMENT_HPP_ #define OPENSCENARIO_INTERPRETER__READER__ELEMENT_HPP_ #include <openscenario_interpreter/iterator/size.hpp> #include <openscenario_interpreter/object.hpp> #include <openscenario_interpreter/type_traits/if_not_default_constructible.hpp> #include <openscenario_interpreter/utility/pugi_extension.hpp> #include <functional> #include <iterator> #include <limits> #include <string> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace reader { constexpr auto unbounded { std :: numeric_limits < typename std :: iterator_traits < typename pugi :: xml_node :: iterator >:: difference_type >:: max () }; template < typename T , typename Node , typename ... Ts > auto readElement ( const std :: string & name , const Node & parent , Ts && ... xs ) { if ( const auto child = parent . child ( name . c_str ())) { return T ( child , std :: forward < decltype ( xs ) > ( xs )...); } else { return IfNotDefaultConstructible < T >:: error ( parent . name (), name ); } } template < typename Node , typename Callee > void callWithElements ( const Node & parent , const std :: string & name , typename std :: iterator_traits < typename Node :: iterator >:: difference_type min_occurs , typename std :: iterator_traits < typename Node :: iterator >:: difference_type max_occurs , Callee && call_with ) { const auto children = parent . children ( name . c_str ()); if ( const auto size = iterator :: size ( children )) { if ( min_occurs != 0 && size < min_occurs ) { std :: stringstream ss {}; ss << parent . name () << \" requires class \" << name ; ss << \" at least \" << min_occurs << \" element\" << ( 1 < min_occurs ? \"s\" : \"\" ); ss << \", but \" << size << \" element\" << ( 1 < size ? \"s\" : \"\" ) << \" specified\" ; throw SyntaxError ( ss . str ()); } else if ( max_occurs < size ) { std :: stringstream ss {}; ss << parent . name () << \" requires class \" << name ; ss << \" at most \" << max_occurs << \" element\" << ( 1 < max_occurs ? \"s\" : \"\" ); ss << \", but \" << size << \" element\" << ( 1 < size ? \"s\" : \"\" ) << \" specified\" ; throw SyntaxError ( ss . str ()); } else { for ( const auto & child : children ) { call_with ( child ); } } } else if ( min_occurs != 0 ) { std :: stringstream ss {}; ss << parent . name () << \" requires class \" << name ; ss << \" at least \" << min_occurs << \" element\" << ( 1 < min_occurs ? \"s\" : \"\" ); ss << \", but there is no specification\" ; throw SyntaxError ( ss . str ()); } } template < typename Node , typename ... Ts > decltype ( auto ) choice ( const Node & node , Ts && ... xs ) { const std :: unordered_map < std :: string , std :: function < Element ( const Node & ) >> callees { std :: forward < decltype ( xs ) > ( xs )... }; std :: unordered_map < std :: string , Node > specs {}; for ( const auto & each : callees ) { if ( const auto child { node . child ( std :: get < 0 > ( each ). c_str ())}) { specs . emplace ( std :: get < 0 > ( each ), child ); } } auto print_keys_to = [ & ]( auto & os , const auto & xs ) -> decltype ( auto ) { if ( ! xs . empty ()) { for ( auto iter { std :: begin ( xs )}; iter != std :: end ( xs ); ++ iter ) { os << std :: get < 0 > ( * iter ); switch ( std :: distance ( iter , std :: end ( xs ))) { case 1 : return os ; case 2 : os << \" and \" ; break ; default : os << \", \" ; break ; } } } return os ; }; if ( specs . empty ()) { std :: stringstream ss {}; ss << \"Class \" << node . name () << \" requires one of following elements: \" ; print_keys_to ( ss , callees ); ss << \". But no element specified\" ; throw SyntaxError ( ss . str ()); } else if ( 1 < specs . size ()) { std :: stringstream ss {}; ss << \"Class \" << node . name () << \" requires just one of following elements: \" ; print_keys_to ( ss , callees ); ss << \". But \" << specs . size () << \" element\" << ( 1 < specs . size () ? \"s\" : \"\" ) << \" (\" ; print_keys_to ( ss , specs ); ss << \") specified\" ; throw SyntaxError ( ss . str ()); } else { const auto iter { std :: cbegin ( specs )}; return callees . at ( std :: get < 0 > ( * iter ))( std :: get < 1 > ( * iter )); } } template < typename Callee > decltype ( auto ) callWithElement ( const pugi :: xml_node & parent , const std :: string & name , Callee && call_with ) { return callWithElements ( parent , name , 1 , 1 , std :: forward < decltype ( call_with ) > ( call_with )); } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__READER__ELEMENT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/entities_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entities.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Entities Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ENTITIES_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ENTITIES_HPP_ #include <openscenario_interpreter/syntax/entity_selection.hpp> #include <openscenario_interpreter/syntax/scenario_object.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- Entities --------------------------------------------------------------- * * <xsd:complexType name=\"Entities\"> * <xsd:sequence> * <xsd:element name=\"ScenarioObject\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"ScenarioObject\"/> * <xsd:element name=\"EntitySelection\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"EntitySelection\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Entities { template < typename Node , typename Scope > explicit Entities ( const Node & node , Scope & outer_scope ) { callWithElements ( node , \"ScenarioObject\" , 0 , unbounded , [ & ]( auto && node ) { outer_scope . entities . emplace ( readAttribute < ScenarioObject :: Name > ( \"name\" , node , outer_scope ), make < ScenarioObject > ( node , outer_scope )); }); callWithElements ( node , \"EntitySelection\" , 0 , unbounded , UNSUPPORTED ()); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ENTITIES_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entities.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/entities_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxentitieshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entities.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/entities_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/entities_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Entities","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/entities_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ENTITIES_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ENTITIES_HPP_ #include <openscenario_interpreter/syntax/entity_selection.hpp> #include <openscenario_interpreter/syntax/scenario_object.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- Entities --------------------------------------------------------------- * * <xsd:complexType name=\"Entities\"> * <xsd:sequence> * <xsd:element name=\"ScenarioObject\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"ScenarioObject\"/> * <xsd:element name=\"EntitySelection\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"EntitySelection\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Entities { template < typename Node , typename Scope > explicit Entities ( const Node & node , Scope & outer_scope ) { callWithElements ( node , \"ScenarioObject\" , 0 , unbounded , [ & ]( auto && node ) { outer_scope . entities . emplace ( readAttribute < ScenarioObject :: Name > ( \"name\" , node , outer_scope ), make < ScenarioObject > ( node , outer_scope )); }); callWithElements ( node , \"EntitySelection\" , 0 , unbounded , UNSUPPORTED ()); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ENTITIES_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/entity__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::EntityAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_ACTION_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/reader/element.hpp> #include <openscenario_interpreter/syntax/add_entity_action.hpp> #include <openscenario_interpreter/syntax/delete_entity_action.hpp> #include <typeindex> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- EntityAction ----------------------------------------------------------- * * <xsd:complexType name=\"EntityAction\"> * <xsd:choice> * <xsd:element name=\"AddEntityAction\" type=\"AddEntityAction\"/> * <xsd:element name=\"DeleteEntityAction\" type=\"DeleteEntityAction\"/> * </xsd:choice> * <xsd:attribute name=\"entityRef\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct EntityAction : public Element { const String entity_ref ; const std :: true_type accomplished {}; template < typename Node , typename Scope > explicit EntityAction ( const Node & node , Scope & outer_scope ) : Element ( choice ( node , std :: make_pair ( \"AddEntityAction\" , [ & ]( auto && node ) { return make < AddEntityAction > ( node , outer_scope ); }), std :: make_pair ( \"DeleteEntityAction\" , [ & ]( auto && node ) { return make < DeleteEntityAction > ( node , outer_scope ); }) )), entity_ref ( readAttribute < String > ( \"entityRef\" , node , outer_scope )) {} decltype ( auto ) evaluate () const { static const std :: unordered_map < std :: type_index , std :: function < Element ( const String & ) >> overloads { { typeid ( AddEntityAction ), [ this ]( auto && ... xs ) { return as < AddEntityAction > ()( std :: forward < decltype ( xs ) > ( xs )...); } }, { typeid ( DeleteEntityAction ), [ this ]( auto && ... xs ) { return as < DeleteEntityAction > ()( std :: forward < decltype ( xs ) > ( xs )...); } } }; return overloads . at ( type ())( entity_ref ); } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/entity__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxentity_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/entity__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/entity__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::EntityAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/entity__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_ACTION_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/reader/element.hpp> #include <openscenario_interpreter/syntax/add_entity_action.hpp> #include <openscenario_interpreter/syntax/delete_entity_action.hpp> #include <typeindex> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- EntityAction ----------------------------------------------------------- * * <xsd:complexType name=\"EntityAction\"> * <xsd:choice> * <xsd:element name=\"AddEntityAction\" type=\"AddEntityAction\"/> * <xsd:element name=\"DeleteEntityAction\" type=\"DeleteEntityAction\"/> * </xsd:choice> * <xsd:attribute name=\"entityRef\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct EntityAction : public Element { const String entity_ref ; const std :: true_type accomplished {}; template < typename Node , typename Scope > explicit EntityAction ( const Node & node , Scope & outer_scope ) : Element ( choice ( node , std :: make_pair ( \"AddEntityAction\" , [ & ]( auto && node ) { return make < AddEntityAction > ( node , outer_scope ); }), std :: make_pair ( \"DeleteEntityAction\" , [ & ]( auto && node ) { return make < DeleteEntityAction > ( node , outer_scope ); }) )), entity_ref ( readAttribute < String > ( \"entityRef\" , node , outer_scope )) {} decltype ( auto ) evaluate () const { static const std :: unordered_map < std :: type_index , std :: function < Element ( const String & ) >> overloads { { typeid ( AddEntityAction ), [ this ]( auto && ... xs ) { return as < AddEntityAction > ()( std :: forward < decltype ( xs ) > ( xs )...); } }, { typeid ( DeleteEntityAction ), [ this ]( auto && ... xs ) { return as < DeleteEntityAction > ()( std :: forward < decltype ( xs ) > ( xs )...); } } }; return overloads . at ( type ())( entity_ref ); } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/entity__condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::EntityCondition Defines # Name ELEMENT (TYPENAME) Macro Documentation # define ELEMENT # #define ELEMENT( TYPENAME ) std :: make_pair ( \\ #TYPENAME, \\ [&](auto && node) { \\ return make<TYPENAME>(node, std::forward<decltype(xs)>(xs)...); \\ }) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_CONDITION_HPP_ #include <openscenario_interpreter/syntax/acceleration_condition.hpp> #include <openscenario_interpreter/syntax/collision_condition.hpp> #include <openscenario_interpreter/syntax/distance_condition.hpp> #include <openscenario_interpreter/syntax/reach_position_condition.hpp> #include <openscenario_interpreter/syntax/relative_distance_condition.hpp> #include <openscenario_interpreter/syntax/speed_condition.hpp> #include <openscenario_interpreter/syntax/stand_still_condition.hpp> #include <openscenario_interpreter/syntax/time_headway_condition.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- EntityCondition -------------------------------------------------------- * * <xsd:complexType name=\"EntityCondition\"> * <xsd:choice> * <xsd:element name=\"EndOfRoadCondition\" type=\"EndOfRoadCondition\"/> * <xsd:element name=\"CollisionCondition\" type=\"CollisionCondition\"/> * <xsd:element name=\"OffroadCondition\" type=\"OffroadCondition\"/> * <xsd:element name=\"TimeHeadwayCondition\" type=\"TimeHeadwayCondition\"/> * <xsd:element name=\"TimeToCollisionCondition\" type=\"TimeToCollisionCondition\"/> * <xsd:element name=\"AccelerationCondition\" type=\"AccelerationCondition\"/> * <xsd:element name=\"StandStillCondition\" type=\"StandStillCondition\"/> * <xsd:element name=\"SpeedCondition\" type=\"SpeedCondition\"/> * <xsd:element name=\"RelativeSpeedCondition\" type=\"RelativeSpeedCondition\"/> * <xsd:element name=\"TraveledDistanceCondition\" type=\"TraveledDistanceCondition\"/> * <xsd:element name=\"ReachPositionCondition\" type=\"ReachPositionCondition\"/> * <xsd:element name=\"DistanceCondition\" type=\"DistanceCondition\"/> * <xsd:element name=\"RelativeDistanceCondition\" type=\"RelativeDistanceCondition\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPENAME) \\ std::make_pair( \\ #TYPENAME, \\ [&](auto && node) { \\ return make<TYPENAME>(node, std::forward<decltype(xs)>(xs)...); \\ }) struct EntityCondition : public Element { template < typename Node , typename ... Ts > explicit EntityCondition ( const Node & node , Ts && ... xs ) : Element ( choice ( node , std :: make_pair ( \"EndOfRoadCondition\" , UNSUPPORTED ()), ELEMENT ( CollisionCondition ), std :: make_pair ( \"OffroadCondition\" , UNSUPPORTED ()), ELEMENT ( TimeHeadwayCondition ), std :: make_pair ( \"TimeToCollisionCondition\" , UNSUPPORTED ()), ELEMENT ( AccelerationCondition ), ELEMENT ( StandStillCondition ), ELEMENT ( SpeedCondition ), std :: make_pair ( \"RelativeSpeedCondition\" , UNSUPPORTED ()), std :: make_pair ( \"TraveledDistanceCondition\" , UNSUPPORTED ()), ELEMENT ( ReachPositionCondition ), ELEMENT ( DistanceCondition ), ELEMENT ( RelativeDistanceCondition ))) {} }; #undef ELEMENT } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/entity__condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxentity_conditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/entity__condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/entity__condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::EntityCondition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/entity__condition_8hpp/#defines","text":"Name ELEMENT (TYPENAME)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/entity__condition_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/entity__condition_8hpp/#define-element","text":"#define ELEMENT( TYPENAME ) std :: make_pair ( \\ #TYPENAME, \\ [&](auto && node) { \\ return make<TYPENAME>(node, std::forward<decltype(xs)>(xs)...); \\ })","title":"define ELEMENT"},{"location":"package/openscenario_interpreter/markdown/Files/entity__condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_CONDITION_HPP_ #include <openscenario_interpreter/syntax/acceleration_condition.hpp> #include <openscenario_interpreter/syntax/collision_condition.hpp> #include <openscenario_interpreter/syntax/distance_condition.hpp> #include <openscenario_interpreter/syntax/reach_position_condition.hpp> #include <openscenario_interpreter/syntax/relative_distance_condition.hpp> #include <openscenario_interpreter/syntax/speed_condition.hpp> #include <openscenario_interpreter/syntax/stand_still_condition.hpp> #include <openscenario_interpreter/syntax/time_headway_condition.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- EntityCondition -------------------------------------------------------- * * <xsd:complexType name=\"EntityCondition\"> * <xsd:choice> * <xsd:element name=\"EndOfRoadCondition\" type=\"EndOfRoadCondition\"/> * <xsd:element name=\"CollisionCondition\" type=\"CollisionCondition\"/> * <xsd:element name=\"OffroadCondition\" type=\"OffroadCondition\"/> * <xsd:element name=\"TimeHeadwayCondition\" type=\"TimeHeadwayCondition\"/> * <xsd:element name=\"TimeToCollisionCondition\" type=\"TimeToCollisionCondition\"/> * <xsd:element name=\"AccelerationCondition\" type=\"AccelerationCondition\"/> * <xsd:element name=\"StandStillCondition\" type=\"StandStillCondition\"/> * <xsd:element name=\"SpeedCondition\" type=\"SpeedCondition\"/> * <xsd:element name=\"RelativeSpeedCondition\" type=\"RelativeSpeedCondition\"/> * <xsd:element name=\"TraveledDistanceCondition\" type=\"TraveledDistanceCondition\"/> * <xsd:element name=\"ReachPositionCondition\" type=\"ReachPositionCondition\"/> * <xsd:element name=\"DistanceCondition\" type=\"DistanceCondition\"/> * <xsd:element name=\"RelativeDistanceCondition\" type=\"RelativeDistanceCondition\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPENAME) \\ std::make_pair( \\ #TYPENAME, \\ [&](auto && node) { \\ return make<TYPENAME>(node, std::forward<decltype(xs)>(xs)...); \\ }) struct EntityCondition : public Element { template < typename Node , typename ... Ts > explicit EntityCondition ( const Node & node , Ts && ... xs ) : Element ( choice ( node , std :: make_pair ( \"EndOfRoadCondition\" , UNSUPPORTED ()), ELEMENT ( CollisionCondition ), std :: make_pair ( \"OffroadCondition\" , UNSUPPORTED ()), ELEMENT ( TimeHeadwayCondition ), std :: make_pair ( \"TimeToCollisionCondition\" , UNSUPPORTED ()), ELEMENT ( AccelerationCondition ), ELEMENT ( StandStillCondition ), ELEMENT ( SpeedCondition ), std :: make_pair ( \"RelativeSpeedCondition\" , UNSUPPORTED ()), std :: make_pair ( \"TraveledDistanceCondition\" , UNSUPPORTED ()), ELEMENT ( ReachPositionCondition ), ELEMENT ( DistanceCondition ), ELEMENT ( RelativeDistanceCondition ))) {} }; #undef ELEMENT } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/entity__object_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_object.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::EntityObject Defines # Name ELEMENT (TYPE) Macro Documentation # define ELEMENT # #define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_OBJECT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_OBJECT_HPP_ #include <openscenario_interpreter/syntax/pedestrian.hpp> #include <openscenario_interpreter/syntax/vehicle.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) /* ---- EntityObject ----------------------------------------------------------- * * <xsd:group name=\"EntityObject\"> * <xsd:choice> * <xsd:element name=\"CatalogReference\" type=\"CatalogReference\"/> * <xsd:element name=\"Vehicle\" type=\"Vehicle\"/> * <xsd:element name=\"Pedestrian\" type=\"Pedestrian\"/> * <xsd:element name=\"MiscObject\" type=\"MiscObject\"/> * </xsd:choice> * </xsd:group> * * -------------------------------------------------------------------------- */ struct EntityObject : public Group { template < typename Node , typename ... Ts > explicit EntityObject ( const Node & node , Ts && ... xs ) : Group ( choice ( node , std :: make_pair ( \"CatalogReference\" , UNSUPPORTED ()), ELEMENT ( Vehicle ), ELEMENT ( Pedestrian ), std :: make_pair ( \"MiscObject\" , UNSUPPORTED ()))) {} }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_OBJECT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_object.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/entity__object_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxentity_objecthpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_object.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/entity__object_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/entity__object_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::EntityObject","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/entity__object_8hpp/#defines","text":"Name ELEMENT (TYPE)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/entity__object_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/entity__object_8hpp/#define-element","text":"#define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ })","title":"define ELEMENT"},{"location":"package/openscenario_interpreter/markdown/Files/entity__object_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_OBJECT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_OBJECT_HPP_ #include <openscenario_interpreter/syntax/pedestrian.hpp> #include <openscenario_interpreter/syntax/vehicle.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) /* ---- EntityObject ----------------------------------------------------------- * * <xsd:group name=\"EntityObject\"> * <xsd:choice> * <xsd:element name=\"CatalogReference\" type=\"CatalogReference\"/> * <xsd:element name=\"Vehicle\" type=\"Vehicle\"/> * <xsd:element name=\"Pedestrian\" type=\"Pedestrian\"/> * <xsd:element name=\"MiscObject\" type=\"MiscObject\"/> * </xsd:choice> * </xsd:group> * * -------------------------------------------------------------------------- */ struct EntityObject : public Group { template < typename Node , typename ... Ts > explicit EntityObject ( const Node & node , Ts && ... xs ) : Group ( choice ( node , std :: make_pair ( \"CatalogReference\" , UNSUPPORTED ()), ELEMENT ( Vehicle ), ELEMENT ( Pedestrian ), std :: make_pair ( \"MiscObject\" , UNSUPPORTED ()))) {} }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_OBJECT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/entity__ref_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_ref.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::EntityRef Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_REF_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_REF_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- EntityRef -------------------------------------------------------------- * * <xsd:complexType name=\"EntityRef\"> * <xsd:attribute name=\"entityRef\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct EntityRef : public String { template < typename ... Ts > explicit constexpr EntityRef ( Ts && ... xs ) : String ( std :: forward < decltype ( xs ) > ( xs )...) {} template < typename Node , typename Scope > explicit EntityRef ( const Node & node , Scope & scope ) : String ( readAttribute < String > ( \"entityRef\" , node , scope )) {} }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_REF_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_ref.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/entity__ref_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxentity_refhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_ref.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/entity__ref_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/entity__ref_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::EntityRef","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/entity__ref_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_REF_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_REF_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- EntityRef -------------------------------------------------------------- * * <xsd:complexType name=\"EntityRef\"> * <xsd:attribute name=\"entityRef\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct EntityRef : public String { template < typename ... Ts > explicit constexpr EntityRef ( Ts && ... xs ) : String ( std :: forward < decltype ( xs ) > ( xs )...) {} template < typename Node , typename Scope > explicit EntityRef ( const Node & node , Scope & scope ) : String ( readAttribute < String > ( \"entityRef\" , node , scope )) {} }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_REF_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/entity__selection_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_selection.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::EntitySelection Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_SELECTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_SELECTION_HPP_ #include <openscenario_interpreter/syntax/selected_entities.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== EntitySelection ====================================================== * * <xsd:complexType name=\"EntitySelection\"> * <xsd:sequence> * <xsd:element name=\"Members\" type=\"SelectedEntities\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct EntitySelection {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_SELECTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_selection.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/entity__selection_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxentity_selectionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/entity_selection.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/entity__selection_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/entity__selection_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::EntitySelection","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/entity__selection_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_SELECTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_SELECTION_HPP_ #include <openscenario_interpreter/syntax/selected_entities.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== EntitySelection ====================================================== * * <xsd:complexType name=\"EntitySelection\"> * <xsd:sequence> * <xsd:element name=\"Members\" type=\"SelectedEntities\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct EntitySelection {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ENTITY_SELECTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/equal__to_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional/equal_to.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::equal_to< T, typename std::enable_if< std::is_floating_point< T >::value >::type > struct openscenario_interpreter::syntax::equal_to Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__FUNCTIONAL__EQUAL_TO_HPP_ #define OPENSCENARIO_INTERPRETER__FUNCTIONAL__EQUAL_TO_HPP_ #include <cmath> #include <functional> #include <limits> #include <type_traits> namespace openscenario_interpreter { inline namespace syntax { template < typename T , typename = void > struct equal_to : public std :: equal_to < T > {}; template < typename T > struct equal_to < T , typename std :: enable_if < std :: is_floating_point < T >:: value >:: type > { constexpr auto operator ()( const T & lhs , const T & rhs ) const noexcept { return std :: abs ( lhs - rhs ) < std :: numeric_limits < typename std :: decay < T >:: type >:: epsilon (); } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__FUNCTIONAL__EQUAL_TO_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional/equal_to.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/equal__to_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterfunctionalequal_tohpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional/equal_to.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/equal__to_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/equal__to_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::equal_to< T, typename std::enable_if< std::is_floating_point< T >::value >::type > struct openscenario_interpreter::syntax::equal_to","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/equal__to_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__FUNCTIONAL__EQUAL_TO_HPP_ #define OPENSCENARIO_INTERPRETER__FUNCTIONAL__EQUAL_TO_HPP_ #include <cmath> #include <functional> #include <limits> #include <type_traits> namespace openscenario_interpreter { inline namespace syntax { template < typename T , typename = void > struct equal_to : public std :: equal_to < T > {}; template < typename T > struct equal_to < T , typename std :: enable_if < std :: is_floating_point < T >:: value >:: type > { constexpr auto operator ()( const T & lhs , const T & rhs ) const noexcept { return std :: abs ( lhs - rhs ) < std :: numeric_limits < typename std :: decay < T >:: type >:: epsilon (); } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__FUNCTIONAL__EQUAL_TO_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/error_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/error.hpp # Namespaces # Name openscenario_interpreter Classes # Name struct openscenario_interpreter::SyntaxError struct openscenario_interpreter::SemanticError struct openscenario_interpreter::ImplementationFault struct openscenario_interpreter::Error struct openscenario_interpreter::ConnectionError Defines # Name UNSUPPORTED () UNIMPLEMENTED (NAME) THROW_UNSUPPORTED_ERROR (PARENT) THROW_IMPLEMENTATION_FAULT () THROW (TYPENAME) Macro Documentation # define UNSUPPORTED # #define UNSUPPORTED( ) [ & ]( auto && node ) \\ { \\ std :: stringstream ss {}; \\ ss << \"given class \\' \" << node . name () << \\ \" is valid OpenSCENARIO element, but is not supported\" ; \\ throw SyntaxError ( ss . str ()); \\ return unspecified ; \\ } define UNIMPLEMENTED # #define UNIMPLEMENTED( NAME ) do { \\ std :: stringstream ss {}; \\ ss << \"given class \\' \" << NAME << \\ \" \\' is valid OpenSCENARIO element, but is not yet implemented\" ; \\ throw ImplementationFault { ss . str ()}; \\ } while ( false ) define THROW_UNSUPPORTED_ERROR # #define THROW_UNSUPPORTED_ERROR( PARENT ) [ & ]( auto && child ) \\ { \\ std :: stringstream ss {}; \\ ss << \"given class \\' \" << child . name () << \" \\' (element of class \\' \" << PARENT . name () << \\ \" \\' ) is valid OpenSCENARIO element, but is not supported\" ; \\ throw SyntaxError ( ss . str ()); \\ return unspecified ; \\ } define THROW_IMPLEMENTATION_FAULT # #define THROW_IMPLEMENTATION_FAULT( ) THROW ( ImplementationFault ) define THROW # #define THROW( TYPENAME ) do { \\ std :: stringstream ss {}; \\ ss << __FILE__ << \":\" << __LINE__ ; \\ throw TYPENAME { ss . str ()}; \\ } while ( false ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__ERROR_HPP_ #define OPENSCENARIO_INTERPRETER__ERROR_HPP_ #include <openscenario_interpreter/string/cat.hpp> #include <stdexcept> #include <string> #include <utility> namespace openscenario_interpreter { /* ---- Error ------------------------------------------------------------------ * * -- Error * |-- SyntaxError * |-- ConnectionError * |-- SemanticError * `-- ImplementationFault * * -------------------------------------------------------------------------- */ struct Error : public std :: runtime_error { template < typename ... Ts > explicit Error ( Ts && ... xs ) : std :: runtime_error ( cat ( std :: forward < decltype ( xs ) > ( xs )...)) {} }; struct SyntaxError : public Error { template < typename ... Ts > explicit SyntaxError ( Ts && ... xs ) : Error ( \"syntax-error: \" , std :: forward < decltype ( xs ) > ( xs )...) {} }; struct SemanticError : public Error { template < typename ... Ts > explicit SemanticError ( Ts && ... xs ) : Error ( \"semantic-error: \" , std :: forward < decltype ( xs ) > ( xs )...) {} }; struct ConnectionError : public Error { template < typename ... Ts > explicit ConnectionError ( Ts && ... xs ) : Error ( \"connection-error: \" , std :: forward < decltype ( xs ) > ( xs )...) {} }; struct ImplementationFault : public Error { template < typename ... Ts > explicit ImplementationFault ( Ts && ... xs ) : Error ( \"implementation-fault: \" , std :: forward < decltype ( xs ) > ( xs )...) {} }; #define THROW(TYPENAME) \\ do { \\ std::stringstream ss {}; \\ ss << __FILE__ << \":\" << __LINE__; \\ throw TYPENAME {ss.str()}; \\ } while (false) #define THROW_IMPLEMENTATION_FAULT() THROW(ImplementationFault) #define UNIMPLEMENTED(NAME) \\ do { \\ std::stringstream ss {}; \\ ss << \"given class \\'\" << NAME << \\ \"\\' is valid OpenSCENARIO element, but is not yet implemented\"; \\ throw ImplementationFault {ss.str()}; \\ } while (false) #define THROW_UNSUPPORTED_ERROR(PARENT) \\ [&](auto && child) \\ { \\ std::stringstream ss {}; \\ ss << \"given class \\'\" << child.name() << \"\\' (element of class \\'\" << PARENT.name() << \\ \"\\') is valid OpenSCENARIO element, but is not supported\"; \\ throw SyntaxError(ss.str()); \\ return unspecified; \\ } #define UNSUPPORTED() \\ [&](auto && node) \\ { \\ std::stringstream ss {}; \\ ss << \"given class \\'\" << node.name() << \\ \" is valid OpenSCENARIO element, but is not supported\"; \\ throw SyntaxError(ss.str()); \\ return unspecified; \\ } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__ERROR_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/error.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/error_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretererrorhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/error.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/error_8hpp/#namespaces","text":"Name openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/error_8hpp/#classes","text":"Name struct openscenario_interpreter::SyntaxError struct openscenario_interpreter::SemanticError struct openscenario_interpreter::ImplementationFault struct openscenario_interpreter::Error struct openscenario_interpreter::ConnectionError","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/error_8hpp/#defines","text":"Name UNSUPPORTED () UNIMPLEMENTED (NAME) THROW_UNSUPPORTED_ERROR (PARENT) THROW_IMPLEMENTATION_FAULT () THROW (TYPENAME)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/error_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/error_8hpp/#define-unsupported","text":"#define UNSUPPORTED( ) [ & ]( auto && node ) \\ { \\ std :: stringstream ss {}; \\ ss << \"given class \\' \" << node . name () << \\ \" is valid OpenSCENARIO element, but is not supported\" ; \\ throw SyntaxError ( ss . str ()); \\ return unspecified ; \\ }","title":"define UNSUPPORTED"},{"location":"package/openscenario_interpreter/markdown/Files/error_8hpp/#define-unimplemented","text":"#define UNIMPLEMENTED( NAME ) do { \\ std :: stringstream ss {}; \\ ss << \"given class \\' \" << NAME << \\ \" \\' is valid OpenSCENARIO element, but is not yet implemented\" ; \\ throw ImplementationFault { ss . str ()}; \\ } while ( false )","title":"define UNIMPLEMENTED"},{"location":"package/openscenario_interpreter/markdown/Files/error_8hpp/#define-throw_unsupported_error","text":"#define THROW_UNSUPPORTED_ERROR( PARENT ) [ & ]( auto && child ) \\ { \\ std :: stringstream ss {}; \\ ss << \"given class \\' \" << child . name () << \" \\' (element of class \\' \" << PARENT . name () << \\ \" \\' ) is valid OpenSCENARIO element, but is not supported\" ; \\ throw SyntaxError ( ss . str ()); \\ return unspecified ; \\ }","title":"define THROW_UNSUPPORTED_ERROR"},{"location":"package/openscenario_interpreter/markdown/Files/error_8hpp/#define-throw_implementation_fault","text":"#define THROW_IMPLEMENTATION_FAULT( ) THROW ( ImplementationFault )","title":"define THROW_IMPLEMENTATION_FAULT"},{"location":"package/openscenario_interpreter/markdown/Files/error_8hpp/#define-throw","text":"#define THROW( TYPENAME ) do { \\ std :: stringstream ss {}; \\ ss << __FILE__ << \":\" << __LINE__ ; \\ throw TYPENAME { ss . str ()}; \\ } while ( false )","title":"define THROW"},{"location":"package/openscenario_interpreter/markdown/Files/error_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__ERROR_HPP_ #define OPENSCENARIO_INTERPRETER__ERROR_HPP_ #include <openscenario_interpreter/string/cat.hpp> #include <stdexcept> #include <string> #include <utility> namespace openscenario_interpreter { /* ---- Error ------------------------------------------------------------------ * * -- Error * |-- SyntaxError * |-- ConnectionError * |-- SemanticError * `-- ImplementationFault * * -------------------------------------------------------------------------- */ struct Error : public std :: runtime_error { template < typename ... Ts > explicit Error ( Ts && ... xs ) : std :: runtime_error ( cat ( std :: forward < decltype ( xs ) > ( xs )...)) {} }; struct SyntaxError : public Error { template < typename ... Ts > explicit SyntaxError ( Ts && ... xs ) : Error ( \"syntax-error: \" , std :: forward < decltype ( xs ) > ( xs )...) {} }; struct SemanticError : public Error { template < typename ... Ts > explicit SemanticError ( Ts && ... xs ) : Error ( \"semantic-error: \" , std :: forward < decltype ( xs ) > ( xs )...) {} }; struct ConnectionError : public Error { template < typename ... Ts > explicit ConnectionError ( Ts && ... xs ) : Error ( \"connection-error: \" , std :: forward < decltype ( xs ) > ( xs )...) {} }; struct ImplementationFault : public Error { template < typename ... Ts > explicit ImplementationFault ( Ts && ... xs ) : Error ( \"implementation-fault: \" , std :: forward < decltype ( xs ) > ( xs )...) {} }; #define THROW(TYPENAME) \\ do { \\ std::stringstream ss {}; \\ ss << __FILE__ << \":\" << __LINE__; \\ throw TYPENAME {ss.str()}; \\ } while (false) #define THROW_IMPLEMENTATION_FAULT() THROW(ImplementationFault) #define UNIMPLEMENTED(NAME) \\ do { \\ std::stringstream ss {}; \\ ss << \"given class \\'\" << NAME << \\ \"\\' is valid OpenSCENARIO element, but is not yet implemented\"; \\ throw ImplementationFault {ss.str()}; \\ } while (false) #define THROW_UNSUPPORTED_ERROR(PARENT) \\ [&](auto && child) \\ { \\ std::stringstream ss {}; \\ ss << \"given class \\'\" << child.name() << \"\\' (element of class \\'\" << PARENT.name() << \\ \"\\') is valid OpenSCENARIO element, but is not supported\"; \\ throw SyntaxError(ss.str()); \\ return unspecified; \\ } #define UNSUPPORTED() \\ [&](auto && node) \\ { \\ std::stringstream ss {}; \\ ss << \"given class \\'\" << node.name() << \\ \" is valid OpenSCENARIO element, but is not supported\"; \\ throw SyntaxError(ss.str()); \\ return unspecified; \\ } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__ERROR_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/escape__sequence_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console/escape_sequence.hpp # Namespaces # Name openscenario_interpreter::console::foreground openscenario_interpreter::console::background openscenario_interpreter::console openscenario_interpreter Defines # Name BOILERPLATE (CODE, NAME) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( CODE , NAME ) auto NAME = []( std :: ostream & os ) -> decltype ( auto ) \\ { \\ return escape_sequence ( os , CODE ); \\ } Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__CONSOLE__ESCAPE_SEQUENCE_HPP_ #define OPENSCENARIO_INTERPRETER__CONSOLE__ESCAPE_SEQUENCE_HPP_ #include <openscenario_interpreter/console/is_console.hpp> #include <string> namespace openscenario_interpreter { inline namespace console { template < typename ... Ts > auto & escape_sequence ( std :: basic_ostream < Ts ... > & os , const std :: string & code ) { return is_console ( os ) ? ( os << \" \\x1b \" << code ) : os ; } #define BOILERPLATE(CODE, NAME) \\ auto NAME = [](std::ostream & os) -> decltype(auto) \\ { \\ return escape_sequence(os, CODE); \\ } BOILERPLATE ( \"[0m\" , reset ); BOILERPLATE ( \"[1m\" , bold ); BOILERPLATE ( \"[2m\" , faint ); BOILERPLATE ( \"[3m\" , italic ); // Not widely supported. Sometimes treated as inverse. BOILERPLATE ( \"[4m\" , underline ); BOILERPLATE ( \"[5m\" , slow_blink ); // Less than 150 per minite. BOILERPLATE ( \"[6m\" , rapid_blink ); // More than 150 per minite. Not widely supported. BOILERPLATE ( \"[7m\" , reverse ); BOILERPLATE ( \"[8m\" , conceal ); // Not widely supported. inline namespace foreground { BOILERPLATE ( \"[30m\" , black ); BOILERPLATE ( \"[31m\" , red ); BOILERPLATE ( \"[32m\" , green ); BOILERPLATE ( \"[33m\" , yellow ); BOILERPLATE ( \"[34m\" , blue ); BOILERPLATE ( \"[35m\" , magenta ); BOILERPLATE ( \"[36m\" , cyan ); BOILERPLATE ( \"[37m\" , white ); } // namespace foreground namespace background { BOILERPLATE ( \"[40m\" , black ); BOILERPLATE ( \"[41m\" , red ); BOILERPLATE ( \"[42m\" , green ); BOILERPLATE ( \"[43m\" , yellow ); BOILERPLATE ( \"[44m\" , blue ); BOILERPLATE ( \"[45m\" , magenta ); BOILERPLATE ( \"[46m\" , cyan ); BOILERPLATE ( \"[47m\" , white ); } // namespace background #undef BOILERPLATE } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__CONSOLE__ESCAPE_SEQUENCE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console/escape_sequence.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/escape__sequence_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterconsoleescape_sequencehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console/escape_sequence.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/escape__sequence_8hpp/#namespaces","text":"Name openscenario_interpreter::console::foreground openscenario_interpreter::console::background openscenario_interpreter::console openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/escape__sequence_8hpp/#defines","text":"Name BOILERPLATE (CODE, NAME)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/escape__sequence_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/escape__sequence_8hpp/#define-boilerplate","text":"#define BOILERPLATE( CODE , NAME ) auto NAME = []( std :: ostream & os ) -> decltype ( auto ) \\ { \\ return escape_sequence ( os , CODE ); \\ }","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/escape__sequence_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__CONSOLE__ESCAPE_SEQUENCE_HPP_ #define OPENSCENARIO_INTERPRETER__CONSOLE__ESCAPE_SEQUENCE_HPP_ #include <openscenario_interpreter/console/is_console.hpp> #include <string> namespace openscenario_interpreter { inline namespace console { template < typename ... Ts > auto & escape_sequence ( std :: basic_ostream < Ts ... > & os , const std :: string & code ) { return is_console ( os ) ? ( os << \" \\x1b \" << code ) : os ; } #define BOILERPLATE(CODE, NAME) \\ auto NAME = [](std::ostream & os) -> decltype(auto) \\ { \\ return escape_sequence(os, CODE); \\ } BOILERPLATE ( \"[0m\" , reset ); BOILERPLATE ( \"[1m\" , bold ); BOILERPLATE ( \"[2m\" , faint ); BOILERPLATE ( \"[3m\" , italic ); // Not widely supported. Sometimes treated as inverse. BOILERPLATE ( \"[4m\" , underline ); BOILERPLATE ( \"[5m\" , slow_blink ); // Less than 150 per minite. BOILERPLATE ( \"[6m\" , rapid_blink ); // More than 150 per minite. Not widely supported. BOILERPLATE ( \"[7m\" , reverse ); BOILERPLATE ( \"[8m\" , conceal ); // Not widely supported. inline namespace foreground { BOILERPLATE ( \"[30m\" , black ); BOILERPLATE ( \"[31m\" , red ); BOILERPLATE ( \"[32m\" , green ); BOILERPLATE ( \"[33m\" , yellow ); BOILERPLATE ( \"[34m\" , blue ); BOILERPLATE ( \"[35m\" , magenta ); BOILERPLATE ( \"[36m\" , cyan ); BOILERPLATE ( \"[37m\" , white ); } // namespace foreground namespace background { BOILERPLATE ( \"[40m\" , black ); BOILERPLATE ( \"[41m\" , red ); BOILERPLATE ( \"[42m\" , green ); BOILERPLATE ( \"[43m\" , yellow ); BOILERPLATE ( \"[44m\" , blue ); BOILERPLATE ( \"[45m\" , magenta ); BOILERPLATE ( \"[46m\" , cyan ); BOILERPLATE ( \"[47m\" , white ); } // namespace background #undef BOILERPLATE } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__CONSOLE__ESCAPE_SEQUENCE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/event_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/event.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Event Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__EVENT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__EVENT_HPP_ #include <openscenario_interpreter/syntax/action.hpp> #include <openscenario_interpreter/syntax/priority.hpp> #include <openscenario_interpreter/syntax/storyboard_element.hpp> #include <openscenario_interpreter/syntax/trigger.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- Event ------------------------------------------------------------------ * * <xsd:complexType name=\"Event\"> * <xsd:sequence> * <xsd:element name=\"Action\" maxOccurs=\"unbounded\" type=\"Action\"/> * <xsd:element name=\"StartTrigger\" type=\"Trigger\"/> * </xsd:sequence> * <xsd:attribute name=\"priority\" type=\"Priority\" use=\"required\"/> * <xsd:attribute name=\"maximumExecutionCount\" type=\"UnsignedInt\"/> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Event : public StoryboardElement < Event > , public Elements { // Name of the event. const String name ; // Priority of each event. const Priority priority ; Scope inner_scope ; Trigger start_trigger ; template < typename XML > explicit Event ( const XML & node , Scope & outer_scope ) : StoryboardElement ( readAttribute < UnsignedInt > ( \"maximumExecutionCount\" , node , outer_scope , UnsignedInt ( 1 ))), name ( readAttribute < String > ( \"name\" , node , outer_scope )), priority ( readAttribute < Priority > ( \"priority\" , node , outer_scope )), inner_scope ( outer_scope ), start_trigger ( readElement < Trigger > ( \"StartTrigger\" , node , inner_scope )) { callWithElements ( node , \"Action\" , 1 , unbounded , [ & ]( auto && node ) { return push_back ( readStoryboardElement < Action > ( node , inner_scope , maximum_execution_count )); }); } auto ready () { return start_trigger . evaluate (). as < Boolean > (); } static constexpr auto stopTriggered () noexcept { return false ; } /* ------------------------------------------------------------------------- * * An Event's goal is accomplished when all its Actions are in the * completeState. * * ---------------------------------------------------------------------- */ auto accomplished () const { return std :: all_of ( std :: begin ( * this ), std :: end ( * this ), []( auto && each ) { return each . template as < Action > (). complete (); }); } using StoryboardElement :: evaluate ; void stop () { for ( auto && each : * this ) { each . as < Action > (). override (); each . evaluate (); } } void run () { for ( auto && each : * this ) { each . evaluate (); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__EVENT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/event.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/event_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxeventhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/event.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/event_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/event_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Event","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/event_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__EVENT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__EVENT_HPP_ #include <openscenario_interpreter/syntax/action.hpp> #include <openscenario_interpreter/syntax/priority.hpp> #include <openscenario_interpreter/syntax/storyboard_element.hpp> #include <openscenario_interpreter/syntax/trigger.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- Event ------------------------------------------------------------------ * * <xsd:complexType name=\"Event\"> * <xsd:sequence> * <xsd:element name=\"Action\" maxOccurs=\"unbounded\" type=\"Action\"/> * <xsd:element name=\"StartTrigger\" type=\"Trigger\"/> * </xsd:sequence> * <xsd:attribute name=\"priority\" type=\"Priority\" use=\"required\"/> * <xsd:attribute name=\"maximumExecutionCount\" type=\"UnsignedInt\"/> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Event : public StoryboardElement < Event > , public Elements { // Name of the event. const String name ; // Priority of each event. const Priority priority ; Scope inner_scope ; Trigger start_trigger ; template < typename XML > explicit Event ( const XML & node , Scope & outer_scope ) : StoryboardElement ( readAttribute < UnsignedInt > ( \"maximumExecutionCount\" , node , outer_scope , UnsignedInt ( 1 ))), name ( readAttribute < String > ( \"name\" , node , outer_scope )), priority ( readAttribute < Priority > ( \"priority\" , node , outer_scope )), inner_scope ( outer_scope ), start_trigger ( readElement < Trigger > ( \"StartTrigger\" , node , inner_scope )) { callWithElements ( node , \"Action\" , 1 , unbounded , [ & ]( auto && node ) { return push_back ( readStoryboardElement < Action > ( node , inner_scope , maximum_execution_count )); }); } auto ready () { return start_trigger . evaluate (). as < Boolean > (); } static constexpr auto stopTriggered () noexcept { return false ; } /* ------------------------------------------------------------------------- * * An Event's goal is accomplished when all its Actions are in the * completeState. * * ---------------------------------------------------------------------- */ auto accomplished () const { return std :: all_of ( std :: begin ( * this ), std :: end ( * this ), []( auto && each ) { return each . template as < Action > (). complete (); }); } using StoryboardElement :: evaluate ; void stop () { for ( auto && each : * this ) { each . as < Action > (). override (); each . evaluate (); } } void run () { for ( auto && each : * this ) { each . evaluate (); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__EVENT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/expression_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/expression.hpp # Namespaces # Name openscenario_interpreter Classes # Name struct openscenario_interpreter::Expression Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__EXPRESSION_HPP_ #define OPENSCENARIO_INTERPRETER__EXPRESSION_HPP_ #include <openscenario_interpreter/pointer.hpp> namespace openscenario_interpreter { struct Expression { virtual const std :: type_info & type () const noexcept { return typeid ( Expression ); } virtual std :: ostream & write ( std :: ostream & os ) const { return IfHasStreamOutputOperator < Expression >:: applyIt ( os , * this ); } virtual Pointer < Expression > evaluate ( const Pointer < Expression > & ) { std :: stringstream ss {}; ss << \"no viable evaluation for class Expression\" ; throw ImplementationFault { ss . str ()}; } virtual bool accomplished () { return false ; } virtual const Pointer < Expression > & state () const { std :: stringstream ss {}; ss << \"class Expression is not stateful\" ; throw ImplementationFault { ss . str ()}; } virtual void start () { std :: stringstream ss {}; ss << \"class Expression is not startable\" ; throw ImplementationFault { ss . str ()}; } }; } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__EXPRESSION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/expression.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/expression_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterexpressionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/expression.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/expression_8hpp/#namespaces","text":"Name openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/expression_8hpp/#classes","text":"Name struct openscenario_interpreter::Expression","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/expression_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__EXPRESSION_HPP_ #define OPENSCENARIO_INTERPRETER__EXPRESSION_HPP_ #include <openscenario_interpreter/pointer.hpp> namespace openscenario_interpreter { struct Expression { virtual const std :: type_info & type () const noexcept { return typeid ( Expression ); } virtual std :: ostream & write ( std :: ostream & os ) const { return IfHasStreamOutputOperator < Expression >:: applyIt ( os , * this ); } virtual Pointer < Expression > evaluate ( const Pointer < Expression > & ) { std :: stringstream ss {}; ss << \"no viable evaluation for class Expression\" ; throw ImplementationFault { ss . str ()}; } virtual bool accomplished () { return false ; } virtual const Pointer < Expression > & state () const { std :: stringstream ss {}; ss << \"class Expression is not stateful\" ; throw ImplementationFault { ss . str ()}; } virtual void start () { std :: stringstream ss {}; ss << \"class Expression is not startable\" ; throw ImplementationFault { ss . str ()}; } }; } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__EXPRESSION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/file_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/file.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::File Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__FILE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__FILE_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/syntax/string.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- File ------------------------------------------------------------------- * * <xsd:complexType name=\"File\"> * <xsd:attribute name=\"filepath\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct File { using FilePath = String ; const FilePath filepath ; File () : filepath ( \"./\" ) {} template < typename ... Ts > explicit File ( Ts && ... xs ) : filepath ( readAttribute < FilePath > ( \"filepath\" , std :: forward < decltype ( xs ) > ( xs )...)) {} operator String () const noexcept { return filepath ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__FILE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/file.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/file_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxfilehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/file.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/file_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/file_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::File","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/file_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__FILE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__FILE_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/syntax/string.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- File ------------------------------------------------------------------- * * <xsd:complexType name=\"File\"> * <xsd:attribute name=\"filepath\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct File { using FilePath = String ; const FilePath filepath ; File () : filepath ( \"./\" ) {} template < typename ... Ts > explicit File ( Ts && ... xs ) : filepath ( readAttribute < FilePath > ( \"filepath\" , std :: forward < decltype ( xs ) > ( xs )...)) {} operator String () const noexcept { return filepath ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__FILE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/file__header_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/file_header.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::FileHeader Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__FILE_HEADER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__FILE_HEADER_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== FileHeader =========================================================== * * <xsd:complexType name=\"FileHeader\"> * <xsd:attribute name=\"revMajor\" type=\"UnsignedShort\" use=\"required\"/> * <xsd:attribute name=\"revMinor\" type=\"UnsignedShort\" use=\"required\"/> * <xsd:attribute name=\"date\" type=\"DateTime\" use=\"required\"/> * <xsd:attribute name=\"description\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"author\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct FileHeader { const UnsignedShort revMajor ; const UnsignedShort revMinor ; const String date ; const String description ; const String author ; template < typename Node , typename Scope > explicit FileHeader ( const Node & node , Scope & outer_scope ) : revMajor { readAttribute < UnsignedShort > ( \"revMajor\" , node , outer_scope )}, revMinor { readAttribute < UnsignedShort > ( \"revMinor\" , node , outer_scope )}, date { readAttribute < String > ( \"date\" , node , outer_scope )}, description { readAttribute < String > ( \"description\" , node , outer_scope )}, author { readAttribute < String > ( \"author\" , node , outer_scope )} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__FILE_HEADER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/file_header.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/file__header_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxfile_headerhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/file_header.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/file__header_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/file__header_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::FileHeader","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/file__header_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__FILE_HEADER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__FILE_HEADER_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== FileHeader =========================================================== * * <xsd:complexType name=\"FileHeader\"> * <xsd:attribute name=\"revMajor\" type=\"UnsignedShort\" use=\"required\"/> * <xsd:attribute name=\"revMinor\" type=\"UnsignedShort\" use=\"required\"/> * <xsd:attribute name=\"date\" type=\"DateTime\" use=\"required\"/> * <xsd:attribute name=\"description\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"author\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct FileHeader { const UnsignedShort revMajor ; const UnsignedShort revMinor ; const String date ; const String description ; const String author ; template < typename Node , typename Scope > explicit FileHeader ( const Node & node , Scope & outer_scope ) : revMajor { readAttribute < UnsignedShort > ( \"revMajor\" , node , outer_scope )}, revMinor { readAttribute < UnsignedShort > ( \"revMinor\" , node , outer_scope )}, date { readAttribute < String > ( \"date\" , node , outer_scope )}, description { readAttribute < String > ( \"description\" , node , outer_scope )}, author { readAttribute < String > ( \"author\" , node , outer_scope )} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__FILE_HEADER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/fold_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional/fold.hpp # Namespaces # Name openscenario_interpreter::functional openscenario_interpreter Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__FUNCTIONAL__FOLD_HPP_ #define OPENSCENARIO_INTERPRETER__FUNCTIONAL__FOLD_HPP_ #include <functional> #include <utility> namespace openscenario_interpreter { inline namespace functional { template < typename F , typename T > constexpr decltype ( auto ) fold_left ( F && , T && x ) { return std :: forward < decltype ( x ) > ( x ); } template < typename F , typename T , typename U , typename ... Ts > constexpr decltype ( auto ) fold_left ( F && f , T && x , U && y , Ts && ... xs ) { return fold_left ( f , f ( std :: forward < decltype ( x ) > ( x ), std :: forward < decltype ( y ) > ( y )), std :: forward < decltype ( xs ) > ( xs )...); } template < typename F , typename T > constexpr decltype ( auto ) fold_right ( F && , T && x ) { return std :: forward < decltype ( x ) > ( x ); } template < typename F , typename T , typename ... Ts > constexpr decltype ( auto ) fold_right ( F && f , T && x , Ts && ... xs ) { return f ( std :: forward < decltype ( x ) > ( x ), fold_right ( f , std :: forward < decltype ( xs ) > ( xs )...)); } } // namespace functional } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__FUNCTIONAL__FOLD_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional/fold.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/fold_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterfunctionalfoldhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/functional/fold.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/fold_8hpp/#namespaces","text":"Name openscenario_interpreter::functional openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/fold_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__FUNCTIONAL__FOLD_HPP_ #define OPENSCENARIO_INTERPRETER__FUNCTIONAL__FOLD_HPP_ #include <functional> #include <utility> namespace openscenario_interpreter { inline namespace functional { template < typename F , typename T > constexpr decltype ( auto ) fold_left ( F && , T && x ) { return std :: forward < decltype ( x ) > ( x ); } template < typename F , typename T , typename U , typename ... Ts > constexpr decltype ( auto ) fold_left ( F && f , T && x , U && y , Ts && ... xs ) { return fold_left ( f , f ( std :: forward < decltype ( x ) > ( x ), std :: forward < decltype ( y ) > ( y )), std :: forward < decltype ( xs ) > ( xs )...); } template < typename F , typename T > constexpr decltype ( auto ) fold_right ( F && , T && x ) { return std :: forward < decltype ( x ) > ( x ); } template < typename F , typename T , typename ... Ts > constexpr decltype ( auto ) fold_right ( F && f , T && x , Ts && ... xs ) { return f ( std :: forward < decltype ( x ) > ( x ), fold_right ( f , std :: forward < decltype ( xs ) > ( xs )...)); } } // namespace functional } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__FUNCTIONAL__FOLD_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/fork__exec_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/posix/fork_exec.hpp # Namespaces # Name openscenario_interpreter::posix openscenario_interpreter Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__POSIX__FORK_EXEC_HPP_ #define OPENSCENARIO_INTERPRETER__POSIX__FORK_EXEC_HPP_ #include <sys/types.h> #include <sys/wait.h> #include <unistd.h> #include <openscenario_interpreter/string/split.hpp> #include <iostream> #include <string> #include <system_error> #include <vector> namespace openscenario_interpreter { inline namespace posix { auto execvp ( const std :: vector < std :: string > & f_xs ) { std :: vector < std :: vector < char >> buffer {}; buffer . resize ( f_xs . size ()); std :: vector < std :: add_pointer < char >:: type > argv {}; argv . reserve ( f_xs . size ()); for ( const auto & each : f_xs ) { #ifndef NDEBUG std :: cout << std :: quoted ( each ) << std :: endl ; #endif buffer . emplace_back ( std :: begin ( each ), std :: end ( each )); buffer . back (). push_back ( '\\0' ); argv . push_back ( buffer . back (). data ()); } argv . emplace_back ( static_cast < std :: add_pointer < char >:: type > ( 0 )); return :: execvp ( argv [ 0 ], argv . data ()); } auto fork_exec ( const std :: vector < std :: string > & f_xs ) { const auto pid = fork (); if ( pid < 0 ) { throw std :: system_error ( errno , std :: system_category ()); } else { int status = 0 ; switch ( pid ) { case 0 : if ( execvp ( f_xs ) < 0 ) { std :: cerr << std :: system_error ( errno , std :: system_category ()). what () << std :: endl ; std :: exit ( EXIT_FAILURE ); } break ; default : do { :: waitpid ( pid , & status , WUNTRACED ); } while ( ! WIFEXITED ( status ) && ! WIFSIGNALED ( status )); } return EXIT_SUCCESS ; } } auto fork_exec ( const std :: string & f_xs ) { return fork_exec ( split ( f_xs )); } auto fork_exec ( const std :: string & f , const std :: string & xs ) { return fork_exec ( xs . empty () ? f : f + \" \" + xs ); } } // namespace posix } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__POSIX__FORK_EXEC_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/posix/fork_exec.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/fork__exec_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterposixfork_exechpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/posix/fork_exec.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/fork__exec_8hpp/#namespaces","text":"Name openscenario_interpreter::posix openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/fork__exec_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__POSIX__FORK_EXEC_HPP_ #define OPENSCENARIO_INTERPRETER__POSIX__FORK_EXEC_HPP_ #include <sys/types.h> #include <sys/wait.h> #include <unistd.h> #include <openscenario_interpreter/string/split.hpp> #include <iostream> #include <string> #include <system_error> #include <vector> namespace openscenario_interpreter { inline namespace posix { auto execvp ( const std :: vector < std :: string > & f_xs ) { std :: vector < std :: vector < char >> buffer {}; buffer . resize ( f_xs . size ()); std :: vector < std :: add_pointer < char >:: type > argv {}; argv . reserve ( f_xs . size ()); for ( const auto & each : f_xs ) { #ifndef NDEBUG std :: cout << std :: quoted ( each ) << std :: endl ; #endif buffer . emplace_back ( std :: begin ( each ), std :: end ( each )); buffer . back (). push_back ( '\\0' ); argv . push_back ( buffer . back (). data ()); } argv . emplace_back ( static_cast < std :: add_pointer < char >:: type > ( 0 )); return :: execvp ( argv [ 0 ], argv . data ()); } auto fork_exec ( const std :: vector < std :: string > & f_xs ) { const auto pid = fork (); if ( pid < 0 ) { throw std :: system_error ( errno , std :: system_category ()); } else { int status = 0 ; switch ( pid ) { case 0 : if ( execvp ( f_xs ) < 0 ) { std :: cerr << std :: system_error ( errno , std :: system_category ()). what () << std :: endl ; std :: exit ( EXIT_FAILURE ); } break ; default : do { :: waitpid ( pid , & status , WUNTRACED ); } while ( ! WIFEXITED ( status ) && ! WIFSIGNALED ( status )); } return EXIT_SUCCESS ; } } auto fork_exec ( const std :: string & f_xs ) { return fork_exec ( split ( f_xs )); } auto fork_exec ( const std :: string & f , const std :: string & xs ) { return fork_exec ( xs . empty () ? f : f + \" \" + xs ); } } // namespace posix } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__POSIX__FORK_EXEC_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/global__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/global_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::GlobalAction Defines # Name ELEMENT (TYPE) Macro Documentation # define ELEMENT # #define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__GLOBAL_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__GLOBAL_ACTION_HPP_ #include <openscenario_interpreter/syntax/entity_action.hpp> #include <openscenario_interpreter/syntax/infrastructure_action.hpp> #include <openscenario_interpreter/syntax/parameter_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- GlobalAction ----------------------------------------------------------- * * <xsd:complexType name=\"GlobalAction\"> * <xsd:choice> * <xsd:element name=\"EnvironmentAction\" type=\"EnvironmentAction\"/> * <xsd:element name=\"EntityAction\" type=\"EntityAction\"/> * <xsd:element name=\"ParameterAction\" type=\"ParameterAction\"/> * <xsd:element name=\"InfrastructureAction\" type=\"InfrastructureAction\"/> * <xsd:element name=\"TrafficAction\" type=\"TrafficAction\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) struct GlobalAction : public Element { template < typename Node , typename ... Ts > explicit GlobalAction ( const Node & node , Ts && ... xs ) : Element ( choice ( node , std :: make_pair ( \"EnvironmentAction\" , UNSUPPORTED ()), ELEMENT ( EntityAction ), ELEMENT ( ParameterAction ), std :: make_pair ( \"InfrastructureAction\" , UNSUPPORTED ()), std :: make_pair ( \"TrafficAction\" , UNSUPPORTED ()))) {} }; #undef ELEMENT } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__GLOBAL_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/global_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/global__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxglobal_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/global_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/global__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/global__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::GlobalAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/global__action_8hpp/#defines","text":"Name ELEMENT (TYPE)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/global__action_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/global__action_8hpp/#define-element","text":"#define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ })","title":"define ELEMENT"},{"location":"package/openscenario_interpreter/markdown/Files/global__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__GLOBAL_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__GLOBAL_ACTION_HPP_ #include <openscenario_interpreter/syntax/entity_action.hpp> #include <openscenario_interpreter/syntax/infrastructure_action.hpp> #include <openscenario_interpreter/syntax/parameter_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- GlobalAction ----------------------------------------------------------- * * <xsd:complexType name=\"GlobalAction\"> * <xsd:choice> * <xsd:element name=\"EnvironmentAction\" type=\"EnvironmentAction\"/> * <xsd:element name=\"EntityAction\" type=\"EntityAction\"/> * <xsd:element name=\"ParameterAction\" type=\"ParameterAction\"/> * <xsd:element name=\"InfrastructureAction\" type=\"InfrastructureAction\"/> * <xsd:element name=\"TrafficAction\" type=\"TrafficAction\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) struct GlobalAction : public Element { template < typename Node , typename ... Ts > explicit GlobalAction ( const Node & node , Ts && ... xs ) : Element ( choice ( node , std :: make_pair ( \"EnvironmentAction\" , UNSUPPORTED ()), ELEMENT ( EntityAction ), ELEMENT ( ParameterAction ), std :: make_pair ( \"InfrastructureAction\" , UNSUPPORTED ()), std :: make_pair ( \"TrafficAction\" , UNSUPPORTED ()))) {} }; #undef ELEMENT } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__GLOBAL_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__accomplished_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_accomplished.hpp # Namespaces # Name openscenario_interpreter::type_traits openscenario_interpreter Classes # Name struct openscenario_interpreter::type_traits::HasMemberFunctionAccomplished< T, void_t< decltype(std::declval< T >().accomplished())> > struct openscenario_interpreter::type_traits::HasMemberFunctionAccomplished Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_ACCOMPLISHED_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_ACCOMPLISHED_HPP_ #include <openscenario_interpreter/type_traits/void_t.hpp> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct HasMemberFunctionAccomplished : public std :: false_type {}; template < typename T > struct HasMemberFunctionAccomplished < T , void_t < decltype ( std :: declval < T > (). accomplished ()) >> : public std :: true_type {}; } // namespace type_traits } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_ACCOMPLISHED_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_accomplished.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__accomplished_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretertype_traitshas_member_function_accomplishedhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_accomplished.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__accomplished_8hpp/#namespaces","text":"Name openscenario_interpreter::type_traits openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__accomplished_8hpp/#classes","text":"Name struct openscenario_interpreter::type_traits::HasMemberFunctionAccomplished< T, void_t< decltype(std::declval< T >().accomplished())> > struct openscenario_interpreter::type_traits::HasMemberFunctionAccomplished","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__accomplished_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_ACCOMPLISHED_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_ACCOMPLISHED_HPP_ #include <openscenario_interpreter/type_traits/void_t.hpp> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct HasMemberFunctionAccomplished : public std :: false_type {}; template < typename T > struct HasMemberFunctionAccomplished < T , void_t < decltype ( std :: declval < T > (). accomplished ()) >> : public std :: true_type {}; } // namespace type_traits } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_ACCOMPLISHED_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__evaluate_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_evaluate.hpp # Namespaces # Name openscenario_interpreter::type_traits openscenario_interpreter Classes # Name struct openscenario_interpreter::type_traits::HasMemberFunctionEvaluate< T, void_t< decltype(std::declval< T >().evaluate())> > struct openscenario_interpreter::type_traits::HasMemberFunctionEvaluate Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_EVALUATE_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_EVALUATE_HPP_ #include <openscenario_interpreter/type_traits/void_t.hpp> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct HasMemberFunctionEvaluate : public std :: false_type {}; template < typename T > struct HasMemberFunctionEvaluate < T , void_t < decltype ( std :: declval < T > (). evaluate ()) >> : public std :: true_type {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_EVALUATE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_evaluate.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__evaluate_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretertype_traitshas_member_function_evaluatehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_evaluate.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__evaluate_8hpp/#namespaces","text":"Name openscenario_interpreter::type_traits openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__evaluate_8hpp/#classes","text":"Name struct openscenario_interpreter::type_traits::HasMemberFunctionEvaluate< T, void_t< decltype(std::declval< T >().evaluate())> > struct openscenario_interpreter::type_traits::HasMemberFunctionEvaluate","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__evaluate_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_EVALUATE_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_EVALUATE_HPP_ #include <openscenario_interpreter/type_traits/void_t.hpp> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct HasMemberFunctionEvaluate : public std :: false_type {}; template < typename T > struct HasMemberFunctionEvaluate < T , void_t < decltype ( std :: declval < T > (). evaluate ()) >> : public std :: true_type {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_EVALUATE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__start_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_start.hpp # Namespaces # Name openscenario_interpreter::type_traits openscenario_interpreter Classes # Name struct openscenario_interpreter::type_traits::HasMemberFunctionStart< T, void_t< decltype(std::declval< T >().start())> > struct openscenario_interpreter::type_traits::HasMemberFunctionStart Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_START_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_START_HPP_ #include <openscenario_interpreter/type_traits/void_t.hpp> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct HasMemberFunctionStart : public std :: false_type {}; template < typename T > struct HasMemberFunctionStart < T , void_t < decltype ( std :: declval < T > (). start ()) >> : public std :: true_type {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_START_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_start.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__start_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretertype_traitshas_member_function_starthpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_start.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__start_8hpp/#namespaces","text":"Name openscenario_interpreter::type_traits openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__start_8hpp/#classes","text":"Name struct openscenario_interpreter::type_traits::HasMemberFunctionStart< T, void_t< decltype(std::declval< T >().start())> > struct openscenario_interpreter::type_traits::HasMemberFunctionStart","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__start_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_START_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_START_HPP_ #include <openscenario_interpreter/type_traits/void_t.hpp> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct HasMemberFunctionStart : public std :: false_type {}; template < typename T > struct HasMemberFunctionStart < T , void_t < decltype ( std :: declval < T > (). start ()) >> : public std :: true_type {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_START_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__state_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_state.hpp # Namespaces # Name openscenario_interpreter::type_traits openscenario_interpreter Classes # Name struct openscenario_interpreter::type_traits::HasMemberFunctionState< T, void_t< decltype(std::declval< T >().state())> > struct openscenario_interpreter::type_traits::HasMemberFunctionState Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_STATE_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_STATE_HPP_ #include <openscenario_interpreter/type_traits/void_t.hpp> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct HasMemberFunctionState : public std :: false_type {}; template < typename T > struct HasMemberFunctionState < T , void_t < decltype ( std :: declval < T > (). state ()) >> : public std :: true_type {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_STATE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_state.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__state_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretertype_traitshas_member_function_statehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_member_function_state.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__state_8hpp/#namespaces","text":"Name openscenario_interpreter::type_traits openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__state_8hpp/#classes","text":"Name struct openscenario_interpreter::type_traits::HasMemberFunctionState< T, void_t< decltype(std::declval< T >().state())> > struct openscenario_interpreter::type_traits::HasMemberFunctionState","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/has__member__function__state_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_STATE_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_STATE_HPP_ #include <openscenario_interpreter/type_traits/void_t.hpp> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct HasMemberFunctionState : public std :: false_type {}; template < typename T > struct HasMemberFunctionState < T , void_t < decltype ( std :: declval < T > (). state ()) >> : public std :: true_type {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_MEMBER_FUNCTION_STATE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/has__stream__output__operator_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_stream_output_operator.hpp # Namespaces # Name openscenario_interpreter::concepts openscenario_interpreter Classes # Name struct openscenario_interpreter::concepts::HasStreamOutputOperator< T, void_t< decltype(std::declval< std::ostream & >()<< std::declval< const T & >())> > struct openscenario_interpreter::concepts::HasStreamOutputOperator Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_STREAM_OUTPUT_OPERATOR_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_STREAM_OUTPUT_OPERATOR_HPP_ #include <openscenario_interpreter/type_traits/void_t.hpp> #include <iostream> namespace openscenario_interpreter { inline namespace concepts { template < typename T , typename = void > struct HasStreamOutputOperator : public std :: false_type {}; template < typename T > struct HasStreamOutputOperator < T , void_t < decltype ( std :: declval < std :: ostream &> () << std :: declval < const T &> ()) >> : public std :: true_type {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_STREAM_OUTPUT_OPERATOR_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_stream_output_operator.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/has__stream__output__operator_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretertype_traitshas_stream_output_operatorhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/has_stream_output_operator.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/has__stream__output__operator_8hpp/#namespaces","text":"Name openscenario_interpreter::concepts openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/has__stream__output__operator_8hpp/#classes","text":"Name struct openscenario_interpreter::concepts::HasStreamOutputOperator< T, void_t< decltype(std::declval< std::ostream & >()<< std::declval< const T & >())> > struct openscenario_interpreter::concepts::HasStreamOutputOperator","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/has__stream__output__operator_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_STREAM_OUTPUT_OPERATOR_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_STREAM_OUTPUT_OPERATOR_HPP_ #include <openscenario_interpreter/type_traits/void_t.hpp> #include <iostream> namespace openscenario_interpreter { inline namespace concepts { template < typename T , typename = void > struct HasStreamOutputOperator : public std :: false_type {}; template < typename T > struct HasStreamOutputOperator < T , void_t < decltype ( std :: declval < std :: ostream &> () << std :: declval < const T &> ()) >> : public std :: true_type {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__HAS_STREAM_OUTPUT_OPERATOR_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/highlighter_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/highlighter.hpp # Namespaces # Name openscenario_interpreter::utility openscenario_interpreter Classes # Name struct openscenario_interpreter::utility::AttributeHighlighter Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__UTILITY__HIGHLIGHTER_HPP_ #define OPENSCENARIO_INTERPRETER__UTILITY__HIGHLIGHTER_HPP_ #include <openscenario_interpreter/type_traits/has_stream_output_operator.hpp> #include <iostream> #include <string> #include <utility> namespace openscenario_interpreter { inline namespace utility { struct AttributeHighlighter { const std :: string name , value ; template < typename ... Ts > decltype ( auto ) operator ()( std :: basic_ostream < Ts ... >& os ) const { return os << yellow << name << reset << \"=\" << cyan << \" \\\" \" << value << \" \\\" \" << reset ; } }; template < typename ... Ts > decltype ( auto ) operator << ( std :: basic_ostream < Ts ... >& os , const AttributeHighlighter & highlight ) { return highlight ( os ); } template < typename T , typename = typename std :: enable_if < HasStreamOutputOperator < T >:: value >:: type > auto highlight ( const std :: string & name , const T & value ) { return AttributeHighlighter { name , boost :: lexical_cast < std :: string > ( value ) }; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__UTILITY__HIGHLIGHTER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/highlighter.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/highlighter_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterutilityhighlighterhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/highlighter.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/highlighter_8hpp/#namespaces","text":"Name openscenario_interpreter::utility openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/highlighter_8hpp/#classes","text":"Name struct openscenario_interpreter::utility::AttributeHighlighter","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/highlighter_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__UTILITY__HIGHLIGHTER_HPP_ #define OPENSCENARIO_INTERPRETER__UTILITY__HIGHLIGHTER_HPP_ #include <openscenario_interpreter/type_traits/has_stream_output_operator.hpp> #include <iostream> #include <string> #include <utility> namespace openscenario_interpreter { inline namespace utility { struct AttributeHighlighter { const std :: string name , value ; template < typename ... Ts > decltype ( auto ) operator ()( std :: basic_ostream < Ts ... >& os ) const { return os << yellow << name << reset << \"=\" << cyan << \" \\\" \" << value << \" \\\" \" << reset ; } }; template < typename ... Ts > decltype ( auto ) operator << ( std :: basic_ostream < Ts ... >& os , const AttributeHighlighter & highlight ) { return highlight ( os ); } template < typename T , typename = typename std :: enable_if < HasStreamOutputOperator < T >:: value >:: type > auto highlight ( const std :: string & name , const T & value ) { return AttributeHighlighter { name , boost :: lexical_cast < std :: string > ( value ) }; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__UTILITY__HIGHLIGHTER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__accomplished_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_accomplished.hpp # Namespaces # Name openscenario_interpreter::type_traits openscenario_interpreter Classes # Name struct openscenario_interpreter::type_traits::IfHasMemberFunctionAccomplished< T, typename std::enable_if< HasMemberFunctionAccomplished< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionAccomplished Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_ACCOMPLISHED_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_ACCOMPLISHED_HPP_ #include <openscenario_interpreter/type_traits/has_member_function_accomplished.hpp> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct IfHasMemberFunctionAccomplished { static constexpr auto callIt ( const T & ) noexcept { return false ; } }; template < typename T > struct IfHasMemberFunctionAccomplished < T , typename std :: enable_if < HasMemberFunctionAccomplished < T >:: value >:: type > { static decltype ( auto ) callIt ( T & is ) { return is . accomplished (); } }; } // inline namespace type_traits } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_ACCOMPLISHED_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_accomplished.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__accomplished_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretertype_traitsif_has_member_function_accomplishedhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_accomplished.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__accomplished_8hpp/#namespaces","text":"Name openscenario_interpreter::type_traits openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__accomplished_8hpp/#classes","text":"Name struct openscenario_interpreter::type_traits::IfHasMemberFunctionAccomplished< T, typename std::enable_if< HasMemberFunctionAccomplished< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionAccomplished","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__accomplished_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_ACCOMPLISHED_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_ACCOMPLISHED_HPP_ #include <openscenario_interpreter/type_traits/has_member_function_accomplished.hpp> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct IfHasMemberFunctionAccomplished { static constexpr auto callIt ( const T & ) noexcept { return false ; } }; template < typename T > struct IfHasMemberFunctionAccomplished < T , typename std :: enable_if < HasMemberFunctionAccomplished < T >:: value >:: type > { static decltype ( auto ) callIt ( T & is ) { return is . accomplished (); } }; } // inline namespace type_traits } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_ACCOMPLISHED_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__evaluate_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_evaluate.hpp # Namespaces # Name openscenario_interpreter::type_traits openscenario_interpreter Classes # Name struct openscenario_interpreter::type_traits::IfHasMemberFunctionEvaluate< T, typename std::enable_if< HasMemberFunctionEvaluate< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionEvaluate Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_EVALUATE_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_EVALUATE_HPP_ #include <openscenario_interpreter/type_traits/has_member_function_evaluate.hpp> #include <utility> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct IfHasMemberFunctionEvaluate { template < typename Result > static constexpr Result callIt ( T & , const Result & as_self_evaluating ) { return as_self_evaluating ; } }; template < typename T > struct IfHasMemberFunctionEvaluate < T , typename std :: enable_if < HasMemberFunctionEvaluate < T >:: value >:: type > { template < typename Result > static constexpr Result callIt ( T & then , const Result & ) { return then . evaluate (); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_EVALUATE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_evaluate.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__evaluate_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretertype_traitsif_has_member_function_evaluatehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_evaluate.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__evaluate_8hpp/#namespaces","text":"Name openscenario_interpreter::type_traits openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__evaluate_8hpp/#classes","text":"Name struct openscenario_interpreter::type_traits::IfHasMemberFunctionEvaluate< T, typename std::enable_if< HasMemberFunctionEvaluate< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionEvaluate","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__evaluate_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_EVALUATE_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_EVALUATE_HPP_ #include <openscenario_interpreter/type_traits/has_member_function_evaluate.hpp> #include <utility> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct IfHasMemberFunctionEvaluate { template < typename Result > static constexpr Result callIt ( T & , const Result & as_self_evaluating ) { return as_self_evaluating ; } }; template < typename T > struct IfHasMemberFunctionEvaluate < T , typename std :: enable_if < HasMemberFunctionEvaluate < T >:: value >:: type > { template < typename Result > static constexpr Result callIt ( T & then , const Result & ) { return then . evaluate (); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_EVALUATE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__start_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_start.hpp # Namespaces # Name openscenario_interpreter::type_traits openscenario_interpreter Classes # Name struct openscenario_interpreter::type_traits::IfHasMemberFunctionStart< T, typename std::enable_if< HasMemberFunctionStart< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionStart Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_START_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_START_HPP_ #include <openscenario_interpreter/type_traits/has_member_function_start.hpp> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct IfHasMemberFunctionStart { static constexpr void callIt ( const T & ) noexcept {} }; template < typename T > struct IfHasMemberFunctionStart < T , typename std :: enable_if < HasMemberFunctionStart < T >:: value >:: type > { static constexpr decltype ( auto ) callIt ( T & then ) { return then . start (); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_START_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_start.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__start_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretertype_traitsif_has_member_function_starthpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_start.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__start_8hpp/#namespaces","text":"Name openscenario_interpreter::type_traits openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__start_8hpp/#classes","text":"Name struct openscenario_interpreter::type_traits::IfHasMemberFunctionStart< T, typename std::enable_if< HasMemberFunctionStart< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionStart","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__start_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_START_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_START_HPP_ #include <openscenario_interpreter/type_traits/has_member_function_start.hpp> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct IfHasMemberFunctionStart { static constexpr void callIt ( const T & ) noexcept {} }; template < typename T > struct IfHasMemberFunctionStart < T , typename std :: enable_if < HasMemberFunctionStart < T >:: value >:: type > { static constexpr decltype ( auto ) callIt ( T & then ) { return then . start (); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_START_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__state_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_state.hpp # Namespaces # Name openscenario_interpreter::type_traits openscenario_interpreter Classes # Name struct openscenario_interpreter::type_traits::IfHasMemberFunctionState< T, typename std::enable_if< HasMemberFunctionState< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionState Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_STATE_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_STATE_HPP_ #include <openscenario_interpreter/type_traits/has_member_function_state.hpp> #include <sstream> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct IfHasMemberFunctionState { template < typename Result > static const Result & callIt ( const T & ) { std :: stringstream ss {}; ss << \"class \" << typeid ( T ). name () << \" is not has member function 'state'\" ; throw ImplementationFault { ss . str ()}; } }; template < typename T > struct IfHasMemberFunctionState < T , typename std :: enable_if < HasMemberFunctionState < T >:: value >:: type > { template < typename Result > static const Result & callIt ( const T & callee ) { return callee . state (); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_STATE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_state.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__state_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretertype_traitsif_has_member_function_statehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_member_function_state.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__state_8hpp/#namespaces","text":"Name openscenario_interpreter::type_traits openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__state_8hpp/#classes","text":"Name struct openscenario_interpreter::type_traits::IfHasMemberFunctionState< T, typename std::enable_if< HasMemberFunctionState< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionState","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__member__function__state_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_STATE_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_STATE_HPP_ #include <openscenario_interpreter/type_traits/has_member_function_state.hpp> #include <sstream> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct IfHasMemberFunctionState { template < typename Result > static const Result & callIt ( const T & ) { std :: stringstream ss {}; ss << \"class \" << typeid ( T ). name () << \" is not has member function 'state'\" ; throw ImplementationFault { ss . str ()}; } }; template < typename T > struct IfHasMemberFunctionState < T , typename std :: enable_if < HasMemberFunctionState < T >:: value >:: type > { template < typename Result > static const Result & callIt ( const T & callee ) { return callee . state (); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_MEMBER_FUNCTION_STATE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__stream__output__operator_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_stream_output_operator.hpp # Namespaces # Name openscenario_interpreter::type_traits openscenario_interpreter Classes # Name struct openscenario_interpreter::type_traits::IfHasStreamOutputOperator< T, typename std::enable_if< HasStreamOutputOperator< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasStreamOutputOperator Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_STREAM_OUTPUT_OPERATOR_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_STREAM_OUTPUT_OPERATOR_HPP_ #include <openscenario_interpreter/type_traits/has_stream_output_operator.hpp> #include <openscenario_interpreter/console/escape_sequence.hpp> #include <openscenario_interpreter/utility/indent.hpp> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct IfHasStreamOutputOperator { static std :: ostream & applyIt ( std :: ostream & os , const T & ) { return os << indent << blue << \"<\" << typeid ( T ). name () << \"/>\" << reset ; } }; template < typename T > struct IfHasStreamOutputOperator < T , typename std :: enable_if < HasStreamOutputOperator < T >:: value >:: type > { static std :: ostream & applyIt ( std :: ostream & os , const T & rhs ) { return os << rhs ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_STREAM_OUTPUT_OPERATOR_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_stream_output_operator.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__stream__output__operator_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretertype_traitsif_has_stream_output_operatorhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_has_stream_output_operator.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__stream__output__operator_8hpp/#namespaces","text":"Name openscenario_interpreter::type_traits openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__stream__output__operator_8hpp/#classes","text":"Name struct openscenario_interpreter::type_traits::IfHasStreamOutputOperator< T, typename std::enable_if< HasStreamOutputOperator< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasStreamOutputOperator","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/if__has__stream__output__operator_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_STREAM_OUTPUT_OPERATOR_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_STREAM_OUTPUT_OPERATOR_HPP_ #include <openscenario_interpreter/type_traits/has_stream_output_operator.hpp> #include <openscenario_interpreter/console/escape_sequence.hpp> #include <openscenario_interpreter/utility/indent.hpp> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct IfHasStreamOutputOperator { static std :: ostream & applyIt ( std :: ostream & os , const T & ) { return os << indent << blue << \"<\" << typeid ( T ). name () << \"/>\" << reset ; } }; template < typename T > struct IfHasStreamOutputOperator < T , typename std :: enable_if < HasStreamOutputOperator < T >:: value >:: type > { static std :: ostream & applyIt ( std :: ostream & os , const T & rhs ) { return os << rhs ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_HAS_STREAM_OUTPUT_OPERATOR_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/if__not__default__constructible_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_not_default_constructible.hpp # Namespaces # Name openscenario_interpreter::type_traits openscenario_interpreter Classes # Name struct openscenario_interpreter::type_traits::IfNotDefaultConstructible< T, typename std::enable_if< std::is_default_constructible< T >::value >::type > struct openscenario_interpreter::type_traits::IfNotDefaultConstructible Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_NOT_DEFAULT_CONSTRUCTIBLE_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_NOT_DEFAULT_CONSTRUCTIBLE_HPP_ #include <string> #include <type_traits> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct IfNotDefaultConstructible { static T error ( const std :: string & parent_name , const std :: string & child_name ) { std :: stringstream ss {}; ss << parent_name << \" requires class \" << child_name << \" as element, but there is no specification\" ; throw SyntaxError { ss . str ()}; } }; template < typename T > struct IfNotDefaultConstructible < T , typename std :: enable_if < std :: is_default_constructible < T >:: value >:: type > { template < typename ... Ts > static T error ( Ts && ...) { return T {}; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_NOT_DEFAULT_CONSTRUCTIBLE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_not_default_constructible.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/if__not__default__constructible_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretertype_traitsif_not_default_constructiblehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_not_default_constructible.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/if__not__default__constructible_8hpp/#namespaces","text":"Name openscenario_interpreter::type_traits openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/if__not__default__constructible_8hpp/#classes","text":"Name struct openscenario_interpreter::type_traits::IfNotDefaultConstructible< T, typename std::enable_if< std::is_default_constructible< T >::value >::type > struct openscenario_interpreter::type_traits::IfNotDefaultConstructible","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/if__not__default__constructible_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_NOT_DEFAULT_CONSTRUCTIBLE_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_NOT_DEFAULT_CONSTRUCTIBLE_HPP_ #include <string> #include <type_traits> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct IfNotDefaultConstructible { static T error ( const std :: string & parent_name , const std :: string & child_name ) { std :: stringstream ss {}; ss << parent_name << \" requires class \" << child_name << \" as element, but there is no specification\" ; throw SyntaxError { ss . str ()}; } }; template < typename T > struct IfNotDefaultConstructible < T , typename std :: enable_if < std :: is_default_constructible < T >:: value >:: type > { template < typename ... Ts > static T error ( Ts && ...) { return T {}; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_NOT_DEFAULT_CONSTRUCTIBLE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/if__not__nothrow__default__constructible_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_not_nothrow_default_constructible.hpp # Namespaces # Name openscenario_interpreter::type_traits openscenario_interpreter Classes # Name struct openscenario_interpreter::type_traits::IfNotNothrowDefaultConstructible< T, typename std::enable_if< std::is_nothrow_default_constructible< T >::value >::type > struct openscenario_interpreter::type_traits::IfNotNothrowDefaultConstructible Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_NOT_NOTHROW_DEFAULT_CONSTRUCTIBLE_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_NOT_NOTHROW_DEFAULT_CONSTRUCTIBLE_HPP_ #include <string> #include <type_traits> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct IfNotNothrowDefaultConstructible { static T error ( const std :: string & parent_name , const std :: string & child_name ) { std :: stringstream ss {}; ss << parent_name << \" requires class \" << child_name << \" as element, but there is no specification\" ; throw SyntaxError { ss . str ()}; } }; template < typename T > struct IfNotNothrowDefaultConstructible < T , typename std :: enable_if < std :: is_nothrow_default_constructible < T >:: value >:: type > { template < typename ... Ts > static T error ( Ts && ...) { return T {}; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_NOT_NOTHROW_DEFAULT_CONSTRUCTIBLE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_not_nothrow_default_constructible.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/if__not__nothrow__default__constructible_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretertype_traitsif_not_nothrow_default_constructiblehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/if_not_nothrow_default_constructible.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/if__not__nothrow__default__constructible_8hpp/#namespaces","text":"Name openscenario_interpreter::type_traits openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/if__not__nothrow__default__constructible_8hpp/#classes","text":"Name struct openscenario_interpreter::type_traits::IfNotNothrowDefaultConstructible< T, typename std::enable_if< std::is_nothrow_default_constructible< T >::value >::type > struct openscenario_interpreter::type_traits::IfNotNothrowDefaultConstructible","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/if__not__nothrow__default__constructible_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_NOT_NOTHROW_DEFAULT_CONSTRUCTIBLE_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_NOT_NOTHROW_DEFAULT_CONSTRUCTIBLE_HPP_ #include <string> #include <type_traits> namespace openscenario_interpreter { inline namespace type_traits { template < typename T , typename = void > struct IfNotNothrowDefaultConstructible { static T error ( const std :: string & parent_name , const std :: string & child_name ) { std :: stringstream ss {}; ss << parent_name << \" requires class \" << child_name << \" as element, but there is no specification\" ; throw SyntaxError { ss . str ()}; } }; template < typename T > struct IfNotNothrowDefaultConstructible < T , typename std :: enable_if < std :: is_nothrow_default_constructible < T >:: value >:: type > { template < typename ... Ts > static T error ( Ts && ...) { return T {}; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__IF_NOT_NOTHROW_DEFAULT_CONSTRUCTIBLE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/indent_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/indent.hpp # Namespaces # Name openscenario_interpreter::utility openscenario_interpreter Classes # Name struct openscenario_interpreter::utility::Indent Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__UTILITY__INDENT_HPP_ #define OPENSCENARIO_INTERPRETER__UTILITY__INDENT_HPP_ #include <iostream> #include <string> namespace openscenario_interpreter { inline namespace utility { struct Indent { std :: size_t depth { 0 }; std :: size_t width { 2 }; auto & reset () { depth = 0 ; return * this ; } auto & operator ++ () { ++ depth ; return * this ; } auto & operator -- () { depth && -- depth ; return * this ; } auto operator ++ ( int ) { Indent result { * this }; ++ depth ; return result ; } auto operator -- ( int ) { Indent result { * this }; depth && -- depth ; return result ; } } static indent ; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Indent & indent ) { return os << std :: string ( indent . depth * 2 , ' ' ); } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__UTILITY__INDENT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/indent.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/indent_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterutilityindenthpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/indent.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/indent_8hpp/#namespaces","text":"Name openscenario_interpreter::utility openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/indent_8hpp/#classes","text":"Name struct openscenario_interpreter::utility::Indent","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/indent_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__UTILITY__INDENT_HPP_ #define OPENSCENARIO_INTERPRETER__UTILITY__INDENT_HPP_ #include <iostream> #include <string> namespace openscenario_interpreter { inline namespace utility { struct Indent { std :: size_t depth { 0 }; std :: size_t width { 2 }; auto & reset () { depth = 0 ; return * this ; } auto & operator ++ () { ++ depth ; return * this ; } auto & operator -- () { depth && -- depth ; return * this ; } auto operator ++ ( int ) { Indent result { * this }; ++ depth ; return result ; } auto operator -- ( int ) { Indent result { * this }; depth && -- depth ; return result ; } } static indent ; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Indent & indent ) { return os << std :: string ( indent . depth * 2 , ' ' ); } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__UTILITY__INDENT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/infrastructure__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/infrastructure_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::InfrastructureAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__INFRASTRUCTURE_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__INFRASTRUCTURE_ACTION_HPP_ #include <openscenario_interpreter/syntax/traffic_signal_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- InfrastructureAction --------------------------------------------------- * * <xsd:complexType name=\"InfrastructureAction\"> * <xsd:all> * <xsd:element name=\"TrafficSignalAction\" type=\"TrafficSignalAction\"/> * </xsd:all> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct InfrastructureAction : public Element { template < typename Node , typename Scope > explicit InfrastructureAction ( const Node & node , Scope & outer_scope ) : Element ( readElement < TrafficSignalAction > ( \"TrafficSignalAction\" , node , outer_scope )) {} }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__INFRASTRUCTURE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/infrastructure_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/infrastructure__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxinfrastructure_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/infrastructure_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/infrastructure__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/infrastructure__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::InfrastructureAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/infrastructure__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__INFRASTRUCTURE_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__INFRASTRUCTURE_ACTION_HPP_ #include <openscenario_interpreter/syntax/traffic_signal_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- InfrastructureAction --------------------------------------------------- * * <xsd:complexType name=\"InfrastructureAction\"> * <xsd:all> * <xsd:element name=\"TrafficSignalAction\" type=\"TrafficSignalAction\"/> * </xsd:all> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct InfrastructureAction : public Element { template < typename Node , typename Scope > explicit InfrastructureAction ( const Node & node , Scope & outer_scope ) : Element ( readElement < TrafficSignalAction > ( \"TrafficSignalAction\" , node , outer_scope )) {} }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__INFRASTRUCTURE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/init_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/init.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Init Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__INIT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__INIT_HPP_ #include <openscenario_interpreter/syntax/init_actions.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- Init ------------------------------------------------------------------- * * <xsd:complexType name=\"Init\"> * <xsd:sequence> * <xsd:element name=\"Actions\" type=\"InitActions\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Init : public InitActions { template < typename Node , typename Scope > explicit Init ( const Node & node , Scope & scope ) : InitActions ( readElement < InitActions > ( \"Actions\" , node , scope )) {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__INIT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/init.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/init_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxinithpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/init.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/init_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/init_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Init","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/init_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__INIT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__INIT_HPP_ #include <openscenario_interpreter/syntax/init_actions.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- Init ------------------------------------------------------------------- * * <xsd:complexType name=\"Init\"> * <xsd:sequence> * <xsd:element name=\"Actions\" type=\"InitActions\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Init : public InitActions { template < typename Node , typename Scope > explicit Init ( const Node & node , Scope & scope ) : InitActions ( readElement < InitActions > ( \"Actions\" , node , scope )) {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__INIT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/init__actions_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/init_actions.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::InitActions Defines # Name ELEMENT (TYPE) Macro Documentation # define ELEMENT # #define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ push_back(make<TYPE>(node, scope)); \\ }) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__INIT_ACTIONS_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__INIT_ACTIONS_HPP_ #include <openscenario_interpreter/syntax/action.hpp> #include <openscenario_interpreter/syntax/private.hpp> #include <string> #include <unordered_map> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- InitActions ------------------------------------------------------------ * * <xsd:complexType name=\"InitActions\"> * <xsd:sequence> * <xsd:element name=\"GlobalAction\" type=\"GlobalAction\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> * <xsd:element name=\"UserDefinedAction\" type=\"UserDefinedAction\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> * <xsd:element name=\"Private\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"Private\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ push_back(make<TYPE>(node, scope)); \\ }) struct InitActions : public Elements { template < typename Node , typename Scope > explicit InitActions ( const Node & node , Scope & scope ) { std :: unordered_map < std :: string , std :: function < void ( const Node & node ) >> dispatcher { ELEMENT ( GlobalAction ), ELEMENT ( UserDefinedAction ), ELEMENT ( Private ), }; for ( const auto & each : node . children ()) { const auto iter { dispatcher . find ( each . name ()) }; if ( iter != std :: end ( dispatcher )) { std :: get < 1 > ( * iter )( each ); } } } auto evaluate () const { for ( auto && each : * this ) { each . evaluate (); } return unspecified ; } }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__INIT_ACTIONS_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/init_actions.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/init__actions_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxinit_actionshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/init_actions.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/init__actions_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/init__actions_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::InitActions","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/init__actions_8hpp/#defines","text":"Name ELEMENT (TYPE)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/init__actions_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/init__actions_8hpp/#define-element","text":"#define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ push_back(make<TYPE>(node, scope)); \\ })","title":"define ELEMENT"},{"location":"package/openscenario_interpreter/markdown/Files/init__actions_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__INIT_ACTIONS_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__INIT_ACTIONS_HPP_ #include <openscenario_interpreter/syntax/action.hpp> #include <openscenario_interpreter/syntax/private.hpp> #include <string> #include <unordered_map> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- InitActions ------------------------------------------------------------ * * <xsd:complexType name=\"InitActions\"> * <xsd:sequence> * <xsd:element name=\"GlobalAction\" type=\"GlobalAction\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> * <xsd:element name=\"UserDefinedAction\" type=\"UserDefinedAction\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> * <xsd:element name=\"Private\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"Private\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ push_back(make<TYPE>(node, scope)); \\ }) struct InitActions : public Elements { template < typename Node , typename Scope > explicit InitActions ( const Node & node , Scope & scope ) { std :: unordered_map < std :: string , std :: function < void ( const Node & node ) >> dispatcher { ELEMENT ( GlobalAction ), ELEMENT ( UserDefinedAction ), ELEMENT ( Private ), }; for ( const auto & each : node . children ()) { const auto iter { dispatcher . find ( each . name ()) }; if ( iter != std :: end ( dispatcher )) { std :: get < 1 > ( * iter )( each ); } } } auto evaluate () const { for ( auto && each : * this ) { each . evaluate (); } return unspecified ; } }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__INIT_ACTIONS_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/integer_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/integer.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Integer Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__INTEGER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__INTEGER_HPP_ #include <boost/lexical_cast.hpp> #include <std_msgs/msg/int64.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { struct Integer : public std_msgs :: msg :: Int64 { using value_type = decltype ( std_msgs :: msg :: Int64 :: data ); explicit Integer ( value_type value = {}) { data = value ; } explicit Integer ( const std :: string & s ) try { data = boost :: lexical_cast < value_type > ( s ); } catch ( const boost :: bad_lexical_cast & ) { std :: stringstream ss {}; ss << \"can't treat value \\\" \" << s << \" \\\" as type Integer\" ; throw SyntaxError { ss . str ()}; } constexpr operator value_type () const noexcept { return data ; } auto & operator += ( const double & rhs ) { data += rhs ; return * this ; } auto & operator *= ( const double & rhs ) { data *= rhs ; return * this ; } }; std :: ostream & operator << ( std :: ostream & os , const Integer & rhs ) { return os << rhs . data ; } std :: istream & operator >> ( std :: istream & is , Integer & rhs ) { std :: string token {}; is >> token ; rhs . data = boost :: lexical_cast < Integer :: value_type > ( token ); return is ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__INTEGER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/integer.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/integer_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxintegerhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/integer.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/integer_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/integer_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Integer","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/integer_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__INTEGER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__INTEGER_HPP_ #include <boost/lexical_cast.hpp> #include <std_msgs/msg/int64.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { struct Integer : public std_msgs :: msg :: Int64 { using value_type = decltype ( std_msgs :: msg :: Int64 :: data ); explicit Integer ( value_type value = {}) { data = value ; } explicit Integer ( const std :: string & s ) try { data = boost :: lexical_cast < value_type > ( s ); } catch ( const boost :: bad_lexical_cast & ) { std :: stringstream ss {}; ss << \"can't treat value \\\" \" << s << \" \\\" as type Integer\" ; throw SyntaxError { ss . str ()}; } constexpr operator value_type () const noexcept { return data ; } auto & operator += ( const double & rhs ) { data += rhs ; return * this ; } auto & operator *= ( const double & rhs ) { data *= rhs ; return * this ; } }; std :: ostream & operator << ( std :: ostream & os , const Integer & rhs ) { return os << rhs . data ; } std :: istream & operator >> ( std :: istream & is , Integer & rhs ) { std :: string token {}; is >> token ; rhs . data = boost :: lexical_cast < Integer :: value_type > ( token ); return is ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__INTEGER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/is__console_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console/is_console.hpp # Namespaces # Name openscenario_interpreter::console openscenario_interpreter Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__CONSOLE__IS_CONSOLE_HPP_ #define OPENSCENARIO_INTERPRETER__CONSOLE__IS_CONSOLE_HPP_ #include <unistd.h> #include <iostream> namespace openscenario_interpreter { inline namespace console { auto is_console = []( const auto & os ) { if ( os . rdbuf () == std :: cout . rdbuf ()) { static const auto result { static_cast < bool > ( :: isatty ( STDOUT_FILENO ))}; return result ; } else if ( os . rdbuf () == std :: cerr . rdbuf ()) { static const auto result { static_cast < bool > ( :: isatty ( STDERR_FILENO ))}; return result ; } else { return false ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__CONSOLE__IS_CONSOLE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console/is_console.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/is__console_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterconsoleis_consolehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/console/is_console.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/is__console_8hpp/#namespaces","text":"Name openscenario_interpreter::console openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/is__console_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__CONSOLE__IS_CONSOLE_HPP_ #define OPENSCENARIO_INTERPRETER__CONSOLE__IS_CONSOLE_HPP_ #include <unistd.h> #include <iostream> namespace openscenario_interpreter { inline namespace console { auto is_console = []( const auto & os ) { if ( os . rdbuf () == std :: cout . rdbuf ()) { static const auto result { static_cast < bool > ( :: isatty ( STDOUT_FILENO ))}; return result ; } else if ( os . rdbuf () == std :: cerr . rdbuf ()) { static const auto result { static_cast < bool > ( :: isatty ( STDERR_FILENO ))}; return result ; } else { return false ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__CONSOLE__IS_CONSOLE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/lane__change__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_change_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::LaneChangeAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__LANE_CHANGE_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__LANE_CHANGE_ACTION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/lane_change_target.hpp> #include <openscenario_interpreter/syntax/transition_dynamics.hpp> #include <string> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- LaneChangeAction ------------------------------------------------------- * * <xsd:complexType name=\"LaneChangeAction\"> * <xsd:all> * <xsd:element name=\"LaneChangeActionDynamics\" type=\"TransitionDynamics\"/> * <xsd:element name=\"LaneChangeTarget\" type=\"LaneChangeTarget\"/> * </xsd:all> * <xsd:attribute name=\"targetLaneOffset\" type=\"Double\" use=\"optional\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct LaneChangeAction { const Double target_lane_offset ; Scope inner_scope ; const TransitionDynamics lane_change_action_dynamics ; const LaneChangeTarget lane_change_target ; template < typename Node > explicit LaneChangeAction ( const Node & node , Scope & outer_scope ) : target_lane_offset ( readAttribute < Double > ( \"targetLaneOffset\" , node , outer_scope , Double ())), inner_scope ( outer_scope ), lane_change_action_dynamics ( readElement < TransitionDynamics > ( \"LaneChangeActionDynamics\" , node , inner_scope )), lane_change_target ( readElement < LaneChangeTarget > ( \"LaneChangeTarget\" , node , inner_scope )) {} std :: unordered_map < std :: string , Boolean > accomplishments ; void start () { accomplishments . clear (); if ( lane_change_target . is < AbsoluteTargetLane > ()) { for ( const auto & actor : inner_scope . actors ) { accomplishments . emplace ( actor , false ); requestLaneChange ( actor , Integer ( lane_change_target . as < AbsoluteTargetLane > (). value )); } } else { THROW ( ImplementationFault ); } } auto accomplished () { if ( lane_change_target . is < AbsoluteTargetLane > ()) { for ( auto && each : accomplishments ) { if ( ! cdr ( each )) { cdr ( each ) = isInLanelet ( car ( each ), Integer ( lane_change_target . as < AbsoluteTargetLane > (). value ), 0.1 ); } } return std :: all_of ( std :: begin ( accomplishments ), std :: end ( accomplishments ), cdr ); } else { THROW ( ImplementationFault ); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__LANE_CHANGE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_change_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/lane__change__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxlane_change_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_change_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/lane__change__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/lane__change__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::LaneChangeAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/lane__change__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__LANE_CHANGE_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__LANE_CHANGE_ACTION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/lane_change_target.hpp> #include <openscenario_interpreter/syntax/transition_dynamics.hpp> #include <string> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- LaneChangeAction ------------------------------------------------------- * * <xsd:complexType name=\"LaneChangeAction\"> * <xsd:all> * <xsd:element name=\"LaneChangeActionDynamics\" type=\"TransitionDynamics\"/> * <xsd:element name=\"LaneChangeTarget\" type=\"LaneChangeTarget\"/> * </xsd:all> * <xsd:attribute name=\"targetLaneOffset\" type=\"Double\" use=\"optional\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct LaneChangeAction { const Double target_lane_offset ; Scope inner_scope ; const TransitionDynamics lane_change_action_dynamics ; const LaneChangeTarget lane_change_target ; template < typename Node > explicit LaneChangeAction ( const Node & node , Scope & outer_scope ) : target_lane_offset ( readAttribute < Double > ( \"targetLaneOffset\" , node , outer_scope , Double ())), inner_scope ( outer_scope ), lane_change_action_dynamics ( readElement < TransitionDynamics > ( \"LaneChangeActionDynamics\" , node , inner_scope )), lane_change_target ( readElement < LaneChangeTarget > ( \"LaneChangeTarget\" , node , inner_scope )) {} std :: unordered_map < std :: string , Boolean > accomplishments ; void start () { accomplishments . clear (); if ( lane_change_target . is < AbsoluteTargetLane > ()) { for ( const auto & actor : inner_scope . actors ) { accomplishments . emplace ( actor , false ); requestLaneChange ( actor , Integer ( lane_change_target . as < AbsoluteTargetLane > (). value )); } } else { THROW ( ImplementationFault ); } } auto accomplished () { if ( lane_change_target . is < AbsoluteTargetLane > ()) { for ( auto && each : accomplishments ) { if ( ! cdr ( each )) { cdr ( each ) = isInLanelet ( car ( each ), Integer ( lane_change_target . as < AbsoluteTargetLane > (). value ), 0.1 ); } } return std :: all_of ( std :: begin ( accomplishments ), std :: end ( accomplishments ), cdr ); } else { THROW ( ImplementationFault ); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__LANE_CHANGE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/lane__change__target_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_change_target.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::LaneChangeTarget Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__LANE_CHANGE_TARGET_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__LANE_CHANGE_TARGET_HPP_ #include <openscenario_interpreter/syntax/absolute_target_lane.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- LaneChangeTarget ------------------------------------------------------- * * <xsd:complexType name=\"LaneChangeTarget\"> * <xsd:choice> * <xsd:element name=\"RelativeTargetLane\" type=\"RelativeTargetLane\"/> * <xsd:element name=\"AbsoluteTargetLane\" type=\"AbsoluteTargetLane\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct LaneChangeTarget : public Element { template < typename Node , typename ... Ts > explicit LaneChangeTarget ( const Node & node , Ts && ... xs ) : Element ( choice ( node , std :: make_pair ( \"RelativeTargetLane\" , UNSUPPORTED ()), std :: make_pair ( \"AbsoluteTargetLane\" , [ & ]( auto && node ) { return make < AbsoluteTargetLane > ( node , std :: forward < decltype ( xs ) > ( xs )...); }))) {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__LANE_CHANGE_TARGET_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_change_target.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/lane__change__target_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxlane_change_targethpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_change_target.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/lane__change__target_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/lane__change__target_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::LaneChangeTarget","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/lane__change__target_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__LANE_CHANGE_TARGET_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__LANE_CHANGE_TARGET_HPP_ #include <openscenario_interpreter/syntax/absolute_target_lane.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- LaneChangeTarget ------------------------------------------------------- * * <xsd:complexType name=\"LaneChangeTarget\"> * <xsd:choice> * <xsd:element name=\"RelativeTargetLane\" type=\"RelativeTargetLane\"/> * <xsd:element name=\"AbsoluteTargetLane\" type=\"AbsoluteTargetLane\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct LaneChangeTarget : public Element { template < typename Node , typename ... Ts > explicit LaneChangeTarget ( const Node & node , Ts && ... xs ) : Element ( choice ( node , std :: make_pair ( \"RelativeTargetLane\" , UNSUPPORTED ()), std :: make_pair ( \"AbsoluteTargetLane\" , [ & ]( auto && node ) { return make < AbsoluteTargetLane > ( node , std :: forward < decltype ( xs ) > ( xs )...); }))) {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__LANE_CHANGE_TARGET_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/lane__position_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_position.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::LanePosition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__LANE_POSITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__LANE_POSITION_HPP_ #include <openscenario_interpreter/syntax/orientation.hpp> #include <openscenario_msgs/msg/lanelet_pose.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- LanePosition ----------------------------------------------------------- * * <xsd:complexType name=\"LanePosition\"> * <xsd:all> * <xsd:element name=\"Orientation\" type=\"Orientation\" minOccurs=\"0\"/> * </xsd:all> * <xsd:attribute name=\"roadId\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"laneId\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"offset\" type=\"Double\" use=\"optional\"/> * <xsd:attribute name=\"s\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct LanePosition { const String road_id , lane_id ; const Double offset , s ; const Orientation orientation ; template < typename Node , typename Scope > explicit LanePosition ( const Node & node , Scope & scope ) : road_id ( readAttribute < String > ( \"roadId\" , node , scope , \"none\" )), lane_id ( readAttribute < String > ( \"laneId\" , node , scope )), offset ( readAttribute < Double > ( \"offset\" , node , scope , Double ())), s ( readAttribute < Double > ( \"s\" , node , scope )), orientation ( readElement < Orientation > ( \"Orientation\" , node , scope )) {} explicit operator openscenario_msgs :: msg :: LaneletPose () const { const geometry_msgs :: msg :: Vector3 rpy = orientation ; return simulation_api :: helper :: constructLaneletPose ( static_cast < Integer > ( lane_id ), s , offset , rpy . x , rpy . y , rpy . z ); } explicit operator geometry_msgs :: msg :: Pose () const { return toMapPose ( static_cast < openscenario_msgs :: msg :: LaneletPose > ( * this )); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__LANE_POSITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_position.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/lane__position_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxlane_positionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lane_position.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/lane__position_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/lane__position_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::LanePosition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/lane__position_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__LANE_POSITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__LANE_POSITION_HPP_ #include <openscenario_interpreter/syntax/orientation.hpp> #include <openscenario_msgs/msg/lanelet_pose.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- LanePosition ----------------------------------------------------------- * * <xsd:complexType name=\"LanePosition\"> * <xsd:all> * <xsd:element name=\"Orientation\" type=\"Orientation\" minOccurs=\"0\"/> * </xsd:all> * <xsd:attribute name=\"roadId\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"laneId\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"offset\" type=\"Double\" use=\"optional\"/> * <xsd:attribute name=\"s\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct LanePosition { const String road_id , lane_id ; const Double offset , s ; const Orientation orientation ; template < typename Node , typename Scope > explicit LanePosition ( const Node & node , Scope & scope ) : road_id ( readAttribute < String > ( \"roadId\" , node , scope , \"none\" )), lane_id ( readAttribute < String > ( \"laneId\" , node , scope )), offset ( readAttribute < Double > ( \"offset\" , node , scope , Double ())), s ( readAttribute < Double > ( \"s\" , node , scope )), orientation ( readElement < Orientation > ( \"Orientation\" , node , scope )) {} explicit operator openscenario_msgs :: msg :: LaneletPose () const { const geometry_msgs :: msg :: Vector3 rpy = orientation ; return simulation_api :: helper :: constructLaneletPose ( static_cast < Integer > ( lane_id ), s , offset , rpy . x , rpy . y , rpy . z ); } explicit operator geometry_msgs :: msg :: Pose () const { return toMapPose ( static_cast < openscenario_msgs :: msg :: LaneletPose > ( * this )); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__LANE_POSITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/lateral__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lateral_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::LateralAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__LATERAL_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__LATERAL_ACTION_HPP_ #include <openscenario_interpreter/syntax/lane_change_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- LateralAction ---------------------------------------------------------- * * <xsd:complexType name=\"LateralAction\"> * <xsd:choice> * <xsd:element name=\"LaneChangeAction\" type=\"LaneChangeAction\"/> * <xsd:element name=\"LaneOffsetAction\" type=\"LaneOffsetAction\"/> * <xsd:element name=\"LateralDistanceAction\" type=\"LateralDistanceAction\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct LateralAction : public ComplexType { template < typename Node , typename Scope > explicit LateralAction ( const Node & node , Scope & scope ) : ComplexType ( choice ( node , std :: make_pair ( \"LaneChangeAction\" , [ & ]( auto && node ) { return make < LaneChangeAction > ( node , scope ); }), std :: make_pair ( \"LaneOffsetAction\" , UNSUPPORTED ()), std :: make_pair ( \"LateralDistanceAction\" , UNSUPPORTED ()))) {} }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__LATERAL_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lateral_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/lateral__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxlateral_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/lateral_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/lateral__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/lateral__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::LateralAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/lateral__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__LATERAL_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__LATERAL_ACTION_HPP_ #include <openscenario_interpreter/syntax/lane_change_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- LateralAction ---------------------------------------------------------- * * <xsd:complexType name=\"LateralAction\"> * <xsd:choice> * <xsd:element name=\"LaneChangeAction\" type=\"LaneChangeAction\"/> * <xsd:element name=\"LaneOffsetAction\" type=\"LaneOffsetAction\"/> * <xsd:element name=\"LateralDistanceAction\" type=\"LateralDistanceAction\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct LateralAction : public ComplexType { template < typename Node , typename Scope > explicit LateralAction ( const Node & node , Scope & scope ) : ComplexType ( choice ( node , std :: make_pair ( \"LaneChangeAction\" , [ & ]( auto && node ) { return make < LaneChangeAction > ( node , scope ); }), std :: make_pair ( \"LaneOffsetAction\" , UNSUPPORTED ()), std :: make_pair ( \"LateralDistanceAction\" , UNSUPPORTED ()))) {} }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__LATERAL_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/longitudinal__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/longitudinal_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::LongitudinalAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__LONGITUDINAL_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__LONGITUDINAL_ACTION_HPP_ #include <openscenario_interpreter/syntax/speed_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ==== LongitudinalAction =================================================== * * <xsd:complexType name=\"LongitudinalAction\"> * <xsd:choice> * <xsd:element name=\"SpeedAction\" type=\"SpeedAction\"/> * <xsd:element name=\"LongitudinalDistanceAction\" type=\"LongitudinalDistanceAction\"/> * </xsd:choice> * </xsd:complexType> * * ======================================================================== */ struct LongitudinalAction : public Element { template < typename Node , typename ... Ts > explicit LongitudinalAction ( const Node & node , Ts && ... xs ) : Element ( choice ( node , std :: make_pair ( \"SpeedAction\" , [ & ]( auto && node ) { return make < SpeedAction > ( node , std :: forward < decltype ( xs ) > ( xs )...); }), std :: make_pair ( \"LongitudinalDistanceAction\" , UNSUPPORTED ()))) {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__LONGITUDINAL_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/longitudinal_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/longitudinal__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxlongitudinal_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/longitudinal_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/longitudinal__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/longitudinal__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::LongitudinalAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/longitudinal__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__LONGITUDINAL_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__LONGITUDINAL_ACTION_HPP_ #include <openscenario_interpreter/syntax/speed_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ==== LongitudinalAction =================================================== * * <xsd:complexType name=\"LongitudinalAction\"> * <xsd:choice> * <xsd:element name=\"SpeedAction\" type=\"SpeedAction\"/> * <xsd:element name=\"LongitudinalDistanceAction\" type=\"LongitudinalDistanceAction\"/> * </xsd:choice> * </xsd:complexType> * * ======================================================================== */ struct LongitudinalAction : public Element { template < typename Node , typename ... Ts > explicit LongitudinalAction ( const Node & node , Ts && ... xs ) : Element ( choice ( node , std :: make_pair ( \"SpeedAction\" , [ & ]( auto && node ) { return make < SpeedAction > ( node , std :: forward < decltype ( xs ) > ( xs )...); }), std :: make_pair ( \"LongitudinalDistanceAction\" , UNSUPPORTED ()))) {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__LONGITUDINAL_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/maneuver_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/maneuver.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Maneuver Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__MANEUVER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__MANEUVER_HPP_ #include <openscenario_interpreter/syntax/event.hpp> #include <openscenario_interpreter/syntax/parameter_declarations.hpp> #include <openscenario_interpreter/syntax/storyboard_element.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Maneuver ============================================================= * * <xsd:complexType name=\"Maneuver\"> * <xsd:sequence> * <xsd:element name=\"ParameterDeclarations\" type=\"ParameterDeclarations\" minOccurs=\"0\"/> * <xsd:element name=\"Event\" maxOccurs=\"unbounded\" type=\"Event\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Maneuver : public StoryboardElement < Maneuver > , public Elements { const String name ; Scope inner_scope ; template < typename Node , typename Scope > explicit Maneuver ( const Node & node , Scope & outer_scope ) : name { readAttribute < String > ( \"name\" , node , outer_scope )}, inner_scope { outer_scope } { callWithElements ( node , \"ParameterDeclarations\" , 0 , 1 , [ & ]( auto && node ) { return make < ParameterDeclarations > ( node , inner_scope ); }); callWithElements ( node , \"Event\" , 1 , unbounded , [ & ]( auto && node ) { return push_back ( readStoryboardElement < Event > ( node , inner_scope )); }); } static constexpr auto ready () noexcept { return true ; } static constexpr auto stopTriggered () noexcept { return false ; } /* ------------------------------------------------------------------------- * * Maneuver * A Maneuver's goal is accomplished when all its Events are in the * completeState. * * ---------------------------------------------------------------------- */ auto accomplished () const { return std :: all_of ( std :: begin ( * this ), std :: end ( * this ), []( auto && each ) { return each . template as < Event > (). complete (); }); } using StoryboardElement :: evaluate ; void stop () { for ( auto && each : * this ) { each . as < Event > (). override (); each . evaluate (); } } void run () { for ( auto && each : * this ) { each . evaluate (); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__MANEUVER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/maneuver.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/maneuver_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxmaneuverhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/maneuver.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/maneuver_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/maneuver_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Maneuver","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/maneuver_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__MANEUVER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__MANEUVER_HPP_ #include <openscenario_interpreter/syntax/event.hpp> #include <openscenario_interpreter/syntax/parameter_declarations.hpp> #include <openscenario_interpreter/syntax/storyboard_element.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Maneuver ============================================================= * * <xsd:complexType name=\"Maneuver\"> * <xsd:sequence> * <xsd:element name=\"ParameterDeclarations\" type=\"ParameterDeclarations\" minOccurs=\"0\"/> * <xsd:element name=\"Event\" maxOccurs=\"unbounded\" type=\"Event\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Maneuver : public StoryboardElement < Maneuver > , public Elements { const String name ; Scope inner_scope ; template < typename Node , typename Scope > explicit Maneuver ( const Node & node , Scope & outer_scope ) : name { readAttribute < String > ( \"name\" , node , outer_scope )}, inner_scope { outer_scope } { callWithElements ( node , \"ParameterDeclarations\" , 0 , 1 , [ & ]( auto && node ) { return make < ParameterDeclarations > ( node , inner_scope ); }); callWithElements ( node , \"Event\" , 1 , unbounded , [ & ]( auto && node ) { return push_back ( readStoryboardElement < Event > ( node , inner_scope )); }); } static constexpr auto ready () noexcept { return true ; } static constexpr auto stopTriggered () noexcept { return false ; } /* ------------------------------------------------------------------------- * * Maneuver * A Maneuver's goal is accomplished when all its Events are in the * completeState. * * ---------------------------------------------------------------------- */ auto accomplished () const { return std :: all_of ( std :: begin ( * this ), std :: end ( * this ), []( auto && each ) { return each . template as < Event > (). complete (); }); } using StoryboardElement :: evaluate ; void stop () { for ( auto && each : * this ) { each . as < Event > (). override (); each . evaluate (); } } void run () { for ( auto && each : * this ) { each . evaluate (); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__MANEUVER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/maneuver__group_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/maneuver_group.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ManeuverGroup Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__MANEUVER_GROUP_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__MANEUVER_GROUP_HPP_ #include <openscenario_interpreter/syntax/actors.hpp> #include <openscenario_interpreter/syntax/maneuver.hpp> #include <openscenario_interpreter/syntax/storyboard_element.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== ManeuverGroup ======================================================== * * <xsd:complexType name=\"ManeuverGroup\"> * <xsd:sequence> * <xsd:element name=\"Actors\" type=\"Actors\"/> * <xsd:element name=\"CatalogReference\" type=\"CatalogReference\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> * <xsd:element name=\"Maneuver\" type=\"Maneuver\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> * </xsd:sequence> * <xsd:attribute name=\"maximumExecutionCount\" type=\"UnsignedInt\" use=\"required\"/> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct ManeuverGroup : public StoryboardElement < ManeuverGroup > , public Elements { const String name ; Scope inner_scope ; const Actors actors ; template < typename Node , typename Scope > explicit ManeuverGroup ( const Node & node , Scope & outer_scope ) : StoryboardElement { readAttribute < UnsignedInteger > ( \"maximumExecutionCount\" , node , outer_scope , UnsignedInteger ())}, name { readAttribute < String > ( \"name\" , node , outer_scope )}, inner_scope { outer_scope }, actors { readElement < Actors > ( \"Actors\" , node , inner_scope )} { callWithElements ( node , \"CatalogReference\" , 0 , unbounded , THROW_UNSUPPORTED_ERROR ( node )); callWithElements ( node , \"Maneuver\" , 0 , unbounded , [ & ]( auto && node ) { return push_back ( readStoryboardElement < Maneuver > ( node , inner_scope )); }); } static constexpr auto ready () noexcept { return true ; } static constexpr auto stopTriggered () noexcept { return false ; } /* ------------------------------------------------------------------------- * * ManeuverGroup * A ManeuverGroup's goal is accomplished when all its Maneuvers are in * the completeState. * * ---------------------------------------------------------------------- */ auto accomplished () const { return std :: all_of ( std :: begin ( * this ), std :: end ( * this ), [ & ]( auto && each ) { return each . template as < Maneuver > (). complete (); }); } using StoryboardElement :: evaluate ; void stop () { for ( auto && each : * this ) { each . as < Maneuver > (). override (); each . evaluate (); } } void run () { for ( auto && each : * this ) { each . evaluate (); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__MANEUVER_GROUP_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/maneuver_group.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/maneuver__group_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxmaneuver_grouphpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/maneuver_group.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/maneuver__group_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/maneuver__group_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ManeuverGroup","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/maneuver__group_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__MANEUVER_GROUP_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__MANEUVER_GROUP_HPP_ #include <openscenario_interpreter/syntax/actors.hpp> #include <openscenario_interpreter/syntax/maneuver.hpp> #include <openscenario_interpreter/syntax/storyboard_element.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== ManeuverGroup ======================================================== * * <xsd:complexType name=\"ManeuverGroup\"> * <xsd:sequence> * <xsd:element name=\"Actors\" type=\"Actors\"/> * <xsd:element name=\"CatalogReference\" type=\"CatalogReference\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> * <xsd:element name=\"Maneuver\" type=\"Maneuver\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> * </xsd:sequence> * <xsd:attribute name=\"maximumExecutionCount\" type=\"UnsignedInt\" use=\"required\"/> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct ManeuverGroup : public StoryboardElement < ManeuverGroup > , public Elements { const String name ; Scope inner_scope ; const Actors actors ; template < typename Node , typename Scope > explicit ManeuverGroup ( const Node & node , Scope & outer_scope ) : StoryboardElement { readAttribute < UnsignedInteger > ( \"maximumExecutionCount\" , node , outer_scope , UnsignedInteger ())}, name { readAttribute < String > ( \"name\" , node , outer_scope )}, inner_scope { outer_scope }, actors { readElement < Actors > ( \"Actors\" , node , inner_scope )} { callWithElements ( node , \"CatalogReference\" , 0 , unbounded , THROW_UNSUPPORTED_ERROR ( node )); callWithElements ( node , \"Maneuver\" , 0 , unbounded , [ & ]( auto && node ) { return push_back ( readStoryboardElement < Maneuver > ( node , inner_scope )); }); } static constexpr auto ready () noexcept { return true ; } static constexpr auto stopTriggered () noexcept { return false ; } /* ------------------------------------------------------------------------- * * ManeuverGroup * A ManeuverGroup's goal is accomplished when all its Maneuvers are in * the completeState. * * ---------------------------------------------------------------------- */ auto accomplished () const { return std :: all_of ( std :: begin ( * this ), std :: end ( * this ), [ & ]( auto && each ) { return each . template as < Maneuver > (). complete (); }); } using StoryboardElement :: evaluate ; void stop () { for ( auto && each : * this ) { each . as < Maneuver > (). override (); each . evaluate (); } } void run () { for ( auto && each : * this ) { each . evaluate (); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__MANEUVER_GROUP_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/modify__rule_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/modify_rule.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ModifyRule Defines # Name ELEMENT (TYPE) Macro Documentation # define ELEMENT # #define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<Parameter ## TYPE ## Rule>(node, std::forward<decltype(xs)>(xs)...); \\ }) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__MODIFY_RULE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__MODIFY_RULE_HPP_ #include <openscenario_interpreter/reader/element.hpp> #include <openscenario_interpreter/syntax/parameter_add_value_rule.hpp> #include <openscenario_interpreter/syntax/parameter_multiply_by_value_rule.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ModifyRule ------------------------------------------------------------- * * <xsd:complexType name=\"ModifyRule\"> * <xsd:choice> * <xsd:element name=\"AddValue\" type=\"ParameterAddValueRule\"/> * <xsd:element name=\"MultiplyByValue\" type=\"ParameterMultiplyByValueRule\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<Parameter ## TYPE ## Rule>(node, std::forward<decltype(xs)>(xs)...); \\ }) struct ModifyRule : public Element { template < typename Node , typename ... Ts > explicit ModifyRule ( const Node & node , Ts && ... xs ) : Element ( choice ( node , ELEMENT ( AddValue ), ELEMENT ( MultiplyByValue ))) {} }; #undef ELEMENT } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__MODIFY_RULE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/modify_rule.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/modify__rule_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxmodify_rulehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/modify_rule.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/modify__rule_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/modify__rule_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ModifyRule","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/modify__rule_8hpp/#defines","text":"Name ELEMENT (TYPE)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/modify__rule_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/modify__rule_8hpp/#define-element","text":"#define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<Parameter ## TYPE ## Rule>(node, std::forward<decltype(xs)>(xs)...); \\ })","title":"define ELEMENT"},{"location":"package/openscenario_interpreter/markdown/Files/modify__rule_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__MODIFY_RULE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__MODIFY_RULE_HPP_ #include <openscenario_interpreter/reader/element.hpp> #include <openscenario_interpreter/syntax/parameter_add_value_rule.hpp> #include <openscenario_interpreter/syntax/parameter_multiply_by_value_rule.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ModifyRule ------------------------------------------------------------- * * <xsd:complexType name=\"ModifyRule\"> * <xsd:choice> * <xsd:element name=\"AddValue\" type=\"ParameterAddValueRule\"/> * <xsd:element name=\"MultiplyByValue\" type=\"ParameterMultiplyByValueRule\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<Parameter ## TYPE ## Rule>(node, std::forward<decltype(xs)>(xs)...); \\ }) struct ModifyRule : public Element { template < typename Node , typename ... Ts > explicit ModifyRule ( const Node & node , Ts && ... xs ) : Element ( choice ( node , ELEMENT ( AddValue ), ELEMENT ( MultiplyByValue ))) {} }; #undef ELEMENT } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__MODIFY_RULE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/object_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/object.cpp # Namespaces # Name openscenario_interpreter Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <openscenario_interpreter/object.hpp> namespace openscenario_interpreter { const Element unspecified { make < Unspecified > () }; std :: ostream & operator << ( std :: ostream & os , const Unspecified & ) { return os << \"<!-- Unspecified -->\" ; } } // namespace openscenario_interpreter Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/object.cpp"},{"location":"package/openscenario_interpreter/markdown/Files/object_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpretersrcobjectcpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/object.cpp"},{"location":"package/openscenario_interpreter/markdown/Files/object_8cpp/#namespaces","text":"Name openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/object_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <openscenario_interpreter/object.hpp> namespace openscenario_interpreter { const Element unspecified { make < Unspecified > () }; std :: ostream & operator << ( std :: ostream & os , const Unspecified & ) { return os << \"<!-- Unspecified -->\" ; } } // namespace openscenario_interpreter Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/object_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/object.hpp # Namespaces # Name openscenario_interpreter Classes # Name struct openscenario_interpreter::Unspecified Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__OBJECT_HPP_ #define OPENSCENARIO_INTERPRETER__OBJECT_HPP_ #include <openscenario_interpreter/expression.hpp> #include <type_traits> #include <utility> #include <vector> namespace openscenario_interpreter { using Element = Pointer < Expression > ; using ComplexType = Element ; using Group = Element ; using Elements = std :: vector < Element > ; template < typename ... Ts > using IsOptionalElement = std :: is_default_constructible < Ts ... > ; template < typename T , typename ... Ts > inline constexpr decltype ( auto ) make ( Ts && ... xs ) { return Element :: bind < T > ( std :: forward < decltype ( xs ) > ( xs )...); } template < typename T > inline constexpr decltype ( auto ) make ( T && x ) { return Element :: bind < typename std :: decay < decltype ( x ) >:: type > ( std :: forward < decltype ( x ) > ( x )); } extern const Element unspecified ; struct Unspecified { decltype ( auto ) evaluate () const noexcept { return unspecified ; // Self-evaluating. } }; std :: ostream & operator << ( std :: ostream & , const Unspecified & ); } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__OBJECT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/object.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/object_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterobjecthpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/object.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/object_8hpp/#namespaces","text":"Name openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/object_8hpp/#classes","text":"Name struct openscenario_interpreter::Unspecified","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/object_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__OBJECT_HPP_ #define OPENSCENARIO_INTERPRETER__OBJECT_HPP_ #include <openscenario_interpreter/expression.hpp> #include <type_traits> #include <utility> #include <vector> namespace openscenario_interpreter { using Element = Pointer < Expression > ; using ComplexType = Element ; using Group = Element ; using Elements = std :: vector < Element > ; template < typename ... Ts > using IsOptionalElement = std :: is_default_constructible < Ts ... > ; template < typename T , typename ... Ts > inline constexpr decltype ( auto ) make ( Ts && ... xs ) { return Element :: bind < T > ( std :: forward < decltype ( xs ) > ( xs )...); } template < typename T > inline constexpr decltype ( auto ) make ( T && x ) { return Element :: bind < typename std :: decay < decltype ( x ) >:: type > ( std :: forward < decltype ( x ) > ( x )); } extern const Element unspecified ; struct Unspecified { decltype ( auto ) evaluate () const noexcept { return unspecified ; // Self-evaluating. } }; std :: ostream & operator << ( std :: ostream & , const Unspecified & ); } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__OBJECT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/object__controller_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/object_controller.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ObjectController Defines # Name ELEMENT (TYPE) Macro Documentation # define ELEMENT # #define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__OBJECT_CONTROLLER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__OBJECT_CONTROLLER_HPP_ #include <openscenario_interpreter/syntax/controller.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) /* ---- ObjectController ------------------------------------------------------- * * Definition of a controller for a scenario object. Either an inline * definition or a catalog reference to a controller. * * <xsd:complexType name=\"ObjectController\"> * <xsd:choice> * <xsd:element name=\"CatalogReference\" type=\"CatalogReference\"/> * <xsd:element name=\"Controller\" type=\"Controller\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ObjectController : public ComplexType { explicit ObjectController () // ObjectController is optional element. : ComplexType ( unspecified ) {} template < typename Node , typename ... Ts > explicit ObjectController ( const Node & node , Ts && ... xs ) : ComplexType ( choice ( node , std :: make_pair ( \"CatalogReference\" , UNSUPPORTED ()), ELEMENT ( Controller ))) {} bool isEgo () & { if ( is < Unspecified > ()) { static auto controller = DefaultController (); return controller [ \"isEgo\" ]; } else { return as < Controller > ()[ \"isEgo\" ]; } } operator openscenario_msgs :: msg :: DriverModel () const { if ( is < Unspecified > ()) { openscenario_msgs :: msg :: DriverModel controller ; { controller . see_around = ! DefaultController ()[ \"isBlind\" ]; } return controller ; } else { return as < Controller > (); } } }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__OBJECT_CONTROLLER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/object_controller.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/object__controller_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxobject_controllerhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/object_controller.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/object__controller_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/object__controller_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ObjectController","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/object__controller_8hpp/#defines","text":"Name ELEMENT (TYPE)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/object__controller_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/object__controller_8hpp/#define-element","text":"#define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ })","title":"define ELEMENT"},{"location":"package/openscenario_interpreter/markdown/Files/object__controller_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__OBJECT_CONTROLLER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__OBJECT_CONTROLLER_HPP_ #include <openscenario_interpreter/syntax/controller.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) /* ---- ObjectController ------------------------------------------------------- * * Definition of a controller for a scenario object. Either an inline * definition or a catalog reference to a controller. * * <xsd:complexType name=\"ObjectController\"> * <xsd:choice> * <xsd:element name=\"CatalogReference\" type=\"CatalogReference\"/> * <xsd:element name=\"Controller\" type=\"Controller\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ObjectController : public ComplexType { explicit ObjectController () // ObjectController is optional element. : ComplexType ( unspecified ) {} template < typename Node , typename ... Ts > explicit ObjectController ( const Node & node , Ts && ... xs ) : ComplexType ( choice ( node , std :: make_pair ( \"CatalogReference\" , UNSUPPORTED ()), ELEMENT ( Controller ))) {} bool isEgo () & { if ( is < Unspecified > ()) { static auto controller = DefaultController (); return controller [ \"isEgo\" ]; } else { return as < Controller > ()[ \"isEgo\" ]; } } operator openscenario_msgs :: msg :: DriverModel () const { if ( is < Unspecified > ()) { openscenario_msgs :: msg :: DriverModel controller ; { controller . see_around = ! DefaultController ()[ \"isBlind\" ]; } return controller ; } else { return as < Controller > (); } } }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__OBJECT_CONTROLLER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/object__type_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/object_type.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ObjectType Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__OBJECT_TYPE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__OBJECT_TYPE_HPP_ namespace openscenario_interpreter { inline namespace syntax { /* ==== ObjectType =========================================================== * * <xsd:simpleType name=\"ObjectType\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"pedestrian\"/> * <xsd:enumeration value=\"vehicle\"/> * <xsd:enumeration value=\"miscellaneous\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct ObjectType {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__OBJECT_TYPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/object_type.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/object__type_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxobject_typehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/object_type.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/object__type_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/object__type_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ObjectType","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/object__type_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__OBJECT_TYPE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__OBJECT_TYPE_HPP_ namespace openscenario_interpreter { inline namespace syntax { /* ==== ObjectType =========================================================== * * <xsd:simpleType name=\"ObjectType\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"pedestrian\"/> * <xsd:enumeration value=\"vehicle\"/> * <xsd:enumeration value=\"miscellaneous\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct ObjectType {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__OBJECT_TYPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/openscenario.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ScenarioDefinition struct openscenario_interpreter::syntax::OpenScenario Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__OPENSCENARIO_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__OPENSCENARIO_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/catalog_locations.hpp> #include <openscenario_interpreter/syntax/entities.hpp> #include <openscenario_interpreter/syntax/file_header.hpp> #include <openscenario_interpreter/syntax/road_network.hpp> #include <openscenario_interpreter/syntax/storyboard.hpp> #include <string> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- ScenarioDefinition ----------------------------------------------------- * * <xsd:group name=\"ScenarioDefinition\"> * <xsd:sequence> * <xsd:element name=\"ParameterDeclarations\" type=\"ParameterDeclarations\" minOccurs=\"0\"/> * <xsd:element name=\"CatalogLocations\" type=\"CatalogLocations\"/> * <xsd:element name=\"RoadNetwork\" type=\"RoadNetwork\"/> * <xsd:element name=\"Entities\" type=\"Entities\"/> * <xsd:element name=\"Storyboard\" type=\"Storyboard\"/> * </xsd:sequence> * </xsd:group> * * -------------------------------------------------------------------------- */ struct ScenarioDefinition { Element storyboard ; template < typename Node , typename Scope > explicit ScenarioDefinition ( const Node & node , Scope & outer_scope ) { // std::cout << (indent++) << \"<OpenSCENARIO>\" << std::endl; callWithElements ( node , \"ParameterDeclarations\" , 0 , unbounded , [ & ]( auto && each ) { return make < ParameterDeclarations > ( each , outer_scope ); }); // for (const auto & each : outer_scope.parameters) { // std::cout << indent << \"<!-- Parameter \" << cyan << \"\\'\" << std::get<0>(each) << \"\\'\" << // reset << \" of type \" << green << std::get<1>(each).type().name() << reset << // \" declared as value \" << cyan << \"\\\"\" << std::get<1>(each) << cyan << \"\\\"\" << reset << // \" -->\" << std::endl; // } callWithElements ( node , \"CatalogLocations\" , 0 , 1 , [ & ]( auto && node ) { return make < CatalogLocations > ( node , outer_scope ); }); callWithElements ( node , \"RoadNetwork\" , 1 , 1 , [ & ]( auto && node ) { return make < RoadNetwork > ( node , outer_scope ); }); callWithElement ( node , \"Entities\" , [ & ]( auto && node ) { return make < Entities > ( node , outer_scope ); }); // std::cout << (indent++) << \"<Entities>\" << std::endl; // // for (const auto & each : outer_scope.entities) { // std::cout << std::get<1>(each) << std::endl; // } // // std::cout << (--indent) << \"</Entities>\" << std::endl; callWithElement ( node , \"Storyboard\" , [ & ]( auto && node ) { return storyboard = make < Storyboard > ( node , outer_scope ); }); // std::cout << (--indent) << \"</OpenSCENARIO>\" << std::endl; } template < typename ... Ts > decltype ( auto ) complete ( Ts && ... xs ) { return storyboard . as < Storyboard > (). complete ( std :: forward < decltype ( xs ) > ( xs )...); } template < typename ... Ts > auto evaluate ( Ts && ... xs ) { const auto result { storyboard . evaluate () }; updateFrame (); return result ; } }; std :: ostream & operator << ( std :: ostream & os , const ScenarioDefinition & ) { return os << unspecified ; } /* ---- OpenScenario ----------------------------------------------------------- * * <xsd:complexType name=\"OpenScenario\"> * <xsd:sequence> * <xsd:element name=\"FileHeader\" type=\"FileHeader\"/> * <xsd:group ref=\"OpenScenarioCategory\"/> * </xsd:sequence> * </xsd:complexType> * * <xsd:group name=\"OpenScenarioCategory\"> * <xsd:choice> * <xsd:group ref=\"ScenarioDefinition\"/> * <xsd:group ref=\"CatalogDefinition\"/> * </xsd:choice> * </xsd:group> * * <xsd:group name=\"CatalogDefinition\"> * <xsd:sequence> * <xsd:element name=\"Catalog\" type=\"Catalog\"/> * </xsd:sequence> * </xsd:group> * * -------------------------------------------------------------------------- */ struct OpenScenario : public pugi :: xml_document { Element category ; Scope scope ; const auto & load ( const std :: string & scenario ) { const auto result { load_file ( scenario . c_str ()) }; if ( ! result ) { std :: stringstream ss {}; ss << \"while loading scenario \\\" \" << scenario << \" \\\" => \" << result . description (); throw SyntaxError ( ss . str ()); } else { return * this ; } } decltype ( auto ) load ( const boost :: filesystem :: path & scenario ) { return load ( scenario . string ()); } template < typename ... Ts > explicit OpenScenario ( Ts && ... xs ) : scope ( std :: forward < decltype ( xs ) > ( xs )...) { if ( load ( scope . scenario ). child ( \"OpenSCENARIO\" ). child ( \"Catalog\" )) { THROW_IMPLEMENTATION_FAULT (); } else { category = make < ScenarioDefinition > ( child ( \"OpenSCENARIO\" ), scope ); } } template < typename ... Ts > decltype ( auto ) complete ( Ts && ... xs ) { if ( category . is < ScenarioDefinition > ()) { return category . as < ScenarioDefinition > (). complete ( std :: forward < decltype ( xs ) > ( xs )...); } else { THROW_IMPLEMENTATION_FAULT (); } } template < typename ... Ts > decltype ( auto ) evaluate ( Ts && ... xs ) { return category . evaluate ( std :: forward < decltype ( xs ) > ( xs )...); } template < typename ... Ts > decltype ( auto ) operator ()( Ts && ... xs ) { return evaluate ( std :: forward < decltype ( xs ) > ( xs )...); } }; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const OpenScenario & ) { return os << unspecified ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__OPENSCENARIO_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/openscenario.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxopenscenariohpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/openscenario.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ScenarioDefinition struct openscenario_interpreter::syntax::OpenScenario","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__OPENSCENARIO_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__OPENSCENARIO_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/catalog_locations.hpp> #include <openscenario_interpreter/syntax/entities.hpp> #include <openscenario_interpreter/syntax/file_header.hpp> #include <openscenario_interpreter/syntax/road_network.hpp> #include <openscenario_interpreter/syntax/storyboard.hpp> #include <string> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- ScenarioDefinition ----------------------------------------------------- * * <xsd:group name=\"ScenarioDefinition\"> * <xsd:sequence> * <xsd:element name=\"ParameterDeclarations\" type=\"ParameterDeclarations\" minOccurs=\"0\"/> * <xsd:element name=\"CatalogLocations\" type=\"CatalogLocations\"/> * <xsd:element name=\"RoadNetwork\" type=\"RoadNetwork\"/> * <xsd:element name=\"Entities\" type=\"Entities\"/> * <xsd:element name=\"Storyboard\" type=\"Storyboard\"/> * </xsd:sequence> * </xsd:group> * * -------------------------------------------------------------------------- */ struct ScenarioDefinition { Element storyboard ; template < typename Node , typename Scope > explicit ScenarioDefinition ( const Node & node , Scope & outer_scope ) { // std::cout << (indent++) << \"<OpenSCENARIO>\" << std::endl; callWithElements ( node , \"ParameterDeclarations\" , 0 , unbounded , [ & ]( auto && each ) { return make < ParameterDeclarations > ( each , outer_scope ); }); // for (const auto & each : outer_scope.parameters) { // std::cout << indent << \"<!-- Parameter \" << cyan << \"\\'\" << std::get<0>(each) << \"\\'\" << // reset << \" of type \" << green << std::get<1>(each).type().name() << reset << // \" declared as value \" << cyan << \"\\\"\" << std::get<1>(each) << cyan << \"\\\"\" << reset << // \" -->\" << std::endl; // } callWithElements ( node , \"CatalogLocations\" , 0 , 1 , [ & ]( auto && node ) { return make < CatalogLocations > ( node , outer_scope ); }); callWithElements ( node , \"RoadNetwork\" , 1 , 1 , [ & ]( auto && node ) { return make < RoadNetwork > ( node , outer_scope ); }); callWithElement ( node , \"Entities\" , [ & ]( auto && node ) { return make < Entities > ( node , outer_scope ); }); // std::cout << (indent++) << \"<Entities>\" << std::endl; // // for (const auto & each : outer_scope.entities) { // std::cout << std::get<1>(each) << std::endl; // } // // std::cout << (--indent) << \"</Entities>\" << std::endl; callWithElement ( node , \"Storyboard\" , [ & ]( auto && node ) { return storyboard = make < Storyboard > ( node , outer_scope ); }); // std::cout << (--indent) << \"</OpenSCENARIO>\" << std::endl; } template < typename ... Ts > decltype ( auto ) complete ( Ts && ... xs ) { return storyboard . as < Storyboard > (). complete ( std :: forward < decltype ( xs ) > ( xs )...); } template < typename ... Ts > auto evaluate ( Ts && ... xs ) { const auto result { storyboard . evaluate () }; updateFrame (); return result ; } }; std :: ostream & operator << ( std :: ostream & os , const ScenarioDefinition & ) { return os << unspecified ; } /* ---- OpenScenario ----------------------------------------------------------- * * <xsd:complexType name=\"OpenScenario\"> * <xsd:sequence> * <xsd:element name=\"FileHeader\" type=\"FileHeader\"/> * <xsd:group ref=\"OpenScenarioCategory\"/> * </xsd:sequence> * </xsd:complexType> * * <xsd:group name=\"OpenScenarioCategory\"> * <xsd:choice> * <xsd:group ref=\"ScenarioDefinition\"/> * <xsd:group ref=\"CatalogDefinition\"/> * </xsd:choice> * </xsd:group> * * <xsd:group name=\"CatalogDefinition\"> * <xsd:sequence> * <xsd:element name=\"Catalog\" type=\"Catalog\"/> * </xsd:sequence> * </xsd:group> * * -------------------------------------------------------------------------- */ struct OpenScenario : public pugi :: xml_document { Element category ; Scope scope ; const auto & load ( const std :: string & scenario ) { const auto result { load_file ( scenario . c_str ()) }; if ( ! result ) { std :: stringstream ss {}; ss << \"while loading scenario \\\" \" << scenario << \" \\\" => \" << result . description (); throw SyntaxError ( ss . str ()); } else { return * this ; } } decltype ( auto ) load ( const boost :: filesystem :: path & scenario ) { return load ( scenario . string ()); } template < typename ... Ts > explicit OpenScenario ( Ts && ... xs ) : scope ( std :: forward < decltype ( xs ) > ( xs )...) { if ( load ( scope . scenario ). child ( \"OpenSCENARIO\" ). child ( \"Catalog\" )) { THROW_IMPLEMENTATION_FAULT (); } else { category = make < ScenarioDefinition > ( child ( \"OpenSCENARIO\" ), scope ); } } template < typename ... Ts > decltype ( auto ) complete ( Ts && ... xs ) { if ( category . is < ScenarioDefinition > ()) { return category . as < ScenarioDefinition > (). complete ( std :: forward < decltype ( xs ) > ( xs )...); } else { THROW_IMPLEMENTATION_FAULT (); } } template < typename ... Ts > decltype ( auto ) evaluate ( Ts && ... xs ) { return category . evaluate ( std :: forward < decltype ( xs ) > ( xs )...); } template < typename ... Ts > decltype ( auto ) operator ()( Ts && ... xs ) { return evaluate ( std :: forward < decltype ( xs ) > ( xs )...); } }; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const OpenScenario & ) { return os << unspecified ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__OPENSCENARIO_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/openscenario_interpreter.cpp # Namespaces # Name openscenario_interpreter Defines # Name OPENSCENARIO_INTERPRETER_NO_EXTENSION OPENSCENARIO_INTERPRETER_ALLOW_ATTRIBUTES_TO_BE_BLANK GET_PARAMETER (IDENTIFIER) DECLARE_PARAMETER (IDENTIFIER) Macro Documentation # define OPENSCENARIO_INTERPRETER_NO_EXTENSION # #define OPENSCENARIO_INTERPRETER_NO_EXTENSION define OPENSCENARIO_INTERPRETER_ALLOW_ATTRIBUTES_TO_BE_BLANK # #define OPENSCENARIO_INTERPRETER_ALLOW_ATTRIBUTES_TO_BE_BLANK define GET_PARAMETER # #define GET_PARAMETER( IDENTIFIER ) get_parameter ( # IDENTIFIER , IDENTIFIER ) define DECLARE_PARAMETER # #define DECLARE_PARAMETER( IDENTIFIER ) declare_parameter < decltype ( IDENTIFIER ) > ( # IDENTIFIER , IDENTIFIER ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #define OPENSCENARIO_INTERPRETER_ALLOW_ATTRIBUTES_TO_BE_BLANK #define OPENSCENARIO_INTERPRETER_NO_EXTENSION #undef NDEBUG #include <boost/filesystem.hpp> #include <openscenario_interpreter/openscenario_interpreter.hpp> #include <rclcpp_components/register_node_macro.hpp> #include <memory> #include <string> namespace openscenario_interpreter { Interpreter :: Interpreter ( const rclcpp :: NodeOptions & options ) : rclcpp_lifecycle :: LifecycleNode ( \"openscenario_interpreter\" , options ), intended_result ( \"success\" ), local_frame_rate ( 30 ), local_real_time_factor ( 1.0 ), osc_path ( \"\" ), output_directory ( \"/tmp\" ) { #define DECLARE_PARAMETER(IDENTIFIER) \\ declare_parameter<decltype(IDENTIFIER)>(#IDENTIFIER, IDENTIFIER) DECLARE_PARAMETER ( intended_result ); DECLARE_PARAMETER ( local_frame_rate ); DECLARE_PARAMETER ( local_real_time_factor ); DECLARE_PARAMETER ( osc_path ); DECLARE_PARAMETER ( output_directory ); #undef DECLARE_PARAMETER } Interpreter :: Result Interpreter :: on_configure ( const rclcpp_lifecycle :: State & ) try { std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); #define GET_PARAMETER(IDENTIFIER) \\ get_parameter(#IDENTIFIER, IDENTIFIER) GET_PARAMETER ( intended_result ); GET_PARAMETER ( local_frame_rate ); GET_PARAMETER ( local_real_time_factor ); GET_PARAMETER ( osc_path ); GET_PARAMETER ( output_directory ); #undef GET_PARAMETER script . rebind < OpenScenario > ( osc_path ); connect ( shared_from_this (), boost :: filesystem :: path ( osc_path ). replace_extension ( \"\" ), script . as < OpenScenario > (). scope . logic_file . string ()); // NOTE: /path/to/lanelet2_map.osm const auto interval_upper_bound = 1 / local_frame_rate * local_real_time_factor ; initialize ( local_real_time_factor , interval_upper_bound ); return Interpreter :: Result :: SUCCESS ; } catch ( const openscenario_interpreter :: SyntaxError & error ) { std :: cerr << \" \\x1b [1;31m\" << error . what () << \" \\x1b [0m\" << std :: endl ; return Interpreter :: Result :: FAILURE ; } Interpreter :: Result Interpreter :: on_activate ( const rclcpp_lifecycle :: State & ) { timer = create_wall_timer ( std :: chrono :: milliseconds ( static_cast < unsigned int > ( 1 / local_frame_rate * 1000 )), [ this ]() { withExceptionHandler ( [ this ]() { if ( script ) { if ( ! script . as < OpenScenario > (). complete ()) { script . as < OpenScenario > (). evaluate (); #ifndef NDEBUG RCLCPP_INFO ( get_logger (), \"[%d standby (=> %d) => %d running (=> %d) => %d complete] \\n \" , openscenario_interpreter :: standby_state . use_count () - 1 , openscenario_interpreter :: start_transition . use_count () - 1 , openscenario_interpreter :: running_state . use_count () - 1 , openscenario_interpreter :: stop_transition . use_count () - 1 , openscenario_interpreter :: complete_state . use_count () - 1 ); #endif } else { if ( intended_result == \"success\" ) { report ( SUCCESS , \"intended-success\" ); } else { report ( FAILURE , \"unintended-success\" , \"expected \" + intended_result ); } } } }); }); return Interpreter :: Result :: SUCCESS ; } Interpreter :: Result Interpreter :: on_deactivate ( const rclcpp_lifecycle :: State & ) { timer . reset (); return Interpreter :: Result :: SUCCESS ; } Interpreter :: Result Interpreter :: on_cleanup ( const rclcpp_lifecycle :: State & ) { connection . ~ API (); return Interpreter :: Result :: SUCCESS ; } Interpreter :: Result Interpreter :: on_shutdown ( const rclcpp_lifecycle :: State & ) { timer . reset (); return Interpreter :: Result :: SUCCESS ; } Interpreter :: Result Interpreter :: on_error ( const rclcpp_lifecycle :: State & ) { timer . reset (); return Interpreter :: Result :: SUCCESS ; } } // namespace openscenario_interpreter RCLCPP_COMPONENTS_REGISTER_NODE ( openscenario_interpreter :: Interpreter ) Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/openscenario_interpreter.cpp"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpretersrcopenscenario_interpretercpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/openscenario_interpreter.cpp"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter_8cpp/#namespaces","text":"Name openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter_8cpp/#defines","text":"Name OPENSCENARIO_INTERPRETER_NO_EXTENSION OPENSCENARIO_INTERPRETER_ALLOW_ATTRIBUTES_TO_BE_BLANK GET_PARAMETER (IDENTIFIER) DECLARE_PARAMETER (IDENTIFIER)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter_8cpp/#define-openscenario_interpreter_no_extension","text":"#define OPENSCENARIO_INTERPRETER_NO_EXTENSION","title":"define OPENSCENARIO_INTERPRETER_NO_EXTENSION"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter_8cpp/#define-openscenario_interpreter_allow_attributes_to_be_blank","text":"#define OPENSCENARIO_INTERPRETER_ALLOW_ATTRIBUTES_TO_BE_BLANK","title":"define OPENSCENARIO_INTERPRETER_ALLOW_ATTRIBUTES_TO_BE_BLANK"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter_8cpp/#define-get_parameter","text":"#define GET_PARAMETER( IDENTIFIER ) get_parameter ( # IDENTIFIER , IDENTIFIER )","title":"define GET_PARAMETER"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter_8cpp/#define-declare_parameter","text":"#define DECLARE_PARAMETER( IDENTIFIER ) declare_parameter < decltype ( IDENTIFIER ) > ( # IDENTIFIER , IDENTIFIER )","title":"define DECLARE_PARAMETER"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #define OPENSCENARIO_INTERPRETER_ALLOW_ATTRIBUTES_TO_BE_BLANK #define OPENSCENARIO_INTERPRETER_NO_EXTENSION #undef NDEBUG #include <boost/filesystem.hpp> #include <openscenario_interpreter/openscenario_interpreter.hpp> #include <rclcpp_components/register_node_macro.hpp> #include <memory> #include <string> namespace openscenario_interpreter { Interpreter :: Interpreter ( const rclcpp :: NodeOptions & options ) : rclcpp_lifecycle :: LifecycleNode ( \"openscenario_interpreter\" , options ), intended_result ( \"success\" ), local_frame_rate ( 30 ), local_real_time_factor ( 1.0 ), osc_path ( \"\" ), output_directory ( \"/tmp\" ) { #define DECLARE_PARAMETER(IDENTIFIER) \\ declare_parameter<decltype(IDENTIFIER)>(#IDENTIFIER, IDENTIFIER) DECLARE_PARAMETER ( intended_result ); DECLARE_PARAMETER ( local_frame_rate ); DECLARE_PARAMETER ( local_real_time_factor ); DECLARE_PARAMETER ( osc_path ); DECLARE_PARAMETER ( output_directory ); #undef DECLARE_PARAMETER } Interpreter :: Result Interpreter :: on_configure ( const rclcpp_lifecycle :: State & ) try { std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); #define GET_PARAMETER(IDENTIFIER) \\ get_parameter(#IDENTIFIER, IDENTIFIER) GET_PARAMETER ( intended_result ); GET_PARAMETER ( local_frame_rate ); GET_PARAMETER ( local_real_time_factor ); GET_PARAMETER ( osc_path ); GET_PARAMETER ( output_directory ); #undef GET_PARAMETER script . rebind < OpenScenario > ( osc_path ); connect ( shared_from_this (), boost :: filesystem :: path ( osc_path ). replace_extension ( \"\" ), script . as < OpenScenario > (). scope . logic_file . string ()); // NOTE: /path/to/lanelet2_map.osm const auto interval_upper_bound = 1 / local_frame_rate * local_real_time_factor ; initialize ( local_real_time_factor , interval_upper_bound ); return Interpreter :: Result :: SUCCESS ; } catch ( const openscenario_interpreter :: SyntaxError & error ) { std :: cerr << \" \\x1b [1;31m\" << error . what () << \" \\x1b [0m\" << std :: endl ; return Interpreter :: Result :: FAILURE ; } Interpreter :: Result Interpreter :: on_activate ( const rclcpp_lifecycle :: State & ) { timer = create_wall_timer ( std :: chrono :: milliseconds ( static_cast < unsigned int > ( 1 / local_frame_rate * 1000 )), [ this ]() { withExceptionHandler ( [ this ]() { if ( script ) { if ( ! script . as < OpenScenario > (). complete ()) { script . as < OpenScenario > (). evaluate (); #ifndef NDEBUG RCLCPP_INFO ( get_logger (), \"[%d standby (=> %d) => %d running (=> %d) => %d complete] \\n \" , openscenario_interpreter :: standby_state . use_count () - 1 , openscenario_interpreter :: start_transition . use_count () - 1 , openscenario_interpreter :: running_state . use_count () - 1 , openscenario_interpreter :: stop_transition . use_count () - 1 , openscenario_interpreter :: complete_state . use_count () - 1 ); #endif } else { if ( intended_result == \"success\" ) { report ( SUCCESS , \"intended-success\" ); } else { report ( FAILURE , \"unintended-success\" , \"expected \" + intended_result ); } } } }); }); return Interpreter :: Result :: SUCCESS ; } Interpreter :: Result Interpreter :: on_deactivate ( const rclcpp_lifecycle :: State & ) { timer . reset (); return Interpreter :: Result :: SUCCESS ; } Interpreter :: Result Interpreter :: on_cleanup ( const rclcpp_lifecycle :: State & ) { connection . ~ API (); return Interpreter :: Result :: SUCCESS ; } Interpreter :: Result Interpreter :: on_shutdown ( const rclcpp_lifecycle :: State & ) { timer . reset (); return Interpreter :: Result :: SUCCESS ; } Interpreter :: Result Interpreter :: on_error ( const rclcpp_lifecycle :: State & ) { timer . reset (); return Interpreter :: Result :: SUCCESS ; } } // namespace openscenario_interpreter RCLCPP_COMPONENTS_REGISTER_NODE ( openscenario_interpreter :: Interpreter ) Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/openscenario_interpreter.hpp # Namespaces # Name openscenario_interpreter Classes # Name class openscenario_interpreter::Interpreter Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__OPENSCENARIO_INTERPRETER_HPP_ #define OPENSCENARIO_INTERPRETER__OPENSCENARIO_INTERPRETER_HPP_ #include <junit_exporter/junit_exporter.hpp> #include <lifecycle_msgs/msg/state.hpp> #include <lifecycle_msgs/msg/transition.hpp> #include <openscenario_interpreter/syntax/openscenario.hpp> #include <openscenario_interpreter/utility/verbose.hpp> #include <openscenario_interpreter/utility/visibility.h> #include <rclcpp_lifecycle/lifecycle_node.hpp> #include <rclcpp/rclcpp.hpp> #include <memory> #include <string> #include <utility> namespace openscenario_interpreter { class Interpreter : public rclcpp_lifecycle :: LifecycleNode { /* ---- NOTE ----------------------------------------------------------------- * * ROS Parameters * * - intended_result * - local_frame_rate * - local_real_time_factor * - osc_path * - output_directory * * ------------------------------------------------------------------------ */ std :: string intended_result ; double local_frame_rate ; double local_real_time_factor ; std :: string osc_path ; std :: string output_directory ; Element script ; std :: shared_ptr < rclcpp :: TimerBase > timer ; junit_exporter :: JunitExporter exporter ; const junit_exporter :: TestResult ERROR = junit_exporter :: TestResult :: ERROR ; const junit_exporter :: TestResult FAILURE = junit_exporter :: TestResult :: FAILURE ; const junit_exporter :: TestResult SUCCESS = junit_exporter :: TestResult :: SUCCESS ; decltype ( auto ) report ( const junit_exporter :: TestResult & result , const std :: string & type , const std :: string & what = \"\" ) { exporter . addTestCase ( script . as < OpenScenario > (). scope . scenario . string (), // XXX DIRTY HACK!!! \"scenario_testing\" , 0 , result , type , what ); switch ( result ) { case junit_exporter :: TestResult :: ERROR : case junit_exporter :: TestResult :: FAILURE : if ( what . empty ()) { std :: cout << \" \\x1b [1;31mYield \" << type . c_str () << \" \\x1b [0m\" << std :: endl ; } else { std :: cout << \" \\x1b [1;31mYield \" << type . c_str () << \" (\" << what . c_str () << \") \\x1b [0m\" << std :: endl ; } break ; case junit_exporter :: TestResult :: SUCCESS : if ( what . empty ()) { std :: cout << \" \\x1b [32mYield \" << type . c_str () << \" \\x1b [0m\" << std :: endl ; } else { std :: cout << \" \\x1b [32mYield \" << type . c_str () << \" (\" << what . c_str () << \") \\x1b [0m\" << std :: endl ; } break ; } exporter . write ( output_directory + \"/result.junit.xml\" ); script . reset (); while ( get_current_state (). id () != lifecycle_msgs :: msg :: State :: PRIMARY_STATE_ACTIVE ) { std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); } deactivate (); } template < typename Thunk > void withExceptionHandler ( Thunk && thunk ) { try { return thunk (); } catch ( const int command ) { switch ( command ) { case EXIT_SUCCESS : if ( intended_result == \"success\" ) { report ( SUCCESS , \"intended-success\" ); } else { report ( FAILURE , \"unintended-success\" , \"expected \" + intended_result ); } break ; case EXIT_FAILURE : if ( intended_result == \"failure\" ) { report ( SUCCESS , \"intended-failure\" ); } else { report ( FAILURE , \"unintended-failure\" , \"expected \" + intended_result ); } break ; default : break ; } } catch ( const openscenario_interpreter :: SemanticError & error ) { if ( intended_result == \"error\" ) { report ( SUCCESS , \"intended-error\" ); } else { report ( ERROR , \"semantic-error\" , error . what ()); } } catch ( const openscenario_interpreter :: ImplementationFault & error ) { if ( intended_result == \"error\" ) { report ( SUCCESS , \"intended-error\" ); } else { report ( ERROR , \"implementation-fault\" , error . what ()); } } catch ( const std :: exception & error ) { if ( intended_result == \"error\" ) { report ( SUCCESS , \"intended-error\" ); } else { report ( ERROR , \"unexpected-standard-exception\" , error . what ()); } } catch (...) { report ( ERROR , \"unexpected-unknown-exception\" ); } } public : OPENSCENARIO_INTERPRETER_PUBLIC explicit Interpreter ( const rclcpp :: NodeOptions & ); using Result = rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn ; Result on_configure ( const rclcpp_lifecycle :: State & ) override ; Result on_activate ( const rclcpp_lifecycle :: State & ) override ; Result on_deactivate ( const rclcpp_lifecycle :: State & ) override ; Result on_cleanup ( const rclcpp_lifecycle :: State & ) override ; Result on_shutdown ( const rclcpp_lifecycle :: State & ) override ; Result on_error ( const rclcpp_lifecycle :: State & ) override ; }; } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__OPENSCENARIO_INTERPRETER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/openscenario_interpreter.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreteropenscenario_interpreterhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/openscenario_interpreter.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter_8hpp/#namespaces","text":"Name openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter_8hpp/#classes","text":"Name class openscenario_interpreter::Interpreter","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__OPENSCENARIO_INTERPRETER_HPP_ #define OPENSCENARIO_INTERPRETER__OPENSCENARIO_INTERPRETER_HPP_ #include <junit_exporter/junit_exporter.hpp> #include <lifecycle_msgs/msg/state.hpp> #include <lifecycle_msgs/msg/transition.hpp> #include <openscenario_interpreter/syntax/openscenario.hpp> #include <openscenario_interpreter/utility/verbose.hpp> #include <openscenario_interpreter/utility/visibility.h> #include <rclcpp_lifecycle/lifecycle_node.hpp> #include <rclcpp/rclcpp.hpp> #include <memory> #include <string> #include <utility> namespace openscenario_interpreter { class Interpreter : public rclcpp_lifecycle :: LifecycleNode { /* ---- NOTE ----------------------------------------------------------------- * * ROS Parameters * * - intended_result * - local_frame_rate * - local_real_time_factor * - osc_path * - output_directory * * ------------------------------------------------------------------------ */ std :: string intended_result ; double local_frame_rate ; double local_real_time_factor ; std :: string osc_path ; std :: string output_directory ; Element script ; std :: shared_ptr < rclcpp :: TimerBase > timer ; junit_exporter :: JunitExporter exporter ; const junit_exporter :: TestResult ERROR = junit_exporter :: TestResult :: ERROR ; const junit_exporter :: TestResult FAILURE = junit_exporter :: TestResult :: FAILURE ; const junit_exporter :: TestResult SUCCESS = junit_exporter :: TestResult :: SUCCESS ; decltype ( auto ) report ( const junit_exporter :: TestResult & result , const std :: string & type , const std :: string & what = \"\" ) { exporter . addTestCase ( script . as < OpenScenario > (). scope . scenario . string (), // XXX DIRTY HACK!!! \"scenario_testing\" , 0 , result , type , what ); switch ( result ) { case junit_exporter :: TestResult :: ERROR : case junit_exporter :: TestResult :: FAILURE : if ( what . empty ()) { std :: cout << \" \\x1b [1;31mYield \" << type . c_str () << \" \\x1b [0m\" << std :: endl ; } else { std :: cout << \" \\x1b [1;31mYield \" << type . c_str () << \" (\" << what . c_str () << \") \\x1b [0m\" << std :: endl ; } break ; case junit_exporter :: TestResult :: SUCCESS : if ( what . empty ()) { std :: cout << \" \\x1b [32mYield \" << type . c_str () << \" \\x1b [0m\" << std :: endl ; } else { std :: cout << \" \\x1b [32mYield \" << type . c_str () << \" (\" << what . c_str () << \") \\x1b [0m\" << std :: endl ; } break ; } exporter . write ( output_directory + \"/result.junit.xml\" ); script . reset (); while ( get_current_state (). id () != lifecycle_msgs :: msg :: State :: PRIMARY_STATE_ACTIVE ) { std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); } deactivate (); } template < typename Thunk > void withExceptionHandler ( Thunk && thunk ) { try { return thunk (); } catch ( const int command ) { switch ( command ) { case EXIT_SUCCESS : if ( intended_result == \"success\" ) { report ( SUCCESS , \"intended-success\" ); } else { report ( FAILURE , \"unintended-success\" , \"expected \" + intended_result ); } break ; case EXIT_FAILURE : if ( intended_result == \"failure\" ) { report ( SUCCESS , \"intended-failure\" ); } else { report ( FAILURE , \"unintended-failure\" , \"expected \" + intended_result ); } break ; default : break ; } } catch ( const openscenario_interpreter :: SemanticError & error ) { if ( intended_result == \"error\" ) { report ( SUCCESS , \"intended-error\" ); } else { report ( ERROR , \"semantic-error\" , error . what ()); } } catch ( const openscenario_interpreter :: ImplementationFault & error ) { if ( intended_result == \"error\" ) { report ( SUCCESS , \"intended-error\" ); } else { report ( ERROR , \"implementation-fault\" , error . what ()); } } catch ( const std :: exception & error ) { if ( intended_result == \"error\" ) { report ( SUCCESS , \"intended-error\" ); } else { report ( ERROR , \"unexpected-standard-exception\" , error . what ()); } } catch (...) { report ( ERROR , \"unexpected-unknown-exception\" ); } } public : OPENSCENARIO_INTERPRETER_PUBLIC explicit Interpreter ( const rclcpp :: NodeOptions & ); using Result = rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn ; Result on_configure ( const rclcpp_lifecycle :: State & ) override ; Result on_activate ( const rclcpp_lifecycle :: State & ) override ; Result on_deactivate ( const rclcpp_lifecycle :: State & ) override ; Result on_cleanup ( const rclcpp_lifecycle :: State & ) override ; Result on_shutdown ( const rclcpp_lifecycle :: State & ) override ; Result on_error ( const rclcpp_lifecycle :: State & ) override ; }; } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__OPENSCENARIO_INTERPRETER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter__node_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/openscenario_interpreter_node.cpp # Functions # Name int main (const int argc, char const const const argv) Functions Documentation # function main # int main ( const int argc , char const * const * const argv ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <glog/logging.h> #include <openscenario_interpreter/openscenario_interpreter.hpp> #include <cstdlib> #include <memory> int main ( const int argc , char const * const * const argv ) { google :: InitGoogleLogging ( argv [ 0 ]); google :: InstallFailureSignalHandler (); rclcpp :: init ( argc , argv ); rclcpp :: executors :: SingleThreadedExecutor executor {}; rclcpp :: NodeOptions options {}; const auto node = std :: make_shared < openscenario_interpreter :: Interpreter > ( options ); executor . add_node (( * node ). get_node_base_interface ()); executor . spin (); return rclcpp :: shutdown () ? EXIT_SUCCESS : EXIT_FAILURE ; } Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/openscenario_interpreter_node.cpp"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter__node_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpretersrcopenscenario_interpreter_nodecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/openscenario_interpreter_node.cpp"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter__node_8cpp/#functions","text":"Name int main (const int argc, char const const const argv)","title":"Functions"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter__node_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter__node_8cpp/#function-main","text":"int main ( const int argc , char const * const * const argv )","title":"function main"},{"location":"package/openscenario_interpreter/markdown/Files/openscenario__interpreter__node_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <glog/logging.h> #include <openscenario_interpreter/openscenario_interpreter.hpp> #include <cstdlib> #include <memory> int main ( const int argc , char const * const * const argv ) { google :: InitGoogleLogging ( argv [ 0 ]); google :: InstallFailureSignalHandler (); rclcpp :: init ( argc , argv ); rclcpp :: executors :: SingleThreadedExecutor executor {}; rclcpp :: NodeOptions options {}; const auto node = std :: make_shared < openscenario_interpreter :: Interpreter > ( options ); executor . add_node (( * node ). get_node_base_interface ()); executor . spin (); return rclcpp :: shutdown () ? EXIT_SUCCESS : EXIT_FAILURE ; } Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/orientation_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/orientation.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Orientation Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ORIENTATION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ORIENTATION_HPP_ #include <geometry_msgs/msg/vector3.hpp> #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/syntax/reference_context.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- Orientation ---------------------------------------------------------- * * <xsd:complexType name=\"Orientation\"> * <xsd:attribute name=\"type\" type=\"ReferenceContext\" use=\"optional\"/> * <xsd:attribute name=\"h\" type=\"Double\" use=\"optional\"/> * <xsd:attribute name=\"p\" type=\"Double\" use=\"optional\"/> * <xsd:attribute name=\"r\" type=\"Double\" use=\"optional\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Orientation { const ReferenceContext type ; const Double h , p , r ; Orientation () = default ; template < typename Node , typename Scope > explicit Orientation ( const Node & node , Scope & scope ) : type ( readAttribute < ReferenceContext > ( \"type\" , node , scope , ReferenceContext :: relative )), h ( readAttribute < Double > ( \"h\" , node , scope , Double ())), p ( readAttribute < Double > ( \"p\" , node , scope , Double ())), r ( readAttribute < Double > ( \"r\" , node , scope , Double ())) {} operator geometry_msgs :: msg :: Vector3 () const { geometry_msgs :: msg :: Vector3 result {}; switch ( type ) { case ReferenceContext :: relative : result . x = r ; // roll result . y = p ; // pitch result . z = h ; // yaw (heading) break ; case ReferenceContext :: absolute : // Jumps can never reach here (see ReferenceContext::operator >>). default : break ; } return result ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ORIENTATION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/orientation.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/orientation_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxorientationhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/orientation.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/orientation_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/orientation_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Orientation","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/orientation_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ORIENTATION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ORIENTATION_HPP_ #include <geometry_msgs/msg/vector3.hpp> #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/syntax/reference_context.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- Orientation ---------------------------------------------------------- * * <xsd:complexType name=\"Orientation\"> * <xsd:attribute name=\"type\" type=\"ReferenceContext\" use=\"optional\"/> * <xsd:attribute name=\"h\" type=\"Double\" use=\"optional\"/> * <xsd:attribute name=\"p\" type=\"Double\" use=\"optional\"/> * <xsd:attribute name=\"r\" type=\"Double\" use=\"optional\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Orientation { const ReferenceContext type ; const Double h , p , r ; Orientation () = default ; template < typename Node , typename Scope > explicit Orientation ( const Node & node , Scope & scope ) : type ( readAttribute < ReferenceContext > ( \"type\" , node , scope , ReferenceContext :: relative )), h ( readAttribute < Double > ( \"h\" , node , scope , Double ())), p ( readAttribute < Double > ( \"p\" , node , scope , Double ())), r ( readAttribute < Double > ( \"r\" , node , scope , Double ())) {} operator geometry_msgs :: msg :: Vector3 () const { geometry_msgs :: msg :: Vector3 result {}; switch ( type ) { case ReferenceContext :: relative : result . x = r ; // roll result . y = p ; // pitch result . z = h ; // yaw (heading) break ; case ReferenceContext :: absolute : // Jumps can never reach here (see ReferenceContext::operator >>). default : break ; } return result ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ORIENTATION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/override__controller__value__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/override_controller_value_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::OverrideControllerValueAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__OVERRIDE_CONTROLLER_VALUE_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__OVERRIDE_CONTROLLER_VALUE_ACTION_HPP_ namespace openscenario_interpreter { inline namespace syntax { /* ---- OverrideControllerValueAction ------------------------------------------ * * Overrides entity controller values. Mostly suited for motor vehicles. * * <xsd:complexType name=\"OverrideControllerValueAction\"> * <xsd:all> * <xsd:element name=\"Throttle\" type=\"OverrideThrottleAction\"/> * <xsd:element name=\"Brake\" type=\"OverrideBrakeAction\"/> * <xsd:element name=\"Clutch\" type=\"OverrideClutchAction\"/> * <xsd:element name=\"ParkingBrake\" type=\"OverrideParkingBrakeAction\"/> * <xsd:element name=\"SteeringWheel\" type=\"OverrideSteeringWheelAction\"/> * <xsd:element name=\"Gear\" type=\"OverrideGearAction\"/> * </xsd:all> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct OverrideControllerValueAction { /* ---- OverrideThrottleAction ----------------------------------------------- * * New value for throttle pedal position or unset value. * * ------------------------------------------------------------------------ */ // TODO(yamacir-kit): const OverrideThrottleAction overrideThrottle; /* ---- OverrideBrakeAction -------------------------------------------------- * * New value for brake position or unset value. * * ------------------------------------------------------------------------ */ // TODO(yamacir-kit): const OverrideBrakeAction overrideBrake; /* ---- OverrideClutchAction ------------------------------------------------- * * New value for clutch position or unset value. * * ------------------------------------------------------------------------ */ // TODO(yamacir-kit): const OverrideClutchAction overrideClutch; /* ---- OverrideParkingBrakeAction ------------------------------------------- * * New value for parking brake position or unset value. * * ------------------------------------------------------------------------ */ // TODO(yamacir-kit): const OverrideParkingBrakeAction overrideParkingBrake; /* ---- OverrideSteeringWheelAction ------------------------------------------ * * New value for steering wheel position or unset value. * * ------------------------------------------------------------------------ */ // TODO(yamacir-kit): const OverrideSteeringWheelAction overrideSteeringWheel; /* ---- OverrideGearAction --------------------------------------------------- * * New value for gear position or unset value. * * ------------------------------------------------------------------------ */ // TODO(yamacir-kit): const OverrideGearAction overrideGear; template < typename Node , typename Scope > explicit OverrideControllerValueAction ( const Node & , Scope & ) {} }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__OVERRIDE_CONTROLLER_VALUE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/override_controller_value_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/override__controller__value__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxoverride_controller_value_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/override_controller_value_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/override__controller__value__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/override__controller__value__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::OverrideControllerValueAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/override__controller__value__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__OVERRIDE_CONTROLLER_VALUE_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__OVERRIDE_CONTROLLER_VALUE_ACTION_HPP_ namespace openscenario_interpreter { inline namespace syntax { /* ---- OverrideControllerValueAction ------------------------------------------ * * Overrides entity controller values. Mostly suited for motor vehicles. * * <xsd:complexType name=\"OverrideControllerValueAction\"> * <xsd:all> * <xsd:element name=\"Throttle\" type=\"OverrideThrottleAction\"/> * <xsd:element name=\"Brake\" type=\"OverrideBrakeAction\"/> * <xsd:element name=\"Clutch\" type=\"OverrideClutchAction\"/> * <xsd:element name=\"ParkingBrake\" type=\"OverrideParkingBrakeAction\"/> * <xsd:element name=\"SteeringWheel\" type=\"OverrideSteeringWheelAction\"/> * <xsd:element name=\"Gear\" type=\"OverrideGearAction\"/> * </xsd:all> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct OverrideControllerValueAction { /* ---- OverrideThrottleAction ----------------------------------------------- * * New value for throttle pedal position or unset value. * * ------------------------------------------------------------------------ */ // TODO(yamacir-kit): const OverrideThrottleAction overrideThrottle; /* ---- OverrideBrakeAction -------------------------------------------------- * * New value for brake position or unset value. * * ------------------------------------------------------------------------ */ // TODO(yamacir-kit): const OverrideBrakeAction overrideBrake; /* ---- OverrideClutchAction ------------------------------------------------- * * New value for clutch position or unset value. * * ------------------------------------------------------------------------ */ // TODO(yamacir-kit): const OverrideClutchAction overrideClutch; /* ---- OverrideParkingBrakeAction ------------------------------------------- * * New value for parking brake position or unset value. * * ------------------------------------------------------------------------ */ // TODO(yamacir-kit): const OverrideParkingBrakeAction overrideParkingBrake; /* ---- OverrideSteeringWheelAction ------------------------------------------ * * New value for steering wheel position or unset value. * * ------------------------------------------------------------------------ */ // TODO(yamacir-kit): const OverrideSteeringWheelAction overrideSteeringWheel; /* ---- OverrideGearAction --------------------------------------------------- * * New value for gear position or unset value. * * ------------------------------------------------------------------------ */ // TODO(yamacir-kit): const OverrideGearAction overrideGear; template < typename Node , typename Scope > explicit OverrideControllerValueAction ( const Node & , Scope & ) {} }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__OVERRIDE_CONTROLLER_VALUE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/pair_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/pair.hpp # Namespaces # Name openscenario_interpreter::utility openscenario_interpreter Defines # Name COMPOSE (NAME, F, G) Macro Documentation # define COMPOSE # #define COMPOSE( NAME , F , G ) template < typename ... Ts > \\ constexpr decltype ( auto ) NAME ( Ts && ... xs ) \\ { \\ return F ( G ( std :: forward < decltype ( xs ) > ( xs )...)); \\ } static_assert ( true , \"\" ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__UTILITY__PAIR_HPP_ #define OPENSCENARIO_INTERPRETER__UTILITY__PAIR_HPP_ #include <utility> namespace openscenario_interpreter { inline namespace utility { auto car = [] ( auto && pare ) noexcept -> decltype ( auto ) { return std :: get < 0 > ( pare ); }; auto cdr = [] ( auto && pare ) noexcept -> decltype ( auto ) { return std :: get < 1 > ( pare ); }; #define COMPOSE(NAME, F, G) \\ template<typename ... Ts> \\ constexpr decltype(auto) NAME(Ts && ... xs) \\ { \\ return F(G(std::forward<decltype(xs)>(xs)...)); \\ } static_assert(true, \"\") COMPOSE ( caar , car , car ); COMPOSE ( cadr , car , cdr ); COMPOSE ( cdar , cdr , car ); COMPOSE ( cddr , cdr , cdr ); #undef COMPOSE } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__UTILITY__PAIR_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/pair.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/pair_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterutilitypairhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/pair.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/pair_8hpp/#namespaces","text":"Name openscenario_interpreter::utility openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/pair_8hpp/#defines","text":"Name COMPOSE (NAME, F, G)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/pair_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/pair_8hpp/#define-compose","text":"#define COMPOSE( NAME , F , G ) template < typename ... Ts > \\ constexpr decltype ( auto ) NAME ( Ts && ... xs ) \\ { \\ return F ( G ( std :: forward < decltype ( xs ) > ( xs )...)); \\ } static_assert ( true , \"\" )","title":"define COMPOSE"},{"location":"package/openscenario_interpreter/markdown/Files/pair_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__UTILITY__PAIR_HPP_ #define OPENSCENARIO_INTERPRETER__UTILITY__PAIR_HPP_ #include <utility> namespace openscenario_interpreter { inline namespace utility { auto car = [] ( auto && pare ) noexcept -> decltype ( auto ) { return std :: get < 0 > ( pare ); }; auto cdr = [] ( auto && pare ) noexcept -> decltype ( auto ) { return std :: get < 1 > ( pare ); }; #define COMPOSE(NAME, F, G) \\ template<typename ... Ts> \\ constexpr decltype(auto) NAME(Ts && ... xs) \\ { \\ return F(G(std::forward<decltype(xs)>(xs)...)); \\ } static_assert(true, \"\") COMPOSE ( caar , car , car ); COMPOSE ( cadr , car , cdr ); COMPOSE ( cdar , cdr , car ); COMPOSE ( cddr , cdr , cdr ); #undef COMPOSE } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__UTILITY__PAIR_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ParameterAction Defines # Name ELEMENT (NAME) Macro Documentation # define ELEMENT # #define ELEMENT( NAME ) std :: make_pair ( \\ #NAME, [&](auto && child) \\ { \\ return make<Parameter ## NAME>( \\ child, outer_scope, readAttribute<String>(\"parameterRef\", parent, outer_scope)); \\ }) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_ACTION_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/reader/element.hpp> #include <openscenario_interpreter/syntax/parameter_modify_action.hpp> #include <openscenario_interpreter/syntax/parameter_set_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ParameterAction -------------------------------------------------------- * * <xsd:complexType name=\"ParameterAction\"> * <xsd:choice> * <xsd:element name=\"SetAction\" type=\"ParameterSetAction\"/> * <xsd:element name=\"ModifyAction\" type=\"ParameterModifyAction\"/> * </xsd:choice> * <xsd:attribute name=\"parameterRef\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(NAME) \\ std::make_pair( \\ #NAME, [&](auto && child) \\ { \\ return make<Parameter ## NAME>( \\ child, outer_scope, readAttribute<String>(\"parameterRef\", parent, outer_scope)); \\ }) struct ParameterAction : public Element { template < typename Node , typename Scope > explicit ParameterAction ( const Node & parent , Scope & outer_scope ) : Element ( choice ( parent , ELEMENT ( SetAction ), ELEMENT ( ModifyAction ))) {} }; #undef ELEMENT } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxparameter_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ParameterAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__action_8hpp/#defines","text":"Name ELEMENT (NAME)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__action_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__action_8hpp/#define-element","text":"#define ELEMENT( NAME ) std :: make_pair ( \\ #NAME, [&](auto && child) \\ { \\ return make<Parameter ## NAME>( \\ child, outer_scope, readAttribute<String>(\"parameterRef\", parent, outer_scope)); \\ })","title":"define ELEMENT"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_ACTION_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/reader/element.hpp> #include <openscenario_interpreter/syntax/parameter_modify_action.hpp> #include <openscenario_interpreter/syntax/parameter_set_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ParameterAction -------------------------------------------------------- * * <xsd:complexType name=\"ParameterAction\"> * <xsd:choice> * <xsd:element name=\"SetAction\" type=\"ParameterSetAction\"/> * <xsd:element name=\"ModifyAction\" type=\"ParameterModifyAction\"/> * </xsd:choice> * <xsd:attribute name=\"parameterRef\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(NAME) \\ std::make_pair( \\ #NAME, [&](auto && child) \\ { \\ return make<Parameter ## NAME>( \\ child, outer_scope, readAttribute<String>(\"parameterRef\", parent, outer_scope)); \\ }) struct ParameterAction : public Element { template < typename Node , typename Scope > explicit ParameterAction ( const Node & parent , Scope & outer_scope ) : Element ( choice ( parent , ELEMENT ( SetAction ), ELEMENT ( ModifyAction ))) {} }; #undef ELEMENT } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__add__value__rule_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_add_value_rule.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ParameterAddValueRule Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_ADD_VALUE_RULE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_ADD_VALUE_RULE_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <typeindex> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ParameterAddValueRule -------------------------------------------------- * * <xsd:complexType name=\"ParameterAddValueRule\"> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ParameterAddValueRule { const Double value ; template < typename ... Ts > explicit ParameterAddValueRule ( Ts && ... xs ) : value ( readAttribute < Double > ( \"value\" , std :: forward < decltype ( xs ) > ( xs )...)) {} auto operator ()( const Element & target ) const { static const std :: unordered_map < std :: type_index , std :: function < Element ( const Element & , const Double & ) > > overloads { { typeid ( Integer ), []( auto && target , auto && value ) { target . template as < Integer > () += value ; return target ; } }, { typeid ( Double ), []( auto && target , auto && value ) { target . template as < Double > () += value ; return target ; } }, { typeid ( UnsignedInteger ), []( auto && target , auto && value ) { target . template as < UnsignedInteger > () += value ; return target ; } }, { typeid ( UnsignedShort ), []( auto && target , auto && value ) { target . template as < UnsignedShort > () += value ; return target ; } }, }; const auto iter { overloads . find ( target . type ())}; if ( iter != std :: end ( overloads )) { return std :: get < 1 > ( * iter )( target , value ); } else { std :: stringstream ss {}; ss << \"The parameter specified by attrribute 'parameterRef' of type 'ParameterAction' \" ; ss << \"must be numeric type (double, integer, unsignedInteger or unsignedShort), but \" ; ss << target << \" (type \" << target . type (). name () << \") specified\" ; throw SyntaxError ( ss . str ()); } } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_ADD_VALUE_RULE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_add_value_rule.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__add__value__rule_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxparameter_add_value_rulehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_add_value_rule.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__add__value__rule_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__add__value__rule_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ParameterAddValueRule","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__add__value__rule_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_ADD_VALUE_RULE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_ADD_VALUE_RULE_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <typeindex> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ParameterAddValueRule -------------------------------------------------- * * <xsd:complexType name=\"ParameterAddValueRule\"> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ParameterAddValueRule { const Double value ; template < typename ... Ts > explicit ParameterAddValueRule ( Ts && ... xs ) : value ( readAttribute < Double > ( \"value\" , std :: forward < decltype ( xs ) > ( xs )...)) {} auto operator ()( const Element & target ) const { static const std :: unordered_map < std :: type_index , std :: function < Element ( const Element & , const Double & ) > > overloads { { typeid ( Integer ), []( auto && target , auto && value ) { target . template as < Integer > () += value ; return target ; } }, { typeid ( Double ), []( auto && target , auto && value ) { target . template as < Double > () += value ; return target ; } }, { typeid ( UnsignedInteger ), []( auto && target , auto && value ) { target . template as < UnsignedInteger > () += value ; return target ; } }, { typeid ( UnsignedShort ), []( auto && target , auto && value ) { target . template as < UnsignedShort > () += value ; return target ; } }, }; const auto iter { overloads . find ( target . type ())}; if ( iter != std :: end ( overloads )) { return std :: get < 1 > ( * iter )( target , value ); } else { std :: stringstream ss {}; ss << \"The parameter specified by attrribute 'parameterRef' of type 'ParameterAction' \" ; ss << \"must be numeric type (double, integer, unsignedInteger or unsignedShort), but \" ; ss << target << \" (type \" << target . type (). name () << \") specified\" ; throw SyntaxError ( ss . str ()); } } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_ADD_VALUE_RULE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ParameterCondition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_CONDITION_HPP_ #include <openscenario_interpreter/syntax/rule.hpp> #include <string> #include <typeindex> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ParameterCondition ----------------------------------------------------- * * <xsd:complexType name=\"ParameterCondition\"> * <xsd:attribute name=\"parameterRef\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"value\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"rule\" type=\"Rule\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ParameterCondition { const String parameter_ref ; const String value ; const Rule compare ; Scope inner_scope ; template < typename Node > explicit ParameterCondition ( const Node & node , Scope & outer_scope ) : parameter_ref ( readAttribute < String > ( \"parameterRef\" , node , outer_scope )), value ( readAttribute < String > ( \"value\" , node , outer_scope )), compare ( readAttribute < Rule > ( \"rule\" , node , outer_scope )), inner_scope ( outer_scope ) {} auto evaluate () const { static const std :: unordered_map < std :: type_index , std :: function < bool ( const Rule , const Element & , const String & ) > > overloads { { typeid ( Integer ), []( auto && compare , auto && lhs , auto && rhs ) { return compare ( lhs . template as < Integer > (), boost :: lexical_cast < Integer > ( rhs )); } }, { typeid ( Double ), []( auto && compare , auto && lhs , auto && rhs ) { return compare ( lhs . template as < Double > (), boost :: lexical_cast < Double > ( rhs )); } }, { typeid ( String ), []( auto && compare , auto && lhs , auto && rhs ) { return compare ( lhs . template as < String > (), rhs ); } }, { typeid ( UnsignedInteger ), []( auto && compare , auto && lhs , auto && rhs ) { return compare ( lhs . template as < UnsignedInteger > (), boost :: lexical_cast < UnsignedInteger > ( rhs )); } }, { typeid ( UnsignedShort ), []( auto && compare , auto && lhs , auto && rhs ) { return compare ( lhs . template as < UnsignedShort > (), boost :: lexical_cast < UnsignedShort > ( rhs )); } }, { typeid ( Boolean ), []( auto && compare , auto && lhs , auto && rhs ) { return compare ( lhs . template as < Boolean > (), boost :: lexical_cast < Boolean > ( rhs )); } }, }; const auto target { inner_scope . parameters . find ( parameter_ref ) }; if ( target != std :: end ( inner_scope . parameters )) { const auto iter { overloads . find ( std :: get < 1 > ( * target ). type ()) }; if ( iter != std :: end ( overloads )) { #ifndef NDEBUG std :: cout << \"ParameterCondition: \" << std :: get < 1 > ( * target ) << \" \" << compare << \" \" << value << \" => \" ; #endif const auto result = std :: get < 1 > ( * iter )( compare , std :: get < 1 > ( * target ), value ) ? true_v : false_v ; #ifndef NDEBUG std :: cout << result << std :: endl ; #endif return result ; } else { throw SemanticError ( \"No viable operation '\" + boost :: lexical_cast < std :: string > ( compare ) + \"' with parameter '\" + parameter_ref + \"' and value '\" + boost :: lexical_cast < std :: string > ( value ) + \"'\" ); } } else { throw SemanticError ( \"No such parameter '\" + parameter_ref + \"'\" ); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxparameter_conditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ParameterCondition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_CONDITION_HPP_ #include <openscenario_interpreter/syntax/rule.hpp> #include <string> #include <typeindex> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ParameterCondition ----------------------------------------------------- * * <xsd:complexType name=\"ParameterCondition\"> * <xsd:attribute name=\"parameterRef\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"value\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"rule\" type=\"Rule\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ParameterCondition { const String parameter_ref ; const String value ; const Rule compare ; Scope inner_scope ; template < typename Node > explicit ParameterCondition ( const Node & node , Scope & outer_scope ) : parameter_ref ( readAttribute < String > ( \"parameterRef\" , node , outer_scope )), value ( readAttribute < String > ( \"value\" , node , outer_scope )), compare ( readAttribute < Rule > ( \"rule\" , node , outer_scope )), inner_scope ( outer_scope ) {} auto evaluate () const { static const std :: unordered_map < std :: type_index , std :: function < bool ( const Rule , const Element & , const String & ) > > overloads { { typeid ( Integer ), []( auto && compare , auto && lhs , auto && rhs ) { return compare ( lhs . template as < Integer > (), boost :: lexical_cast < Integer > ( rhs )); } }, { typeid ( Double ), []( auto && compare , auto && lhs , auto && rhs ) { return compare ( lhs . template as < Double > (), boost :: lexical_cast < Double > ( rhs )); } }, { typeid ( String ), []( auto && compare , auto && lhs , auto && rhs ) { return compare ( lhs . template as < String > (), rhs ); } }, { typeid ( UnsignedInteger ), []( auto && compare , auto && lhs , auto && rhs ) { return compare ( lhs . template as < UnsignedInteger > (), boost :: lexical_cast < UnsignedInteger > ( rhs )); } }, { typeid ( UnsignedShort ), []( auto && compare , auto && lhs , auto && rhs ) { return compare ( lhs . template as < UnsignedShort > (), boost :: lexical_cast < UnsignedShort > ( rhs )); } }, { typeid ( Boolean ), []( auto && compare , auto && lhs , auto && rhs ) { return compare ( lhs . template as < Boolean > (), boost :: lexical_cast < Boolean > ( rhs )); } }, }; const auto target { inner_scope . parameters . find ( parameter_ref ) }; if ( target != std :: end ( inner_scope . parameters )) { const auto iter { overloads . find ( std :: get < 1 > ( * target ). type ()) }; if ( iter != std :: end ( overloads )) { #ifndef NDEBUG std :: cout << \"ParameterCondition: \" << std :: get < 1 > ( * target ) << \" \" << compare << \" \" << value << \" => \" ; #endif const auto result = std :: get < 1 > ( * iter )( compare , std :: get < 1 > ( * target ), value ) ? true_v : false_v ; #ifndef NDEBUG std :: cout << result << std :: endl ; #endif return result ; } else { throw SemanticError ( \"No viable operation '\" + boost :: lexical_cast < std :: string > ( compare ) + \"' with parameter '\" + parameter_ref + \"' and value '\" + boost :: lexical_cast < std :: string > ( value ) + \"'\" ); } } else { throw SemanticError ( \"No such parameter '\" + parameter_ref + \"'\" ); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__declaration_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_declaration.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ParameterDeclaration Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_DECLARATION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_DECLARATION_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <string> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ==== ParameterDeclaration ================================================= * * <xsd:complexType name=\"ParameterDeclaration\"> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"parameterType\" type=\"ParameterType\" use=\"required\"/> * <xsd:attribute name=\"value\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct ParameterDeclaration { const String name ; const ParameterType parameter_type ; const String value ; auto includes ( const std :: string & name , const std :: vector < char > & chars ) { for ( const auto & each : chars ) { if ( name . find ( each ) != std :: string :: npos ) { return true ; } } return false ; } ParameterDeclaration () = default ; template < typename Node , typename Scope > explicit ParameterDeclaration ( const Node & node , Scope & scope ) : name { readAttribute < String > ( \"name\" , node , scope )}, parameter_type { readAttribute < ParameterType > ( \"parameterType\" , node , scope )}, value { readAttribute < String > ( \"value\" , node , scope )} { if ( name . substr ( 0 , 3 ) == \"OSC\" ) { throw SyntaxError { \"Parameter names starting with \\\" OSC \\\" are reserved for special use in future versions \" \"of OpenSCENARIO. Generally, it is forbidden to use the OSC prefix.\" }; } else if ( includes ( name , { ' ' , '$' , '\\'' , '\"' })) { throw SyntaxError { \"In parameter names, usage of symbols is restricted. Symbols that must not be used are: \\n \" \" - \\\" \\\" (blank space) \\n \" \" - $ \\n \" \" - \\'\\n \" \" - \\\"\\n \" }; } else { scope . parameters . emplace ( name , evaluate ()); } } Element evaluate () const { switch ( parameter_type ) { case ParameterType :: INTEGER : return make < Integer > ( value ); case ParameterType :: DOUBLE : return make < Double > ( value ); case ParameterType :: STRING : return make < String > ( value ); case ParameterType :: UNSIGNED_INT : return make < UnsignedInt > ( value ); case ParameterType :: UNSIGNED_SHORT : return make < UnsignedShort > ( value ); case ParameterType :: BOOLEAN : return make < Boolean > ( value ); case ParameterType :: DATE_TIME : return make < String > ( value ); default : return unspecified ; } } }; std :: ostream & operator << ( std :: ostream & os , const ParameterDeclaration & declaration ) { return os << indent << blue << \"<ParameterDeclaration\" << \" \" << highlight ( \"name\" , declaration . name ) << \" \" << highlight ( \"parameterType\" , declaration . parameter_type ) << \" \" << highlight ( \"value\" , declaration . value ) << blue << \"/>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_DECLARATION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_declaration.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__declaration_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxparameter_declarationhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_declaration.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__declaration_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__declaration_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ParameterDeclaration","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__declaration_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_DECLARATION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_DECLARATION_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <string> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ==== ParameterDeclaration ================================================= * * <xsd:complexType name=\"ParameterDeclaration\"> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"parameterType\" type=\"ParameterType\" use=\"required\"/> * <xsd:attribute name=\"value\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct ParameterDeclaration { const String name ; const ParameterType parameter_type ; const String value ; auto includes ( const std :: string & name , const std :: vector < char > & chars ) { for ( const auto & each : chars ) { if ( name . find ( each ) != std :: string :: npos ) { return true ; } } return false ; } ParameterDeclaration () = default ; template < typename Node , typename Scope > explicit ParameterDeclaration ( const Node & node , Scope & scope ) : name { readAttribute < String > ( \"name\" , node , scope )}, parameter_type { readAttribute < ParameterType > ( \"parameterType\" , node , scope )}, value { readAttribute < String > ( \"value\" , node , scope )} { if ( name . substr ( 0 , 3 ) == \"OSC\" ) { throw SyntaxError { \"Parameter names starting with \\\" OSC \\\" are reserved for special use in future versions \" \"of OpenSCENARIO. Generally, it is forbidden to use the OSC prefix.\" }; } else if ( includes ( name , { ' ' , '$' , '\\'' , '\"' })) { throw SyntaxError { \"In parameter names, usage of symbols is restricted. Symbols that must not be used are: \\n \" \" - \\\" \\\" (blank space) \\n \" \" - $ \\n \" \" - \\'\\n \" \" - \\\"\\n \" }; } else { scope . parameters . emplace ( name , evaluate ()); } } Element evaluate () const { switch ( parameter_type ) { case ParameterType :: INTEGER : return make < Integer > ( value ); case ParameterType :: DOUBLE : return make < Double > ( value ); case ParameterType :: STRING : return make < String > ( value ); case ParameterType :: UNSIGNED_INT : return make < UnsignedInt > ( value ); case ParameterType :: UNSIGNED_SHORT : return make < UnsignedShort > ( value ); case ParameterType :: BOOLEAN : return make < Boolean > ( value ); case ParameterType :: DATE_TIME : return make < String > ( value ); default : return unspecified ; } } }; std :: ostream & operator << ( std :: ostream & os , const ParameterDeclaration & declaration ) { return os << indent << blue << \"<ParameterDeclaration\" << \" \" << highlight ( \"name\" , declaration . name ) << \" \" << highlight ( \"parameterType\" , declaration . parameter_type ) << \" \" << highlight ( \"value\" , declaration . value ) << blue << \"/>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_DECLARATION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__declarations_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_declarations.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ParameterDeclarations Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_DECLARATIONS_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_DECLARATIONS_HPP_ #include <openscenario_interpreter/reader/element.hpp> #include <openscenario_interpreter/scope.hpp> #include <openscenario_interpreter/syntax/parameter_declaration.hpp> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- ParameterDeclarations -------------------------------------------------- * * <xsd:complexType name=\"ParameterDeclarations\"> * <xsd:sequence> * <xsd:element name=\"ParameterDeclaration\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"ParameterDeclaration\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ParameterDeclarations : public std :: vector < ParameterDeclaration > { ParameterDeclarations () = default ; template < typename Node , typename Scope > explicit ParameterDeclarations ( const Node & node , Scope & outer_scope ) { callWithElements ( node , \"ParameterDeclaration\" , 0 , unbounded , [ & ]( auto && each ) { return emplace_back ( each , outer_scope ); }); } }; std :: ostream & operator << ( std :: ostream & os , const ParameterDeclarations & ) { return os << ( indent ++ ) << blue << \"<ParameterDeclarations>\" << reset << \" \\n \" << ( -- indent ) << blue << \"</ParameterDeclarations>\" ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_DECLARATIONS_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_declarations.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__declarations_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxparameter_declarationshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_declarations.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__declarations_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__declarations_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ParameterDeclarations","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__declarations_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_DECLARATIONS_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_DECLARATIONS_HPP_ #include <openscenario_interpreter/reader/element.hpp> #include <openscenario_interpreter/scope.hpp> #include <openscenario_interpreter/syntax/parameter_declaration.hpp> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- ParameterDeclarations -------------------------------------------------- * * <xsd:complexType name=\"ParameterDeclarations\"> * <xsd:sequence> * <xsd:element name=\"ParameterDeclaration\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"ParameterDeclaration\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ParameterDeclarations : public std :: vector < ParameterDeclaration > { ParameterDeclarations () = default ; template < typename Node , typename Scope > explicit ParameterDeclarations ( const Node & node , Scope & outer_scope ) { callWithElements ( node , \"ParameterDeclaration\" , 0 , unbounded , [ & ]( auto && each ) { return emplace_back ( each , outer_scope ); }); } }; std :: ostream & operator << ( std :: ostream & os , const ParameterDeclarations & ) { return os << ( indent ++ ) << blue << \"<ParameterDeclarations>\" << reset << \" \\n \" << ( -- indent ) << blue << \"</ParameterDeclarations>\" ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_DECLARATIONS_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__modify__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_modify_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ParameterModifyAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_MODIFY_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_MODIFY_ACTION_HPP_ #include <openscenario_interpreter/syntax/modify_rule.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- ModifyAction ----------------------------------------------------------- * * <xsd:complexType name=\"ParameterModifyAction\"> * <xsd:all> * <xsd:element name=\"Rule\" type=\"ModifyRule\"/> * </xsd:all> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ParameterModifyAction { Scope inner_scope ; const String parameter_ref ; const ModifyRule rule ; const std :: true_type accomplished {}; template < typename Node > explicit ParameterModifyAction ( const Node & node , Scope & outer_scope , const String & parameter_ref ) : inner_scope ( outer_scope ), parameter_ref ( parameter_ref ), rule ( readElement < ModifyRule > ( \"Rule\" , node , inner_scope )) {} auto evaluate () try { const auto target { inner_scope . parameters . at ( parameter_ref ) }; if ( rule . is < ParameterAddValueRule > ()) { return rule . as < ParameterAddValueRule > ()( target ); } else if ( rule . is < ParameterMultiplyByValueRule > ()) { return rule . as < ParameterMultiplyByValueRule > ()( target ); } else { THROW_IMPLEMENTATION_FAULT (); } return unspecified ; } catch ( const std :: out_of_range & ) { throw SemanticError ( \"No such parameter '\" + parameter_ref + \"'\" ); } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_MODIFY_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_modify_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__modify__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxparameter_modify_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_modify_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__modify__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__modify__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ParameterModifyAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__modify__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_MODIFY_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_MODIFY_ACTION_HPP_ #include <openscenario_interpreter/syntax/modify_rule.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- ModifyAction ----------------------------------------------------------- * * <xsd:complexType name=\"ParameterModifyAction\"> * <xsd:all> * <xsd:element name=\"Rule\" type=\"ModifyRule\"/> * </xsd:all> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ParameterModifyAction { Scope inner_scope ; const String parameter_ref ; const ModifyRule rule ; const std :: true_type accomplished {}; template < typename Node > explicit ParameterModifyAction ( const Node & node , Scope & outer_scope , const String & parameter_ref ) : inner_scope ( outer_scope ), parameter_ref ( parameter_ref ), rule ( readElement < ModifyRule > ( \"Rule\" , node , inner_scope )) {} auto evaluate () try { const auto target { inner_scope . parameters . at ( parameter_ref ) }; if ( rule . is < ParameterAddValueRule > ()) { return rule . as < ParameterAddValueRule > ()( target ); } else if ( rule . is < ParameterMultiplyByValueRule > ()) { return rule . as < ParameterMultiplyByValueRule > ()( target ); } else { THROW_IMPLEMENTATION_FAULT (); } return unspecified ; } catch ( const std :: out_of_range & ) { throw SemanticError ( \"No such parameter '\" + parameter_ref + \"'\" ); } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_MODIFY_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__multiply__by__value__rule_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_multiply_by_value_rule.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ParameterMultiplyByValueRule Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_MULTIPLY_BY_VALUE_RULE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_MULTIPLY_BY_VALUE_RULE_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <typeindex> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ParameterMultiplyByValueRule ------------------------------------------- * * <xsd:complexType name=\"ParameterMultiplyByValueRule\"> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ParameterMultiplyByValueRule { const Double value ; template < typename ... Ts > explicit ParameterMultiplyByValueRule ( Ts && ... xs ) : value ( readAttribute < Double > ( \"value\" , std :: forward < decltype ( xs ) > ( xs )...)) {} auto operator ()( const Element & target ) const { static const std :: unordered_map < std :: type_index , std :: function < Element ( const Element & , const Double & ) > > overloads { { typeid ( Integer ), []( auto && target , auto && value ) { target . template as < Integer > () *= value ; return target ; } }, { typeid ( Double ), []( auto && target , auto && value ) { target . template as < Double > () *= value ; return target ; } }, { typeid ( UnsignedInteger ), []( auto && target , auto && value ) { target . template as < UnsignedInteger > () *= value ; return target ; } }, { typeid ( UnsignedShort ), []( auto && target , auto && value ) { target . template as < UnsignedShort > () *= value ; return target ; } }, }; const auto iter { overloads . find ( target . type ())}; if ( iter != std :: end ( overloads )) { return std :: get < 1 > ( * iter )( target , value ); } else { std :: stringstream ss {}; ss << \"The parameter specified by attrribute 'parameterRef' of type 'ParameterAction' \" ; ss << \"must be numeric type (double, integer, unsignedInteger or unsignedShort), but \" ; ss << target << \" (type \" << target . type (). name () << \") specified\" ; throw SyntaxError ( ss . str ()); } } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_MULTIPLY_BY_VALUE_RULE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_multiply_by_value_rule.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__multiply__by__value__rule_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxparameter_multiply_by_value_rulehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_multiply_by_value_rule.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__multiply__by__value__rule_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__multiply__by__value__rule_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ParameterMultiplyByValueRule","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__multiply__by__value__rule_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_MULTIPLY_BY_VALUE_RULE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_MULTIPLY_BY_VALUE_RULE_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <typeindex> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- ParameterMultiplyByValueRule ------------------------------------------- * * <xsd:complexType name=\"ParameterMultiplyByValueRule\"> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ParameterMultiplyByValueRule { const Double value ; template < typename ... Ts > explicit ParameterMultiplyByValueRule ( Ts && ... xs ) : value ( readAttribute < Double > ( \"value\" , std :: forward < decltype ( xs ) > ( xs )...)) {} auto operator ()( const Element & target ) const { static const std :: unordered_map < std :: type_index , std :: function < Element ( const Element & , const Double & ) > > overloads { { typeid ( Integer ), []( auto && target , auto && value ) { target . template as < Integer > () *= value ; return target ; } }, { typeid ( Double ), []( auto && target , auto && value ) { target . template as < Double > () *= value ; return target ; } }, { typeid ( UnsignedInteger ), []( auto && target , auto && value ) { target . template as < UnsignedInteger > () *= value ; return target ; } }, { typeid ( UnsignedShort ), []( auto && target , auto && value ) { target . template as < UnsignedShort > () *= value ; return target ; } }, }; const auto iter { overloads . find ( target . type ())}; if ( iter != std :: end ( overloads )) { return std :: get < 1 > ( * iter )( target , value ); } else { std :: stringstream ss {}; ss << \"The parameter specified by attrribute 'parameterRef' of type 'ParameterAction' \" ; ss << \"must be numeric type (double, integer, unsignedInteger or unsignedShort), but \" ; ss << target << \" (type \" << target . type (). name () << \") specified\" ; throw SyntaxError ( ss . str ()); } } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_MULTIPLY_BY_VALUE_RULE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__set__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_set_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ParameterSetAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_SET_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_SET_ACTION_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <typeindex> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- SetAction -------------------------------------------------------------- * * <xsd:complexType name=\"ParameterSetAction\"> * <xsd:attribute name=\"value\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ParameterSetAction { Scope inner_scope ; const String parameter_ref ; const String value ; const std :: true_type accomplished {}; template < typename Node , typename Scope > explicit ParameterSetAction ( const Node & node , Scope & outer_scope , const String & parameter_ref ) : inner_scope ( outer_scope ), parameter_ref ( parameter_ref ), value ( readAttribute < String > ( \"value\" , node , inner_scope )) {} auto evaluate () const noexcept ( false ) { static const std :: unordered_map < std :: type_index , std :: function < Element ( const Element & , const String & ) > > overloads { { typeid ( Integer ), []( auto && target , auto && value ) { target . template as < Integer > () = boost :: lexical_cast < Integer > ( value ); return target ; } }, { typeid ( Double ), []( auto && target , auto && value ) { target . template as < Double > () = boost :: lexical_cast < Double > ( value ); return target ; } }, { typeid ( String ), []( auto && target , auto && value ) { target . template as < String > () = value ; return target ; } }, { typeid ( UnsignedInteger ), []( auto && target , auto && value ) { target . template as < UnsignedInteger > () = boost :: lexical_cast < UnsignedInteger > ( value ); return target ; } }, { typeid ( UnsignedShort ), []( auto && target , auto && value ) { target . template as < UnsignedShort > () = boost :: lexical_cast < UnsignedShort > ( value ); return target ; } }, { typeid ( Boolean ), []( auto && target , auto && value ) { target . template as < Boolean > () = boost :: lexical_cast < Boolean > ( value ); return target ; } }, }; const auto target { inner_scope . parameters . at ( parameter_ref ) }; const auto iter { overloads . find ( target . type ()) }; if ( iter != std :: end ( overloads )) { return std :: get < 1 > ( * iter )( target , value ); } else { THROW_IMPLEMENTATION_FAULT (); } } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_SET_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_set_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__set__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxparameter_set_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_set_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__set__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__set__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ParameterSetAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__set__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_SET_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_SET_ACTION_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <typeindex> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- SetAction -------------------------------------------------------------- * * <xsd:complexType name=\"ParameterSetAction\"> * <xsd:attribute name=\"value\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ParameterSetAction { Scope inner_scope ; const String parameter_ref ; const String value ; const std :: true_type accomplished {}; template < typename Node , typename Scope > explicit ParameterSetAction ( const Node & node , Scope & outer_scope , const String & parameter_ref ) : inner_scope ( outer_scope ), parameter_ref ( parameter_ref ), value ( readAttribute < String > ( \"value\" , node , inner_scope )) {} auto evaluate () const noexcept ( false ) { static const std :: unordered_map < std :: type_index , std :: function < Element ( const Element & , const String & ) > > overloads { { typeid ( Integer ), []( auto && target , auto && value ) { target . template as < Integer > () = boost :: lexical_cast < Integer > ( value ); return target ; } }, { typeid ( Double ), []( auto && target , auto && value ) { target . template as < Double > () = boost :: lexical_cast < Double > ( value ); return target ; } }, { typeid ( String ), []( auto && target , auto && value ) { target . template as < String > () = value ; return target ; } }, { typeid ( UnsignedInteger ), []( auto && target , auto && value ) { target . template as < UnsignedInteger > () = boost :: lexical_cast < UnsignedInteger > ( value ); return target ; } }, { typeid ( UnsignedShort ), []( auto && target , auto && value ) { target . template as < UnsignedShort > () = boost :: lexical_cast < UnsignedShort > ( value ); return target ; } }, { typeid ( Boolean ), []( auto && target , auto && value ) { target . template as < Boolean > () = boost :: lexical_cast < Boolean > ( value ); return target ; } }, }; const auto target { inner_scope . parameters . at ( parameter_ref ) }; const auto iter { overloads . find ( target . type ()) }; if ( iter != std :: end ( overloads )) { return std :: get < 1 > ( * iter )( target , value ); } else { THROW_IMPLEMENTATION_FAULT (); } } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_SET_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__type_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_type.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ParameterType Defines # Name BOILERPLATE (NAME, IDENTIFIER) BOILERPLATE (NAME, ID) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( NAME , IDENTIFIER ) if ( buffer == NAME ) { \\ type . value = ParameterType :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( NAME , ID ) case ParameterType :: ID : return os << NAME ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_TYPE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_TYPE_HPP_ #include <openscenario_interpreter/syntax/boolean.hpp> #include <openscenario_interpreter/syntax/double.hpp> #include <openscenario_interpreter/syntax/integer.hpp> #include <openscenario_interpreter/syntax/string.hpp> #include <openscenario_interpreter/syntax/unsigned_integer.hpp> #include <openscenario_interpreter/syntax/unsigned_short.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== ParameterType ======================================================== * * <xsd:simpleType name=\"ParameterType\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"integer\"/> * <xsd:enumeration value=\"double\"/> * <xsd:enumeration value=\"string\"/> * <xsd:enumeration value=\"unsignedInt\"/> * <xsd:enumeration value=\"unsignedShort\"/> * <xsd:enumeration value=\"boolean\"/> * <xsd:enumeration value=\"dateTime\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct ParameterType { enum value_type { INTEGER , DOUBLE , STRING , UNSIGNED_INT , UNSIGNED_SHORT , BOOLEAN , DATE_TIME , } value ; explicit constexpr ParameterType ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , ParameterType & type ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(NAME, IDENTIFIER) \\ if (buffer == NAME) { \\ type.value = ParameterType::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( \"integer\" , INTEGER ); BOILERPLATE ( \"double\" , DOUBLE ); BOILERPLATE ( \"string\" , STRING ); BOILERPLATE ( \"unsignedInt\" , UNSIGNED_INT ); BOILERPLATE ( \"unsignedShort\" , UNSIGNED_SHORT ); BOILERPLATE ( \"boolean\" , BOOLEAN ); BOILERPLATE ( \"dateTime\" , DATE_TIME ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type ParameterType\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const ParameterType & type ) { switch ( type ) { #define BOILERPLATE(NAME, ID) case ParameterType::ID: return os << NAME; BOILERPLATE ( \"integer\" , INTEGER ); BOILERPLATE ( \"double\" , DOUBLE ); BOILERPLATE ( \"string\" , STRING ); BOILERPLATE ( \"unsignedInt\" , UNSIGNED_INT ); BOILERPLATE ( \"unsignedShort\" , UNSIGNED_SHORT ); BOILERPLATE ( \"boolean\" , BOOLEAN ); BOILERPLATE ( \"dateTime\" , DATE_TIME ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class ParameterType holds unexpected value \" << static_cast < ParameterType :: value_type > ( type . value ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_TYPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_type.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__type_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxparameter_typehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/parameter_type.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__type_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__type_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ParameterType","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__type_8hpp/#defines","text":"Name BOILERPLATE (NAME, IDENTIFIER) BOILERPLATE (NAME, ID)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__type_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__type_8hpp/#define-boilerplate","text":"#define BOILERPLATE( NAME , IDENTIFIER ) if ( buffer == NAME ) { \\ type . value = ParameterType :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__type_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( NAME , ID ) case ParameterType :: ID : return os << NAME ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/parameter__type_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_TYPE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_TYPE_HPP_ #include <openscenario_interpreter/syntax/boolean.hpp> #include <openscenario_interpreter/syntax/double.hpp> #include <openscenario_interpreter/syntax/integer.hpp> #include <openscenario_interpreter/syntax/string.hpp> #include <openscenario_interpreter/syntax/unsigned_integer.hpp> #include <openscenario_interpreter/syntax/unsigned_short.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== ParameterType ======================================================== * * <xsd:simpleType name=\"ParameterType\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"integer\"/> * <xsd:enumeration value=\"double\"/> * <xsd:enumeration value=\"string\"/> * <xsd:enumeration value=\"unsignedInt\"/> * <xsd:enumeration value=\"unsignedShort\"/> * <xsd:enumeration value=\"boolean\"/> * <xsd:enumeration value=\"dateTime\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct ParameterType { enum value_type { INTEGER , DOUBLE , STRING , UNSIGNED_INT , UNSIGNED_SHORT , BOOLEAN , DATE_TIME , } value ; explicit constexpr ParameterType ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , ParameterType & type ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(NAME, IDENTIFIER) \\ if (buffer == NAME) { \\ type.value = ParameterType::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( \"integer\" , INTEGER ); BOILERPLATE ( \"double\" , DOUBLE ); BOILERPLATE ( \"string\" , STRING ); BOILERPLATE ( \"unsignedInt\" , UNSIGNED_INT ); BOILERPLATE ( \"unsignedShort\" , UNSIGNED_SHORT ); BOILERPLATE ( \"boolean\" , BOOLEAN ); BOILERPLATE ( \"dateTime\" , DATE_TIME ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type ParameterType\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const ParameterType & type ) { switch ( type ) { #define BOILERPLATE(NAME, ID) case ParameterType::ID: return os << NAME; BOILERPLATE ( \"integer\" , INTEGER ); BOILERPLATE ( \"double\" , DOUBLE ); BOILERPLATE ( \"string\" , STRING ); BOILERPLATE ( \"unsignedInt\" , UNSIGNED_INT ); BOILERPLATE ( \"unsignedShort\" , UNSIGNED_SHORT ); BOILERPLATE ( \"boolean\" , BOOLEAN ); BOILERPLATE ( \"dateTime\" , DATE_TIME ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class ParameterType holds unexpected value \" << static_cast < ParameterType :: value_type > ( type . value ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PARAMETER_TYPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/pedestrian_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/pedestrian.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Pedestrian Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PEDESTRIAN_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PEDESTRIAN_HPP_ #include <openscenario_interpreter/syntax/bounding_box.hpp> #include <openscenario_interpreter/syntax/parameter_declarations.hpp> #include <openscenario_interpreter/syntax/pedestrian_category.hpp> #include <openscenario_interpreter/syntax/properties.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Pedestrian =========================================================== * * <xsd:complexType name=\"Pedestrian\"> * <xsd:all> * <xsd:element name=\"ParameterDeclarations\" type=\"ParameterDeclarations\" minOccurs=\"0\"/> * <xsd:element name=\"BoundingBox\" type=\"BoundingBox\"/> * <xsd:element name=\"Properties\" type=\"Properties\"/> * </xsd:all> * <xsd:attribute name=\"model\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"mass\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"pedestrianCategory\" type=\"PedestrianCategory\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Pedestrian { const String name ; const Double mass ; const String model ; const PedestrianCategory pedestrian_category ; Scope inner_scope ; const ParameterDeclarations parameter_declarations ; const BoundingBox bounding_box ; const Properties properties ; template < typename Node , typename Scope > explicit Pedestrian ( const Node & node , Scope & outer_scope ) : name { readAttribute < String > ( \"name\" , node , outer_scope )}, mass { readAttribute < Double > ( \"mass\" , node , outer_scope )}, model { readAttribute < String > ( \"model\" , node , outer_scope )}, pedestrian_category { readAttribute < PedestrianCategory > ( \"pedestrianCategory\" , node , outer_scope )}, inner_scope { outer_scope }, parameter_declarations { readElement < ParameterDeclarations > ( \"ParameterDeclarations\" , node , inner_scope )}, bounding_box { readElement < BoundingBox > ( \"BoundingBox\" , node , inner_scope )}, properties { readElement < Properties > ( \"Properties\" , node , inner_scope )} {} }; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Pedestrian & rhs ) { return os << ( indent ++ ) << blue << \"<Pedestrian\" << \" \" << highlight ( \"name\" , rhs . name ) << \" \" << highlight ( \"mass\" , rhs . mass ) << \" \" << highlight ( \"model\" , rhs . model ) << \" \" << highlight ( \"pedestrianCategory\" , rhs . pedestrian_category ) << blue << \"> \\n \" << reset << rhs . parameter_declarations << \" \\n \" << rhs . bounding_box << \" \\n \" << ( -- indent ) << blue << \"</Pedestrian>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PEDESTRIAN_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/pedestrian.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/pedestrian_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxpedestrianhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/pedestrian.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/pedestrian_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/pedestrian_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Pedestrian","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/pedestrian_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PEDESTRIAN_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PEDESTRIAN_HPP_ #include <openscenario_interpreter/syntax/bounding_box.hpp> #include <openscenario_interpreter/syntax/parameter_declarations.hpp> #include <openscenario_interpreter/syntax/pedestrian_category.hpp> #include <openscenario_interpreter/syntax/properties.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Pedestrian =========================================================== * * <xsd:complexType name=\"Pedestrian\"> * <xsd:all> * <xsd:element name=\"ParameterDeclarations\" type=\"ParameterDeclarations\" minOccurs=\"0\"/> * <xsd:element name=\"BoundingBox\" type=\"BoundingBox\"/> * <xsd:element name=\"Properties\" type=\"Properties\"/> * </xsd:all> * <xsd:attribute name=\"model\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"mass\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"pedestrianCategory\" type=\"PedestrianCategory\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Pedestrian { const String name ; const Double mass ; const String model ; const PedestrianCategory pedestrian_category ; Scope inner_scope ; const ParameterDeclarations parameter_declarations ; const BoundingBox bounding_box ; const Properties properties ; template < typename Node , typename Scope > explicit Pedestrian ( const Node & node , Scope & outer_scope ) : name { readAttribute < String > ( \"name\" , node , outer_scope )}, mass { readAttribute < Double > ( \"mass\" , node , outer_scope )}, model { readAttribute < String > ( \"model\" , node , outer_scope )}, pedestrian_category { readAttribute < PedestrianCategory > ( \"pedestrianCategory\" , node , outer_scope )}, inner_scope { outer_scope }, parameter_declarations { readElement < ParameterDeclarations > ( \"ParameterDeclarations\" , node , inner_scope )}, bounding_box { readElement < BoundingBox > ( \"BoundingBox\" , node , inner_scope )}, properties { readElement < Properties > ( \"Properties\" , node , inner_scope )} {} }; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Pedestrian & rhs ) { return os << ( indent ++ ) << blue << \"<Pedestrian\" << \" \" << highlight ( \"name\" , rhs . name ) << \" \" << highlight ( \"mass\" , rhs . mass ) << \" \" << highlight ( \"model\" , rhs . model ) << \" \" << highlight ( \"pedestrianCategory\" , rhs . pedestrian_category ) << blue << \"> \\n \" << reset << rhs . parameter_declarations << \" \\n \" << rhs . bounding_box << \" \\n \" << ( -- indent ) << blue << \"</Pedestrian>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PEDESTRIAN_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/pedestrian__category_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/pedestrian_category.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::PedestrianCategory Defines # Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ category . value = PedestrianCategory :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ category . value = PedestrianCategory :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( NAME ) case PedestrianCategory :: NAME : return os << # NAME ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PEDESTRIAN_CATEGORY_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PEDESTRIAN_CATEGORY_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== PedestrianCategory ====================================================== * * <xsd:simpleType name=\"PedestrianCategory\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"pedestrian\"/> * <xsd:enumeration value=\"wheelchair\"/> * <xsd:enumeration value=\"animal\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct PedestrianCategory { enum value_type { pedestrian , wheelchair , animal , } value ; explicit constexpr PedestrianCategory ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , PedestrianCategory & category ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ category.value = PedestrianCategory::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( pedestrian ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" << buffer << \\ \"\\' is valid OpenSCENARIO value of type PedestrianCategory, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") BOILERPLATE ( wheelchair ); BOILERPLATE ( animal ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type PedestrianCategory\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const PedestrianCategory & category ) { switch ( category ) { #define BOILERPLATE(NAME) case PedestrianCategory::NAME: return os << #NAME; BOILERPLATE ( pedestrian ); BOILERPLATE ( wheelchair ); BOILERPLATE ( animal ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class PedestrianCategory holds unexpected value \" << static_cast < PedestrianCategory :: value_type > ( category ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PEDESTRIAN_CATEGORY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/pedestrian_category.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/pedestrian__category_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxpedestrian_categoryhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/pedestrian_category.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/pedestrian__category_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/pedestrian__category_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::PedestrianCategory","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/pedestrian__category_8hpp/#defines","text":"Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/pedestrian__category_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/pedestrian__category_8hpp/#define-boilerplate","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ category . value = PedestrianCategory :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/pedestrian__category_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ category . value = PedestrianCategory :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/pedestrian__category_8hpp/#define-boilerplate_2","text":"#define BOILERPLATE( NAME ) case PedestrianCategory :: NAME : return os << # NAME ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/pedestrian__category_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PEDESTRIAN_CATEGORY_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PEDESTRIAN_CATEGORY_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== PedestrianCategory ====================================================== * * <xsd:simpleType name=\"PedestrianCategory\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"pedestrian\"/> * <xsd:enumeration value=\"wheelchair\"/> * <xsd:enumeration value=\"animal\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct PedestrianCategory { enum value_type { pedestrian , wheelchair , animal , } value ; explicit constexpr PedestrianCategory ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , PedestrianCategory & category ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ category.value = PedestrianCategory::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( pedestrian ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" << buffer << \\ \"\\' is valid OpenSCENARIO value of type PedestrianCategory, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") BOILERPLATE ( wheelchair ); BOILERPLATE ( animal ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type PedestrianCategory\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const PedestrianCategory & category ) { switch ( category ) { #define BOILERPLATE(NAME) case PedestrianCategory::NAME: return os << #NAME; BOILERPLATE ( pedestrian ); BOILERPLATE ( wheelchair ); BOILERPLATE ( animal ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class PedestrianCategory holds unexpected value \" << static_cast < PedestrianCategory :: value_type > ( category ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PEDESTRIAN_CATEGORY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/performance_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/performance.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Performance Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PERFORMANCE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PERFORMANCE_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/reader/element.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Performance ========================================================== * * <xsd:complexType name=\"Performance\"> * <xsd:attribute name=\"maxSpeed\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"maxAcceleration\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"maxDeceleration\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Performance { const Double max_speed ; const Double max_acceleration ; const Double max_deceleration ; Performance () = default ; template < typename Node , typename Scope > explicit Performance ( const Node & node , Scope & scope ) : max_speed { readAttribute < Double > ( \"maxSpeed\" , node , scope )}, max_acceleration { readAttribute < Double > ( \"maxAcceleration\" , node , scope )}, max_deceleration { readAttribute < Double > ( \"maxDeceleration\" , node , scope )} {} }; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Performance & rhs ) { return os << indent << blue << \"<Performance\" << \" \" << highlight ( \"maxSpeed\" , rhs . max_speed ) << \" \" << highlight ( \"maxAcceleration\" , rhs . max_acceleration ) << \" \" << highlight ( \"maxDeceleration\" , rhs . max_deceleration ) << blue << \"/>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PERFORMANCE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/performance.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/performance_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxperformancehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/performance.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/performance_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/performance_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Performance","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/performance_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PERFORMANCE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PERFORMANCE_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/reader/element.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Performance ========================================================== * * <xsd:complexType name=\"Performance\"> * <xsd:attribute name=\"maxSpeed\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"maxAcceleration\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"maxDeceleration\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Performance { const Double max_speed ; const Double max_acceleration ; const Double max_deceleration ; Performance () = default ; template < typename Node , typename Scope > explicit Performance ( const Node & node , Scope & scope ) : max_speed { readAttribute < Double > ( \"maxSpeed\" , node , scope )}, max_acceleration { readAttribute < Double > ( \"maxAcceleration\" , node , scope )}, max_deceleration { readAttribute < Double > ( \"maxDeceleration\" , node , scope )} {} }; template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Performance & rhs ) { return os << indent << blue << \"<Performance\" << \" \" << highlight ( \"maxSpeed\" , rhs . max_speed ) << \" \" << highlight ( \"maxAcceleration\" , rhs . max_acceleration ) << \" \" << highlight ( \"maxDeceleration\" , rhs . max_deceleration ) << blue << \"/>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PERFORMANCE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/pointer_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/pointer.hpp # Namespaces # Name openscenario_interpreter Classes # Name class openscenario_interpreter::Pointer Defines # Name DEBUG () Macro Documentation # define DEBUG # #define DEBUG( ) std :: cout << green << __FILE__ << magenta << \":\" << cyan << __LINE__ << reset << std :: endl Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__POINTER_HPP_ #define OPENSCENARIO_INTERPRETER__POINTER_HPP_ #include <openscenario_interpreter/error.hpp> #include <openscenario_interpreter/type_traits/if_has_member_function_accomplished.hpp> #include <openscenario_interpreter/type_traits/if_has_member_function_evaluate.hpp> #include <openscenario_interpreter/type_traits/if_has_member_function_start.hpp> #include <openscenario_interpreter/type_traits/if_has_member_function_state.hpp> #include <openscenario_interpreter/type_traits/if_has_stream_output_operator.hpp> #include <openscenario_interpreter/utility/pair.hpp> #include <memory> #include <typeinfo> #include <utility> #define DEBUG() \\ std::cout << green << __FILE__ << magenta << \":\" << cyan << __LINE__ << reset << std::endl namespace openscenario_interpreter { template < typename T > class Pointer : public std :: shared_ptr < T > { template < typename Bound > struct Binder : public T , public Bound { using top = T ; template < typename ... Ts > explicit constexpr Binder ( Ts && ... xs ) : Bound { std :: forward < decltype ( xs ) > ( xs )...} {} virtual ~ Binder () = default ; const std :: type_info & type () const noexcept override { return typeid ( Bound ); } private : // ^ Note: This broken indent was forced by ament_uncrustify. std :: ostream & write ( std :: ostream & os ) const override { return IfHasStreamOutputOperator < Bound >:: applyIt ( os , * this ); } Pointer evaluate ( const Pointer & else_ ) override { return IfHasMemberFunctionEvaluate < Bound >:: callIt ( static_cast < Bound &> ( * this ), else_ ); } bool accomplished () override { return IfHasMemberFunctionAccomplished < Bound >:: callIt ( * this ); } const Pointer & state () const override { return IfHasMemberFunctionState < Bound >:: template callIt < Pointer > ( * this ); } void start () override // corresponds to startTransition { IfHasMemberFunctionStart < Bound >:: callIt ( * this ); } }; public : template < typename ... Ts > explicit constexpr Pointer ( Ts && ... xs ) : std :: shared_ptr < T > { std :: forward < decltype ( xs ) > ( xs )...} {} template < typename U , typename ... Ts > static Pointer bind ( Ts && ... xs ) { using Binding = Binder < U > ; return static_cast < Pointer > ( std :: make_shared < Binding > ( std :: forward < decltype ( xs ) > ( xs )...)); } template < typename U , typename ... Ts > decltype ( auto ) rebind ( Ts && ... xs ) { return * this = bind < U > ( std :: forward < decltype ( xs ) > ( xs )...); } decltype ( auto ) binding () const { if ( * this ) { return std :: shared_ptr < T >:: operator * (); } else { std :: stringstream ss {}; ss << \"dereferencing nullptr\" ; throw ImplementationFault { ss . str ()}; } } decltype ( auto ) type () const { return binding (). type (); } template < typename U > decltype ( auto ) is () const { return type () == typeid ( U ); } template < typename U > decltype ( auto ) as () const { const auto bound { std :: dynamic_pointer_cast < U > ( * this )}; if ( bound ) { return * bound ; } else { std :: stringstream ss {}; ss << \"type-error: can't treat \" << binding (). type (). name () << \" as type \" << typeid ( U ). name (); throw std :: runtime_error { ss . str ()}; } } template < typename U > decltype ( auto ) as ( const char * const file , int line ) const try { return as < U > (); } catch ( const std :: runtime_error & error ) { std :: stringstream ss {}; ss << error . what () << \" (call from \" << file << \":\" << line << \")\" ; throw std :: runtime_error { ss . str ()}; } public : template < typename ... Ts > decltype ( auto ) evaluate ( Ts && ... xs ) const { return binding (). evaluate ( * this , std :: forward < decltype ( xs ) > ( xs )...); } template < typename ... Ts > decltype ( auto ) accomplished ( Ts && ... xs ) const { return binding (). accomplished ( std :: forward < decltype ( xs ) > ( xs )...); } template < typename ... Ts > decltype ( auto ) state ( Ts && ... xs ) const { return binding (). state ( std :: forward < decltype ( xs ) > ( xs )...); } template < typename ... Ts > decltype ( auto ) start ( Ts && ... xs ) const { return binding (). start ( std :: forward < decltype ( xs ) > ( xs )...); } }; template < typename T , typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Pointer < T > & pointer ) { return ( pointer ? pointer . binding (). write ( os ) : ( os << faint << \"<Null/>\" )) << reset ; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__POINTER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/pointer.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/pointer_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterpointerhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/pointer.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/pointer_8hpp/#namespaces","text":"Name openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/pointer_8hpp/#classes","text":"Name class openscenario_interpreter::Pointer","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/pointer_8hpp/#defines","text":"Name DEBUG ()","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/pointer_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/pointer_8hpp/#define-debug","text":"#define DEBUG( ) std :: cout << green << __FILE__ << magenta << \":\" << cyan << __LINE__ << reset << std :: endl","title":"define DEBUG"},{"location":"package/openscenario_interpreter/markdown/Files/pointer_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__POINTER_HPP_ #define OPENSCENARIO_INTERPRETER__POINTER_HPP_ #include <openscenario_interpreter/error.hpp> #include <openscenario_interpreter/type_traits/if_has_member_function_accomplished.hpp> #include <openscenario_interpreter/type_traits/if_has_member_function_evaluate.hpp> #include <openscenario_interpreter/type_traits/if_has_member_function_start.hpp> #include <openscenario_interpreter/type_traits/if_has_member_function_state.hpp> #include <openscenario_interpreter/type_traits/if_has_stream_output_operator.hpp> #include <openscenario_interpreter/utility/pair.hpp> #include <memory> #include <typeinfo> #include <utility> #define DEBUG() \\ std::cout << green << __FILE__ << magenta << \":\" << cyan << __LINE__ << reset << std::endl namespace openscenario_interpreter { template < typename T > class Pointer : public std :: shared_ptr < T > { template < typename Bound > struct Binder : public T , public Bound { using top = T ; template < typename ... Ts > explicit constexpr Binder ( Ts && ... xs ) : Bound { std :: forward < decltype ( xs ) > ( xs )...} {} virtual ~ Binder () = default ; const std :: type_info & type () const noexcept override { return typeid ( Bound ); } private : // ^ Note: This broken indent was forced by ament_uncrustify. std :: ostream & write ( std :: ostream & os ) const override { return IfHasStreamOutputOperator < Bound >:: applyIt ( os , * this ); } Pointer evaluate ( const Pointer & else_ ) override { return IfHasMemberFunctionEvaluate < Bound >:: callIt ( static_cast < Bound &> ( * this ), else_ ); } bool accomplished () override { return IfHasMemberFunctionAccomplished < Bound >:: callIt ( * this ); } const Pointer & state () const override { return IfHasMemberFunctionState < Bound >:: template callIt < Pointer > ( * this ); } void start () override // corresponds to startTransition { IfHasMemberFunctionStart < Bound >:: callIt ( * this ); } }; public : template < typename ... Ts > explicit constexpr Pointer ( Ts && ... xs ) : std :: shared_ptr < T > { std :: forward < decltype ( xs ) > ( xs )...} {} template < typename U , typename ... Ts > static Pointer bind ( Ts && ... xs ) { using Binding = Binder < U > ; return static_cast < Pointer > ( std :: make_shared < Binding > ( std :: forward < decltype ( xs ) > ( xs )...)); } template < typename U , typename ... Ts > decltype ( auto ) rebind ( Ts && ... xs ) { return * this = bind < U > ( std :: forward < decltype ( xs ) > ( xs )...); } decltype ( auto ) binding () const { if ( * this ) { return std :: shared_ptr < T >:: operator * (); } else { std :: stringstream ss {}; ss << \"dereferencing nullptr\" ; throw ImplementationFault { ss . str ()}; } } decltype ( auto ) type () const { return binding (). type (); } template < typename U > decltype ( auto ) is () const { return type () == typeid ( U ); } template < typename U > decltype ( auto ) as () const { const auto bound { std :: dynamic_pointer_cast < U > ( * this )}; if ( bound ) { return * bound ; } else { std :: stringstream ss {}; ss << \"type-error: can't treat \" << binding (). type (). name () << \" as type \" << typeid ( U ). name (); throw std :: runtime_error { ss . str ()}; } } template < typename U > decltype ( auto ) as ( const char * const file , int line ) const try { return as < U > (); } catch ( const std :: runtime_error & error ) { std :: stringstream ss {}; ss << error . what () << \" (call from \" << file << \":\" << line << \")\" ; throw std :: runtime_error { ss . str ()}; } public : template < typename ... Ts > decltype ( auto ) evaluate ( Ts && ... xs ) const { return binding (). evaluate ( * this , std :: forward < decltype ( xs ) > ( xs )...); } template < typename ... Ts > decltype ( auto ) accomplished ( Ts && ... xs ) const { return binding (). accomplished ( std :: forward < decltype ( xs ) > ( xs )...); } template < typename ... Ts > decltype ( auto ) state ( Ts && ... xs ) const { return binding (). state ( std :: forward < decltype ( xs ) > ( xs )...); } template < typename ... Ts > decltype ( auto ) start ( Ts && ... xs ) const { return binding (). start ( std :: forward < decltype ( xs ) > ( xs )...); } }; template < typename T , typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Pointer < T > & pointer ) { return ( pointer ? pointer . binding (). write ( os ) : ( os << faint << \"<Null/>\" )) << reset ; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__POINTER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/position_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/position.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Position Defines # Name ELEMENT (TYPE) BOILERPLATE (TYPE) Macro Documentation # define ELEMENT # #define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) define BOILERPLATE # #define BOILERPLATE( TYPE ) { \\ typeid ( TYPE ), []( F && f , const Position & position , Ts && ... xs ) \\ { \\ return f ( position . as < TYPE > (), std :: forward < decltype ( xs ) > ( xs )...); \\ } \\ } Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__POSITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__POSITION_HPP_ #include <boost/function_types/result_type.hpp> #include <openscenario_interpreter/syntax/lane_position.hpp> #include <openscenario_interpreter/syntax/relative_world_position.hpp> #include <openscenario_interpreter/syntax/world_position.hpp> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- Position --------------------------------------------------------------- * * <xsd:complexType name=\"Position\"> * <xsd:choice> * <xsd:element name=\"WorldPosition\" type=\"WorldPosition\"/> * <xsd:element name=\"RelativeWorldPosition\" type=\"RelativeWorldPosition\"/> * <xsd:element name=\"RelativeObjectPosition\" type=\"RelativeObjectPosition\"/> * <xsd:element name=\"RoadPosition\" type=\"RoadPosition\"/> * <xsd:element name=\"RelativeRoadPosition\" type=\"RelativeRoadPosition\"/> * <xsd:element name=\"LanePosition\" type=\"LanePosition\"/> * <xsd:element name=\"RelativeLanePosition\" type=\"RelativeLanePosition\"/> * <xsd:element name=\"RoutePosition\" type=\"RoutePosition\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) struct Position : public Element { template < typename XML , typename ... Ts > explicit Position ( const XML & node , Ts && ... xs ) : Element ( choice ( node , ELEMENT ( /* */ WorldPosition ), ELEMENT ( RelativeWorldPosition ), std :: make_pair ( \"RelativeObjectPosition\" , UNSUPPORTED ()), std :: make_pair ( \"RoadPosition\" , UNSUPPORTED ()), std :: make_pair ( \"RelativeRoadPosition\" , UNSUPPORTED ()), ELEMENT ( LanePosition ), std :: make_pair ( \"RelativeLanePosition\" , UNSUPPORTED ()), std :: make_pair ( \"RoutePosition\" , UNSUPPORTED ()))) {} explicit operator geometry_msgs :: msg :: Pose () const { if ( is < WorldPosition > ()) { return static_cast < geometry_msgs :: msg :: Pose > ( as < WorldPosition > ()); } else if ( is < LanePosition > ()) { return static_cast < geometry_msgs :: msg :: Pose > ( as < LanePosition > ()); } else { THROW ( ImplementationFault ); } } }; #undef ELEMENT template < typename R = void , typename F , typename ... Ts > decltype ( auto ) apply ( F && f , const Position & position , Ts && ... xs ) { #define BOILERPLATE(TYPE) \\ { \\ typeid(TYPE), [](F && f, const Position & position, Ts && ... xs) \\ { \\ return f(position.as<TYPE>(), std::forward<decltype(xs)>(xs)...); \\ } \\ } static const std :: unordered_map < std :: type_index , std :: function < R ( F && f , const Position & position , Ts && ... xs ) >> overloads { BOILERPLATE ( WorldPosition ), BOILERPLATE ( RelativeWorldPosition ), // BOILERPLATE(RelativeObjectPosition), // BOILERPLATE(RoadPosition), // BOILERPLATE(RelativeRoadPosition), BOILERPLATE ( LanePosition ), // BOILERPLATE(RelativeLanePosition), // BOILERPLATE(RoutePosition), }; #undef BOILERPLATE return overloads . at ( position . type ())( std :: forward < decltype ( f ) > ( f ), position , std :: forward < decltype ( xs ) > ( xs )...); } } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__POSITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/position.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/position_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxpositionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/position.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/position_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/position_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Position","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/position_8hpp/#defines","text":"Name ELEMENT (TYPE) BOILERPLATE (TYPE)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/position_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/position_8hpp/#define-element","text":"#define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ })","title":"define ELEMENT"},{"location":"package/openscenario_interpreter/markdown/Files/position_8hpp/#define-boilerplate","text":"#define BOILERPLATE( TYPE ) { \\ typeid ( TYPE ), []( F && f , const Position & position , Ts && ... xs ) \\ { \\ return f ( position . as < TYPE > (), std :: forward < decltype ( xs ) > ( xs )...); \\ } \\ }","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/position_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__POSITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__POSITION_HPP_ #include <boost/function_types/result_type.hpp> #include <openscenario_interpreter/syntax/lane_position.hpp> #include <openscenario_interpreter/syntax/relative_world_position.hpp> #include <openscenario_interpreter/syntax/world_position.hpp> #include <unordered_map> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- Position --------------------------------------------------------------- * * <xsd:complexType name=\"Position\"> * <xsd:choice> * <xsd:element name=\"WorldPosition\" type=\"WorldPosition\"/> * <xsd:element name=\"RelativeWorldPosition\" type=\"RelativeWorldPosition\"/> * <xsd:element name=\"RelativeObjectPosition\" type=\"RelativeObjectPosition\"/> * <xsd:element name=\"RoadPosition\" type=\"RoadPosition\"/> * <xsd:element name=\"RelativeRoadPosition\" type=\"RelativeRoadPosition\"/> * <xsd:element name=\"LanePosition\" type=\"LanePosition\"/> * <xsd:element name=\"RelativeLanePosition\" type=\"RelativeLanePosition\"/> * <xsd:element name=\"RoutePosition\" type=\"RoutePosition\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) struct Position : public Element { template < typename XML , typename ... Ts > explicit Position ( const XML & node , Ts && ... xs ) : Element ( choice ( node , ELEMENT ( /* */ WorldPosition ), ELEMENT ( RelativeWorldPosition ), std :: make_pair ( \"RelativeObjectPosition\" , UNSUPPORTED ()), std :: make_pair ( \"RoadPosition\" , UNSUPPORTED ()), std :: make_pair ( \"RelativeRoadPosition\" , UNSUPPORTED ()), ELEMENT ( LanePosition ), std :: make_pair ( \"RelativeLanePosition\" , UNSUPPORTED ()), std :: make_pair ( \"RoutePosition\" , UNSUPPORTED ()))) {} explicit operator geometry_msgs :: msg :: Pose () const { if ( is < WorldPosition > ()) { return static_cast < geometry_msgs :: msg :: Pose > ( as < WorldPosition > ()); } else if ( is < LanePosition > ()) { return static_cast < geometry_msgs :: msg :: Pose > ( as < LanePosition > ()); } else { THROW ( ImplementationFault ); } } }; #undef ELEMENT template < typename R = void , typename F , typename ... Ts > decltype ( auto ) apply ( F && f , const Position & position , Ts && ... xs ) { #define BOILERPLATE(TYPE) \\ { \\ typeid(TYPE), [](F && f, const Position & position, Ts && ... xs) \\ { \\ return f(position.as<TYPE>(), std::forward<decltype(xs)>(xs)...); \\ } \\ } static const std :: unordered_map < std :: type_index , std :: function < R ( F && f , const Position & position , Ts && ... xs ) >> overloads { BOILERPLATE ( WorldPosition ), BOILERPLATE ( RelativeWorldPosition ), // BOILERPLATE(RelativeObjectPosition), // BOILERPLATE(RoadPosition), // BOILERPLATE(RelativeRoadPosition), BOILERPLATE ( LanePosition ), // BOILERPLATE(RelativeLanePosition), // BOILERPLATE(RoutePosition), }; #undef BOILERPLATE return overloads . at ( position . type ())( std :: forward < decltype ( f ) > ( f ), position , std :: forward < decltype ( xs ) > ( xs )...); } } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__POSITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/priority_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/priority.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Priority Defines # Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ priority . value = Priority :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ priority . value = Priority :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( NAME ) case Priority :: NAME : return os << # NAME ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PRIORITY_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PRIORITY_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== Priority ============================================================= * * <xsd:simpleType name=\"Priority\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"overwrite\"/> * <xsd:enumeration value=\"skip\"/> * <xsd:enumeration value=\"parallel\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct Priority { enum value_type { // If a starting event has priority Overwrite, all events in running state, // within the same scope (maneuver) as the starting event, should be issued // a stop command (stop transition). overwrite , // If a starting event has priority Skip, then it will not be ran if there // is any other event in the same scope (maneuver) in the running state. skip , // Execute in parallel to other events. parallel , } value ; explicit constexpr Priority ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , Priority & priority ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ priority.value = Priority::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( overwrite ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" << buffer << \\ \"\\' is valid OpenSCENARIO value of type Priority, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") BOILERPLATE ( skip ); BOILERPLATE ( parallel ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type Priority\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Priority & priority ) { switch ( priority ) { #define BOILERPLATE(NAME) case Priority::NAME: return os << #NAME; BOILERPLATE ( overwrite ); BOILERPLATE ( skip ); BOILERPLATE ( parallel ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class Priority holds unexpected value \" << static_cast < Priority :: value_type > ( priority ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PRIORITY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/priority.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/priority_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxpriorityhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/priority.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/priority_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/priority_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Priority","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/priority_8hpp/#defines","text":"Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/priority_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/priority_8hpp/#define-boilerplate","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ priority . value = Priority :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/priority_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ priority . value = Priority :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/priority_8hpp/#define-boilerplate_2","text":"#define BOILERPLATE( NAME ) case Priority :: NAME : return os << # NAME ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/priority_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PRIORITY_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PRIORITY_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== Priority ============================================================= * * <xsd:simpleType name=\"Priority\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"overwrite\"/> * <xsd:enumeration value=\"skip\"/> * <xsd:enumeration value=\"parallel\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct Priority { enum value_type { // If a starting event has priority Overwrite, all events in running state, // within the same scope (maneuver) as the starting event, should be issued // a stop command (stop transition). overwrite , // If a starting event has priority Skip, then it will not be ran if there // is any other event in the same scope (maneuver) in the running state. skip , // Execute in parallel to other events. parallel , } value ; explicit constexpr Priority ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , Priority & priority ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ priority.value = Priority::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( overwrite ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" << buffer << \\ \"\\' is valid OpenSCENARIO value of type Priority, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") BOILERPLATE ( skip ); BOILERPLATE ( parallel ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type Priority\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Priority & priority ) { switch ( priority ) { #define BOILERPLATE(NAME) case Priority::NAME: return os << #NAME; BOILERPLATE ( overwrite ); BOILERPLATE ( skip ); BOILERPLATE ( parallel ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class Priority holds unexpected value \" << static_cast < Priority :: value_type > ( priority ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PRIORITY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/private_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/private.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Private Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PRIVATE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PRIVATE_HPP_ #include <openscenario_interpreter/syntax/private_action.hpp> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- Private ---------------------------------------------------------------- * * <xsd:complexType name=\"Private\"> * <xsd:sequence> * <xsd:element name=\"PrivateAction\" type=\"PrivateAction\" maxOccurs=\"unbounded\"/> * </xsd:sequence> * <xsd:attribute name=\"entityRef\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Private : public std :: vector < PrivateAction > { Scope inner_scope ; template < typename Node > explicit Private ( const Node & node , Scope & outer_scope ) : inner_scope ( outer_scope ) { inner_scope . actors . emplace_back ( readAttribute < String > ( \"entityRef\" , node , inner_scope )); callWithElements ( node , \"PrivateAction\" , 1 , unbounded , [ & ]( auto && node ) { emplace_back ( node , inner_scope ); }); } auto evaluate () { for ( auto && each : * this ) { each . start (); } return unspecified ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PRIVATE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/private.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/private_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxprivatehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/private.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/private_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/private_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Private","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/private_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PRIVATE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PRIVATE_HPP_ #include <openscenario_interpreter/syntax/private_action.hpp> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- Private ---------------------------------------------------------------- * * <xsd:complexType name=\"Private\"> * <xsd:sequence> * <xsd:element name=\"PrivateAction\" type=\"PrivateAction\" maxOccurs=\"unbounded\"/> * </xsd:sequence> * <xsd:attribute name=\"entityRef\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Private : public std :: vector < PrivateAction > { Scope inner_scope ; template < typename Node > explicit Private ( const Node & node , Scope & outer_scope ) : inner_scope ( outer_scope ) { inner_scope . actors . emplace_back ( readAttribute < String > ( \"entityRef\" , node , inner_scope )); callWithElements ( node , \"PrivateAction\" , 1 , unbounded , [ & ]( auto && node ) { emplace_back ( node , inner_scope ); }); } auto evaluate () { for ( auto && each : * this ) { each . start (); } return unspecified ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PRIVATE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/private__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/private_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::PrivateAction Defines # Name ELEMENT (TYPE) Macro Documentation # define ELEMENT # #define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PRIVATE_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PRIVATE_ACTION_HPP_ #include <openscenario_interpreter/syntax/controller_action.hpp> #include <openscenario_interpreter/syntax/lateral_action.hpp> #include <openscenario_interpreter/syntax/longitudinal_action.hpp> #include <openscenario_interpreter/syntax/routing_action.hpp> #include <openscenario_interpreter/syntax/teleport_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) /* ---- PrivateAction ---------------------------------------------------------- * * <xsd:complexType name=\"PrivateAction\"> * <xsd:choice> * <xsd:element name=\"LongitudinalAction\" type=\"LongitudinalAction\"/> * <xsd:element name=\"LateralAction\" type=\"LateralAction\"/> * <xsd:element name=\"VisibilityAction\" type=\"VisibilityAction\"/> * <xsd:element name=\"SynchronizeAction\" type=\"SynchronizeAction\"/> * <xsd:element name=\"ActivateControllerAction\" type=\"ActivateControllerAction\"/> * <xsd:element name=\"ControllerAction\" type=\"ControllerAction\"/> * <xsd:element name=\"TeleportAction\" type=\"TeleportAction\"/> * <xsd:element name=\"RoutingAction\" type=\"RoutingAction\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct PrivateAction : public ComplexType { template < typename Node , typename ... Ts > explicit PrivateAction ( const Node & node , Ts && ... xs ) : ComplexType ( choice ( node , ELEMENT ( LongitudinalAction ), ELEMENT ( LateralAction ), std :: make_pair ( \"VisibilityAction\" , UNSUPPORTED ()), std :: make_pair ( \"SynchronizeAction\" , UNSUPPORTED ()), std :: make_pair ( \"ActivateControllerAction\" , UNSUPPORTED ()), ELEMENT ( ControllerAction ), ELEMENT ( TeleportAction ), ELEMENT ( RoutingAction ))) {} }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PRIVATE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/private_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/private__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxprivate_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/private_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/private__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/private__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::PrivateAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/private__action_8hpp/#defines","text":"Name ELEMENT (TYPE)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/private__action_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/private__action_8hpp/#define-element","text":"#define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ })","title":"define ELEMENT"},{"location":"package/openscenario_interpreter/markdown/Files/private__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PRIVATE_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PRIVATE_ACTION_HPP_ #include <openscenario_interpreter/syntax/controller_action.hpp> #include <openscenario_interpreter/syntax/lateral_action.hpp> #include <openscenario_interpreter/syntax/longitudinal_action.hpp> #include <openscenario_interpreter/syntax/routing_action.hpp> #include <openscenario_interpreter/syntax/teleport_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) /* ---- PrivateAction ---------------------------------------------------------- * * <xsd:complexType name=\"PrivateAction\"> * <xsd:choice> * <xsd:element name=\"LongitudinalAction\" type=\"LongitudinalAction\"/> * <xsd:element name=\"LateralAction\" type=\"LateralAction\"/> * <xsd:element name=\"VisibilityAction\" type=\"VisibilityAction\"/> * <xsd:element name=\"SynchronizeAction\" type=\"SynchronizeAction\"/> * <xsd:element name=\"ActivateControllerAction\" type=\"ActivateControllerAction\"/> * <xsd:element name=\"ControllerAction\" type=\"ControllerAction\"/> * <xsd:element name=\"TeleportAction\" type=\"TeleportAction\"/> * <xsd:element name=\"RoutingAction\" type=\"RoutingAction\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct PrivateAction : public ComplexType { template < typename Node , typename ... Ts > explicit PrivateAction ( const Node & node , Ts && ... xs ) : ComplexType ( choice ( node , ELEMENT ( LongitudinalAction ), ELEMENT ( LateralAction ), std :: make_pair ( \"VisibilityAction\" , UNSUPPORTED ()), std :: make_pair ( \"SynchronizeAction\" , UNSUPPORTED ()), std :: make_pair ( \"ActivateControllerAction\" , UNSUPPORTED ()), ELEMENT ( ControllerAction ), ELEMENT ( TeleportAction ), ELEMENT ( RoutingAction ))) {} }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PRIVATE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/procedure_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/procedure.cpp # Namespaces # Name openscenario_interpreter Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <openscenario_interpreter/procedure.hpp> #include <memory> namespace openscenario_interpreter { static typename std :: aligned_storage < sizeof ( scenario_simulator :: API ), alignof ( scenario_simulator :: API ) >:: type memory ; scenario_simulator :: API & connection { reinterpret_cast < scenario_simulator :: API &> ( memory ) }; // static int schwarz_counter { 0 }; // // Connector::Connector() // { // if (schwarz_counter++ == 0) // { // new (&connection) scenario_simulator::API(); // } // } // // Connector::~Connector() // { // if (--schwarz_counter == 0) // { // connection.~API(); // } // } } // namespace openscenario_interpreter Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/procedure.cpp"},{"location":"package/openscenario_interpreter/markdown/Files/procedure_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpretersrcprocedurecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/src/procedure.cpp"},{"location":"package/openscenario_interpreter/markdown/Files/procedure_8cpp/#namespaces","text":"Name openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/procedure_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <openscenario_interpreter/procedure.hpp> #include <memory> namespace openscenario_interpreter { static typename std :: aligned_storage < sizeof ( scenario_simulator :: API ), alignof ( scenario_simulator :: API ) >:: type memory ; scenario_simulator :: API & connection { reinterpret_cast < scenario_simulator :: API &> ( memory ) }; // static int schwarz_counter { 0 }; // // Connector::Connector() // { // if (schwarz_counter++ == 0) // { // new (&connection) scenario_simulator::API(); // } // } // // Connector::~Connector() // { // if (--schwarz_counter == 0) // { // connection.~API(); // } // } } // namespace openscenario_interpreter Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/procedure_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/procedure.hpp # Namespaces # Name openscenario_interpreter Defines # Name STRIP_OPTIONAL (IDENTIFIER, ALTERNATE) FORWARD_TO_SIMULATION_API (IDENTIFIER) Macro Documentation # define STRIP_OPTIONAL # #define STRIP_OPTIONAL( IDENTIFIER , ALTERNATE ) template < typename ... Ts > \\ auto IDENTIFIER ( Ts && ... xs ) \\ { \\ const auto result = connection . IDENTIFIER ( std :: forward < decltype ( xs ) > ( xs )...); \\ if ( result ) { \\ return result . get (); \\ } else { \\ using value_type = typename std :: decay < decltype ( result ) >:: type :: value_type ; \\ return ALTERNATE ; \\ } \\ } static_assert ( true , \"\" ) define FORWARD_TO_SIMULATION_API # #define FORWARD_TO_SIMULATION_API( IDENTIFIER ) template < typename ... Ts > \\ decltype ( auto ) IDENTIFIER ( Ts && ... xs ) \\ { \\ return connection . IDENTIFIER ( std :: forward < decltype ( xs ) > ( xs )...); \\ } static_assert ( true , \"\" ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__PROCEDURE_HPP_ #define OPENSCENARIO_INTERPRETER__PROCEDURE_HPP_ #include <simulation_api/api/api.hpp> #include <openscenario_interpreter/error.hpp> #include <limits> #include <memory> #include <utility> namespace openscenario_interpreter { extern scenario_simulator :: API & connection ; // static struct Connector // { // Connector(); // ~Connector(); // } connector; template < typename ... Ts > decltype ( auto ) connect ( Ts && ... xs ) { new ( & connection ) scenario_simulator :: API ( std :: forward < decltype ( xs ) > ( xs )...); return connection ; } template < typename ... Ts > decltype ( auto ) getEntityStatus ( Ts && ... xs ) try { return connection . getEntityStatus ( std :: forward < decltype ( xs ) > ( xs )...); } catch ( const simulation_api :: SimulationRuntimeError & error ) { std :: stringstream ss {}; ss << error . what () << \". \\n \" ; ss << \"Possible causes: \\n \" ; ss << \" (1) The position of the corresponding entity is not specified by Teleport Action\" ; throw SemanticError ( ss . str ()); } template < typename ... Ts > decltype ( auto ) isReachedPosition ( Ts && ... xs ) { return connection . reachPosition ( std :: forward < decltype ( xs ) > ( xs )...); } // template<typename ... Ts> // decltype(auto) getRelativeDistance(Ts && ... xs) // { // return connection.getRelativeDistance(std::forward<decltype(xs)>(xs)...); // } template < typename ... Ts > decltype ( auto ) getRelativePose ( Ts && ... xs ) try { return connection . getRelativePose ( std :: forward < decltype ( xs ) > ( xs )...); } catch ( const simulation_api :: SimulationRuntimeError & ) { geometry_msgs :: msg :: Pose result {}; result . position . x = std :: numeric_limits < double >:: quiet_NaN (); result . position . y = std :: numeric_limits < double >:: quiet_NaN (); result . position . z = std :: numeric_limits < double >:: quiet_NaN (); result . orientation . x = 0 ; result . orientation . y = 0 ; result . orientation . z = 0 ; result . orientation . w = 1 ; return result ; } // template <typename... Ts> // auto getDistanceAlongRoute(Ts&&... xs) // { // if (const auto result { // connection->entity->getLongitudinalDistance(std::forward<decltype(xs)>(xs)...) }) // { // return *result; // } // else // { // using value_type = typename std::decay<decltype(result)>::type::value_type; // return std::numeric_limits<value_type>::infinity(); // } // } template < typename ... Ts > decltype ( auto ) setController ( Ts && ... xs ) { return connection . setDriverModel ( std :: forward < decltype ( xs ) > ( xs )...); } #define STRIP_OPTIONAL(IDENTIFIER, ALTERNATE) \\ template<typename ... Ts> \\ auto IDENTIFIER(Ts && ... xs) \\ { \\ const auto result = connection.IDENTIFIER(std::forward<decltype(xs)>(xs)...); \\ if (result) { \\ return result.get(); \\ } else { \\ using value_type = typename std::decay<decltype(result)>::type::value_type; \\ return ALTERNATE; \\ } \\ } static_assert(true, \"\") STRIP_OPTIONAL ( getBoundingBoxDistance , static_cast < value_type > ( 0 )); STRIP_OPTIONAL ( getStandStillDuration , static_cast < value_type > ( 0 )); STRIP_OPTIONAL ( getTimeHeadway , std :: numeric_limits < value_type >:: quiet_NaN ()); #undef STRIP_OPTIONAL #define FORWARD_TO_SIMULATION_API(IDENTIFIER) \\ template<typename ... Ts> \\ decltype(auto) IDENTIFIER(Ts && ... xs) \\ { \\ return connection.IDENTIFIER(std::forward<decltype(xs)>(xs)...); \\ } static_assert(true, \"\") FORWARD_TO_SIMULATION_API ( attachDetectionSensor ); FORWARD_TO_SIMULATION_API ( attachLidarSensor ); FORWARD_TO_SIMULATION_API ( checkCollision ); FORWARD_TO_SIMULATION_API ( despawn ); FORWARD_TO_SIMULATION_API ( getCurrentTime ); FORWARD_TO_SIMULATION_API ( initialize ); FORWARD_TO_SIMULATION_API ( isInLanelet ); FORWARD_TO_SIMULATION_API ( requestAcquirePosition ); FORWARD_TO_SIMULATION_API ( requestAssignRoute ); FORWARD_TO_SIMULATION_API ( requestLaneChange ); FORWARD_TO_SIMULATION_API ( requestWalkStraight ); FORWARD_TO_SIMULATION_API ( setEntityStatus ); FORWARD_TO_SIMULATION_API ( setTargetSpeed ); FORWARD_TO_SIMULATION_API ( spawn ); FORWARD_TO_SIMULATION_API ( toMapPose ); FORWARD_TO_SIMULATION_API ( updateFrame ); #undef DEFINE_FORWARD } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__PROCEDURE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/procedure.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/procedure_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterprocedurehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/procedure.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/procedure_8hpp/#namespaces","text":"Name openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/procedure_8hpp/#defines","text":"Name STRIP_OPTIONAL (IDENTIFIER, ALTERNATE) FORWARD_TO_SIMULATION_API (IDENTIFIER)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/procedure_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/procedure_8hpp/#define-strip_optional","text":"#define STRIP_OPTIONAL( IDENTIFIER , ALTERNATE ) template < typename ... Ts > \\ auto IDENTIFIER ( Ts && ... xs ) \\ { \\ const auto result = connection . IDENTIFIER ( std :: forward < decltype ( xs ) > ( xs )...); \\ if ( result ) { \\ return result . get (); \\ } else { \\ using value_type = typename std :: decay < decltype ( result ) >:: type :: value_type ; \\ return ALTERNATE ; \\ } \\ } static_assert ( true , \"\" )","title":"define STRIP_OPTIONAL"},{"location":"package/openscenario_interpreter/markdown/Files/procedure_8hpp/#define-forward_to_simulation_api","text":"#define FORWARD_TO_SIMULATION_API( IDENTIFIER ) template < typename ... Ts > \\ decltype ( auto ) IDENTIFIER ( Ts && ... xs ) \\ { \\ return connection . IDENTIFIER ( std :: forward < decltype ( xs ) > ( xs )...); \\ } static_assert ( true , \"\" )","title":"define FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Files/procedure_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__PROCEDURE_HPP_ #define OPENSCENARIO_INTERPRETER__PROCEDURE_HPP_ #include <simulation_api/api/api.hpp> #include <openscenario_interpreter/error.hpp> #include <limits> #include <memory> #include <utility> namespace openscenario_interpreter { extern scenario_simulator :: API & connection ; // static struct Connector // { // Connector(); // ~Connector(); // } connector; template < typename ... Ts > decltype ( auto ) connect ( Ts && ... xs ) { new ( & connection ) scenario_simulator :: API ( std :: forward < decltype ( xs ) > ( xs )...); return connection ; } template < typename ... Ts > decltype ( auto ) getEntityStatus ( Ts && ... xs ) try { return connection . getEntityStatus ( std :: forward < decltype ( xs ) > ( xs )...); } catch ( const simulation_api :: SimulationRuntimeError & error ) { std :: stringstream ss {}; ss << error . what () << \". \\n \" ; ss << \"Possible causes: \\n \" ; ss << \" (1) The position of the corresponding entity is not specified by Teleport Action\" ; throw SemanticError ( ss . str ()); } template < typename ... Ts > decltype ( auto ) isReachedPosition ( Ts && ... xs ) { return connection . reachPosition ( std :: forward < decltype ( xs ) > ( xs )...); } // template<typename ... Ts> // decltype(auto) getRelativeDistance(Ts && ... xs) // { // return connection.getRelativeDistance(std::forward<decltype(xs)>(xs)...); // } template < typename ... Ts > decltype ( auto ) getRelativePose ( Ts && ... xs ) try { return connection . getRelativePose ( std :: forward < decltype ( xs ) > ( xs )...); } catch ( const simulation_api :: SimulationRuntimeError & ) { geometry_msgs :: msg :: Pose result {}; result . position . x = std :: numeric_limits < double >:: quiet_NaN (); result . position . y = std :: numeric_limits < double >:: quiet_NaN (); result . position . z = std :: numeric_limits < double >:: quiet_NaN (); result . orientation . x = 0 ; result . orientation . y = 0 ; result . orientation . z = 0 ; result . orientation . w = 1 ; return result ; } // template <typename... Ts> // auto getDistanceAlongRoute(Ts&&... xs) // { // if (const auto result { // connection->entity->getLongitudinalDistance(std::forward<decltype(xs)>(xs)...) }) // { // return *result; // } // else // { // using value_type = typename std::decay<decltype(result)>::type::value_type; // return std::numeric_limits<value_type>::infinity(); // } // } template < typename ... Ts > decltype ( auto ) setController ( Ts && ... xs ) { return connection . setDriverModel ( std :: forward < decltype ( xs ) > ( xs )...); } #define STRIP_OPTIONAL(IDENTIFIER, ALTERNATE) \\ template<typename ... Ts> \\ auto IDENTIFIER(Ts && ... xs) \\ { \\ const auto result = connection.IDENTIFIER(std::forward<decltype(xs)>(xs)...); \\ if (result) { \\ return result.get(); \\ } else { \\ using value_type = typename std::decay<decltype(result)>::type::value_type; \\ return ALTERNATE; \\ } \\ } static_assert(true, \"\") STRIP_OPTIONAL ( getBoundingBoxDistance , static_cast < value_type > ( 0 )); STRIP_OPTIONAL ( getStandStillDuration , static_cast < value_type > ( 0 )); STRIP_OPTIONAL ( getTimeHeadway , std :: numeric_limits < value_type >:: quiet_NaN ()); #undef STRIP_OPTIONAL #define FORWARD_TO_SIMULATION_API(IDENTIFIER) \\ template<typename ... Ts> \\ decltype(auto) IDENTIFIER(Ts && ... xs) \\ { \\ return connection.IDENTIFIER(std::forward<decltype(xs)>(xs)...); \\ } static_assert(true, \"\") FORWARD_TO_SIMULATION_API ( attachDetectionSensor ); FORWARD_TO_SIMULATION_API ( attachLidarSensor ); FORWARD_TO_SIMULATION_API ( checkCollision ); FORWARD_TO_SIMULATION_API ( despawn ); FORWARD_TO_SIMULATION_API ( getCurrentTime ); FORWARD_TO_SIMULATION_API ( initialize ); FORWARD_TO_SIMULATION_API ( isInLanelet ); FORWARD_TO_SIMULATION_API ( requestAcquirePosition ); FORWARD_TO_SIMULATION_API ( requestAssignRoute ); FORWARD_TO_SIMULATION_API ( requestLaneChange ); FORWARD_TO_SIMULATION_API ( requestWalkStraight ); FORWARD_TO_SIMULATION_API ( setEntityStatus ); FORWARD_TO_SIMULATION_API ( setTargetSpeed ); FORWARD_TO_SIMULATION_API ( spawn ); FORWARD_TO_SIMULATION_API ( toMapPose ); FORWARD_TO_SIMULATION_API ( updateFrame ); #undef DEFINE_FORWARD } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__PROCEDURE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/properties_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/properties.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Properties Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PROPERTIES_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PROPERTIES_HPP_ #include <openscenario_interpreter/syntax/file.hpp> #include <openscenario_interpreter/syntax/property.hpp> #include <unordered_map> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- Properties ------------------------------------------------------------- * * Container for one or more properties. Properties encloses multiple property * instances and/or multiple file references. * * <xsd:complexType name=\"Properties\"> * <xsd:sequence> * <xsd:element name=\"Property\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"Property\"/> * <xsd:element name=\"File\" type=\"File\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Properties { /* ---- properties ----------------------------------------------------------- * * A name-value pair. The semantic of the name/values are subject of a * contract between the provider of a simulation environment and the author * of a scenario. * * ------------------------------------------------------------------------ */ std :: unordered_map < Property :: Name , Property > properties ; /* ---- files ---------------------------------------------------------------- * * A list of arbitrary files attached to an object that owns the properties. * The semantic and the file formats are subject of a contract between the * provider of a simulation environment and the author of a scenario. * * Note: currently ignored. * * ------------------------------------------------------------------------ */ std :: vector < File > files ; Properties () = default ; template < typename Node , typename Scope > explicit Properties ( const Node & node , Scope & outer_scope ) { callWithElements ( node , \"Property\" , 0 , unbounded , [ & ]( auto && node ) { return properties . emplace ( std :: piecewise_construct , std :: forward_as_tuple ( readAttribute < Property :: Name > ( \"name\" , node , outer_scope )), std :: forward_as_tuple ( node , outer_scope )); }); callWithElements ( node , \"File\" , 0 , unbounded , [ & ]( auto && node ) { return files . emplace_back ( std :: forward < decltype ( node ) > ( node ), outer_scope ); }); } template < typename ... Ts > decltype ( auto ) operator []( Ts && ... xs ) { return properties . operator []( std :: forward < decltype ( xs ) > ( xs )...); } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PROPERTIES_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/properties.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/properties_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxpropertieshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/properties.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/properties_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/properties_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Properties","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/properties_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PROPERTIES_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PROPERTIES_HPP_ #include <openscenario_interpreter/syntax/file.hpp> #include <openscenario_interpreter/syntax/property.hpp> #include <unordered_map> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- Properties ------------------------------------------------------------- * * Container for one or more properties. Properties encloses multiple property * instances and/or multiple file references. * * <xsd:complexType name=\"Properties\"> * <xsd:sequence> * <xsd:element name=\"Property\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"Property\"/> * <xsd:element name=\"File\" type=\"File\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Properties { /* ---- properties ----------------------------------------------------------- * * A name-value pair. The semantic of the name/values are subject of a * contract between the provider of a simulation environment and the author * of a scenario. * * ------------------------------------------------------------------------ */ std :: unordered_map < Property :: Name , Property > properties ; /* ---- files ---------------------------------------------------------------- * * A list of arbitrary files attached to an object that owns the properties. * The semantic and the file formats are subject of a contract between the * provider of a simulation environment and the author of a scenario. * * Note: currently ignored. * * ------------------------------------------------------------------------ */ std :: vector < File > files ; Properties () = default ; template < typename Node , typename Scope > explicit Properties ( const Node & node , Scope & outer_scope ) { callWithElements ( node , \"Property\" , 0 , unbounded , [ & ]( auto && node ) { return properties . emplace ( std :: piecewise_construct , std :: forward_as_tuple ( readAttribute < Property :: Name > ( \"name\" , node , outer_scope )), std :: forward_as_tuple ( node , outer_scope )); }); callWithElements ( node , \"File\" , 0 , unbounded , [ & ]( auto && node ) { return files . emplace_back ( std :: forward < decltype ( node ) > ( node ), outer_scope ); }); } template < typename ... Ts > decltype ( auto ) operator []( Ts && ... xs ) { return properties . operator []( std :: forward < decltype ( xs ) > ( xs )...); } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PROPERTIES_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/property_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/property.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Property Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PROPERTY_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PROPERTY_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/syntax/boolean.hpp> #include <openscenario_interpreter/syntax/string.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- Property --------------------------------------------------------------- * * <xsd:complexType name=\"Property\"> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"value\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Property { using Name = String ; const Name name ; using Value = String ; const Value value ; /* --------------------------------------------------------------------------- * * NOTE: by yamacir-kit * * The default construct is used to give the value of an unspecified * property. * * Generally, this default constructor is called when an unspecified property * name is specified in operator [] of std::unordered_map that holds the * Property class. * * The default constructed property has an empty \"value\". * The implicit cast operator of the Property class constructs the target * type by default constructor if the string \"value\" is empty. * * Keep in mind that the C++ bool type has a value 'false' when it is * initialized by default construction. * * ------------------------------------------------------------------------ */ Property () = default ; template < typename Node , typename Scope > explicit Property ( const Node & node , Scope & outer_scope ) : name ( readAttribute < Name > ( \"name\" , node , outer_scope )), value ( readAttribute < Value > ( \"value\" , node , outer_scope )) {} operator bool () const { if ( value . empty ()) { return Boolean (); } else { return Boolean ( value ); } } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PROPERTY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/property.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/property_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxpropertyhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/property.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/property_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/property_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Property","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/property_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__PROPERTY_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__PROPERTY_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/syntax/boolean.hpp> #include <openscenario_interpreter/syntax/string.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- Property --------------------------------------------------------------- * * <xsd:complexType name=\"Property\"> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"value\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Property { using Name = String ; const Name name ; using Value = String ; const Value value ; /* --------------------------------------------------------------------------- * * NOTE: by yamacir-kit * * The default construct is used to give the value of an unspecified * property. * * Generally, this default constructor is called when an unspecified property * name is specified in operator [] of std::unordered_map that holds the * Property class. * * The default constructed property has an empty \"value\". * The implicit cast operator of the Property class constructs the target * type by default constructor if the string \"value\" is empty. * * Keep in mind that the C++ bool type has a value 'false' when it is * initialized by default construction. * * ------------------------------------------------------------------------ */ Property () = default ; template < typename Node , typename Scope > explicit Property ( const Node & node , Scope & outer_scope ) : name ( readAttribute < Name > ( \"name\" , node , outer_scope )), value ( readAttribute < Value > ( \"value\" , node , outer_scope )) {} operator bool () const { if ( value . empty ()) { return Boolean (); } else { return Boolean ( value ); } } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__PROPERTY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/pugi__extension_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/pugi_extension.hpp # Functions # Name std::ostream & operator<< (std::ostream & os, const pugi::xml_node & node) Functions Documentation # function operator<< # std :: ostream & operator << ( std :: ostream & os , const pugi :: xml_node & node ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__UTILITY__PUGI_EXTENSION_HPP_ #define OPENSCENARIO_INTERPRETER__UTILITY__PUGI_EXTENSION_HPP_ #include <pugixml.hpp> #include <string> std :: ostream & operator << ( std :: ostream & os , const pugi :: xml_node & node ) { static std :: size_t depth { 0 }; const auto indent { std :: string ( depth * 2 , ' ' )}; os << indent << \" \\x1b [34m< \\x1b [1m\" << node . name () << \" \\x1b [0m\" ; for ( const auto & attribute : node . attributes ()) { os << \" \\x1b [33m\" << attribute . name () << \" \\x1b [0m= \\x1b [36m \\\" \" << attribute . value () << \" \\\"\\x1b [0m\" ; } if ( node . first_child (). empty ()) { return os << \" \\x1b [34m/> \\x1b [0m\" << std :: endl ; } else { os << \" \\x1b [34m> \\x1b [0m\" << std :: endl ; ++ depth ; for ( const auto & each : node . children ()) { os << each ; } -- depth ; return os << indent << \" \\x1b [34m</ \\x1b [1m\" << node . name () << \" \\x1b [34m> \\x1b [0m\" << std :: endl ; } } #endif // OPENSCENARIO_INTERPRETER__UTILITY__PUGI_EXTENSION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/pugi_extension.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/pugi__extension_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterutilitypugi_extensionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/pugi_extension.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/pugi__extension_8hpp/#functions","text":"Name std::ostream & operator<< (std::ostream & os, const pugi::xml_node & node)","title":"Functions"},{"location":"package/openscenario_interpreter/markdown/Files/pugi__extension_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/pugi__extension_8hpp/#function-operator","text":"std :: ostream & operator << ( std :: ostream & os , const pugi :: xml_node & node )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Files/pugi__extension_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__UTILITY__PUGI_EXTENSION_HPP_ #define OPENSCENARIO_INTERPRETER__UTILITY__PUGI_EXTENSION_HPP_ #include <pugixml.hpp> #include <string> std :: ostream & operator << ( std :: ostream & os , const pugi :: xml_node & node ) { static std :: size_t depth { 0 }; const auto indent { std :: string ( depth * 2 , ' ' )}; os << indent << \" \\x1b [34m< \\x1b [1m\" << node . name () << \" \\x1b [0m\" ; for ( const auto & attribute : node . attributes ()) { os << \" \\x1b [33m\" << attribute . name () << \" \\x1b [0m= \\x1b [36m \\\" \" << attribute . value () << \" \\\"\\x1b [0m\" ; } if ( node . first_child (). empty ()) { return os << \" \\x1b [34m/> \\x1b [0m\" << std :: endl ; } else { os << \" \\x1b [34m> \\x1b [0m\" << std :: endl ; ++ depth ; for ( const auto & each : node . children ()) { os << each ; } -- depth ; return os << indent << \" \\x1b [34m</ \\x1b [1m\" << node . name () << \" \\x1b [34m> \\x1b [0m\" << std :: endl ; } } #endif // OPENSCENARIO_INTERPRETER__UTILITY__PUGI_EXTENSION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/reach__position__condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/reach_position_condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ReachPositionCondition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__REACH_POSITION_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__REACH_POSITION_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/position.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> #include <simulation_api/helper/helper.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- ReachPositionCondition ------------------------------------------------- * * <xsd:complexType name=\"ReachPositionCondition\"> * <xsd:all> * <xsd:element name=\"Position\" type=\"Position\"/> * </xsd:all> * <xsd:attribute name=\"tolerance\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ReachPositionCondition { const Double tolerance ; const Position position ; template < typename Node > explicit ReachPositionCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & triggering_entities ) : tolerance ( readAttribute < Double > ( \"tolerance\" , node , outer_scope )), position ( readElement < Position > ( \"Position\" , node , outer_scope )), for_each ( triggering_entities ) {} const TriggeringEntities for_each ; using TriggeringEntity = TriggeringEntities :: value_type ; decltype ( auto ) operator ()( const WorldPosition & world_position , const TriggeringEntity & triggering_entity ) const { return isReachedPosition ( triggering_entity , static_cast < geometry_msgs :: msg :: Pose > ( world_position ), tolerance ); } bool operator ()( const RelativeWorldPosition & , const TriggeringEntity & ) const { THROW ( ImplementationFault ); } decltype ( auto ) operator ()( const LanePosition & lane_position , const TriggeringEntity & triggering_entity ) const { return isReachedPosition ( triggering_entity , static_cast < openscenario_msgs :: msg :: LaneletPose > ( lane_position ), tolerance ); } #ifndef NDEBUG auto distance ( const TriggeringEntity & name ) { const auto pose = getRelativePose ( name , static_cast < geometry_msgs :: msg :: Pose > ( position )); return std :: hypot ( pose . position . x , pose . position . y ); } #endif auto evaluate () { #ifndef NDEBUG std :: cout << ( indent ++ ) << \"- BEC.RPC: \\n \" ; #endif const auto result = asBoolean ( for_each ( [ & ]( const auto & triggering_entity ) { const bool result = apply < bool > ( * this , position , triggering_entity ); #ifndef NDEBUG std :: cout << indent << \" \" << triggering_entity << \": \" ; std :: cout << std :: boolalpha << result ; std :: cout << \" (distance = \" << distance ( triggering_entity ); std :: cout << \" < \" << tolerance << \")\" << std :: endl ; #endif return result ; })); #ifndef NDEBUG -- indent ; #endif return result ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__REACH_POSITION_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/reach_position_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/reach__position__condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxreach_position_conditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/reach_position_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/reach__position__condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/reach__position__condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ReachPositionCondition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/reach__position__condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__REACH_POSITION_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__REACH_POSITION_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/position.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> #include <simulation_api/helper/helper.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- ReachPositionCondition ------------------------------------------------- * * <xsd:complexType name=\"ReachPositionCondition\"> * <xsd:all> * <xsd:element name=\"Position\" type=\"Position\"/> * </xsd:all> * <xsd:attribute name=\"tolerance\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ReachPositionCondition { const Double tolerance ; const Position position ; template < typename Node > explicit ReachPositionCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & triggering_entities ) : tolerance ( readAttribute < Double > ( \"tolerance\" , node , outer_scope )), position ( readElement < Position > ( \"Position\" , node , outer_scope )), for_each ( triggering_entities ) {} const TriggeringEntities for_each ; using TriggeringEntity = TriggeringEntities :: value_type ; decltype ( auto ) operator ()( const WorldPosition & world_position , const TriggeringEntity & triggering_entity ) const { return isReachedPosition ( triggering_entity , static_cast < geometry_msgs :: msg :: Pose > ( world_position ), tolerance ); } bool operator ()( const RelativeWorldPosition & , const TriggeringEntity & ) const { THROW ( ImplementationFault ); } decltype ( auto ) operator ()( const LanePosition & lane_position , const TriggeringEntity & triggering_entity ) const { return isReachedPosition ( triggering_entity , static_cast < openscenario_msgs :: msg :: LaneletPose > ( lane_position ), tolerance ); } #ifndef NDEBUG auto distance ( const TriggeringEntity & name ) { const auto pose = getRelativePose ( name , static_cast < geometry_msgs :: msg :: Pose > ( position )); return std :: hypot ( pose . position . x , pose . position . y ); } #endif auto evaluate () { #ifndef NDEBUG std :: cout << ( indent ++ ) << \"- BEC.RPC: \\n \" ; #endif const auto result = asBoolean ( for_each ( [ & ]( const auto & triggering_entity ) { const bool result = apply < bool > ( * this , position , triggering_entity ); #ifndef NDEBUG std :: cout << indent << \" \" << triggering_entity << \": \" ; std :: cout << std :: boolalpha << result ; std :: cout << \" (distance = \" << distance ( triggering_entity ); std :: cout << \" < \" << tolerance << \")\" << std :: endl ; #endif return result ; })); #ifndef NDEBUG -- indent ; #endif return result ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__REACH_POSITION_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/reference__context_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/reference_context.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ReferenceContext Defines # Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (ID) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ context . value = ReferenceContext :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ context . value = ReferenceContext :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( ID ) case ReferenceContext :: ID : return os << # ID ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__REFERENCE_CONTEXT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__REFERENCE_CONTEXT_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== ReferenceContext ===================================================== * * <xsd:simpleType name=\"ReferenceContext\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"relative\"/> * <xsd:enumeration value=\"absolute\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct ReferenceContext { enum value_type { relative , absolute , } value ; constexpr ReferenceContext ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , ReferenceContext & context ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ context.value = ReferenceContext::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( relative ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" << buffer << \\ \"\\' is valid OpenSCENARIO value of type ReferenceContext, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") BOILERPLATE ( absolute ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type ReferenceContext\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const ReferenceContext & context ) { switch ( context ) { #define BOILERPLATE(ID) case ReferenceContext::ID: return os << #ID; BOILERPLATE ( absolute ); BOILERPLATE ( relative ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class ReferenceContext holds unexpected value \" << static_cast < ReferenceContext :: value_type > ( context . value ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__REFERENCE_CONTEXT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/reference_context.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/reference__context_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxreference_contexthpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/reference_context.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/reference__context_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/reference__context_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ReferenceContext","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/reference__context_8hpp/#defines","text":"Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (ID)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/reference__context_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/reference__context_8hpp/#define-boilerplate","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ context . value = ReferenceContext :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/reference__context_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ context . value = ReferenceContext :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/reference__context_8hpp/#define-boilerplate_2","text":"#define BOILERPLATE( ID ) case ReferenceContext :: ID : return os << # ID ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/reference__context_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__REFERENCE_CONTEXT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__REFERENCE_CONTEXT_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== ReferenceContext ===================================================== * * <xsd:simpleType name=\"ReferenceContext\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"relative\"/> * <xsd:enumeration value=\"absolute\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct ReferenceContext { enum value_type { relative , absolute , } value ; constexpr ReferenceContext ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , ReferenceContext & context ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ context.value = ReferenceContext::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( relative ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" << buffer << \\ \"\\' is valid OpenSCENARIO value of type ReferenceContext, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") BOILERPLATE ( absolute ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type ReferenceContext\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const ReferenceContext & context ) { switch ( context ) { #define BOILERPLATE(ID) case ReferenceContext::ID: return os << #ID; BOILERPLATE ( absolute ); BOILERPLATE ( relative ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class ReferenceContext holds unexpected value \" << static_cast < ReferenceContext :: value_type > ( context . value ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__REFERENCE_CONTEXT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/relative__distance__condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_distance_condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::RelativeDistanceCondition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_DISTANCE_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_DISTANCE_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/relative_distance_type.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- RelativeDistanceCondition ---------------------------------------------- * * <xsd:complexType name=\"RelativeDistanceCondition\"> * <xsd:attribute name=\"entityRef\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"relativeDistanceType\" type=\"RelativeDistanceType\" use=\"required\"/> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"freespace\" type=\"Boolean\" use=\"required\"/> * <xsd:attribute name=\"rule\" type=\"Rule\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct RelativeDistanceCondition { const String entity_ref ; const RelativeDistanceType relative_distance_type ; const Double value ; /* ---- freespace ------------------------------------------------------------ * * True: distance is measured between closest bounding box points. * False: reference point distance is used. * * ------------------------------------------------------------------------ */ const Boolean freespace ; const Rule compare ; template < typename Node , typename Scope > explicit RelativeDistanceCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & triggering_entities ) : entity_ref ( readAttribute < String > ( \"entityRef\" , node , outer_scope )), relative_distance_type ( readAttribute < RelativeDistanceType > ( \"relativeDistanceType\" , node , outer_scope )), value ( readAttribute < Double > ( \"value\" , node , outer_scope )), freespace ( readAttribute < Boolean > ( \"freespace\" , node , outer_scope )), compare ( readAttribute < Rule > ( \"rule\" , node , outer_scope )), for_each ( triggering_entities ) {} const TriggeringEntities for_each ; using TriggeringEntity = TriggeringEntities :: value_type ; auto distance ( const TriggeringEntity & triggering_entity ) { if ( freespace ) { switch ( relative_distance_type ) { case RelativeDistanceType :: cartesianDistance : return getBoundingBoxDistance ( entity_ref , triggering_entity ); default : THROW ( ImplementationFault ); } } else { switch ( relative_distance_type ) { case RelativeDistanceType :: longitudinal : return std :: abs ( getRelativePose ( triggering_entity , entity_ref ). position . x ); case RelativeDistanceType :: lateral : return std :: abs ( getRelativePose ( triggering_entity , entity_ref ). position . y ); case RelativeDistanceType :: cartesianDistance : return std :: hypot ( getRelativePose ( triggering_entity , entity_ref ). position . x , getRelativePose ( triggering_entity , entity_ref ). position . y ); default : THROW ( ImplementationFault ); } } } template < typename ... Ts > auto operator ()( Ts && ... xs ) { return compare ( distance ( std :: forward < decltype ( xs ) > ( xs )...), value ); } auto evaluate () { #ifndef NDEBUG std :: cout << ( indent ++ ) << \"- BEC.RDC: \\n \" ; #endif const auto result = asBoolean ( for_each ( [ & ]( auto && triggering_entity ) { const auto result = ( * this )( triggering_entity ); #ifndef NDEBUG std :: cout << indent << \" \" << triggering_entity << \": \" ; std :: cout << \"distance = \" << distance ( triggering_entity ); std :: cout << \" \" << compare << \" \" << value << \"? => \" << std :: boolalpha << result ; std :: cout << std :: endl ; #endif return result ; })); #ifndef NDEBUG -- indent ; #endif return result ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_DISTANCE_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_distance_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/relative__distance__condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxrelative_distance_conditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_distance_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/relative__distance__condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/relative__distance__condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::RelativeDistanceCondition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/relative__distance__condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_DISTANCE_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_DISTANCE_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/relative_distance_type.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- RelativeDistanceCondition ---------------------------------------------- * * <xsd:complexType name=\"RelativeDistanceCondition\"> * <xsd:attribute name=\"entityRef\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"relativeDistanceType\" type=\"RelativeDistanceType\" use=\"required\"/> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"freespace\" type=\"Boolean\" use=\"required\"/> * <xsd:attribute name=\"rule\" type=\"Rule\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct RelativeDistanceCondition { const String entity_ref ; const RelativeDistanceType relative_distance_type ; const Double value ; /* ---- freespace ------------------------------------------------------------ * * True: distance is measured between closest bounding box points. * False: reference point distance is used. * * ------------------------------------------------------------------------ */ const Boolean freespace ; const Rule compare ; template < typename Node , typename Scope > explicit RelativeDistanceCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & triggering_entities ) : entity_ref ( readAttribute < String > ( \"entityRef\" , node , outer_scope )), relative_distance_type ( readAttribute < RelativeDistanceType > ( \"relativeDistanceType\" , node , outer_scope )), value ( readAttribute < Double > ( \"value\" , node , outer_scope )), freespace ( readAttribute < Boolean > ( \"freespace\" , node , outer_scope )), compare ( readAttribute < Rule > ( \"rule\" , node , outer_scope )), for_each ( triggering_entities ) {} const TriggeringEntities for_each ; using TriggeringEntity = TriggeringEntities :: value_type ; auto distance ( const TriggeringEntity & triggering_entity ) { if ( freespace ) { switch ( relative_distance_type ) { case RelativeDistanceType :: cartesianDistance : return getBoundingBoxDistance ( entity_ref , triggering_entity ); default : THROW ( ImplementationFault ); } } else { switch ( relative_distance_type ) { case RelativeDistanceType :: longitudinal : return std :: abs ( getRelativePose ( triggering_entity , entity_ref ). position . x ); case RelativeDistanceType :: lateral : return std :: abs ( getRelativePose ( triggering_entity , entity_ref ). position . y ); case RelativeDistanceType :: cartesianDistance : return std :: hypot ( getRelativePose ( triggering_entity , entity_ref ). position . x , getRelativePose ( triggering_entity , entity_ref ). position . y ); default : THROW ( ImplementationFault ); } } } template < typename ... Ts > auto operator ()( Ts && ... xs ) { return compare ( distance ( std :: forward < decltype ( xs ) > ( xs )...), value ); } auto evaluate () { #ifndef NDEBUG std :: cout << ( indent ++ ) << \"- BEC.RDC: \\n \" ; #endif const auto result = asBoolean ( for_each ( [ & ]( auto && triggering_entity ) { const auto result = ( * this )( triggering_entity ); #ifndef NDEBUG std :: cout << indent << \" \" << triggering_entity << \": \" ; std :: cout << \"distance = \" << distance ( triggering_entity ); std :: cout << \" \" << compare << \" \" << value << \"? => \" << std :: boolalpha << result ; std :: cout << std :: endl ; #endif return result ; })); #ifndef NDEBUG -- indent ; #endif return result ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_DISTANCE_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/relative__distance__type_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_distance_type.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::RelativeDistanceType Defines # Name BOILERPLATE (IDENTIFIER) BOILERPLATE (ID) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ type . value = RelativeDistanceType :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( ID ) case RelativeDistanceType :: ID : return os << # ID ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_DISTANCE_TYPE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_DISTANCE_TYPE_HPP_ #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== RelativeDistanceType ================================================= * * <xsd:simpleType name=\"RelativeDistanceType\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"longitudinal\"/> * <xsd:enumeration value=\"lateral\"/> * <xsd:enumeration value=\"cartesianDistance\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct RelativeDistanceType { enum value_type { longitudinal , lateral , cartesianDistance , } value ; explicit constexpr RelativeDistanceType ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , RelativeDistanceType & type ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ type.value = RelativeDistanceType::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( longitudinal ); BOILERPLATE ( lateral ); BOILERPLATE ( cartesianDistance ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type RelativeDistanceType\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const RelativeDistanceType & type ) { switch ( type ) { #define BOILERPLATE(ID) case RelativeDistanceType::ID: return os << #ID; BOILERPLATE ( longitudinal ); BOILERPLATE ( lateral ); BOILERPLATE ( cartesianDistance ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class RelativeDistanceType holds unexpected value \" << static_cast < RelativeDistanceType :: value_type > ( type . value ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_DISTANCE_TYPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_distance_type.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/relative__distance__type_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxrelative_distance_typehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_distance_type.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/relative__distance__type_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/relative__distance__type_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::RelativeDistanceType","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/relative__distance__type_8hpp/#defines","text":"Name BOILERPLATE (IDENTIFIER) BOILERPLATE (ID)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/relative__distance__type_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/relative__distance__type_8hpp/#define-boilerplate","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ type . value = RelativeDistanceType :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/relative__distance__type_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( ID ) case RelativeDistanceType :: ID : return os << # ID ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/relative__distance__type_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_DISTANCE_TYPE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_DISTANCE_TYPE_HPP_ #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== RelativeDistanceType ================================================= * * <xsd:simpleType name=\"RelativeDistanceType\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"longitudinal\"/> * <xsd:enumeration value=\"lateral\"/> * <xsd:enumeration value=\"cartesianDistance\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct RelativeDistanceType { enum value_type { longitudinal , lateral , cartesianDistance , } value ; explicit constexpr RelativeDistanceType ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , RelativeDistanceType & type ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ type.value = RelativeDistanceType::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( longitudinal ); BOILERPLATE ( lateral ); BOILERPLATE ( cartesianDistance ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type RelativeDistanceType\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const RelativeDistanceType & type ) { switch ( type ) { #define BOILERPLATE(ID) case RelativeDistanceType::ID: return os << #ID; BOILERPLATE ( longitudinal ); BOILERPLATE ( lateral ); BOILERPLATE ( cartesianDistance ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class RelativeDistanceType holds unexpected value \" << static_cast < RelativeDistanceType :: value_type > ( type . value ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_DISTANCE_TYPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/relative__target__speed_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_target_speed.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::RelativeTargetSpeed Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_TARGET_SPEED_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_TARGET_SPEED_HPP_ #include <openscenario_interpreter/syntax/speed_target_value_type.hpp> #include <openscenario_interpreter/reader/attribute.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== RelativeTargetSpeed ================================================== * * <xsd:complexType name=\"RelativeTargetSpeed\"> * <xsd:attribute name=\"entityRef\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"speedTargetValueType\" type=\"SpeedTargetValueType\" use=\"required\"/> * <xsd:attribute name=\"continuous\" type=\"Boolean\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct RelativeTargetSpeed { const String entity_ref ; const Double value ; const SpeedTargetValueType speed_target_value_type ; const Boolean continuous ; template < typename Node , typename Scope > explicit RelativeTargetSpeed ( const Node & node , Scope & scope ) : entity_ref { readAttribute < String > ( \"entityRef\" , node , scope )}, value { readAttribute < Double > ( \"value\" , node , scope )}, speed_target_value_type { readAttribute < SpeedTargetValueType > ( \"speedTargetValueType\" , node , scope , SpeedTargetValueType ())}, continuous { readAttribute < Boolean > ( \"continuous\" , node , scope , Boolean ())} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_TARGET_SPEED_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_target_speed.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/relative__target__speed_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxrelative_target_speedhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_target_speed.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/relative__target__speed_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/relative__target__speed_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::RelativeTargetSpeed","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/relative__target__speed_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_TARGET_SPEED_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_TARGET_SPEED_HPP_ #include <openscenario_interpreter/syntax/speed_target_value_type.hpp> #include <openscenario_interpreter/reader/attribute.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== RelativeTargetSpeed ================================================== * * <xsd:complexType name=\"RelativeTargetSpeed\"> * <xsd:attribute name=\"entityRef\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"speedTargetValueType\" type=\"SpeedTargetValueType\" use=\"required\"/> * <xsd:attribute name=\"continuous\" type=\"Boolean\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct RelativeTargetSpeed { const String entity_ref ; const Double value ; const SpeedTargetValueType speed_target_value_type ; const Boolean continuous ; template < typename Node , typename Scope > explicit RelativeTargetSpeed ( const Node & node , Scope & scope ) : entity_ref { readAttribute < String > ( \"entityRef\" , node , scope )}, value { readAttribute < Double > ( \"value\" , node , scope )}, speed_target_value_type { readAttribute < SpeedTargetValueType > ( \"speedTargetValueType\" , node , scope , SpeedTargetValueType ())}, continuous { readAttribute < Boolean > ( \"continuous\" , node , scope , Boolean ())} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_TARGET_SPEED_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/relative__world__position_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_world_position.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::RelativeWorldPosition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_WORLD_POSITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_WORLD_POSITION_HPP_ #include <geometry_msgs/msg/point.hpp> #include <openscenario_interpreter/syntax/entity_ref.hpp> #include <openscenario_msgs/msg/lanelet_pose.hpp> #include <quaternion_operation/quaternion_operation.h> namespace openscenario_interpreter { inline namespace syntax { /* ---- RelativeWorldPosition -------------------------------------------------- * * <xsd:complexType name=\"RelativeWorldPosition\"> * <xsd:all> * <xsd:element name=\"Orientation\" type=\"Orientation\" minOccurs=\"0\"/> * </xsd:all> * <xsd:attribute name=\"entityRef\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"dx\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"dy\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"dz\" type=\"Double\" use=\"optional\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct RelativeWorldPosition { const Orientation orientation ; const EntityRef reference ; const Double dx , dy , dz ; template < typename Node , typename Scope > explicit RelativeWorldPosition ( const Node & node , Scope & scope ) : orientation ( readElement < Orientation > ( \"Orientation\" , node , scope )), reference ( readAttribute < EntityRef > ( \"entityRef\" , node , scope )), dx ( readAttribute < Double > ( \"dx\" , node , scope )), dy ( readAttribute < Double > ( \"dy\" , node , scope )), dz ( readAttribute < Double > ( \"dz\" , node , scope , Double ())) {} operator geometry_msgs :: msg :: Point () const { geometry_msgs :: msg :: Point result {}; result . x = dx ; result . y = dy ; result . z = dz ; return result ; } explicit operator openscenario_msgs :: msg :: LaneletPose () const { THROW ( ImplementationFault ); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_WORLD_POSITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_world_position.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/relative__world__position_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxrelative_world_positionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/relative_world_position.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/relative__world__position_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/relative__world__position_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::RelativeWorldPosition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/relative__world__position_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_WORLD_POSITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_WORLD_POSITION_HPP_ #include <geometry_msgs/msg/point.hpp> #include <openscenario_interpreter/syntax/entity_ref.hpp> #include <openscenario_msgs/msg/lanelet_pose.hpp> #include <quaternion_operation/quaternion_operation.h> namespace openscenario_interpreter { inline namespace syntax { /* ---- RelativeWorldPosition -------------------------------------------------- * * <xsd:complexType name=\"RelativeWorldPosition\"> * <xsd:all> * <xsd:element name=\"Orientation\" type=\"Orientation\" minOccurs=\"0\"/> * </xsd:all> * <xsd:attribute name=\"entityRef\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"dx\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"dy\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"dz\" type=\"Double\" use=\"optional\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct RelativeWorldPosition { const Orientation orientation ; const EntityRef reference ; const Double dx , dy , dz ; template < typename Node , typename Scope > explicit RelativeWorldPosition ( const Node & node , Scope & scope ) : orientation ( readElement < Orientation > ( \"Orientation\" , node , scope )), reference ( readAttribute < EntityRef > ( \"entityRef\" , node , scope )), dx ( readAttribute < Double > ( \"dx\" , node , scope )), dy ( readAttribute < Double > ( \"dy\" , node , scope )), dz ( readAttribute < Double > ( \"dz\" , node , scope , Double ())) {} operator geometry_msgs :: msg :: Point () const { geometry_msgs :: msg :: Point result {}; result . x = dx ; result . y = dy ; result . z = dz ; return result ; } explicit operator openscenario_msgs :: msg :: LaneletPose () const { THROW ( ImplementationFault ); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__RELATIVE_WORLD_POSITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/road__network_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/road_network.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::RoadNetwork Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ROAD_NETWORK_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ROAD_NETWORK_HPP_ #include <openscenario_interpreter/syntax/file.hpp> #include <openscenario_interpreter/syntax/traffic_signals.hpp> #include <openscenario_interpreter/utility/assertion_auxiliary.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- RoadNetwork ------------------------------------------------------------ * * <xsd:complexType name=\"RoadNetwork\"> * <xsd:sequence> * <xsd:element name=\"LogicFile\" type=\"File\" minOccurs=\"0\"/> * <xsd:element name=\"SceneGraphFile\" type=\"File\" minOccurs=\"0\"/> * <xsd:element name=\"TrafficSignals\" minOccurs=\"0\" type=\"TrafficSignals\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ ASSERT_DEFAULT_CONSTRUCTIBLE ( File ); ASSERT_DEFAULT_CONSTRUCTIBLE ( TrafficSignals ); struct RoadNetwork { const File logic_file ; const File scene_graph_file ; const TrafficSignals traffic_signals ; template < typename Node , typename Scope > explicit RoadNetwork ( const Node & node , Scope & outer_scope ) : logic_file ( readElement < File > ( \"LogicFile\" , node , outer_scope )), scene_graph_file ( readElement < File > ( \"SceneGraphFile\" , node , outer_scope )), traffic_signals ( readElement < TrafficSignals > ( \"TrafficSignals\" , node , outer_scope )) { outer_scope . logic_file = logic_file ; outer_scope . scene_graph_file = scene_graph_file ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ROAD_NETWORK_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/road_network.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/road__network_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxroad_networkhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/road_network.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/road__network_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/road__network_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::RoadNetwork","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/road__network_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ROAD_NETWORK_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ROAD_NETWORK_HPP_ #include <openscenario_interpreter/syntax/file.hpp> #include <openscenario_interpreter/syntax/traffic_signals.hpp> #include <openscenario_interpreter/utility/assertion_auxiliary.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- RoadNetwork ------------------------------------------------------------ * * <xsd:complexType name=\"RoadNetwork\"> * <xsd:sequence> * <xsd:element name=\"LogicFile\" type=\"File\" minOccurs=\"0\"/> * <xsd:element name=\"SceneGraphFile\" type=\"File\" minOccurs=\"0\"/> * <xsd:element name=\"TrafficSignals\" minOccurs=\"0\" type=\"TrafficSignals\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ ASSERT_DEFAULT_CONSTRUCTIBLE ( File ); ASSERT_DEFAULT_CONSTRUCTIBLE ( TrafficSignals ); struct RoadNetwork { const File logic_file ; const File scene_graph_file ; const TrafficSignals traffic_signals ; template < typename Node , typename Scope > explicit RoadNetwork ( const Node & node , Scope & outer_scope ) : logic_file ( readElement < File > ( \"LogicFile\" , node , outer_scope )), scene_graph_file ( readElement < File > ( \"SceneGraphFile\" , node , outer_scope )), traffic_signals ( readElement < TrafficSignals > ( \"TrafficSignals\" , node , outer_scope )) { outer_scope . logic_file = logic_file ; outer_scope . scene_graph_file = scene_graph_file ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ROAD_NETWORK_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/route_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/route.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Route Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ROUTE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ROUTE_HPP_ #include <openscenario_interpreter/syntax/parameter_declarations.hpp> #include <openscenario_interpreter/syntax/waypoint.hpp> #include <string> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- Route ------------------------------------------------------------------ * * <xsd:complexType name=\"Route\"> * <xsd:sequence> * <xsd:element name=\"ParameterDeclarations\" type=\"ParameterDeclarations\" minOccurs=\"0\"/> * <xsd:element name=\"Waypoint\" minOccurs=\"2\" maxOccurs=\"unbounded\" type=\"Waypoint\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"closed\" type=\"Boolean\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Route { const String name ; const Boolean closed ; Scope inner_scope ; std :: vector < Waypoint > waypoints ; template < typename Node > explicit Route ( const Node & node , Scope & outer_scope ) : name ( readAttribute < String > ( \"name\" , node , outer_scope )), closed ( readAttribute < Boolean > ( \"closed\" , node , outer_scope , Boolean ())), inner_scope ( outer_scope ) { callWithElements ( node , \"ParameterDeclarations\" , 0 , 1 , [ & ]( auto && node ) { return ParameterDeclarations ( node , inner_scope ); }); callWithElements ( node , \"Waypoint\" , 2 , unbounded , [ & ]( auto && node ) { return waypoints . emplace_back ( node , inner_scope ); }); } explicit operator std :: vector < openscenario_msgs :: msg :: LaneletPose > () const { std :: vector < openscenario_msgs :: msg :: LaneletPose > lanelet_poses {}; for ( const auto & waypoint : waypoints ) { lanelet_poses . emplace_back ( static_cast < openscenario_msgs :: msg :: LaneletPose > ( waypoint )); } return lanelet_poses ; } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ROUTE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/route.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/route_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxroutehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/route.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/route_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/route_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Route","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/route_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ROUTE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ROUTE_HPP_ #include <openscenario_interpreter/syntax/parameter_declarations.hpp> #include <openscenario_interpreter/syntax/waypoint.hpp> #include <string> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- Route ------------------------------------------------------------------ * * <xsd:complexType name=\"Route\"> * <xsd:sequence> * <xsd:element name=\"ParameterDeclarations\" type=\"ParameterDeclarations\" minOccurs=\"0\"/> * <xsd:element name=\"Waypoint\" minOccurs=\"2\" maxOccurs=\"unbounded\" type=\"Waypoint\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"closed\" type=\"Boolean\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Route { const String name ; const Boolean closed ; Scope inner_scope ; std :: vector < Waypoint > waypoints ; template < typename Node > explicit Route ( const Node & node , Scope & outer_scope ) : name ( readAttribute < String > ( \"name\" , node , outer_scope )), closed ( readAttribute < Boolean > ( \"closed\" , node , outer_scope , Boolean ())), inner_scope ( outer_scope ) { callWithElements ( node , \"ParameterDeclarations\" , 0 , 1 , [ & ]( auto && node ) { return ParameterDeclarations ( node , inner_scope ); }); callWithElements ( node , \"Waypoint\" , 2 , unbounded , [ & ]( auto && node ) { return waypoints . emplace_back ( node , inner_scope ); }); } explicit operator std :: vector < openscenario_msgs :: msg :: LaneletPose > () const { std :: vector < openscenario_msgs :: msg :: LaneletPose > lanelet_poses {}; for ( const auto & waypoint : waypoints ) { lanelet_poses . emplace_back ( static_cast < openscenario_msgs :: msg :: LaneletPose > ( waypoint )); } return lanelet_poses ; } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ROUTE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/route__strategy_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/route_strategy.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::RouteStrategy Defines # Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ strategy . value = RouteStrategy :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ strategy . value = RouteStrategy :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( NAME ) case RouteStrategy :: NAME : return os << # NAME ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ROUTE_STRATEGY_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ROUTE_STRATEGY_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== RouteStrategy ======================================================== * * <xsd:simpleType name=\"RouteStrategy\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"fastest\"/> * <xsd:enumeration value=\"shortest\"/> * <xsd:enumeration value=\"leastIntersections\"/> * <xsd:enumeration value=\"random\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct RouteStrategy { enum value_type { // Fastest route. fastest , // Shortest route. shortest , // Route with least number of intersections. leastIntersections , // Random route. random , } value ; explicit constexpr RouteStrategy ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , RouteStrategy & strategy ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ strategy.value = RouteStrategy::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( shortest ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" << buffer << \\ \"\\' is valid OpenSCENARIO value of type RouteStrategy, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") BOILERPLATE ( fastest ); BOILERPLATE ( leastIntersections ); BOILERPLATE ( random ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type RouteStrategy\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const RouteStrategy & strategy ) { switch ( strategy ) { #define BOILERPLATE(NAME) case RouteStrategy::NAME: return os << #NAME; BOILERPLATE ( fastest ); BOILERPLATE ( shortest ); BOILERPLATE ( leastIntersections ); BOILERPLATE ( random ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class RouteStrategy holds unexpected value \" << static_cast < RouteStrategy :: value_type > ( strategy ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ROUTE_STRATEGY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/route_strategy.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/route__strategy_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxroute_strategyhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/route_strategy.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/route__strategy_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/route__strategy_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::RouteStrategy","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/route__strategy_8hpp/#defines","text":"Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/route__strategy_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/route__strategy_8hpp/#define-boilerplate","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ strategy . value = RouteStrategy :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/route__strategy_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ strategy . value = RouteStrategy :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/route__strategy_8hpp/#define-boilerplate_2","text":"#define BOILERPLATE( NAME ) case RouteStrategy :: NAME : return os << # NAME ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/route__strategy_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ROUTE_STRATEGY_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ROUTE_STRATEGY_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== RouteStrategy ======================================================== * * <xsd:simpleType name=\"RouteStrategy\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"fastest\"/> * <xsd:enumeration value=\"shortest\"/> * <xsd:enumeration value=\"leastIntersections\"/> * <xsd:enumeration value=\"random\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct RouteStrategy { enum value_type { // Fastest route. fastest , // Shortest route. shortest , // Route with least number of intersections. leastIntersections , // Random route. random , } value ; explicit constexpr RouteStrategy ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , RouteStrategy & strategy ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ strategy.value = RouteStrategy::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( shortest ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" << buffer << \\ \"\\' is valid OpenSCENARIO value of type RouteStrategy, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") BOILERPLATE ( fastest ); BOILERPLATE ( leastIntersections ); BOILERPLATE ( random ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type RouteStrategy\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const RouteStrategy & strategy ) { switch ( strategy ) { #define BOILERPLATE(NAME) case RouteStrategy::NAME: return os << #NAME; BOILERPLATE ( fastest ); BOILERPLATE ( shortest ); BOILERPLATE ( leastIntersections ); BOILERPLATE ( random ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class RouteStrategy holds unexpected value \" << static_cast < RouteStrategy :: value_type > ( strategy ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ROUTE_STRATEGY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/routing__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/routing_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::RoutingAction Defines # Name ELEMENT (TYPE) Macro Documentation # define ELEMENT # #define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ROUTING_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ROUTING_ACTION_HPP_ #include <openscenario_interpreter/syntax/acquire_position_action.hpp> #include <openscenario_interpreter/syntax/assign_route_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- RoutingAction ---------------------------------------------------------- * * <xsd:complexType name=\"RoutingAction\"> * <xsd:choice> * <xsd:element name=\"AssignRouteAction\" type=\"AssignRouteAction\"/> * <xsd:element name=\"FollowTrajectoryAction\" type=\"FollowTrajectoryAction\"/> * <xsd:element name=\"AcquirePositionAction\" type=\"AcquirePositionAction\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) struct RoutingAction : public Element { template < typename Node , typename ... Ts > explicit RoutingAction ( const Node & node , Ts && ... xs ) : Element ( choice ( node , ELEMENT ( AssignRouteAction ), std :: make_pair ( \"FollowTrajectoryAction\" , UNSUPPORTED ()), ELEMENT ( AcquirePositionAction ))) {} }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ROUTING_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/routing_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/routing__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxrouting_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/routing_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/routing__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/routing__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::RoutingAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/routing__action_8hpp/#defines","text":"Name ELEMENT (TYPE)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/routing__action_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/routing__action_8hpp/#define-element","text":"#define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ })","title":"define ELEMENT"},{"location":"package/openscenario_interpreter/markdown/Files/routing__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__ROUTING_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__ROUTING_ACTION_HPP_ #include <openscenario_interpreter/syntax/acquire_position_action.hpp> #include <openscenario_interpreter/syntax/assign_route_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- RoutingAction ---------------------------------------------------------- * * <xsd:complexType name=\"RoutingAction\"> * <xsd:choice> * <xsd:element name=\"AssignRouteAction\" type=\"AssignRouteAction\"/> * <xsd:element name=\"FollowTrajectoryAction\" type=\"FollowTrajectoryAction\"/> * <xsd:element name=\"AcquirePositionAction\" type=\"AcquirePositionAction\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) struct RoutingAction : public Element { template < typename Node , typename ... Ts > explicit RoutingAction ( const Node & node , Ts && ... xs ) : Element ( choice ( node , ELEMENT ( AssignRouteAction ), std :: make_pair ( \"FollowTrajectoryAction\" , UNSUPPORTED ()), ELEMENT ( AcquirePositionAction ))) {} }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__ROUTING_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/rule_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/rule.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Rule Defines # Name BOILERPLATE (IDENTIFIER) BOILERPLATE (ID) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ rule . value = Rule :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( ID ) case Rule :: ID : return os << # ID ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__RULE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__RULE_HPP_ #include <openscenario_interpreter/functional/equal_to.hpp> #include <openscenario_interpreter/reader/attribute.hpp> #include <functional> #include <string> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- Rule ------------------------------------------------------------------- * * <xsd:simpleType name=\"Rule\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"greaterThan\"/> * <xsd:enumeration value=\"lessThan\"/> * <xsd:enumeration value=\"equalTo\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * -------------------------------------------------------------------------- */ struct Rule { enum value_type { greaterThan , lessThan , equalTo , } value ; explicit constexpr Rule ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } template < typename T , typename U = T > constexpr decltype ( auto ) operator ()( const T & lhs , const U & rhs ) const noexcept { switch ( value ) { case greaterThan : return std :: greater < void > ()( std :: forward < decltype ( lhs ) > ( lhs ), std :: forward < decltype ( rhs ) > ( rhs )); case lessThan : return std :: less < void > ()( std :: forward < decltype ( lhs ) > ( lhs ), std :: forward < decltype ( rhs ) > ( rhs )); case equalTo : return equal_to < T > ()( std :: forward < decltype ( lhs ) > ( lhs ), std :: forward < decltype ( rhs ) > ( rhs )); default : return false ; } } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , Rule & rule ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ rule.value = Rule::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( greaterThan ); BOILERPLATE ( lessThan ); BOILERPLATE ( equalTo ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type Rule\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Rule & rule ) { switch ( rule ) { #define BOILERPLATE(ID) case Rule::ID: return os << #ID; BOILERPLATE ( greaterThan ); BOILERPLATE ( lessThan ); BOILERPLATE ( equalTo ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class Rule holds unexpected value \" << static_cast < Rule :: value_type > ( rule . value ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__RULE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/rule.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/rule_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxrulehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/rule.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/rule_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/rule_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Rule","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/rule_8hpp/#defines","text":"Name BOILERPLATE (IDENTIFIER) BOILERPLATE (ID)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/rule_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/rule_8hpp/#define-boilerplate","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ rule . value = Rule :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/rule_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( ID ) case Rule :: ID : return os << # ID ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/rule_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__RULE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__RULE_HPP_ #include <openscenario_interpreter/functional/equal_to.hpp> #include <openscenario_interpreter/reader/attribute.hpp> #include <functional> #include <string> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- Rule ------------------------------------------------------------------- * * <xsd:simpleType name=\"Rule\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"greaterThan\"/> * <xsd:enumeration value=\"lessThan\"/> * <xsd:enumeration value=\"equalTo\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * -------------------------------------------------------------------------- */ struct Rule { enum value_type { greaterThan , lessThan , equalTo , } value ; explicit constexpr Rule ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } template < typename T , typename U = T > constexpr decltype ( auto ) operator ()( const T & lhs , const U & rhs ) const noexcept { switch ( value ) { case greaterThan : return std :: greater < void > ()( std :: forward < decltype ( lhs ) > ( lhs ), std :: forward < decltype ( rhs ) > ( rhs )); case lessThan : return std :: less < void > ()( std :: forward < decltype ( lhs ) > ( lhs ), std :: forward < decltype ( rhs ) > ( rhs )); case equalTo : return equal_to < T > ()( std :: forward < decltype ( lhs ) > ( lhs ), std :: forward < decltype ( rhs ) > ( rhs )); default : return false ; } } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , Rule & rule ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ rule.value = Rule::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( greaterThan ); BOILERPLATE ( lessThan ); BOILERPLATE ( equalTo ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type Rule\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Rule & rule ) { switch ( rule ) { #define BOILERPLATE(ID) case Rule::ID: return os << #ID; BOILERPLATE ( greaterThan ); BOILERPLATE ( lessThan ); BOILERPLATE ( equalTo ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class Rule holds unexpected value \" << static_cast < Rule :: value_type > ( rule . value ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__RULE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/scenario__object_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/scenario_object.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::ScenarioObject Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__SCENARIO_OBJECT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__SCENARIO_OBJECT_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/entity_object.hpp> #include <openscenario_interpreter/syntax/entity_ref.hpp> #include <openscenario_interpreter/syntax/object_controller.hpp> #include <openscenario_interpreter/syntax/string.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- ScenarioObject --------------------------------------------------------- * * <xsd:complexType name=\"ScenarioObject\"> * <xsd:sequence> * <xsd:group ref=\"EntityObject\"/> * <xsd:element name=\"ObjectController\" minOccurs=\"0\" type=\"ObjectController\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ScenarioObject /* ----------------------------------------------------------------------------- * * The EntityObject (either instance of type Vehicle, Pedestrian or * MiscObject). * * NOTE: This framework expresses xsd:group as mixin. * * ------------------------------------------------------------------------- */ : public EntityObject { /* ---- name ----------------------------------------------------------------- * * Identifier of the scenario object. * * ------------------------------------------------------------------------ */ using Name = String ; const Name name ; /* ---- ObjectController ----------------------------------------------------- * * Controller of the EntityObject instance. * * ------------------------------------------------------------------------ */ ObjectController object_controller ; static_assert ( IsOptionalElement < ObjectController >:: value , \"minOccurs= \\\" 0 \\\" \" ); template < typename Node , typename Scope > explicit ScenarioObject ( const Node & node , Scope & outer_scope ) : EntityObject ( node , outer_scope ), name ( readAttribute < String > ( \"name\" , node , outer_scope )), object_controller ( readElement < ObjectController > ( \"ObjectController\" , node , outer_scope )) {} auto evaluate () { if ( spawn ( is < Vehicle > () && object_controller . isEgo (), name , boost :: lexical_cast < String > ( static_cast < const EntityObject &> ( * this )))) // XXX UGLY CODE!!! { if ( is < Vehicle > ()) { setController ( name , object_controller ); if ( object_controller . isEgo ()) { attachLidarSensor ( simulation_api :: helper :: constructLidarConfiguration ( simulation_api :: helper :: LidarType :: VLP32 , name , \"/sensing/lidar/no_ground/pointcloud\" )); attachDetectionSensor ( simulation_api :: helper :: constructDetectionSensorConfiguration ( name , \"/perception/object_recognition/objects\" , 0.1 )); } } return unspecified ; } else { throw SemanticError ( \"Failed to spawn entity '\" , name , \"'.\" ); } } }; std :: ostream & operator << ( std :: ostream & os , const ScenarioObject & datum ) { return os << ( indent ++ ) << blue << \"<ScenarioObject\" << \" \" << highlight ( \"name\" , datum . name ) << blue << \"> \\n \" << reset << static_cast < const EntityObject &> ( datum ) << \" \\n \" << ( -- indent ) << blue << \"</ScenarioObject>\" << reset ; } } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__SCENARIO_OBJECT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/scenario_object.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/scenario__object_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxscenario_objecthpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/scenario_object.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/scenario__object_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/scenario__object_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::ScenarioObject","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/scenario__object_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__SCENARIO_OBJECT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__SCENARIO_OBJECT_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/entity_object.hpp> #include <openscenario_interpreter/syntax/entity_ref.hpp> #include <openscenario_interpreter/syntax/object_controller.hpp> #include <openscenario_interpreter/syntax/string.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- ScenarioObject --------------------------------------------------------- * * <xsd:complexType name=\"ScenarioObject\"> * <xsd:sequence> * <xsd:group ref=\"EntityObject\"/> * <xsd:element name=\"ObjectController\" minOccurs=\"0\" type=\"ObjectController\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct ScenarioObject /* ----------------------------------------------------------------------------- * * The EntityObject (either instance of type Vehicle, Pedestrian or * MiscObject). * * NOTE: This framework expresses xsd:group as mixin. * * ------------------------------------------------------------------------- */ : public EntityObject { /* ---- name ----------------------------------------------------------------- * * Identifier of the scenario object. * * ------------------------------------------------------------------------ */ using Name = String ; const Name name ; /* ---- ObjectController ----------------------------------------------------- * * Controller of the EntityObject instance. * * ------------------------------------------------------------------------ */ ObjectController object_controller ; static_assert ( IsOptionalElement < ObjectController >:: value , \"minOccurs= \\\" 0 \\\" \" ); template < typename Node , typename Scope > explicit ScenarioObject ( const Node & node , Scope & outer_scope ) : EntityObject ( node , outer_scope ), name ( readAttribute < String > ( \"name\" , node , outer_scope )), object_controller ( readElement < ObjectController > ( \"ObjectController\" , node , outer_scope )) {} auto evaluate () { if ( spawn ( is < Vehicle > () && object_controller . isEgo (), name , boost :: lexical_cast < String > ( static_cast < const EntityObject &> ( * this )))) // XXX UGLY CODE!!! { if ( is < Vehicle > ()) { setController ( name , object_controller ); if ( object_controller . isEgo ()) { attachLidarSensor ( simulation_api :: helper :: constructLidarConfiguration ( simulation_api :: helper :: LidarType :: VLP32 , name , \"/sensing/lidar/no_ground/pointcloud\" )); attachDetectionSensor ( simulation_api :: helper :: constructDetectionSensorConfiguration ( name , \"/perception/object_recognition/objects\" , 0.1 )); } } return unspecified ; } else { throw SemanticError ( \"Failed to spawn entity '\" , name , \"'.\" ); } } }; std :: ostream & operator << ( std :: ostream & os , const ScenarioObject & datum ) { return os << ( indent ++ ) << blue << \"<ScenarioObject\" << \" \" << highlight ( \"name\" , datum . name ) << blue << \"> \\n \" << reset << static_cast < const EntityObject &> ( datum ) << \" \\n \" << ( -- indent ) << blue << \"</ScenarioObject>\" << reset ; } } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__SCENARIO_OBJECT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/scope_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/scope.hpp # Namespaces # Name openscenario_interpreter Classes # Name struct openscenario_interpreter::Scope Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SCOPE_HPP_ #define OPENSCENARIO_INTERPRETER__SCOPE_HPP_ #include <boost/filesystem.hpp> #include <openscenario_interpreter/syntax/entity_ref.hpp> #include <limits> #include <memory> #include <string> #include <unordered_map> #include <utility> #include <vector> namespace openscenario_interpreter { struct Scope { std :: unordered_map < String , Element > parameters ; std :: unordered_map < String , Element > entities ; std :: unordered_map < String , Element > storyboard_elements ; using Actor = EntityRef ; using Actors = std :: vector < Actor > ; Actors actors ; boost :: filesystem :: path logic_file ; boost :: filesystem :: path scene_graph_file ; // for substituation syntax '$(dirname)' const boost :: filesystem :: path scenario ; Scope () = delete ; explicit Scope ( Scope & ) = default ; explicit Scope ( const Scope & ) = default ; template < typename ... Ts > explicit Scope ( const std :: string & scenario , Ts && ... xs ) : scenario ( scenario ) {} }; } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SCOPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/scope.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/scope_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterscopehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/scope.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/scope_8hpp/#namespaces","text":"Name openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/scope_8hpp/#classes","text":"Name struct openscenario_interpreter::Scope","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/scope_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SCOPE_HPP_ #define OPENSCENARIO_INTERPRETER__SCOPE_HPP_ #include <boost/filesystem.hpp> #include <openscenario_interpreter/syntax/entity_ref.hpp> #include <limits> #include <memory> #include <string> #include <unordered_map> #include <utility> #include <vector> namespace openscenario_interpreter { struct Scope { std :: unordered_map < String , Element > parameters ; std :: unordered_map < String , Element > entities ; std :: unordered_map < String , Element > storyboard_elements ; using Actor = EntityRef ; using Actors = std :: vector < Actor > ; Actors actors ; boost :: filesystem :: path logic_file ; boost :: filesystem :: path scene_graph_file ; // for substituation syntax '$(dirname)' const boost :: filesystem :: path scenario ; Scope () = delete ; explicit Scope ( Scope & ) = default ; explicit Scope ( const Scope & ) = default ; template < typename ... Ts > explicit Scope ( const std :: string & scenario , Ts && ... xs ) : scenario ( scenario ) {} }; } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SCOPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/selected__entities_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/selected_entities.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::SelectedEntities Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__SELECTED_ENTITIES_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__SELECTED_ENTITIES_HPP_ #include <openscenario_interpreter/syntax/by_type.hpp> #include <openscenario_interpreter/syntax/entity_ref.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== SelectedEntities ===================================================== * * <xsd:complexType name=\"SelectedEntities\"> * <xsd:choice> * <xsd:element name=\"EntityRef\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"EntityRef\"/> * <xsd:element name=\"ByType\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"ByType\"/> * </xsd:choice> * </xsd:complexType> * * ======================================================================== */ struct SelectedEntities {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__SELECTED_ENTITIES_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/selected_entities.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/selected__entities_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxselected_entitieshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/selected_entities.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/selected__entities_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/selected__entities_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::SelectedEntities","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/selected__entities_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__SELECTED_ENTITIES_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__SELECTED_ENTITIES_HPP_ #include <openscenario_interpreter/syntax/by_type.hpp> #include <openscenario_interpreter/syntax/entity_ref.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== SelectedEntities ===================================================== * * <xsd:complexType name=\"SelectedEntities\"> * <xsd:choice> * <xsd:element name=\"EntityRef\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"EntityRef\"/> * <xsd:element name=\"ByType\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"ByType\"/> * </xsd:choice> * </xsd:complexType> * * ======================================================================== */ struct SelectedEntities {}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__SELECTED_ENTITIES_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/simulation__time__condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/simulation_time_condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::SimulationTimeCondition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__SIMULATION_TIME_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__SIMULATION_TIME_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/rule.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- SimulationTimeCondition ------------------------------------------------ * * <xsd:complexType name=\"SimulationTimeCondition\"> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"rule\" type=\"Rule\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct SimulationTimeCondition { const Double value ; const Rule compare ; template < typename Node , typename Scope > explicit SimulationTimeCondition ( const Node & node , Scope & scope ) : value ( readAttribute < Double > ( \"value\" , node , scope )), compare ( readAttribute < Rule > ( \"rule\" , node , scope )) {} Element result ; auto evaluate () { result = asBoolean ( compare ( getCurrentTime (), value )); #ifndef NDEBUG std :: cout << * this << std :: endl ; #endif return result ; } friend std :: ostream & operator << ( std :: ostream & os , const SimulationTimeCondition & condition ) { os << indent ; os << \"- BVC.STC: \" ; os << getCurrentTime (); os << \" is \" ; os << condition . compare ; os << \" \" ; os << condition . value ; os << \"? => \" ; os << condition . result ; return os ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__SIMULATION_TIME_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/simulation_time_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/simulation__time__condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxsimulation_time_conditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/simulation_time_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/simulation__time__condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/simulation__time__condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::SimulationTimeCondition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/simulation__time__condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__SIMULATION_TIME_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__SIMULATION_TIME_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/rule.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- SimulationTimeCondition ------------------------------------------------ * * <xsd:complexType name=\"SimulationTimeCondition\"> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"rule\" type=\"Rule\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct SimulationTimeCondition { const Double value ; const Rule compare ; template < typename Node , typename Scope > explicit SimulationTimeCondition ( const Node & node , Scope & scope ) : value ( readAttribute < Double > ( \"value\" , node , scope )), compare ( readAttribute < Rule > ( \"rule\" , node , scope )) {} Element result ; auto evaluate () { result = asBoolean ( compare ( getCurrentTime (), value )); #ifndef NDEBUG std :: cout << * this << std :: endl ; #endif return result ; } friend std :: ostream & operator << ( std :: ostream & os , const SimulationTimeCondition & condition ) { os << indent ; os << \"- BVC.STC: \" ; os << getCurrentTime (); os << \" is \" ; os << condition . compare ; os << \" \" ; os << condition . value ; os << \"? => \" ; os << condition . result ; return os ; } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__SIMULATION_TIME_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/size_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/iterator/size.hpp # Namespaces # Name openscenario_interpreter::iterator openscenario_interpreter Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__ITERATOR__SIZE_HPP_ #define OPENSCENARIO_INTERPRETER__ITERATOR__SIZE_HPP_ #include <iterator> namespace openscenario_interpreter { inline namespace iterator { template < typename T > auto size ( const T & range ) { return std :: distance ( std :: begin ( range ), std :: end ( range )); } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__ITERATOR__SIZE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/iterator/size.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/size_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreteriteratorsizehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/iterator/size.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/size_8hpp/#namespaces","text":"Name openscenario_interpreter::iterator openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/size_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__ITERATOR__SIZE_HPP_ #define OPENSCENARIO_INTERPRETER__ITERATOR__SIZE_HPP_ #include <iterator> namespace openscenario_interpreter { inline namespace iterator { template < typename T > auto size ( const T & range ) { return std :: distance ( std :: begin ( range ), std :: end ( range )); } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__ITERATOR__SIZE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/speed__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::SpeedAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_ACTION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/rule.hpp> #include <openscenario_interpreter/syntax/speed_action_target.hpp> #include <openscenario_interpreter/syntax/transition_dynamics.hpp> #include <string> #include <unordered_map> namespace openscenario_interpreter { inline namespace syntax { /* ---- SpeedAction ------------------------------------------------------------ * * <xsd:complexType name=\"SpeedAction\"> * <xsd:all> * <xsd:element name=\"SpeedActionDynamics\" type=\"TransitionDynamics\"/> * <xsd:element name=\"SpeedActionTarget\" type=\"SpeedActionTarget\"/> * </xsd:all> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct SpeedAction { Scope inner_scope ; const TransitionDynamics speed_action_dynamics ; const SpeedActionTarget speed_action_target ; template < typename Node > explicit SpeedAction ( const Node & node , Scope & outer_scope ) : inner_scope ( outer_scope ), speed_action_dynamics ( readElement < TransitionDynamics > ( \"SpeedActionDynamics\" , node , inner_scope )), speed_action_target ( readElement < SpeedActionTarget > ( \"SpeedActionTarget\" , node , inner_scope )) {} std :: unordered_map < String , Boolean > accomplishments ; auto reset () { accomplishments . clear (); for ( const auto & actor : inner_scope . actors ) { accomplishments . emplace ( actor , false ); } } template < typename T > decltype ( auto ) setLinearTransition ( const Scope :: Actor & actor , const T value ) const { return setTargetSpeed ( actor , value , true ); } template < typename T > decltype ( auto ) setStepTransition ( const Scope :: Actor & actor , const T value ) const { auto status = getEntityStatus ( actor ); status . action_status . twist . linear . x = value ; setEntityStatus ( actor , status ); return setTargetSpeed ( actor , status . action_status . twist . linear . x , true ); } decltype ( auto ) operator ()( const Scope :: Actor & actor ) const { if ( speed_action_target . is < AbsoluteTargetSpeed > ()) { switch ( speed_action_dynamics . dynamics_shape ) { case DynamicsShape :: linear : return setLinearTransition ( actor , speed_action_target . as < AbsoluteTargetSpeed > (). value ); case DynamicsShape :: step : return setStepTransition ( actor , speed_action_target . as < AbsoluteTargetSpeed > (). value ); default : THROW ( ImplementationFault ); } } else { THROW ( ImplementationFault ); } } auto start () { reset (); for ( const auto & actor : inner_scope . actors ) { ( * this )( actor ); } return unspecified ; } auto check ( const String & actor ) try { const auto compare = Rule ( Rule :: equalTo ); if ( speed_action_target . is < AbsoluteTargetSpeed > ()) { return compare ( getEntityStatus ( actor ). action_status . twist . linear . x , speed_action_target . as < AbsoluteTargetSpeed > (). value ); } else { THROW ( ImplementationFault ); } } catch ( const SemanticError & ) { return false ; // NOTE: The actor is maybe lane-changing now. } auto update () { for ( auto && each : accomplishments ) { each . second = each . second || check ( each . first ); } } auto accomplished () { update (); return std :: all_of ( std :: begin ( accomplishments ), std :: end ( accomplishments ), cdr ); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/speed__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxspeed_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/speed__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/speed__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::SpeedAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/speed__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_ACTION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/rule.hpp> #include <openscenario_interpreter/syntax/speed_action_target.hpp> #include <openscenario_interpreter/syntax/transition_dynamics.hpp> #include <string> #include <unordered_map> namespace openscenario_interpreter { inline namespace syntax { /* ---- SpeedAction ------------------------------------------------------------ * * <xsd:complexType name=\"SpeedAction\"> * <xsd:all> * <xsd:element name=\"SpeedActionDynamics\" type=\"TransitionDynamics\"/> * <xsd:element name=\"SpeedActionTarget\" type=\"SpeedActionTarget\"/> * </xsd:all> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct SpeedAction { Scope inner_scope ; const TransitionDynamics speed_action_dynamics ; const SpeedActionTarget speed_action_target ; template < typename Node > explicit SpeedAction ( const Node & node , Scope & outer_scope ) : inner_scope ( outer_scope ), speed_action_dynamics ( readElement < TransitionDynamics > ( \"SpeedActionDynamics\" , node , inner_scope )), speed_action_target ( readElement < SpeedActionTarget > ( \"SpeedActionTarget\" , node , inner_scope )) {} std :: unordered_map < String , Boolean > accomplishments ; auto reset () { accomplishments . clear (); for ( const auto & actor : inner_scope . actors ) { accomplishments . emplace ( actor , false ); } } template < typename T > decltype ( auto ) setLinearTransition ( const Scope :: Actor & actor , const T value ) const { return setTargetSpeed ( actor , value , true ); } template < typename T > decltype ( auto ) setStepTransition ( const Scope :: Actor & actor , const T value ) const { auto status = getEntityStatus ( actor ); status . action_status . twist . linear . x = value ; setEntityStatus ( actor , status ); return setTargetSpeed ( actor , status . action_status . twist . linear . x , true ); } decltype ( auto ) operator ()( const Scope :: Actor & actor ) const { if ( speed_action_target . is < AbsoluteTargetSpeed > ()) { switch ( speed_action_dynamics . dynamics_shape ) { case DynamicsShape :: linear : return setLinearTransition ( actor , speed_action_target . as < AbsoluteTargetSpeed > (). value ); case DynamicsShape :: step : return setStepTransition ( actor , speed_action_target . as < AbsoluteTargetSpeed > (). value ); default : THROW ( ImplementationFault ); } } else { THROW ( ImplementationFault ); } } auto start () { reset (); for ( const auto & actor : inner_scope . actors ) { ( * this )( actor ); } return unspecified ; } auto check ( const String & actor ) try { const auto compare = Rule ( Rule :: equalTo ); if ( speed_action_target . is < AbsoluteTargetSpeed > ()) { return compare ( getEntityStatus ( actor ). action_status . twist . linear . x , speed_action_target . as < AbsoluteTargetSpeed > (). value ); } else { THROW ( ImplementationFault ); } } catch ( const SemanticError & ) { return false ; // NOTE: The actor is maybe lane-changing now. } auto update () { for ( auto && each : accomplishments ) { each . second = each . second || check ( each . first ); } } auto accomplished () { update (); return std :: all_of ( std :: begin ( accomplishments ), std :: end ( accomplishments ), cdr ); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/speed__action__target_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_action_target.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::SpeedActionTarget Defines # Name ELEMENT (TYPE) Macro Documentation # define ELEMENT # #define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_ACTION_TARGET_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_ACTION_TARGET_HPP_ #include <openscenario_interpreter/syntax/relative_target_speed.hpp> #include <openscenario_interpreter/syntax/absolute_target_speed.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- SpeedActionTarget ------------------------------------------------------ * * <xsd:complexType name=\"SpeedActionTarget\"> * <xsd:choice> * <xsd:element name=\"RelativeTargetSpeed\" type=\"RelativeTargetSpeed\"/> * <xsd:element name=\"AbsoluteTargetSpeed\" type=\"AbsoluteTargetSpeed\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) struct SpeedActionTarget : public Element { template < typename Node , typename ... Ts > explicit SpeedActionTarget ( const Node & node , Ts && ... xs ) : Element ( choice ( node , ELEMENT ( RelativeTargetSpeed ), ELEMENT ( AbsoluteTargetSpeed ))) {} }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_ACTION_TARGET_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_action_target.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/speed__action__target_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxspeed_action_targethpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_action_target.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/speed__action__target_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/speed__action__target_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::SpeedActionTarget","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/speed__action__target_8hpp/#defines","text":"Name ELEMENT (TYPE)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/speed__action__target_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/speed__action__target_8hpp/#define-element","text":"#define ELEMENT( TYPE ) std :: make_pair ( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ })","title":"define ELEMENT"},{"location":"package/openscenario_interpreter/markdown/Files/speed__action__target_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_ACTION_TARGET_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_ACTION_TARGET_HPP_ #include <openscenario_interpreter/syntax/relative_target_speed.hpp> #include <openscenario_interpreter/syntax/absolute_target_speed.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- SpeedActionTarget ------------------------------------------------------ * * <xsd:complexType name=\"SpeedActionTarget\"> * <xsd:choice> * <xsd:element name=\"RelativeTargetSpeed\" type=\"RelativeTargetSpeed\"/> * <xsd:element name=\"AbsoluteTargetSpeed\" type=\"AbsoluteTargetSpeed\"/> * </xsd:choice> * </xsd:complexType> * * -------------------------------------------------------------------------- */ #define ELEMENT(TYPE) \\ std::make_pair( \\ #TYPE, [&](auto && node) \\ { \\ return make<TYPE>(node, std::forward<decltype(xs)>(xs)...); \\ }) struct SpeedActionTarget : public Element { template < typename Node , typename ... Ts > explicit SpeedActionTarget ( const Node & node , Ts && ... xs ) : Element ( choice ( node , ELEMENT ( RelativeTargetSpeed ), ELEMENT ( AbsoluteTargetSpeed ))) {} }; #undef ELEMENT } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_ACTION_TARGET_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/speed__condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::SpeedCondition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/rule.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- SpeedCondition --------------------------------------------------------- * * <xsd:complexType name=\"SpeedCondition\"> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"rule\" type=\"Rule\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct SpeedCondition { const Double value ; const Rule compare ; template < typename AST > explicit SpeedCondition ( const AST & node , Scope & outer_scope , const TriggeringEntities & triggering_entities ) : value ( readAttribute < Double > ( \"value\" , node , outer_scope )), compare ( readAttribute < Rule > ( \"rule\" , node , outer_scope )), for_each ( triggering_entities ) {} const TriggeringEntities for_each ; auto evaluate () { #ifndef NDEBUG std :: cout << ( indent ++ ) << \"- BEC.SC: \\n \" ; #endif const auto result = asBoolean ( for_each ( [ & ]( auto && triggering_entity ) { const auto result = compare ( getEntityStatus ( triggering_entity ). action_status . twist . linear . x , value ); #ifndef NDEBUG std :: cout << indent << \" \" << triggering_entity << \"'s speed = \" ; std :: cout << getEntityStatus ( triggering_entity ). action_status . twist . linear . x ; std :: cout << \" \" << compare << \" \" << value << \"? => \" << result << std :: endl ; #endif return result ; })); #ifndef NDEBUG -- indent ; #endif return result ; } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/speed__condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxspeed_conditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/speed__condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/speed__condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::SpeedCondition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/speed__condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/rule.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- SpeedCondition --------------------------------------------------------- * * <xsd:complexType name=\"SpeedCondition\"> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"rule\" type=\"Rule\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct SpeedCondition { const Double value ; const Rule compare ; template < typename AST > explicit SpeedCondition ( const AST & node , Scope & outer_scope , const TriggeringEntities & triggering_entities ) : value ( readAttribute < Double > ( \"value\" , node , outer_scope )), compare ( readAttribute < Rule > ( \"rule\" , node , outer_scope )), for_each ( triggering_entities ) {} const TriggeringEntities for_each ; auto evaluate () { #ifndef NDEBUG std :: cout << ( indent ++ ) << \"- BEC.SC: \\n \" ; #endif const auto result = asBoolean ( for_each ( [ & ]( auto && triggering_entity ) { const auto result = compare ( getEntityStatus ( triggering_entity ). action_status . twist . linear . x , value ); #ifndef NDEBUG std :: cout << indent << \" \" << triggering_entity << \"'s speed = \" ; std :: cout << getEntityStatus ( triggering_entity ). action_status . twist . linear . x ; std :: cout << \" \" << compare << \" \" << value << \"? => \" << result << std :: endl ; #endif return result ; })); #ifndef NDEBUG -- indent ; #endif return result ; } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/speed__target__value__type_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_target_value_type.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::SpeedTargetValueType Defines # Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ type . value = SpeedTargetValueType :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ type . value = SpeedTargetValueType :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( NAME ) case SpeedTargetValueType :: NAME : return os << # NAME ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_TARGET_VALUE_TYPE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_TARGET_VALUE_TYPE_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== SpeedTargetValueType ================================================= * * <xsd:simpleType name=\"SpeedTargetValueType\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"delta\"/> * <xsd:enumeration value=\"factor\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct SpeedTargetValueType { enum value_type { // The relative value is interpreted as a difference to a referenced value. // Unit: m/s. As an example, a speed value of 10 equals a speed that's 10m/s // faster than the reference speed. delta , // The relative value is interpreted as a factor to a referenced value. No // unit. As an example, a speed value of 1.1 equals a speed that's 10% // faster than the reference speed. factor , } value ; explicit constexpr SpeedTargetValueType ( value_type value = delta ) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , SpeedTargetValueType & type ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ type.value = SpeedTargetValueType::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( delta ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" \\ << buffer \\ << \"\\' is valid OpenSCENARIO value of type SpeedTargetValueType, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") BOILERPLATE ( factor ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type SpeedTargetValueType\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const SpeedTargetValueType & type ) { switch ( type ) { #define BOILERPLATE(NAME) case SpeedTargetValueType::NAME: return os << #NAME; BOILERPLATE ( delta ); BOILERPLATE ( factor ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class SpeedTargetValueType holds unexpected value \" << static_cast < SpeedTargetValueType :: value_type > ( type ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_TARGET_VALUE_TYPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_target_value_type.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/speed__target__value__type_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxspeed_target_value_typehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/speed_target_value_type.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/speed__target__value__type_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/speed__target__value__type_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::SpeedTargetValueType","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/speed__target__value__type_8hpp/#defines","text":"Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/speed__target__value__type_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/speed__target__value__type_8hpp/#define-boilerplate","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ type . value = SpeedTargetValueType :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/speed__target__value__type_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ type . value = SpeedTargetValueType :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/speed__target__value__type_8hpp/#define-boilerplate_2","text":"#define BOILERPLATE( NAME ) case SpeedTargetValueType :: NAME : return os << # NAME ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/speed__target__value__type_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_TARGET_VALUE_TYPE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_TARGET_VALUE_TYPE_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== SpeedTargetValueType ================================================= * * <xsd:simpleType name=\"SpeedTargetValueType\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"delta\"/> * <xsd:enumeration value=\"factor\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct SpeedTargetValueType { enum value_type { // The relative value is interpreted as a difference to a referenced value. // Unit: m/s. As an example, a speed value of 10 equals a speed that's 10m/s // faster than the reference speed. delta , // The relative value is interpreted as a factor to a referenced value. No // unit. As an example, a speed value of 1.1 equals a speed that's 10% // faster than the reference speed. factor , } value ; explicit constexpr SpeedTargetValueType ( value_type value = delta ) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , SpeedTargetValueType & type ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ type.value = SpeedTargetValueType::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( delta ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" \\ << buffer \\ << \"\\' is valid OpenSCENARIO value of type SpeedTargetValueType, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") BOILERPLATE ( factor ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type SpeedTargetValueType\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const SpeedTargetValueType & type ) { switch ( type ) { #define BOILERPLATE(NAME) case SpeedTargetValueType::NAME: return os << #NAME; BOILERPLATE ( delta ); BOILERPLATE ( factor ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class SpeedTargetValueType holds unexpected value \" << static_cast < SpeedTargetValueType :: value_type > ( type ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__SPEED_TARGET_VALUE_TYPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/split_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string/split.hpp # Namespaces # Name openscenario_interpreter::string openscenario_interpreter Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__STRING__SPLIT_HPP_ #define OPENSCENARIO_INTERPRETER__STRING__SPLIT_HPP_ #include <boost/algorithm/string.hpp> #include <string> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace string { auto split ( const std :: string & target ) { std :: vector < std :: string > result {}; boost :: split ( result , target , boost :: is_space ()); return result ; } } // namespace string } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__STRING__SPLIT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string/split.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/split_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterstringsplithpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/string/split.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/split_8hpp/#namespaces","text":"Name openscenario_interpreter::string openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/split_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__STRING__SPLIT_HPP_ #define OPENSCENARIO_INTERPRETER__STRING__SPLIT_HPP_ #include <boost/algorithm/string.hpp> #include <string> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace string { auto split ( const std :: string & target ) { std :: vector < std :: string > result {}; boost :: split ( result , target , boost :: is_space ()); return result ; } } // namespace string } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__STRING__SPLIT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/stand__still__condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/stand_still_condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::StandStillCondition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STAND_STILL_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STAND_STILL_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/rule.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- StandStillCondition --------------------------------------------------------- * * <xsd:complexType name=\"StandStillCondition\"> * <xsd:attribute name=\"duration\" type=\"Double\" use=\"required\"/> * </xsd:complexType>* * * -------------------------------------------------------------------------- */ struct StandStillCondition { const Double duration ; const Rule compare ; const TriggeringEntities for_each ; template < typename Node > explicit StandStillCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & for_each ) : duration ( readAttribute < Double > ( \"duration\" , node , outer_scope )), compare ( Rule :: greaterThan ), for_each ( for_each ) {} auto evaluate () const { return asBoolean ( for_each ( [ & ]( auto && triggering_entity ) { return compare ( getStandStillDuration ( triggering_entity ), duration ); })); } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STAND_STILL_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/stand_still_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/stand__still__condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxstand_still_conditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/stand_still_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/stand__still__condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/stand__still__condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::StandStillCondition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/stand__still__condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STAND_STILL_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STAND_STILL_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/rule.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- StandStillCondition --------------------------------------------------------- * * <xsd:complexType name=\"StandStillCondition\"> * <xsd:attribute name=\"duration\" type=\"Double\" use=\"required\"/> * </xsd:complexType>* * * -------------------------------------------------------------------------- */ struct StandStillCondition { const Double duration ; const Rule compare ; const TriggeringEntities for_each ; template < typename Node > explicit StandStillCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & for_each ) : duration ( readAttribute < Double > ( \"duration\" , node , outer_scope )), compare ( Rule :: greaterThan ), for_each ( for_each ) {} auto evaluate () const { return asBoolean ( for_each ( [ & ]( auto && triggering_entity ) { return compare ( getStandStillDuration ( triggering_entity ), duration ); })); } }; } // namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STAND_STILL_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/story_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/story.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Story Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STORY_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STORY_HPP_ #include <openscenario_interpreter/syntax/act.hpp> #include <openscenario_interpreter/syntax/storyboard_element.hpp> #include <string> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ==== Story ================================================================ * * <xsd:complexType name=\"Story\"> * <xsd:sequence> * <xsd:element name=\"ParameterDeclarations\" type=\"ParameterDeclarations\" minOccurs=\"0\"/> * <xsd:element name=\"Act\" maxOccurs=\"unbounded\" type=\"Act\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Story : public StoryboardElement < Story > , public Elements { const String name ; Scope inner_scope ; template < typename Node > explicit Story ( const Node & node , Scope & outer_scope ) : name { readAttribute < String > ( \"name\" , node , outer_scope )}, inner_scope { outer_scope } { callWithElements ( node , \"ParameterDeclarations\" , 0 , 1 , [ & ]( auto && node ) { return make < ParameterDeclarations > ( node , inner_scope ); }); callWithElements ( node , \"Act\" , 1 , unbounded , [ & ]( auto && node ) { return push_back ( readStoryboardElement < Act > ( node , inner_scope )); }); } static constexpr auto ready () noexcept { return true ; } /* ------------------------------------------------------------------------- * * Story * A Story's goal is accomplished when all its Acts are in the * completeState. * * ---------------------------------------------------------------------- */ auto accomplished () const { return std :: all_of ( std :: begin ( * this ), std :: end ( * this ), []( auto && each ) { return each . template as < Act > (). complete (); }); } static constexpr auto stopTriggered () noexcept { return false ; } auto stop () { for ( auto && each : * this ) { each . as < Act > (). override (); each . evaluate (); } } using StoryboardElement :: evaluate ; void run () { for ( auto && act : * this ) { act . evaluate (); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STORY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/story.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/story_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxstoryhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/story.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/story_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/story_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Story","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/story_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STORY_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STORY_HPP_ #include <openscenario_interpreter/syntax/act.hpp> #include <openscenario_interpreter/syntax/storyboard_element.hpp> #include <string> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ==== Story ================================================================ * * <xsd:complexType name=\"Story\"> * <xsd:sequence> * <xsd:element name=\"ParameterDeclarations\" type=\"ParameterDeclarations\" minOccurs=\"0\"/> * <xsd:element name=\"Act\" maxOccurs=\"unbounded\" type=\"Act\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct Story : public StoryboardElement < Story > , public Elements { const String name ; Scope inner_scope ; template < typename Node > explicit Story ( const Node & node , Scope & outer_scope ) : name { readAttribute < String > ( \"name\" , node , outer_scope )}, inner_scope { outer_scope } { callWithElements ( node , \"ParameterDeclarations\" , 0 , 1 , [ & ]( auto && node ) { return make < ParameterDeclarations > ( node , inner_scope ); }); callWithElements ( node , \"Act\" , 1 , unbounded , [ & ]( auto && node ) { return push_back ( readStoryboardElement < Act > ( node , inner_scope )); }); } static constexpr auto ready () noexcept { return true ; } /* ------------------------------------------------------------------------- * * Story * A Story's goal is accomplished when all its Acts are in the * completeState. * * ---------------------------------------------------------------------- */ auto accomplished () const { return std :: all_of ( std :: begin ( * this ), std :: end ( * this ), []( auto && each ) { return each . template as < Act > (). complete (); }); } static constexpr auto stopTriggered () noexcept { return false ; } auto stop () { for ( auto && each : * this ) { each . as < Act > (). override (); each . evaluate (); } } using StoryboardElement :: evaluate ; void run () { for ( auto && act : * this ) { act . evaluate (); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STORY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Storyboard Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/init.hpp> #include <openscenario_interpreter/syntax/story.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Storyboard =========================================================== * * <xsd:complexType name=\"Storyboard\"> * <xsd:sequence> * <xsd:element name=\"Init\" type=\"Init\"/> * <xsd:element name=\"Story\" maxOccurs=\"unbounded\" type=\"Story\"/> * <xsd:element name=\"StopTrigger\" type=\"Trigger\"/> * </xsd:sequence> * </xsd:complexType> * * ======================================================================== */ struct Storyboard : public StoryboardElement < Storyboard > , public Elements { Scope inner_scope ; Init init ; Trigger stop_trigger ; const String name { // XXX DIRTY HACK!!! \"Storyboard\" }; template < typename Node , typename Scope > explicit Storyboard ( const Node & node , Scope & outer_scope ) : inner_scope ( outer_scope ), init ( readElement < Init > ( \"Init\" , node , inner_scope )), stop_trigger ( readElement < Trigger > ( \"StopTrigger\" , node , inner_scope )) { callWithElements ( node , \"Story\" , 1 , unbounded , [ & ]( auto && node ) { return push_back ( readStoryboardElement < Story > ( node , inner_scope )); }); } const std :: true_type ready {}; void start () { for ( const auto & each : inner_scope . entities ) { std :: get < 1 > ( each ). evaluate (); } init . evaluate (); // NOTE RENAME TO 'start'? } decltype ( auto ) stopTriggered () { return stop_trigger . evaluate (). as < Boolean > (); } void stop () { for ( auto && each : * this ) { each . as < Story > (). override (); each . evaluate (); } } auto accomplished () const { auto check = []( auto && each ) { return each . template as < Story > (). complete (); }; return std :: all_of ( std :: begin ( * this ), std :: end ( * this ), check ); } auto run () { for ( auto && story : * this ) { story . evaluate (); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxstoryboardhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Storyboard","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/init.hpp> #include <openscenario_interpreter/syntax/story.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== Storyboard =========================================================== * * <xsd:complexType name=\"Storyboard\"> * <xsd:sequence> * <xsd:element name=\"Init\" type=\"Init\"/> * <xsd:element name=\"Story\" maxOccurs=\"unbounded\" type=\"Story\"/> * <xsd:element name=\"StopTrigger\" type=\"Trigger\"/> * </xsd:sequence> * </xsd:complexType> * * ======================================================================== */ struct Storyboard : public StoryboardElement < Storyboard > , public Elements { Scope inner_scope ; Init init ; Trigger stop_trigger ; const String name { // XXX DIRTY HACK!!! \"Storyboard\" }; template < typename Node , typename Scope > explicit Storyboard ( const Node & node , Scope & outer_scope ) : inner_scope ( outer_scope ), init ( readElement < Init > ( \"Init\" , node , inner_scope )), stop_trigger ( readElement < Trigger > ( \"StopTrigger\" , node , inner_scope )) { callWithElements ( node , \"Story\" , 1 , unbounded , [ & ]( auto && node ) { return push_back ( readStoryboardElement < Story > ( node , inner_scope )); }); } const std :: true_type ready {}; void start () { for ( const auto & each : inner_scope . entities ) { std :: get < 1 > ( each ). evaluate (); } init . evaluate (); // NOTE RENAME TO 'start'? } decltype ( auto ) stopTriggered () { return stop_trigger . evaluate (). as < Boolean > (); } void stop () { for ( auto && each : * this ) { each . as < Story > (). override (); each . evaluate (); } } auto accomplished () const { auto check = []( auto && each ) { return each . template as < Story > (). complete (); }; return std :: all_of ( std :: begin ( * this ), std :: end ( * this ), check ); } auto run () { for ( auto && story : * this ) { story . evaluate (); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name class openscenario_interpreter::syntax::StoryboardElement Defines # Name DEFINE_PERFECT_FORWARD (IDENTIFIER, CONST) BOILERPLATE (NAME, STATE) Macro Documentation # define DEFINE_PERFECT_FORWARD # #define DEFINE_PERFECT_FORWARD( IDENTIFIER , CONST ) template < typename ... Ts > \\ constexpr decltype ( auto ) IDENTIFIER ( Ts && ... xs ) CONST \\ { \\ return static_cast < CONST T &> ( * this ). IDENTIFIER ( std :: forward < decltype ( xs ) > ( xs )...); \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( NAME , STATE ) constexpr auto NAME () const noexcept \\ { \\ return state (). template as < StoryboardElementState > () == StoryboardElementState :: STATE ; \\ } static_assert ( true , \"\" ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_HPP_ #include <boost/mpl/and.hpp> #include <boost/scope_exit.hpp> #include <openscenario_interpreter/syntax/storyboard_element_state.hpp> #include <string> #include <type_traits> #include <unordered_set> #include <utility> namespace openscenario_interpreter { inline namespace syntax { template < typename T > class StoryboardElement { public : const std :: size_t maximum_execution_count ; std :: size_t current_execution_count ; Element current_state ; explicit constexpr StoryboardElement ( std :: size_t maximum_execution_count = 1 ) : maximum_execution_count ( maximum_execution_count ), current_execution_count ( 0 ), current_state ( standby_state ) {} const auto & state () const { return current_state ; } #define BOILERPLATE(NAME, STATE) \\ constexpr auto NAME() const noexcept \\ { \\ return state().template as<StoryboardElementState>() == StoryboardElementState::STATE; \\ } static_assert(true, \"\") BOILERPLATE ( standby , standbyState ); BOILERPLATE ( starting , startTransition ); BOILERPLATE ( running , runningState ); BOILERPLATE ( ending , endTransition ); BOILERPLATE ( complete , completeState ); BOILERPLATE ( stopping , stopTransition ); BOILERPLATE ( skipping , skipTransition ); #undef BOILERPLATE template < typename Boolean , REQUIRES ( std :: is_convertible < Boolean , bool > ) > auto changeStateIf ( Boolean && test , const Element & consequent_state , const Element & alternate_state ) { if ( test ) { #ifndef NDEBUG std :: cout << indent ; std :: cout << typeid ( T ). name (); std :: cout << \"::evaluate [\" << current_state << \" => \" << consequent_state << \"]\" ; std :: cout << std :: endl ; #endif return current_state = consequent_state ; } else { return current_state = alternate_state ; } } template < typename Boolean , REQUIRES ( std :: is_convertible < Boolean , bool > ) > decltype ( auto ) changeStateIf ( Boolean && test , const Element & consequent_state ) { return changeStateIf ( test , consequent_state , current_state ); } template < typename Predicate , typename ... Ts , REQUIRES ( std :: is_function < Predicate > ) > decltype ( auto ) changeStateIf ( Predicate && predicate , Ts && ... xs ) { return changeStateIf ( predicate (), std :: forward < decltype ( xs ) > ( xs )...); } Element override () { #ifndef NDEBUG std :: cout << state () << std :: endl ; #endif if ( ! complete () && ! stopping ()) { return current_state = stop_transition ; } else { return current_state ; } } private : static constexpr void start () noexcept {} #define DEFINE_PERFECT_FORWARD(IDENTIFIER, CONST) \\ template<typename ... Ts> \\ constexpr decltype(auto) IDENTIFIER(Ts && ... xs) CONST \\ { \\ return static_cast<CONST T &>(*this).IDENTIFIER(std::forward<decltype(xs)>(xs)...); \\ } static_assert(true, \"\") DEFINE_PERFECT_FORWARD ( accomplished , const ); DEFINE_PERFECT_FORWARD ( ready , ); DEFINE_PERFECT_FORWARD ( run , ); DEFINE_PERFECT_FORWARD ( stop , ); DEFINE_PERFECT_FORWARD ( stopTriggered , ); #undef DEFINE_PERFECT_FORWARD protected : auto rename ( const std :: string & name ) const { static std :: size_t id = 0 ; return name . empty () ? std :: string ( \"annonymous-\" ) + std :: to_string ( ++ id ) : name ; } std :: unordered_set < std :: string > names ; auto unique ( const std :: string & name ) { return cdr ( names . emplace ( name )); } template < typename U , typename Node , typename Scope , typename ... Ts > decltype ( auto ) readStoryboardElement ( const Node & node , Scope & inner_scope , Ts && ... xs ) { const auto name = rename ( readAttribute < String > ( \"name\" , node , inner_scope )); if ( unique ( name )) { return inner_scope . storyboard_elements [ name ] = make < U > ( node , inner_scope , std :: forward < decltype ( xs ) > ( xs )...); } else { std :: stringstream ss {}; ss << \"detected redefinition of StoryboardElement named \\' \" << name << \" \\' \" ; ss << \"(class \" << typeid ( U ). name () << \")\" ; throw SyntaxError ( ss . str ()); } } public : /* ---- States and Transitions of StoryboardElements ------------------------- * * See https://releases.asam.net/OpenSCENARIO/1.0.0/ASAM_OpenSCENARIO_BS-1-2_User-Guide_V1-0-0.html#_states_and_transitions_of_storyboardelements * * ------------------------------------------------------------------------ */ auto evaluate () { if ( stopTriggered ()) { override (); } #ifndef NDEBUG std :: cout << ( indent ++ ); std :: cout << \"- evaluate: \\x1b [36m\" ; std :: cout << std :: quoted ( static_cast < const T &> ( * this ). name ); std :: cout << \" \\x1b [0m\" ; std :: cout << \" [\" << current_state << \"] \" ; std :: cout << std :: endl ; #endif BOOST_SCOPE_EXIT_ALL () { -- indent ; }; switch ( state (). template as < StoryboardElementState > ( __FILE__ , __LINE__ )) { /* ---- StandBy ---------------------------------------------------------- * * This is the default initialization state of a StoryboardElement. When * it is in this state, the runtime instantiation of the * StoryboardElement is ready to execute once given a startTrigger. A * runtime instantiation of any StoryboardElement is created once its * parent element is in the standbyState. From the standbyState, the * Story element instantaneously transitions into the runningState. * * -------------------------------------------------------------------- */ case StoryboardElementState :: standbyState : return changeStateIf ( ready (), start_transition ); /* ---- Start ------------------------------------------------------------ * * The startTransition symbolizes that the execution of the runtime * instantiation is now starting. The startTransition can be used in * conditions to trigger based on this transition. * * -------------------------------------------------------------------- */ case StoryboardElementState :: startTransition : static_cast < T &> ( * this ). start (); // NOTE: DON'T USE MACRO DEFINE_PERFECT_FORWARD FOR THIS! ++ current_execution_count ; return changeStateIf ( std :: true_type (), running_state ); /* ---- Running ---------------------------------------------------------- * * The runningState symbolizes that the execution of the runtime * instantiation is now ongoing and has not yet accomplished its goal. * * The concept of accomplishing a goal varies depending on the type of * StoryboardElement under consideration: * * Action * An Action's goal is a function of the Action type and cannot be * generalized. Accomplishing an Action's goal will involve meeting * some arbitrary prerequisites related with the Action type (for * example, a SpeedAction accomplishes its goal when the considered * Entity is travelling at the prescribed speed). If an Action is * acting on an EntitySelection, all instances of Entity within the * selection have to complete in order to reach the completeState of * the Action. * * Event * An Event's goal is accomplished when all its Actions are in the * completeState. * * Maneuver * A Maneuver's goal is accomplished when all its Events are in the * completeState. * * ManeuverGroup * A ManeuverGroup's goal is accomplished when all its Maneuvers are in * the completeState. * * Act * An Act's goal is accomplished when all its ManeuverGroups are in the * completeState. * * Story * A Story's goal is accomplished when all its Acts are in the * completeState. * * -------------------------------------------------------------------- */ case StoryboardElementState :: runningState : run (); return changeStateIf ( accomplished (), end_transition ); /* ---- End -------------------------------------------------------------- * * The endTransition occurs when the runtime instantiation of the * StoryboardElement accomplishes its goal. Once the endTransition occurs, * a check for completeness is made. A positive outcome moves the state * machine to the completeState, whereas a negative outcome moves the * state machine to the standbyState. The endTransition can be used in * conditions to trigger based on this transition. * * -------------------------------------------------------------------- */ case StoryboardElementState :: endTransition : return changeStateIf ( current_execution_count < maximum_execution_count , standby_state , complete_state ); /* ---- Complete --------------------------------------------------------- * * The completeState signals that the runtime instantiation of the * StoryboardElement cannot reach a running state without external * interference. If the affected runtime instantiation of the * StoryboardElement is defined with a maximumExecutionCount, to be * complete implies that there are no more executions left to run, or a * stopTransition has occurred. * * Checking for completeness involves verifying if the given runtime * instantiation of the StoryboardElement still has executions left upon * finishing the runningState. This check returns false if there are * executions left. This check returns true if there are no executions * left, or if the maximumExecutionCount is not defined in the * StoryboardElement. * * Resetting the completeState can only be achieved externally by the * parent StoryboardElement whose child is in the completeState. This may * only occur if the parent initiates a new execution. * * -------------------------------------------------------------------- */ case StoryboardElementState :: completeState : return current_state ; /* ---- Skip ------------------------------------------------------------- * * Transition marking the moment an element is asked to move to the * runningState but is instead skipped so it remains in the standbyState * (only for Event instances). The skipTransition can be used in * conditions to trigger based on this transition. * * -------------------------------------------------------------------- */ case StoryboardElementState :: skipTransition : return current_state ; /* ---- Stop ------------------------------------------------------------- * * The stopTransition marks the reception of a stopTrigger or the * storyboard element is overridden (applicable for Event and Action). * This implies that the stopTransition cannot be reached other than with * an external intervention to the runtime instantiation of the * StoryboardElement. * * When a runtime instantiation of a StoryboardElement goes through a * stopTransition, all of its child elements are also forced to go * through the same transition. The stopTransition can be used in * conditions to trigger based on this transition. * * -------------------------------------------------------------------- */ default : case StoryboardElementState :: stopTransition : if ( ! accomplished ()) { stop (); return current_state ; } else { #ifndef NDEBUG std :: cout << indent ; std :: cout << typeid ( T ). name (); std :: cout << \"::stop [\" << current_state << \" => \" << complete_state << \"]\" ; std :: cout << std :: endl ; #endif return current_state = complete_state ; } } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxstoryboard_elementhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element_8hpp/#classes","text":"Name class openscenario_interpreter::syntax::StoryboardElement","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element_8hpp/#defines","text":"Name DEFINE_PERFECT_FORWARD (IDENTIFIER, CONST) BOILERPLATE (NAME, STATE)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element_8hpp/#define-define_perfect_forward","text":"#define DEFINE_PERFECT_FORWARD( IDENTIFIER , CONST ) template < typename ... Ts > \\ constexpr decltype ( auto ) IDENTIFIER ( Ts && ... xs ) CONST \\ { \\ return static_cast < CONST T &> ( * this ). IDENTIFIER ( std :: forward < decltype ( xs ) > ( xs )...); \\ } static_assert ( true , \"\" )","title":"define DEFINE_PERFECT_FORWARD"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element_8hpp/#define-boilerplate","text":"#define BOILERPLATE( NAME , STATE ) constexpr auto NAME () const noexcept \\ { \\ return state (). template as < StoryboardElementState > () == StoryboardElementState :: STATE ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_HPP_ #include <boost/mpl/and.hpp> #include <boost/scope_exit.hpp> #include <openscenario_interpreter/syntax/storyboard_element_state.hpp> #include <string> #include <type_traits> #include <unordered_set> #include <utility> namespace openscenario_interpreter { inline namespace syntax { template < typename T > class StoryboardElement { public : const std :: size_t maximum_execution_count ; std :: size_t current_execution_count ; Element current_state ; explicit constexpr StoryboardElement ( std :: size_t maximum_execution_count = 1 ) : maximum_execution_count ( maximum_execution_count ), current_execution_count ( 0 ), current_state ( standby_state ) {} const auto & state () const { return current_state ; } #define BOILERPLATE(NAME, STATE) \\ constexpr auto NAME() const noexcept \\ { \\ return state().template as<StoryboardElementState>() == StoryboardElementState::STATE; \\ } static_assert(true, \"\") BOILERPLATE ( standby , standbyState ); BOILERPLATE ( starting , startTransition ); BOILERPLATE ( running , runningState ); BOILERPLATE ( ending , endTransition ); BOILERPLATE ( complete , completeState ); BOILERPLATE ( stopping , stopTransition ); BOILERPLATE ( skipping , skipTransition ); #undef BOILERPLATE template < typename Boolean , REQUIRES ( std :: is_convertible < Boolean , bool > ) > auto changeStateIf ( Boolean && test , const Element & consequent_state , const Element & alternate_state ) { if ( test ) { #ifndef NDEBUG std :: cout << indent ; std :: cout << typeid ( T ). name (); std :: cout << \"::evaluate [\" << current_state << \" => \" << consequent_state << \"]\" ; std :: cout << std :: endl ; #endif return current_state = consequent_state ; } else { return current_state = alternate_state ; } } template < typename Boolean , REQUIRES ( std :: is_convertible < Boolean , bool > ) > decltype ( auto ) changeStateIf ( Boolean && test , const Element & consequent_state ) { return changeStateIf ( test , consequent_state , current_state ); } template < typename Predicate , typename ... Ts , REQUIRES ( std :: is_function < Predicate > ) > decltype ( auto ) changeStateIf ( Predicate && predicate , Ts && ... xs ) { return changeStateIf ( predicate (), std :: forward < decltype ( xs ) > ( xs )...); } Element override () { #ifndef NDEBUG std :: cout << state () << std :: endl ; #endif if ( ! complete () && ! stopping ()) { return current_state = stop_transition ; } else { return current_state ; } } private : static constexpr void start () noexcept {} #define DEFINE_PERFECT_FORWARD(IDENTIFIER, CONST) \\ template<typename ... Ts> \\ constexpr decltype(auto) IDENTIFIER(Ts && ... xs) CONST \\ { \\ return static_cast<CONST T &>(*this).IDENTIFIER(std::forward<decltype(xs)>(xs)...); \\ } static_assert(true, \"\") DEFINE_PERFECT_FORWARD ( accomplished , const ); DEFINE_PERFECT_FORWARD ( ready , ); DEFINE_PERFECT_FORWARD ( run , ); DEFINE_PERFECT_FORWARD ( stop , ); DEFINE_PERFECT_FORWARD ( stopTriggered , ); #undef DEFINE_PERFECT_FORWARD protected : auto rename ( const std :: string & name ) const { static std :: size_t id = 0 ; return name . empty () ? std :: string ( \"annonymous-\" ) + std :: to_string ( ++ id ) : name ; } std :: unordered_set < std :: string > names ; auto unique ( const std :: string & name ) { return cdr ( names . emplace ( name )); } template < typename U , typename Node , typename Scope , typename ... Ts > decltype ( auto ) readStoryboardElement ( const Node & node , Scope & inner_scope , Ts && ... xs ) { const auto name = rename ( readAttribute < String > ( \"name\" , node , inner_scope )); if ( unique ( name )) { return inner_scope . storyboard_elements [ name ] = make < U > ( node , inner_scope , std :: forward < decltype ( xs ) > ( xs )...); } else { std :: stringstream ss {}; ss << \"detected redefinition of StoryboardElement named \\' \" << name << \" \\' \" ; ss << \"(class \" << typeid ( U ). name () << \")\" ; throw SyntaxError ( ss . str ()); } } public : /* ---- States and Transitions of StoryboardElements ------------------------- * * See https://releases.asam.net/OpenSCENARIO/1.0.0/ASAM_OpenSCENARIO_BS-1-2_User-Guide_V1-0-0.html#_states_and_transitions_of_storyboardelements * * ------------------------------------------------------------------------ */ auto evaluate () { if ( stopTriggered ()) { override (); } #ifndef NDEBUG std :: cout << ( indent ++ ); std :: cout << \"- evaluate: \\x1b [36m\" ; std :: cout << std :: quoted ( static_cast < const T &> ( * this ). name ); std :: cout << \" \\x1b [0m\" ; std :: cout << \" [\" << current_state << \"] \" ; std :: cout << std :: endl ; #endif BOOST_SCOPE_EXIT_ALL () { -- indent ; }; switch ( state (). template as < StoryboardElementState > ( __FILE__ , __LINE__ )) { /* ---- StandBy ---------------------------------------------------------- * * This is the default initialization state of a StoryboardElement. When * it is in this state, the runtime instantiation of the * StoryboardElement is ready to execute once given a startTrigger. A * runtime instantiation of any StoryboardElement is created once its * parent element is in the standbyState. From the standbyState, the * Story element instantaneously transitions into the runningState. * * -------------------------------------------------------------------- */ case StoryboardElementState :: standbyState : return changeStateIf ( ready (), start_transition ); /* ---- Start ------------------------------------------------------------ * * The startTransition symbolizes that the execution of the runtime * instantiation is now starting. The startTransition can be used in * conditions to trigger based on this transition. * * -------------------------------------------------------------------- */ case StoryboardElementState :: startTransition : static_cast < T &> ( * this ). start (); // NOTE: DON'T USE MACRO DEFINE_PERFECT_FORWARD FOR THIS! ++ current_execution_count ; return changeStateIf ( std :: true_type (), running_state ); /* ---- Running ---------------------------------------------------------- * * The runningState symbolizes that the execution of the runtime * instantiation is now ongoing and has not yet accomplished its goal. * * The concept of accomplishing a goal varies depending on the type of * StoryboardElement under consideration: * * Action * An Action's goal is a function of the Action type and cannot be * generalized. Accomplishing an Action's goal will involve meeting * some arbitrary prerequisites related with the Action type (for * example, a SpeedAction accomplishes its goal when the considered * Entity is travelling at the prescribed speed). If an Action is * acting on an EntitySelection, all instances of Entity within the * selection have to complete in order to reach the completeState of * the Action. * * Event * An Event's goal is accomplished when all its Actions are in the * completeState. * * Maneuver * A Maneuver's goal is accomplished when all its Events are in the * completeState. * * ManeuverGroup * A ManeuverGroup's goal is accomplished when all its Maneuvers are in * the completeState. * * Act * An Act's goal is accomplished when all its ManeuverGroups are in the * completeState. * * Story * A Story's goal is accomplished when all its Acts are in the * completeState. * * -------------------------------------------------------------------- */ case StoryboardElementState :: runningState : run (); return changeStateIf ( accomplished (), end_transition ); /* ---- End -------------------------------------------------------------- * * The endTransition occurs when the runtime instantiation of the * StoryboardElement accomplishes its goal. Once the endTransition occurs, * a check for completeness is made. A positive outcome moves the state * machine to the completeState, whereas a negative outcome moves the * state machine to the standbyState. The endTransition can be used in * conditions to trigger based on this transition. * * -------------------------------------------------------------------- */ case StoryboardElementState :: endTransition : return changeStateIf ( current_execution_count < maximum_execution_count , standby_state , complete_state ); /* ---- Complete --------------------------------------------------------- * * The completeState signals that the runtime instantiation of the * StoryboardElement cannot reach a running state without external * interference. If the affected runtime instantiation of the * StoryboardElement is defined with a maximumExecutionCount, to be * complete implies that there are no more executions left to run, or a * stopTransition has occurred. * * Checking for completeness involves verifying if the given runtime * instantiation of the StoryboardElement still has executions left upon * finishing the runningState. This check returns false if there are * executions left. This check returns true if there are no executions * left, or if the maximumExecutionCount is not defined in the * StoryboardElement. * * Resetting the completeState can only be achieved externally by the * parent StoryboardElement whose child is in the completeState. This may * only occur if the parent initiates a new execution. * * -------------------------------------------------------------------- */ case StoryboardElementState :: completeState : return current_state ; /* ---- Skip ------------------------------------------------------------- * * Transition marking the moment an element is asked to move to the * runningState but is instead skipped so it remains in the standbyState * (only for Event instances). The skipTransition can be used in * conditions to trigger based on this transition. * * -------------------------------------------------------------------- */ case StoryboardElementState :: skipTransition : return current_state ; /* ---- Stop ------------------------------------------------------------- * * The stopTransition marks the reception of a stopTrigger or the * storyboard element is overridden (applicable for Event and Action). * This implies that the stopTransition cannot be reached other than with * an external intervention to the runtime instantiation of the * StoryboardElement. * * When a runtime instantiation of a StoryboardElement goes through a * stopTransition, all of its child elements are also forced to go * through the same transition. The stopTransition can be used in * conditions to trigger based on this transition. * * -------------------------------------------------------------------- */ default : case StoryboardElementState :: stopTransition : if ( ! accomplished ()) { stop (); return current_state ; } else { #ifndef NDEBUG std :: cout << indent ; std :: cout << typeid ( T ). name (); std :: cout << \"::stop [\" << current_state << \" => \" << complete_state << \"]\" ; std :: cout << std :: endl ; #endif return current_state = complete_state ; } } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__state_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_state.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::StoryboardElementState Defines # Name BOILERPLATE (IDENTIFIER) BOILERPLATE (ID) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ state . value = StoryboardElementState :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( ID ) case StoryboardElementState :: ID : return os << # ID ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_STATE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_STATE_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ---- StoryboardElementState ------------------------------------------------- * * <xsd:simpleType name=\"StoryboardElementState\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"startTransition\"/> * <xsd:enumeration value=\"endTransition\"/> * <xsd:enumeration value=\"stopTransition\"/> * <xsd:enumeration value=\"skipTransition\"/> * <xsd:enumeration value=\"completeState\"/> * <xsd:enumeration value=\"runningState\"/> * <xsd:enumeration value=\"standbyState\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * -------------------------------------------------------------------------- */ struct StoryboardElementState { enum value_type { /* ---- StandBy ---------------------------------------------------------- * * This is the default initialization state of a StoryboardElement. When * it is in this state, the runtime instantiation of the StoryboardElement * is ready to execute once given a startTrigger. A runtime instantiation * of any StoryboardElement is created once its parent element is in the * standbyState. From the standbyState, the Story element instantaneously * transitions into the runningState. * * -------------------------------------------------------------------- */ standbyState , /* ---- Running ---------------------------------------------------------- * * The runningState symbolizes that the execution of the runtime * instantiation is now ongoing and has not yet accomplished its goal. * * The concept of accomplishing a goal varies depending on the type of * StoryboardElement under consideration: * * Action * An Action's goal is a function of the Action type and cannot be * generalized. Accomplishing an Action's goal will involve meeting some * arbitrary prerequisites related with the Action type (for example, a * SpeedAction accomplishes its goal when the considered Entity is * travelling at the prescribed speed). If an Action is acting on an * EntitySelection, all instances of Entity within the selection have to * complete in order to reach the completeState of the Action. * * Event * An Event's goal is accomplished when all its Actions are in the * completeState. * * Maneuver * A Maneuver's goal is accomplished when all its Events are in the * completeState. * * ManeuverGroup * A ManeuverGroup's goal is accomplished when all its Maneuvers are in * the completeState. * * Act * An Act's goal is accomplished when all its ManeuverGroups are in the * completeState. * * Story * A Story's goal is accomplished when all its Acts are in the * completeState. * * -------------------------------------------------------------------- */ runningState , /* ---- Complete --------------------------------------------------------- * * The completeState signals that the runtime instantiation of the * StoryboardElement cannot reach a running state without external * interference. If the affected runtime instantiation of the * StoryboardElement is defined with a maximumExecutionCount, to be * complete implies that there are no more executions left to run, or a * stopTransition has occurred. * * Checking for completeness involves verifying if the given runtime * instantiation of the StoryboardElement still has executions left upon * finishing the runningState. This check returns false if there are * executions left. This check returns true if there are no executions * left, or if the maximumExecutionCount is not defined in the * StoryboardElement. * * Resetting the completeState can only be achieved externally by the * parent StoryboardElement whose child is in the completeState. This may * only occur if the parent initiates a new execution. * * -------------------------------------------------------------------- */ completeState , /* ---- Start ------------------------------------------------------------ * * The startTransition symbolizes that the execution of the runtime * instantiation is now starting. The startTransition can be used in * conditions to trigger based on this transition. * * -------------------------------------------------------------------- */ startTransition , /* ---- End -------------------------------------------------------------- * * The endTransition occurs when the runtime instantiation of the * StoryboardElement accomplishes its goal. Once the endTransition occurs, * a check for completeness is made. A positive outcome moves the state * machine to the completeState, whereas a negative outcome moves the * state machine to the standbyState. The endTransition can be used in * conditions to trigger based on this transition. * * -------------------------------------------------------------------- */ endTransition , /* ---- Stop ------------------------------------------------------------- * * The stopTransition marks the reception of a stopTrigger or the * storyboard element is overridden (applicable for Event and Action). * This implies that the stopTransition cannot be reached other than with * an external intervention to the runtime instantiation of the * StoryboardElement. * * When a runtime instantiation of a StoryboardElement goes through a * stopTransition, all of its child elements are also forced to go through * the same transition. The stopTransition can be used in conditions to * trigger based on this transition. * * -------------------------------------------------------------------- */ stopTransition , /* ---- Skip ------------------------------------------------------------- * * Transition marking the moment an element is asked to move to the * runningState but is instead skipped so it remains in the standbyState * (only for Event instances). The skipTransition can be used in * conditions to trigger based on this transition. * * -------------------------------------------------------------------- */ skipTransition , } value ; explicit constexpr StoryboardElementState ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , StoryboardElementState & state ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ state.value = StoryboardElementState::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( startTransition ); BOILERPLATE ( endTransition ); BOILERPLATE ( stopTransition ); BOILERPLATE ( skipTransition ); BOILERPLATE ( completeState ); BOILERPLATE ( runningState ); BOILERPLATE ( standbyState ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type StoryboardElementState\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const StoryboardElementState & state ) { switch ( state ) { #define BOILERPLATE(ID) case StoryboardElementState::ID: return os << #ID; BOILERPLATE ( startTransition ); BOILERPLATE ( endTransition ); BOILERPLATE ( stopTransition ); BOILERPLATE ( skipTransition ); BOILERPLATE ( completeState ); BOILERPLATE ( runningState ); BOILERPLATE ( standbyState ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class StoryboardElementState holds unexpected value \" << static_cast < StoryboardElementState :: value_type > ( state . value ); throw ImplementationFault { ss . str ()}; } } static const auto standby_state { make < StoryboardElementState > ( StoryboardElementState :: standbyState )}; static const auto running_state { make < StoryboardElementState > ( StoryboardElementState :: runningState )}; static const auto complete_state { make < StoryboardElementState > ( StoryboardElementState :: completeState )}; static const auto start_transition { make < StoryboardElementState > ( StoryboardElementState :: startTransition )}; static const auto end_transition { make < StoryboardElementState > ( StoryboardElementState :: endTransition )}; static const auto stop_transition { make < StoryboardElementState > ( StoryboardElementState :: stopTransition )}; static const auto skip_transition { make < StoryboardElementState > ( StoryboardElementState :: skipTransition )}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_STATE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_state.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__state_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxstoryboard_element_statehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_state.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__state_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__state_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::StoryboardElementState","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__state_8hpp/#defines","text":"Name BOILERPLATE (IDENTIFIER) BOILERPLATE (ID)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__state_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__state_8hpp/#define-boilerplate","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ state . value = StoryboardElementState :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__state_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( ID ) case StoryboardElementState :: ID : return os << # ID ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__state_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_STATE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_STATE_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ---- StoryboardElementState ------------------------------------------------- * * <xsd:simpleType name=\"StoryboardElementState\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"startTransition\"/> * <xsd:enumeration value=\"endTransition\"/> * <xsd:enumeration value=\"stopTransition\"/> * <xsd:enumeration value=\"skipTransition\"/> * <xsd:enumeration value=\"completeState\"/> * <xsd:enumeration value=\"runningState\"/> * <xsd:enumeration value=\"standbyState\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * -------------------------------------------------------------------------- */ struct StoryboardElementState { enum value_type { /* ---- StandBy ---------------------------------------------------------- * * This is the default initialization state of a StoryboardElement. When * it is in this state, the runtime instantiation of the StoryboardElement * is ready to execute once given a startTrigger. A runtime instantiation * of any StoryboardElement is created once its parent element is in the * standbyState. From the standbyState, the Story element instantaneously * transitions into the runningState. * * -------------------------------------------------------------------- */ standbyState , /* ---- Running ---------------------------------------------------------- * * The runningState symbolizes that the execution of the runtime * instantiation is now ongoing and has not yet accomplished its goal. * * The concept of accomplishing a goal varies depending on the type of * StoryboardElement under consideration: * * Action * An Action's goal is a function of the Action type and cannot be * generalized. Accomplishing an Action's goal will involve meeting some * arbitrary prerequisites related with the Action type (for example, a * SpeedAction accomplishes its goal when the considered Entity is * travelling at the prescribed speed). If an Action is acting on an * EntitySelection, all instances of Entity within the selection have to * complete in order to reach the completeState of the Action. * * Event * An Event's goal is accomplished when all its Actions are in the * completeState. * * Maneuver * A Maneuver's goal is accomplished when all its Events are in the * completeState. * * ManeuverGroup * A ManeuverGroup's goal is accomplished when all its Maneuvers are in * the completeState. * * Act * An Act's goal is accomplished when all its ManeuverGroups are in the * completeState. * * Story * A Story's goal is accomplished when all its Acts are in the * completeState. * * -------------------------------------------------------------------- */ runningState , /* ---- Complete --------------------------------------------------------- * * The completeState signals that the runtime instantiation of the * StoryboardElement cannot reach a running state without external * interference. If the affected runtime instantiation of the * StoryboardElement is defined with a maximumExecutionCount, to be * complete implies that there are no more executions left to run, or a * stopTransition has occurred. * * Checking for completeness involves verifying if the given runtime * instantiation of the StoryboardElement still has executions left upon * finishing the runningState. This check returns false if there are * executions left. This check returns true if there are no executions * left, or if the maximumExecutionCount is not defined in the * StoryboardElement. * * Resetting the completeState can only be achieved externally by the * parent StoryboardElement whose child is in the completeState. This may * only occur if the parent initiates a new execution. * * -------------------------------------------------------------------- */ completeState , /* ---- Start ------------------------------------------------------------ * * The startTransition symbolizes that the execution of the runtime * instantiation is now starting. The startTransition can be used in * conditions to trigger based on this transition. * * -------------------------------------------------------------------- */ startTransition , /* ---- End -------------------------------------------------------------- * * The endTransition occurs when the runtime instantiation of the * StoryboardElement accomplishes its goal. Once the endTransition occurs, * a check for completeness is made. A positive outcome moves the state * machine to the completeState, whereas a negative outcome moves the * state machine to the standbyState. The endTransition can be used in * conditions to trigger based on this transition. * * -------------------------------------------------------------------- */ endTransition , /* ---- Stop ------------------------------------------------------------- * * The stopTransition marks the reception of a stopTrigger or the * storyboard element is overridden (applicable for Event and Action). * This implies that the stopTransition cannot be reached other than with * an external intervention to the runtime instantiation of the * StoryboardElement. * * When a runtime instantiation of a StoryboardElement goes through a * stopTransition, all of its child elements are also forced to go through * the same transition. The stopTransition can be used in conditions to * trigger based on this transition. * * -------------------------------------------------------------------- */ stopTransition , /* ---- Skip ------------------------------------------------------------- * * Transition marking the moment an element is asked to move to the * runningState but is instead skipped so it remains in the standbyState * (only for Event instances). The skipTransition can be used in * conditions to trigger based on this transition. * * -------------------------------------------------------------------- */ skipTransition , } value ; explicit constexpr StoryboardElementState ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , StoryboardElementState & state ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ state.value = StoryboardElementState::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( startTransition ); BOILERPLATE ( endTransition ); BOILERPLATE ( stopTransition ); BOILERPLATE ( skipTransition ); BOILERPLATE ( completeState ); BOILERPLATE ( runningState ); BOILERPLATE ( standbyState ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type StoryboardElementState\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const StoryboardElementState & state ) { switch ( state ) { #define BOILERPLATE(ID) case StoryboardElementState::ID: return os << #ID; BOILERPLATE ( startTransition ); BOILERPLATE ( endTransition ); BOILERPLATE ( stopTransition ); BOILERPLATE ( skipTransition ); BOILERPLATE ( completeState ); BOILERPLATE ( runningState ); BOILERPLATE ( standbyState ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class StoryboardElementState holds unexpected value \" << static_cast < StoryboardElementState :: value_type > ( state . value ); throw ImplementationFault { ss . str ()}; } } static const auto standby_state { make < StoryboardElementState > ( StoryboardElementState :: standbyState )}; static const auto running_state { make < StoryboardElementState > ( StoryboardElementState :: runningState )}; static const auto complete_state { make < StoryboardElementState > ( StoryboardElementState :: completeState )}; static const auto start_transition { make < StoryboardElementState > ( StoryboardElementState :: startTransition )}; static const auto end_transition { make < StoryboardElementState > ( StoryboardElementState :: endTransition )}; static const auto stop_transition { make < StoryboardElementState > ( StoryboardElementState :: stopTransition )}; static const auto skip_transition { make < StoryboardElementState > ( StoryboardElementState :: skipTransition )}; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_STATE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__state__condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_state_condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::StoryboardElementStateCondition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_STATE_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_STATE_CONDITION_HPP_ #include <openscenario_interpreter/syntax/storyboard_element_state.hpp> #include <openscenario_interpreter/syntax/storyboard_element_type.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== StoryboardElementStateCondition ======================================== * * <xsd:complexType name=\"StoryboardElementStateCondition\"> * <xsd:attribute name=\"storyboardElementType\" type=\"StoryboardElementType\" use=\"required\"/> * <xsd:attribute name=\"storyboardElementRef\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"state\" type=\"StoryboardElementState\" use=\"required\"/> * </xsd:complexType> * * ========================================================================== */ struct StoryboardElementStateCondition { const String name ; const StoryboardElementType type ; const StoryboardElementState state ; Scope inner_scope ; template < typename Node , typename Scope > explicit StoryboardElementStateCondition ( const Node & node , Scope & outer_scope ) : name ( readAttribute < String > ( \"storyboardElementRef\" , node , outer_scope )), type ( readAttribute < StoryboardElementType > ( \"storyboardElementType\" , node , outer_scope )), state ( readAttribute < StoryboardElementState > ( \"state\" , node , outer_scope )), inner_scope ( outer_scope ) {} auto compare ( const Element & lhs , StoryboardElementState rhs ) const { return asBoolean ( lhs . as < StoryboardElementState > () == rhs ); } auto evaluate () const { const auto result { compare ( inner_scope . storyboard_elements . at ( name ). state (), state )}; #ifndef NDEBUG std :: cout << indent << \"StoryboardElementState [Is \" << cyan << \" \\\" \" << name << \" \\\" \" << reset << \" in \" << state << \"? => \" << result << \"]\" << std :: endl ; #endif return result ; } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_STATE_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_state_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__state__condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxstoryboard_element_state_conditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_state_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__state__condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__state__condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::StoryboardElementStateCondition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__state__condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_STATE_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_STATE_CONDITION_HPP_ #include <openscenario_interpreter/syntax/storyboard_element_state.hpp> #include <openscenario_interpreter/syntax/storyboard_element_type.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== StoryboardElementStateCondition ======================================== * * <xsd:complexType name=\"StoryboardElementStateCondition\"> * <xsd:attribute name=\"storyboardElementType\" type=\"StoryboardElementType\" use=\"required\"/> * <xsd:attribute name=\"storyboardElementRef\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"state\" type=\"StoryboardElementState\" use=\"required\"/> * </xsd:complexType> * * ========================================================================== */ struct StoryboardElementStateCondition { const String name ; const StoryboardElementType type ; const StoryboardElementState state ; Scope inner_scope ; template < typename Node , typename Scope > explicit StoryboardElementStateCondition ( const Node & node , Scope & outer_scope ) : name ( readAttribute < String > ( \"storyboardElementRef\" , node , outer_scope )), type ( readAttribute < StoryboardElementType > ( \"storyboardElementType\" , node , outer_scope )), state ( readAttribute < StoryboardElementState > ( \"state\" , node , outer_scope )), inner_scope ( outer_scope ) {} auto compare ( const Element & lhs , StoryboardElementState rhs ) const { return asBoolean ( lhs . as < StoryboardElementState > () == rhs ); } auto evaluate () const { const auto result { compare ( inner_scope . storyboard_elements . at ( name ). state (), state )}; #ifndef NDEBUG std :: cout << indent << \"StoryboardElementState [Is \" << cyan << \" \\\" \" << name << \" \\\" \" << reset << \" in \" << state << \"? => \" << result << \"]\" << std :: endl ; #endif return result ; } }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_STATE_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__type_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_type.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::StoryboardElementType Defines # Name BOILERPLATE (IDENTIFIER) BOILERPLATE (ID) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ type . value = StoryboardElementType :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( ID ) case StoryboardElementType :: ID : return os << # ID ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_TYPE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_TYPE_HPP_ #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== StoryboardElementType ================================================== * * <xsd:simpleType name=\"StoryboardElementType\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"story\"/> * <xsd:enumeration value=\"act\"/> * <xsd:enumeration value=\"maneuver\"/> * <xsd:enumeration value=\"event\"/> * <xsd:enumeration value=\"action\"/> * <xsd:enumeration value=\"maneuverGroup\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ========================================================================== */ struct StoryboardElementType { enum value_type { act , action , event , maneuver , maneuverGroup , story , } value ; explicit constexpr StoryboardElementType ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , StoryboardElementType & type ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ type.value = StoryboardElementType::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( act ); BOILERPLATE ( action ); BOILERPLATE ( event ); BOILERPLATE ( maneuver ); BOILERPLATE ( maneuverGroup ); BOILERPLATE ( story ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type StoryboardElementType\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const StoryboardElementType & type ) { switch ( type ) { #define BOILERPLATE(ID) case StoryboardElementType::ID: return os << #ID; BOILERPLATE ( act ); BOILERPLATE ( action ); BOILERPLATE ( event ); BOILERPLATE ( maneuver ); BOILERPLATE ( maneuverGroup ); BOILERPLATE ( story ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class StoryboardElementType holds unexpected value \" << static_cast < StoryboardElementType :: value_type > ( type . value ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_TYPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_type.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__type_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxstoryboard_element_typehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/storyboard_element_type.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__type_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__type_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::StoryboardElementType","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__type_8hpp/#defines","text":"Name BOILERPLATE (IDENTIFIER) BOILERPLATE (ID)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__type_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__type_8hpp/#define-boilerplate","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ type . value = StoryboardElementType :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__type_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( ID ) case StoryboardElementType :: ID : return os << # ID ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/storyboard__element__type_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_TYPE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_TYPE_HPP_ #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== StoryboardElementType ================================================== * * <xsd:simpleType name=\"StoryboardElementType\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"story\"/> * <xsd:enumeration value=\"act\"/> * <xsd:enumeration value=\"maneuver\"/> * <xsd:enumeration value=\"event\"/> * <xsd:enumeration value=\"action\"/> * <xsd:enumeration value=\"maneuverGroup\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ========================================================================== */ struct StoryboardElementType { enum value_type { act , action , event , maneuver , maneuverGroup , story , } value ; explicit constexpr StoryboardElementType ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , StoryboardElementType & type ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ type.value = StoryboardElementType::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( act ); BOILERPLATE ( action ); BOILERPLATE ( event ); BOILERPLATE ( maneuver ); BOILERPLATE ( maneuverGroup ); BOILERPLATE ( story ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type StoryboardElementType\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const StoryboardElementType & type ) { switch ( type ) { #define BOILERPLATE(ID) case StoryboardElementType::ID: return os << #ID; BOILERPLATE ( act ); BOILERPLATE ( action ); BOILERPLATE ( event ); BOILERPLATE ( maneuver ); BOILERPLATE ( maneuverGroup ); BOILERPLATE ( story ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class StoryboardElementType holds unexpected value \" << static_cast < StoryboardElementType :: value_type > ( type . value ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STORYBOARD_ELEMENT_TYPE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/string_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/string.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STRING_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STRING_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== String =============================================================== * * TODO * * ======================================================================== */ using String = std :: string ; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STRING_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/string.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/string_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxstringhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/string.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/string_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/string_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__STRING_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__STRING_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== String =============================================================== * * TODO * * ======================================================================== */ using String = std :: string ; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__STRING_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/teleport__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/teleport_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::TeleportAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TELEPORT_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TELEPORT_ACTION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/position.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- TeleportAction --------------------------------------------------------- * * <xsd:complexType name=\"TeleportAction\"> * <xsd:sequence> * <xsd:element name=\"Position\" type=\"Position\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct TeleportAction { Scope inner_scope ; const Position position ; template < typename Node > explicit TeleportAction ( const Node & node , Scope & outer_scope ) : inner_scope ( outer_scope ), position ( readElement < Position > ( \"Position\" , node , inner_scope )) {} const std :: true_type accomplished {}; decltype ( auto ) operator ()( const WorldPosition & world_position , const Scope :: Actor & actor ) const { return setEntityStatus ( actor , static_cast < geometry_msgs :: msg :: Pose > ( world_position )); } decltype ( auto ) operator ()( const LanePosition & lane_position , const Scope :: Actor & actor ) const { return setEntityStatus ( actor , static_cast < openscenario_msgs :: msg :: LaneletPose > ( lane_position )); } decltype ( auto ) operator ()( const RelativeWorldPosition & relative_world_position , const Scope :: Actor & actor ) const { return setEntityStatus ( actor , relative_world_position . reference , // name relative_world_position , // geometry_msgs::msg::Point relative_world_position . orientation ); } void start () const { for ( const auto & actor : inner_scope . actors ) { apply ( * this , position , actor ); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TELEPORT_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/teleport_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/teleport__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxteleport_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/teleport_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/teleport__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/teleport__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::TeleportAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/teleport__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TELEPORT_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TELEPORT_ACTION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/position.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- TeleportAction --------------------------------------------------------- * * <xsd:complexType name=\"TeleportAction\"> * <xsd:sequence> * <xsd:element name=\"Position\" type=\"Position\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct TeleportAction { Scope inner_scope ; const Position position ; template < typename Node > explicit TeleportAction ( const Node & node , Scope & outer_scope ) : inner_scope ( outer_scope ), position ( readElement < Position > ( \"Position\" , node , inner_scope )) {} const std :: true_type accomplished {}; decltype ( auto ) operator ()( const WorldPosition & world_position , const Scope :: Actor & actor ) const { return setEntityStatus ( actor , static_cast < geometry_msgs :: msg :: Pose > ( world_position )); } decltype ( auto ) operator ()( const LanePosition & lane_position , const Scope :: Actor & actor ) const { return setEntityStatus ( actor , static_cast < openscenario_msgs :: msg :: LaneletPose > ( lane_position )); } decltype ( auto ) operator ()( const RelativeWorldPosition & relative_world_position , const Scope :: Actor & actor ) const { return setEntityStatus ( actor , relative_world_position . reference , // name relative_world_position , // geometry_msgs::msg::Point relative_world_position . orientation ); } void start () const { for ( const auto & actor : inner_scope . actors ) { apply ( * this , position , actor ); } } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TELEPORT_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/test__syntax_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/test/test_syntax.cpp # Functions # Name int main (int argc, char ** argv) TEST (syntax , dummy ) Functions Documentation # function main # int main ( int argc , char ** argv ) function TEST # TEST ( syntax , dummy ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <ament_index_cpp/get_package_share_directory.hpp> #include <gtest/gtest.h> #include <openscenario_interpreter/syntax/openscenario.hpp> #include <rclcpp/rclcpp.hpp> #include <chrono> #include <cstdlib> #include <memory> #include <thread> TEST ( syntax , dummy ) { ASSERT_TRUE ( true ); } // TEST(Syntax, LexicalScope) // { // using ament_index_cpp::get_package_share_directory; // // auto node { // std::make_shared<rclcpp::Node>(\"\", rclcpp::NodeOptions()) // }; // // openscenario_interpreter::OpenScenario interperter { // get_package_share_directory(\"openscenario_interpreter\") + \"/test/lexical-scope.xosc\", // node // }; // } // // TEST(Error, Success) // { // using ament_index_cpp::get_package_share_directory; // // auto node { // std::make_shared<rclcpp::Node>(\"\", rclcpp::NodeOptions()) // }; // // openscenario_interpreter::OpenScenario evaluate { // get_package_share_directory(\"openscenario_interpreter\") + \"/test/success.xosc\", // node // }; // // ASSERT_FALSE(evaluate.complete()); // // const auto begin {std::chrono::high_resolution_clock::now()}; // // using std::chrono_literals::operator\"\"ms; // // rclcpp::WallRate rate {50ms}; // // using openscenario_interpreter::complete_state; // // for (evaluate.init(); evaluate() != complete_state; rate.sleep()) { // ASSERT_LT( // std::chrono::duration_cast<std::chrono::seconds>( // std::chrono::high_resolution_clock::now() - begin).count(), // 20); // } // } // TEST(Syntax, invalid) // { // auto f = []() // { // openscenario_interpreter::OpenSCENARIO osc { XOSC(\"invalid-1.xosc\") }; // }; // // EXPECT_THROW({ f(); }, openscenario_interpreter::SyntaxError); // } // TEST(Syntax, scenarioDefinition) // { // using namespace openscenario_interpreter; // // OpenSCENARIO osc { XOSC(\"example.xosc\"), \"127.0.0.1\", 8080 }; // // // EXPECT_TRUE(osc.element(\"FileHeader\")); // // EXPECT_TRUE(osc.element(\"ParameterDeclarations\")); // // // EXPECT_EQ(osc[\"FileHeader\"].revMajor(), 1); // // EXPECT_TRUE(osc.catalog_locations); // // EXPECT_TRUE(osc.entities); // // EXPECT_TRUE(osc.parameter_declarations); // // EXPECT_TRUE(osc.road_network); // // EXPECT_TRUE(osc.storyboard); // // EXPECT_TRUE(osc.evaluate().is<Boolean>()); // } // TEST(Core, objectBinder) // { // using openscenario_interpreter::make; // // const auto hoge {make<Double>(3.14)}; // // const auto result {hoge.evaluate()}; // // EXPECT_TRUE(result.is<Double>()); // EXPECT_TRUE(result.as<Double>().data = 3.14); // } // TEST(Scenario, LaneChange) // { // using namespace openscenario_interpreter; // // OpenSCENARIO osc { XOSC(\"lane_change.xosc\"), \"127.0.0.1\", 8080 }; // } int main ( int argc , char ** argv ) { testing :: InitGoogleTest ( & argc , argv ); return RUN_ALL_TESTS (); } Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/test/test_syntax.cpp"},{"location":"package/openscenario_interpreter/markdown/Files/test__syntax_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpretertesttest_syntaxcpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/test/test_syntax.cpp"},{"location":"package/openscenario_interpreter/markdown/Files/test__syntax_8cpp/#functions","text":"Name int main (int argc, char ** argv) TEST (syntax , dummy )","title":"Functions"},{"location":"package/openscenario_interpreter/markdown/Files/test__syntax_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/test__syntax_8cpp/#function-main","text":"int main ( int argc , char ** argv )","title":"function main"},{"location":"package/openscenario_interpreter/markdown/Files/test__syntax_8cpp/#function-test","text":"TEST ( syntax , dummy )","title":"function TEST"},{"location":"package/openscenario_interpreter/markdown/Files/test__syntax_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <ament_index_cpp/get_package_share_directory.hpp> #include <gtest/gtest.h> #include <openscenario_interpreter/syntax/openscenario.hpp> #include <rclcpp/rclcpp.hpp> #include <chrono> #include <cstdlib> #include <memory> #include <thread> TEST ( syntax , dummy ) { ASSERT_TRUE ( true ); } // TEST(Syntax, LexicalScope) // { // using ament_index_cpp::get_package_share_directory; // // auto node { // std::make_shared<rclcpp::Node>(\"\", rclcpp::NodeOptions()) // }; // // openscenario_interpreter::OpenScenario interperter { // get_package_share_directory(\"openscenario_interpreter\") + \"/test/lexical-scope.xosc\", // node // }; // } // // TEST(Error, Success) // { // using ament_index_cpp::get_package_share_directory; // // auto node { // std::make_shared<rclcpp::Node>(\"\", rclcpp::NodeOptions()) // }; // // openscenario_interpreter::OpenScenario evaluate { // get_package_share_directory(\"openscenario_interpreter\") + \"/test/success.xosc\", // node // }; // // ASSERT_FALSE(evaluate.complete()); // // const auto begin {std::chrono::high_resolution_clock::now()}; // // using std::chrono_literals::operator\"\"ms; // // rclcpp::WallRate rate {50ms}; // // using openscenario_interpreter::complete_state; // // for (evaluate.init(); evaluate() != complete_state; rate.sleep()) { // ASSERT_LT( // std::chrono::duration_cast<std::chrono::seconds>( // std::chrono::high_resolution_clock::now() - begin).count(), // 20); // } // } // TEST(Syntax, invalid) // { // auto f = []() // { // openscenario_interpreter::OpenSCENARIO osc { XOSC(\"invalid-1.xosc\") }; // }; // // EXPECT_THROW({ f(); }, openscenario_interpreter::SyntaxError); // } // TEST(Syntax, scenarioDefinition) // { // using namespace openscenario_interpreter; // // OpenSCENARIO osc { XOSC(\"example.xosc\"), \"127.0.0.1\", 8080 }; // // // EXPECT_TRUE(osc.element(\"FileHeader\")); // // EXPECT_TRUE(osc.element(\"ParameterDeclarations\")); // // // EXPECT_EQ(osc[\"FileHeader\"].revMajor(), 1); // // EXPECT_TRUE(osc.catalog_locations); // // EXPECT_TRUE(osc.entities); // // EXPECT_TRUE(osc.parameter_declarations); // // EXPECT_TRUE(osc.road_network); // // EXPECT_TRUE(osc.storyboard); // // EXPECT_TRUE(osc.evaluate().is<Boolean>()); // } // TEST(Core, objectBinder) // { // using openscenario_interpreter::make; // // const auto hoge {make<Double>(3.14)}; // // const auto result {hoge.evaluate()}; // // EXPECT_TRUE(result.is<Double>()); // EXPECT_TRUE(result.as<Double>().data = 3.14); // } // TEST(Scenario, LaneChange) // { // using namespace openscenario_interpreter; // // OpenSCENARIO osc { XOSC(\"lane_change.xosc\"), \"127.0.0.1\", 8080 }; // } int main ( int argc , char ** argv ) { testing :: InitGoogleTest ( & argc , argv ); return RUN_ALL_TESTS (); } Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/time__headway__condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/time_headway_condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::TimeHeadwayCondition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TIME_HEADWAY_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TIME_HEADWAY_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/rule.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- TimeHeadwayCondition --------------------------------------------------- * * <xsd:complexType name=\"TimeHeadwayCondition\"> * <xsd:attribute name=\"entityRef\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"freespace\" type=\"Boolean\" use=\"required\"/> * <xsd:attribute name=\"alongRoute\" type=\"Boolean\" use=\"required\"/> * <xsd:attribute name=\"rule\" type=\"Rule\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct TimeHeadwayCondition { const String entity_ref ; const Double value ; const Boolean freespace ; const Boolean along_route ; const Rule compare ; const TriggeringEntities trigger ; template < typename Node > explicit TimeHeadwayCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & trigger ) : entity_ref ( /* */ readAttribute < String > /* */ ( \"entityRef\" , /* */ node , outer_scope )), value ( /* */ readAttribute < Double > /* */ ( \"value\" , /* */ node , outer_scope )), freespace ( /* */ readAttribute < Boolean > ( \"freespace\" , /* */ node , outer_scope )), along_route ( readAttribute < Boolean > ( \"alongRoute\" , node , outer_scope )), compare ( /* */ readAttribute < Rule > /* */ ( \"rule\" , /* */ node , outer_scope )), trigger ( trigger ) {} auto evaluate () { return asBoolean ( trigger ( [ & ]( auto && entity ) { return compare ( getTimeHeadway ( entity , entity_ref ), value ); })); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TIME_HEADWAY_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/time_headway_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/time__headway__condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxtime_headway_conditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/time_headway_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/time__headway__condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/time__headway__condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::TimeHeadwayCondition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/time__headway__condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TIME_HEADWAY_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TIME_HEADWAY_CONDITION_HPP_ #include <openscenario_interpreter/procedure.hpp> #include <openscenario_interpreter/syntax/rule.hpp> #include <openscenario_interpreter/syntax/triggering_entities.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- TimeHeadwayCondition --------------------------------------------------- * * <xsd:complexType name=\"TimeHeadwayCondition\"> * <xsd:attribute name=\"entityRef\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"freespace\" type=\"Boolean\" use=\"required\"/> * <xsd:attribute name=\"alongRoute\" type=\"Boolean\" use=\"required\"/> * <xsd:attribute name=\"rule\" type=\"Rule\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct TimeHeadwayCondition { const String entity_ref ; const Double value ; const Boolean freespace ; const Boolean along_route ; const Rule compare ; const TriggeringEntities trigger ; template < typename Node > explicit TimeHeadwayCondition ( const Node & node , Scope & outer_scope , const TriggeringEntities & trigger ) : entity_ref ( /* */ readAttribute < String > /* */ ( \"entityRef\" , /* */ node , outer_scope )), value ( /* */ readAttribute < Double > /* */ ( \"value\" , /* */ node , outer_scope )), freespace ( /* */ readAttribute < Boolean > ( \"freespace\" , /* */ node , outer_scope )), along_route ( readAttribute < Boolean > ( \"alongRoute\" , node , outer_scope )), compare ( /* */ readAttribute < Rule > /* */ ( \"rule\" , /* */ node , outer_scope )), trigger ( trigger ) {} auto evaluate () { return asBoolean ( trigger ( [ & ]( auto && entity ) { return compare ( getTimeHeadway ( entity , entity_ref ), value ); })); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TIME_HEADWAY_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signal__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::TrafficSignalAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_ACTION_HPP_ #include <openscenario_interpreter/reader/element.hpp> #include <openscenario_interpreter/syntax/traffic_signal_state_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ==== TrafficSignalAction ================================================== * * <xsd:complexType name=\"TrafficSignalAction\"> * <xsd:choice> * <xsd:element name=\"TrafficSignalControllerAction\" type=\"TrafficSignalControllerAction\"/> * <xsd:element name=\"TrafficSignalStateAction\" type=\"TrafficSignalStateAction\"/> * </xsd:choice> * </xsd:complexType> * * ======================================================================== */ struct TrafficSignalAction : public Element { template < typename Node , typename ... Ts > explicit TrafficSignalAction ( const Node & node , Ts && ...) : Element ( choice ( node , std :: make_pair ( \"TrafficSignalControllerAction\" , [ & ]( auto && ) { return unspecified ; }), std :: make_pair ( \"TrafficSignalStateAction\" , UNSUPPORTED ()))) {} }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signal__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxtraffic_signal_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signal__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signal__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::TrafficSignalAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signal__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_ACTION_HPP_ #include <openscenario_interpreter/reader/element.hpp> #include <openscenario_interpreter/syntax/traffic_signal_state_action.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ==== TrafficSignalAction ================================================== * * <xsd:complexType name=\"TrafficSignalAction\"> * <xsd:choice> * <xsd:element name=\"TrafficSignalControllerAction\" type=\"TrafficSignalControllerAction\"/> * <xsd:element name=\"TrafficSignalStateAction\" type=\"TrafficSignalStateAction\"/> * </xsd:choice> * </xsd:complexType> * * ======================================================================== */ struct TrafficSignalAction : public Element { template < typename Node , typename ... Ts > explicit TrafficSignalAction ( const Node & node , Ts && ...) : Element ( choice ( node , std :: make_pair ( \"TrafficSignalControllerAction\" , [ & ]( auto && ) { return unspecified ; }), std :: make_pair ( \"TrafficSignalStateAction\" , UNSUPPORTED ()))) {} }; } // inline namespace syntax } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signal__condition_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_condition.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::TrafficSignalCondition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_CONDITION_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== TrafficSignalCondition =============================================== * * <xsd:complexType name=\"TrafficSignalCondition\"> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"state\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct TrafficSignalCondition { const String name ; const String state ; template < typename Node , typename Scope > explicit TrafficSignalCondition ( const Node & node , Scope & scope ) : name { readAttribute < String > ( \"name\" , node , scope )}, state { readAttribute < String > ( \"state\" , node , scope )} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signal__condition_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxtraffic_signal_conditionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_condition.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signal__condition_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signal__condition_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::TrafficSignalCondition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signal__condition_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_CONDITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_CONDITION_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== TrafficSignalCondition =============================================== * * <xsd:complexType name=\"TrafficSignalCondition\"> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"state\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct TrafficSignalCondition { const String name ; const String state ; template < typename Node , typename Scope > explicit TrafficSignalCondition ( const Node & node , Scope & scope ) : name { readAttribute < String > ( \"name\" , node , scope )}, state { readAttribute < String > ( \"state\" , node , scope )} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_CONDITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signal__state__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_state_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::TrafficSignalStateAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_STATE_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_STATE_ACTION_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== TrafficSignalStateAction ============================================= * * <xsd:complexType name=\"TrafficSignalStateAction\"> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"state\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct TrafficSignalStateAction { const String name ; const String state ; template < typename Node , typename Scope > explicit TrafficSignalStateAction ( const Node & node , Scope & scope ) : name { readAttribute < String > ( \"name\" , node , scope )}, state { readAttribute < String > ( \"state\" , node , scope )} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_STATE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_state_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signal__state__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxtraffic_signal_state_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signal_state_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signal__state__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signal__state__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::TrafficSignalStateAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signal__state__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_STATE_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_STATE_ACTION_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { /* ==== TrafficSignalStateAction ============================================= * * <xsd:complexType name=\"TrafficSignalStateAction\"> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"state\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct TrafficSignalStateAction { const String name ; const String state ; template < typename Node , typename Scope > explicit TrafficSignalStateAction ( const Node & node , Scope & scope ) : name { readAttribute < String > ( \"name\" , node , scope )}, state { readAttribute < String > ( \"state\" , node , scope )} {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNAL_STATE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signals_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signals.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::TrafficSignals struct openscenario_interpreter::syntax::TrafficSignalState struct openscenario_interpreter::syntax::TrafficSignalController struct openscenario_interpreter::syntax::Phase Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNALS_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNALS_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/reader/element.hpp> #include <limits> #include <string> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- TrafficSignalState ----------------------------------------------------- * * <xsd:complexType name=\"TrafficSignalState\"> * <xsd:attribute name=\"trafficSignalId\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"state\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct TrafficSignalState { const String traffic_signal_id , state ; template < typename Node , typename Scope > explicit TrafficSignalState ( const Node & node , Scope & scope ) : traffic_signal_id { readAttribute < String > ( \"trafficSignalId\" , node , scope )}, state { readAttribute < String > ( \"state\" , node , scope )} {} }; /* ---- Phase ------------------------------------------------------------------ * * <xsd:complexType name=\"Phase\"> * <xsd:sequence> * <xsd:element name=\"TrafficSignalState\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"TrafficSignalState\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"duration\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Phase { const String name ; const Double duration ; const TrafficSignalState state ; template < typename Node , typename Scope > explicit Phase ( const Node & node , Scope & outer_scope ) : name { readAttribute < String > ( \"name\" , node , outer_scope )}, duration { readAttribute < Double > ( \"duration\" , node , outer_scope , Double :: infinity ())}, state { readElement < TrafficSignalState > ( \"TrafficSignalState\" , node , outer_scope )} {} }; /* ---- TrafficSignalController ------------------------------------------------ * * <xsd:complexType name=\"TrafficSignalController\"> * <xsd:sequence> * <xsd:element name=\"Phase\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"Phase\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"delay\" type=\"Double\" use=\"optional\"/> * <xsd:attribute name=\"reference\" type=\"String\" use=\"optional\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct TrafficSignalController { const String name ; const Double delay ; const String reference ; const Phase phase ; template < typename Node , typename Scope > explicit TrafficSignalController ( const Node & node , Scope & outer_scope ) : name ( readAttribute < String > ( \"name\" , node , outer_scope )), delay ( readAttribute < Double > ( \"delay\" , node , outer_scope , Double ())), reference ( readAttribute < String > ( \"reference\" , node , outer_scope , String ())), phase ( readElement < Phase > ( \"Phase\" , node , outer_scope )) {} }; /* ==== TrafficSignals ========================================================= * * <xsd:complexType name=\"TrafficSignals\"> * <xsd:sequence> * <xsd:element name=\"TrafficSignalController\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"TrafficSignalController\"/> * </xsd:sequence> * </xsd:complexType> * * ========================================================================== */ struct TrafficSignals : public std :: vector < TrafficSignalController > { TrafficSignals () = default ; template < typename Node , typename Scope > explicit TrafficSignals ( const Node & node , Scope & outer_scope ) { callWithElements ( node , \"TrafficSignalController\" , 0 , unbounded , [ & ]( auto && node ) { emplace_back ( node , outer_scope ); }); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNALS_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signals.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signals_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxtraffic_signalshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/traffic_signals.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signals_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signals_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::TrafficSignals struct openscenario_interpreter::syntax::TrafficSignalState struct openscenario_interpreter::syntax::TrafficSignalController struct openscenario_interpreter::syntax::Phase","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/traffic__signals_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNALS_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNALS_HPP_ #include <openscenario_interpreter/reader/attribute.hpp> #include <openscenario_interpreter/reader/element.hpp> #include <limits> #include <string> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- TrafficSignalState ----------------------------------------------------- * * <xsd:complexType name=\"TrafficSignalState\"> * <xsd:attribute name=\"trafficSignalId\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"state\" type=\"String\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct TrafficSignalState { const String traffic_signal_id , state ; template < typename Node , typename Scope > explicit TrafficSignalState ( const Node & node , Scope & scope ) : traffic_signal_id { readAttribute < String > ( \"trafficSignalId\" , node , scope )}, state { readAttribute < String > ( \"state\" , node , scope )} {} }; /* ---- Phase ------------------------------------------------------------------ * * <xsd:complexType name=\"Phase\"> * <xsd:sequence> * <xsd:element name=\"TrafficSignalState\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"TrafficSignalState\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"duration\" type=\"Double\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Phase { const String name ; const Double duration ; const TrafficSignalState state ; template < typename Node , typename Scope > explicit Phase ( const Node & node , Scope & outer_scope ) : name { readAttribute < String > ( \"name\" , node , outer_scope )}, duration { readAttribute < Double > ( \"duration\" , node , outer_scope , Double :: infinity ())}, state { readElement < TrafficSignalState > ( \"TrafficSignalState\" , node , outer_scope )} {} }; /* ---- TrafficSignalController ------------------------------------------------ * * <xsd:complexType name=\"TrafficSignalController\"> * <xsd:sequence> * <xsd:element name=\"Phase\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"Phase\"/> * </xsd:sequence> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"delay\" type=\"Double\" use=\"optional\"/> * <xsd:attribute name=\"reference\" type=\"String\" use=\"optional\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct TrafficSignalController { const String name ; const Double delay ; const String reference ; const Phase phase ; template < typename Node , typename Scope > explicit TrafficSignalController ( const Node & node , Scope & outer_scope ) : name ( readAttribute < String > ( \"name\" , node , outer_scope )), delay ( readAttribute < Double > ( \"delay\" , node , outer_scope , Double ())), reference ( readAttribute < String > ( \"reference\" , node , outer_scope , String ())), phase ( readElement < Phase > ( \"Phase\" , node , outer_scope )) {} }; /* ==== TrafficSignals ========================================================= * * <xsd:complexType name=\"TrafficSignals\"> * <xsd:sequence> * <xsd:element name=\"TrafficSignalController\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"TrafficSignalController\"/> * </xsd:sequence> * </xsd:complexType> * * ========================================================================== */ struct TrafficSignals : public std :: vector < TrafficSignalController > { TrafficSignals () = default ; template < typename Node , typename Scope > explicit TrafficSignals ( const Node & node , Scope & outer_scope ) { callWithElements ( node , \"TrafficSignalController\" , 0 , unbounded , [ & ]( auto && node ) { emplace_back ( node , outer_scope ); }); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRAFFIC_SIGNALS_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/transition__dynamics_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/transition_dynamics.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::TransitionDynamics Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRANSITION_DYNAMICS_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRANSITION_DYNAMICS_HPP_ #include <openscenario_interpreter/syntax/dynamics_dimension.hpp> #include <openscenario_interpreter/syntax/dynamics_shape.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- TransitionDynamics ----------------------------------------------------- * * <xsd:complexType name=\"TransitionDynamics\"> * <xsd:attribute name=\"dynamicsShape\" type=\"DynamicsShape\" use=\"required\"/> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"dynamicsDimension\" type=\"DynamicsDimension\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct TransitionDynamics { const DynamicsShape dynamics_shape ; const Double value ; const DynamicsDimension dynamics_dimension ; template < typename Node , typename Scope > explicit TransitionDynamics ( const Node & node , Scope & scope ) : dynamics_shape ( readAttribute < DynamicsShape > ( \"dynamicsShape\" , node , scope )), value ( readAttribute < Double > ( \"value\" , node , scope )), dynamics_dimension ( readAttribute < DynamicsDimension > ( \"dynamicsDimension\" , node , scope )) {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRANSITION_DYNAMICS_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/transition_dynamics.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/transition__dynamics_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxtransition_dynamicshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/transition_dynamics.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/transition__dynamics_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/transition__dynamics_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::TransitionDynamics","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/transition__dynamics_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRANSITION_DYNAMICS_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRANSITION_DYNAMICS_HPP_ #include <openscenario_interpreter/syntax/dynamics_dimension.hpp> #include <openscenario_interpreter/syntax/dynamics_shape.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ---- TransitionDynamics ----------------------------------------------------- * * <xsd:complexType name=\"TransitionDynamics\"> * <xsd:attribute name=\"dynamicsShape\" type=\"DynamicsShape\" use=\"required\"/> * <xsd:attribute name=\"value\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"dynamicsDimension\" type=\"DynamicsDimension\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct TransitionDynamics { const DynamicsShape dynamics_shape ; const Double value ; const DynamicsDimension dynamics_dimension ; template < typename Node , typename Scope > explicit TransitionDynamics ( const Node & node , Scope & scope ) : dynamics_shape ( readAttribute < DynamicsShape > ( \"dynamicsShape\" , node , scope )), value ( readAttribute < Double > ( \"value\" , node , scope )), dynamics_dimension ( readAttribute < DynamicsDimension > ( \"dynamicsDimension\" , node , scope )) {} }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRANSITION_DYNAMICS_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/trigger_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/trigger.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Trigger Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGER_HPP_ #include <openscenario_interpreter/syntax/condition_group.hpp> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- Trigger ---------------------------------------------------------------- * * <xsd:complexType name=\"Trigger\"> * <xsd:sequence> * <xsd:element name=\"ConditionGroup\" type=\"ConditionGroup\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Trigger : public std :: vector < ConditionGroup > { template < typename Node , typename Scope > explicit Trigger ( const Node & node , Scope & scope ) { callWithElements ( node , \"ConditionGroup\" , 0 , unbounded , [ & ]( auto && node ) { emplace_back ( node , scope ); }); } auto evaluate () { /* ------------------------------------------------------------------------- * * A trigger is then defined as an association of condition groups. A * trigger evaluates to true if at least one of the associated condition * groups evaluates to true, otherwise it evaluates to false (OR * operation). * * ---------------------------------------------------------------------- */ return asBoolean ( // NOTE: Don't use std::any_of; Intentionally does not short-circuit evaluation. std :: accumulate ( std :: begin ( * this ), std :: end ( * this ), false , [ & ]( auto && lhs , ConditionGroup & condition_group ) { const auto rhs = condition_group . evaluate (); return lhs || rhs . as < Boolean > (); })); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/trigger.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/trigger_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxtriggerhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/trigger.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/trigger_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/trigger_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Trigger","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/trigger_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGER_HPP_ #include <openscenario_interpreter/syntax/condition_group.hpp> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ---- Trigger ---------------------------------------------------------------- * * <xsd:complexType name=\"Trigger\"> * <xsd:sequence> * <xsd:element name=\"ConditionGroup\" type=\"ConditionGroup\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> * </xsd:sequence> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Trigger : public std :: vector < ConditionGroup > { template < typename Node , typename Scope > explicit Trigger ( const Node & node , Scope & scope ) { callWithElements ( node , \"ConditionGroup\" , 0 , unbounded , [ & ]( auto && node ) { emplace_back ( node , scope ); }); } auto evaluate () { /* ------------------------------------------------------------------------- * * A trigger is then defined as an association of condition groups. A * trigger evaluates to true if at least one of the associated condition * groups evaluates to true, otherwise it evaluates to false (OR * operation). * * ---------------------------------------------------------------------- */ return asBoolean ( // NOTE: Don't use std::any_of; Intentionally does not short-circuit evaluation. std :: accumulate ( std :: begin ( * this ), std :: end ( * this ), false , [ & ]( auto && lhs , ConditionGroup & condition_group ) { const auto rhs = condition_group . evaluate (); return lhs || rhs . as < Boolean > (); })); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/triggering__entities_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/triggering_entities.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::TriggeringEntities Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGERING_ENTITIES_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGERING_ENTITIES_HPP_ #include <openscenario_interpreter/syntax/entity_ref.hpp> #include <openscenario_interpreter/syntax/triggering_entities_rule.hpp> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ==== TriggeringEntities =================================================== * * <xsd:complexType name=\"TriggeringEntities\"> * <xsd:sequence> * <xsd:element name=\"EntityRef\" maxOccurs=\"unbounded\" type=\"EntityRef\"/> * </xsd:sequence> * <xsd:attribute name=\"triggeringEntitiesRule\" type=\"TriggeringEntitiesRule\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct TriggeringEntities : public std :: vector < EntityRef > { const TriggeringEntitiesRule verify ; template < typename Node , typename Scope > explicit TriggeringEntities ( const Node & node , Scope & scope ) : verify { readAttribute < TriggeringEntitiesRule > ( \"triggeringEntitiesRule\" , node , scope )} { callWithElements ( node , \"EntityRef\" , 1 , unbounded , [ & ]( auto && node ) { emplace_back ( node , scope ); }); } template < typename ... Ts > constexpr decltype ( auto ) operator ()( Ts && ... xs ) const { return verify ( std :: begin ( * this ), std :: end ( * this ), std :: forward < decltype ( xs ) > ( xs )...); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGERING_ENTITIES_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/triggering_entities.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/triggering__entities_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxtriggering_entitieshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/triggering_entities.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/triggering__entities_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/triggering__entities_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::TriggeringEntities","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/triggering__entities_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGERING_ENTITIES_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGERING_ENTITIES_HPP_ #include <openscenario_interpreter/syntax/entity_ref.hpp> #include <openscenario_interpreter/syntax/triggering_entities_rule.hpp> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ==== TriggeringEntities =================================================== * * <xsd:complexType name=\"TriggeringEntities\"> * <xsd:sequence> * <xsd:element name=\"EntityRef\" maxOccurs=\"unbounded\" type=\"EntityRef\"/> * </xsd:sequence> * <xsd:attribute name=\"triggeringEntitiesRule\" type=\"TriggeringEntitiesRule\" use=\"required\"/> * </xsd:complexType> * * ======================================================================== */ struct TriggeringEntities : public std :: vector < EntityRef > { const TriggeringEntitiesRule verify ; template < typename Node , typename Scope > explicit TriggeringEntities ( const Node & node , Scope & scope ) : verify { readAttribute < TriggeringEntitiesRule > ( \"triggeringEntitiesRule\" , node , scope )} { callWithElements ( node , \"EntityRef\" , 1 , unbounded , [ & ]( auto && node ) { emplace_back ( node , scope ); }); } template < typename ... Ts > constexpr decltype ( auto ) operator ()( Ts && ... xs ) const { return verify ( std :: begin ( * this ), std :: end ( * this ), std :: forward < decltype ( xs ) > ( xs )...); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGERING_ENTITIES_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/triggering__entities__rule_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/triggering_entities_rule.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::TriggeringEntitiesRule Defines # Name BOILERPLATE (IDENTIFIER) BOILERPLATE (ID) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ rule . value = TriggeringEntitiesRule :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( ID ) case TriggeringEntitiesRule :: ID : return os << # ID ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGERING_ENTITIES_RULE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGERING_ENTITIES_RULE_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ==== TriggeringEntitiesRule =============================================== * * <xsd:simpleType name=\"TriggeringEntitiesRule\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"any\"/> * <xsd:enumeration value=\"all\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct TriggeringEntitiesRule { enum value_type { all , any , none , } value ; explicit constexpr TriggeringEntitiesRule ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } template < typename ... Ts > constexpr decltype ( auto ) operator ()( Ts && ... xs ) const { switch ( value ) { case all : return std :: all_of ( std :: forward < decltype ( xs ) > ( xs )...); case any : return std :: any_of ( std :: forward < decltype ( xs ) > ( xs )...); case none : return std :: none_of ( std :: forward < decltype ( xs ) > ( xs )...); default : return false ; } } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , TriggeringEntitiesRule & rule ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ rule.value = TriggeringEntitiesRule::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( all ); BOILERPLATE ( any ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type TriggeringEntitiesRule\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const TriggeringEntitiesRule & rule ) { switch ( rule ) { #define BOILERPLATE(ID) case TriggeringEntitiesRule::ID: return os << #ID; BOILERPLATE ( all ); BOILERPLATE ( any ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class TriggeringEntitiesRule holds unexpected value \" << static_cast < TriggeringEntitiesRule :: value_type > ( rule . value ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGERING_ENTITIES_RULE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/triggering_entities_rule.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/triggering__entities__rule_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxtriggering_entities_rulehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/triggering_entities_rule.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/triggering__entities__rule_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/triggering__entities__rule_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::TriggeringEntitiesRule","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/triggering__entities__rule_8hpp/#defines","text":"Name BOILERPLATE (IDENTIFIER) BOILERPLATE (ID)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/triggering__entities__rule_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/triggering__entities__rule_8hpp/#define-boilerplate","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ rule . value = TriggeringEntitiesRule :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/triggering__entities__rule_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( ID ) case TriggeringEntitiesRule :: ID : return os << # ID ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/triggering__entities__rule_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGERING_ENTITIES_RULE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGERING_ENTITIES_RULE_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> #include <utility> #include <vector> namespace openscenario_interpreter { inline namespace syntax { /* ==== TriggeringEntitiesRule =============================================== * * <xsd:simpleType name=\"TriggeringEntitiesRule\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"any\"/> * <xsd:enumeration value=\"all\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct TriggeringEntitiesRule { enum value_type { all , any , none , } value ; explicit constexpr TriggeringEntitiesRule ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } template < typename ... Ts > constexpr decltype ( auto ) operator ()( Ts && ... xs ) const { switch ( value ) { case all : return std :: all_of ( std :: forward < decltype ( xs ) > ( xs )...); case any : return std :: any_of ( std :: forward < decltype ( xs ) > ( xs )...); case none : return std :: none_of ( std :: forward < decltype ( xs ) > ( xs )...); default : return false ; } } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , TriggeringEntitiesRule & rule ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ rule.value = TriggeringEntitiesRule::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( all ); BOILERPLATE ( any ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type TriggeringEntitiesRule\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const TriggeringEntitiesRule & rule ) { switch ( rule ) { #define BOILERPLATE(ID) case TriggeringEntitiesRule::ID: return os << #ID; BOILERPLATE ( all ); BOILERPLATE ( any ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class TriggeringEntitiesRule holds unexpected value \" << static_cast < TriggeringEntitiesRule :: value_type > ( rule . value ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__TRIGGERING_ENTITIES_RULE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/unsigned__integer_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/unsigned_integer.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::UnsignedInteger Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__UNSIGNED_INTEGER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__UNSIGNED_INTEGER_HPP_ #include <boost/lexical_cast.hpp> #include <std_msgs/msg/u_int64.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { struct UnsignedInteger : public std_msgs :: msg :: UInt64 { using value_type = decltype ( std_msgs :: msg :: UInt64 :: data ); explicit UnsignedInteger ( value_type value = {}) { data = value ; } explicit UnsignedInteger ( const std :: string & s ) try { data = boost :: lexical_cast < value_type > ( s ); } catch ( const boost :: bad_lexical_cast & ) { std :: stringstream ss {}; ss << \"can't treat value \\\" \" << s << \" \\\" as type UnsignedInteger\" ; throw SyntaxError { ss . str ()}; } constexpr operator value_type () const noexcept { return data ; } decltype ( auto ) operator ++ () noexcept { ++ data ; return * this ; } auto & operator += ( const double & rhs ) { data += rhs ; return * this ; } auto & operator *= ( const double & rhs ) { data *= rhs ; return * this ; } }; template < typename ... Ts > decltype ( auto ) operator << ( std :: basic_ostream < Ts ... >& os , const UnsignedInteger & rhs ) { return os << rhs . data ; } template < typename ... Ts > decltype ( auto ) operator >> ( std :: basic_istream < Ts ... >& is , UnsignedInteger & rhs ) { return is >> rhs . data ; } using UnsignedInt = UnsignedInteger ; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__UNSIGNED_INTEGER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/unsigned_integer.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/unsigned__integer_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxunsigned_integerhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/unsigned_integer.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/unsigned__integer_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/unsigned__integer_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::UnsignedInteger","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/unsigned__integer_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__UNSIGNED_INTEGER_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__UNSIGNED_INTEGER_HPP_ #include <boost/lexical_cast.hpp> #include <std_msgs/msg/u_int64.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { struct UnsignedInteger : public std_msgs :: msg :: UInt64 { using value_type = decltype ( std_msgs :: msg :: UInt64 :: data ); explicit UnsignedInteger ( value_type value = {}) { data = value ; } explicit UnsignedInteger ( const std :: string & s ) try { data = boost :: lexical_cast < value_type > ( s ); } catch ( const boost :: bad_lexical_cast & ) { std :: stringstream ss {}; ss << \"can't treat value \\\" \" << s << \" \\\" as type UnsignedInteger\" ; throw SyntaxError { ss . str ()}; } constexpr operator value_type () const noexcept { return data ; } decltype ( auto ) operator ++ () noexcept { ++ data ; return * this ; } auto & operator += ( const double & rhs ) { data += rhs ; return * this ; } auto & operator *= ( const double & rhs ) { data *= rhs ; return * this ; } }; template < typename ... Ts > decltype ( auto ) operator << ( std :: basic_ostream < Ts ... >& os , const UnsignedInteger & rhs ) { return os << rhs . data ; } template < typename ... Ts > decltype ( auto ) operator >> ( std :: basic_istream < Ts ... >& is , UnsignedInteger & rhs ) { return is >> rhs . data ; } using UnsignedInt = UnsignedInteger ; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__UNSIGNED_INTEGER_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/unsigned__short_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/unsigned_short.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::UnsignedShort Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__UNSIGNED_SHORT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__UNSIGNED_SHORT_HPP_ #include <boost/lexical_cast.hpp> #include <std_msgs/msg/u_int16.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { struct UnsignedShort : public std_msgs :: msg :: UInt16 { using value_type = decltype ( std_msgs :: msg :: UInt16 :: data ); explicit UnsignedShort ( value_type value = {}) { data = value ; } explicit UnsignedShort ( const std :: string & s ) try { data = boost :: lexical_cast < value_type > ( s ); } catch ( const boost :: bad_lexical_cast & ) { std :: stringstream ss {}; ss << \"can't treat value \\\" \" << s << \" \\\" as type UnsignedShort\" ; throw SyntaxError { ss . str ()}; } constexpr operator value_type () const noexcept { return data ; } decltype ( auto ) operator ++ () noexcept { ++ data ; return * this ; } auto & operator += ( const double & rhs ) { data += rhs ; return * this ; } auto & operator *= ( const double & rhs ) { data *= rhs ; return * this ; } }; template < typename ... Ts > decltype ( auto ) operator << ( std :: basic_ostream < Ts ... >& os , const UnsignedShort & rhs ) { return os << rhs . data ; } template < typename ... Ts > decltype ( auto ) operator >> ( std :: basic_istream < Ts ... >& is , UnsignedShort & rhs ) { return is >> rhs . data ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__UNSIGNED_SHORT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/unsigned_short.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/unsigned__short_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxunsigned_shorthpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/unsigned_short.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/unsigned__short_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/unsigned__short_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::UnsignedShort","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/unsigned__short_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__UNSIGNED_SHORT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__UNSIGNED_SHORT_HPP_ #include <boost/lexical_cast.hpp> #include <std_msgs/msg/u_int16.hpp> #include <string> namespace openscenario_interpreter { inline namespace syntax { struct UnsignedShort : public std_msgs :: msg :: UInt16 { using value_type = decltype ( std_msgs :: msg :: UInt16 :: data ); explicit UnsignedShort ( value_type value = {}) { data = value ; } explicit UnsignedShort ( const std :: string & s ) try { data = boost :: lexical_cast < value_type > ( s ); } catch ( const boost :: bad_lexical_cast & ) { std :: stringstream ss {}; ss << \"can't treat value \\\" \" << s << \" \\\" as type UnsignedShort\" ; throw SyntaxError { ss . str ()}; } constexpr operator value_type () const noexcept { return data ; } decltype ( auto ) operator ++ () noexcept { ++ data ; return * this ; } auto & operator += ( const double & rhs ) { data += rhs ; return * this ; } auto & operator *= ( const double & rhs ) { data *= rhs ; return * this ; } }; template < typename ... Ts > decltype ( auto ) operator << ( std :: basic_ostream < Ts ... >& os , const UnsignedShort & rhs ) { return os << rhs . data ; } template < typename ... Ts > decltype ( auto ) operator >> ( std :: basic_istream < Ts ... >& is , UnsignedShort & rhs ) { return is >> rhs . data ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__UNSIGNED_SHORT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/user__defined__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/user_defined_action.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::UserDefinedAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__USER_DEFINED_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__USER_DEFINED_ACTION_HPP_ #include <openscenario_interpreter/syntax/custom_command_action.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== UserDefinedAction ==================================================== * * <xsd:complexType name=\"UserDefinedAction\"> * <xsd:sequence> * <xsd:element name=\"CustomCommandAction\" type=\"CustomCommandAction\"/> * </xsd:sequence> * </xsd:complexType> * * ======================================================================== */ struct UserDefinedAction : public Element { template < typename Node , typename Scope > explicit UserDefinedAction ( const Node & node , Scope & scope ) { callWithElements ( node , \"CustomCommandAction\" , 1 , 1 , [ & ]( auto && node ) { return rebind < CustomCommandAction > ( node , scope ); }); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__USER_DEFINED_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/user_defined_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/user__defined__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxuser_defined_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/user_defined_action.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/user__defined__action_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/user__defined__action_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::UserDefinedAction","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/user__defined__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__USER_DEFINED_ACTION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__USER_DEFINED_ACTION_HPP_ #include <openscenario_interpreter/syntax/custom_command_action.hpp> namespace openscenario_interpreter { inline namespace syntax { /* ==== UserDefinedAction ==================================================== * * <xsd:complexType name=\"UserDefinedAction\"> * <xsd:sequence> * <xsd:element name=\"CustomCommandAction\" type=\"CustomCommandAction\"/> * </xsd:sequence> * </xsd:complexType> * * ======================================================================== */ struct UserDefinedAction : public Element { template < typename Node , typename Scope > explicit UserDefinedAction ( const Node & node , Scope & scope ) { callWithElements ( node , \"CustomCommandAction\" , 1 , 1 , [ & ]( auto && node ) { return rebind < CustomCommandAction > ( node , scope ); }); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__USER_DEFINED_ACTION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/vehicle_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/vehicle.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Vehicle Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__VEHICLE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__VEHICLE_HPP_ #include <openscenario_interpreter/syntax/axles.hpp> #include <openscenario_interpreter/syntax/bounding_box.hpp> #include <openscenario_interpreter/syntax/parameter_declarations.hpp> #include <openscenario_interpreter/syntax/performance.hpp> #include <openscenario_interpreter/syntax/properties.hpp> #include <openscenario_interpreter/syntax/vehicle_category.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- Vehicle ---------------------------------------------------------------- * * <xsd:complexType name=\"Vehicle\"> * <xsd:all> * <xsd:element name=\"ParameterDeclarations\" type=\"ParameterDeclarations\" minOccurs=\"0\"/> * <xsd:element name=\"BoundingBox\" type=\"BoundingBox\"/> * <xsd:element name=\"Performance\" type=\"Performance\"/> * <xsd:element name=\"Axles\" type=\"Axles\"/> * <xsd:element name=\"Properties\" type=\"Properties\"/> * </xsd:all> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"vehicleCategory\" type=\"VehicleCategory\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Vehicle { /* ---- name ----------------------------------------------------------------- * * Name of the vehicle type. * * ------------------------------------------------------------------------ */ const String name ; /* ---- vehicleCategory ------------------------------------------------------ * * Category of the vehicle (bicycle, train,...). * * ------------------------------------------------------------------------ */ const VehicleCategory vehicle_category ; Scope inner_scope ; /* ---- ParameterDeclarations ------------------------------------------------ * * Definition of additional parameters. * * ------------------------------------------------------------------------ */ const ParameterDeclarations parameter_declarations ; /* ---- BoundingBox ---------------------------------------------------------- * * The three dimensional bounding box that encloses the vehicle. * * ------------------------------------------------------------------------ */ const BoundingBox bounding_box ; /* ---- Performance ---------------------------------------------------------- * * Performance properties of the vehicle. * * ------------------------------------------------------------------------ */ const Performance performance ; /* ---- Axles ---------------------------------------------------------------- * * A set of axles (front, rear, additional) and their geometric locations. * * ------------------------------------------------------------------------ */ const Axles axles ; /* ---- Properties ----------------------------------------------------------- * * Additional properties as name value pairs. * * ------------------------------------------------------------------------ */ Properties properties ; template < typename Node , typename Scope > explicit Vehicle ( const Node & node , Scope & outer_scope ) : name ( readAttribute < String > ( \"name\" , node , outer_scope )), vehicle_category ( readAttribute < VehicleCategory > ( \"vehicleCategory\" , node , outer_scope )), inner_scope ( outer_scope ), parameter_declarations ( readElement < ParameterDeclarations > ( \"ParameterDeclarations\" , node , inner_scope )), bounding_box ( readElement < BoundingBox > ( \"BoundingBox\" , node , inner_scope )), performance ( readElement < Performance > ( \"Performance\" , node , inner_scope )), axles ( readElement < Axles > ( \"Axles\" , node , inner_scope )), properties ( readElement < Properties > ( \"Properties\" , node , inner_scope )) {} template < typename ... Ts > decltype ( auto ) operator []( Ts && ... xs ) { return properties . operator []( std :: forward < decltype ( xs ) > ( xs )...); } }; std :: ostream & operator << ( std :: ostream & os , const Vehicle & rhs ) { return os << ( indent ++ ) << blue << \"<Vehicle\" << \" \" << highlight ( \"name\" , rhs . name ) << \" \" << highlight ( \"vehicleCategory\" , rhs . vehicle_category ) << blue << \"> \\n \" << reset << rhs . parameter_declarations << \" \\n \" << rhs . bounding_box << \" \\n \" << rhs . performance << \" \\n \" << rhs . axles << \" \\n \" << ( -- indent ) << blue << \"</Vehicle>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__VEHICLE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/vehicle.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/vehicle_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxvehiclehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/vehicle.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/vehicle_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/vehicle_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Vehicle","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/vehicle_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__VEHICLE_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__VEHICLE_HPP_ #include <openscenario_interpreter/syntax/axles.hpp> #include <openscenario_interpreter/syntax/bounding_box.hpp> #include <openscenario_interpreter/syntax/parameter_declarations.hpp> #include <openscenario_interpreter/syntax/performance.hpp> #include <openscenario_interpreter/syntax/properties.hpp> #include <openscenario_interpreter/syntax/vehicle_category.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- Vehicle ---------------------------------------------------------------- * * <xsd:complexType name=\"Vehicle\"> * <xsd:all> * <xsd:element name=\"ParameterDeclarations\" type=\"ParameterDeclarations\" minOccurs=\"0\"/> * <xsd:element name=\"BoundingBox\" type=\"BoundingBox\"/> * <xsd:element name=\"Performance\" type=\"Performance\"/> * <xsd:element name=\"Axles\" type=\"Axles\"/> * <xsd:element name=\"Properties\" type=\"Properties\"/> * </xsd:all> * <xsd:attribute name=\"name\" type=\"String\" use=\"required\"/> * <xsd:attribute name=\"vehicleCategory\" type=\"VehicleCategory\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Vehicle { /* ---- name ----------------------------------------------------------------- * * Name of the vehicle type. * * ------------------------------------------------------------------------ */ const String name ; /* ---- vehicleCategory ------------------------------------------------------ * * Category of the vehicle (bicycle, train,...). * * ------------------------------------------------------------------------ */ const VehicleCategory vehicle_category ; Scope inner_scope ; /* ---- ParameterDeclarations ------------------------------------------------ * * Definition of additional parameters. * * ------------------------------------------------------------------------ */ const ParameterDeclarations parameter_declarations ; /* ---- BoundingBox ---------------------------------------------------------- * * The three dimensional bounding box that encloses the vehicle. * * ------------------------------------------------------------------------ */ const BoundingBox bounding_box ; /* ---- Performance ---------------------------------------------------------- * * Performance properties of the vehicle. * * ------------------------------------------------------------------------ */ const Performance performance ; /* ---- Axles ---------------------------------------------------------------- * * A set of axles (front, rear, additional) and their geometric locations. * * ------------------------------------------------------------------------ */ const Axles axles ; /* ---- Properties ----------------------------------------------------------- * * Additional properties as name value pairs. * * ------------------------------------------------------------------------ */ Properties properties ; template < typename Node , typename Scope > explicit Vehicle ( const Node & node , Scope & outer_scope ) : name ( readAttribute < String > ( \"name\" , node , outer_scope )), vehicle_category ( readAttribute < VehicleCategory > ( \"vehicleCategory\" , node , outer_scope )), inner_scope ( outer_scope ), parameter_declarations ( readElement < ParameterDeclarations > ( \"ParameterDeclarations\" , node , inner_scope )), bounding_box ( readElement < BoundingBox > ( \"BoundingBox\" , node , inner_scope )), performance ( readElement < Performance > ( \"Performance\" , node , inner_scope )), axles ( readElement < Axles > ( \"Axles\" , node , inner_scope )), properties ( readElement < Properties > ( \"Properties\" , node , inner_scope )) {} template < typename ... Ts > decltype ( auto ) operator []( Ts && ... xs ) { return properties . operator []( std :: forward < decltype ( xs ) > ( xs )...); } }; std :: ostream & operator << ( std :: ostream & os , const Vehicle & rhs ) { return os << ( indent ++ ) << blue << \"<Vehicle\" << \" \" << highlight ( \"name\" , rhs . name ) << \" \" << highlight ( \"vehicleCategory\" , rhs . vehicle_category ) << blue << \"> \\n \" << reset << rhs . parameter_declarations << \" \\n \" << rhs . bounding_box << \" \\n \" << rhs . performance << \" \\n \" << rhs . axles << \" \\n \" << ( -- indent ) << blue << \"</Vehicle>\" << reset ; } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__VEHICLE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/vehicle__category_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/vehicle_category.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::VehicleCategory Defines # Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME) Macro Documentation # define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ category . value = VehicleCategory :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ category . value = VehicleCategory :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" ) define BOILERPLATE # #define BOILERPLATE( NAME ) case VehicleCategory :: NAME : return os << # NAME ; Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__VEHICLE_CATEGORY_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__VEHICLE_CATEGORY_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ==== VehicleCategory ====================================================== * * <xsd:simpleType name=\"VehicleCategory\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"car\"/> * <xsd:enumeration value=\"van\"/> * <xsd:enumeration value=\"truck\"/> * <xsd:enumeration value=\"trailer\"/> * <xsd:enumeration value=\"semitrailer\"/> * <xsd:enumeration value=\"bus\"/> * <xsd:enumeration value=\"motorbike\"/> * <xsd:enumeration value=\"bicycle\"/> * <xsd:enumeration value=\"train\"/> * <xsd:enumeration value=\"tram\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct VehicleCategory { enum value_type { bicycle , bus , car , motorbike , semitrailer , trailer , train , tram , truck , van , } value ; explicit constexpr VehicleCategory ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , VehicleCategory & category ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ category.value = VehicleCategory::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( bicycle ); BOILERPLATE ( bus ); BOILERPLATE ( car ); BOILERPLATE ( motorbike ); BOILERPLATE ( truck ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" << buffer << \\ \"\\' is valid OpenSCENARIO value of type VehicleCategory, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") BOILERPLATE ( semitrailer ); BOILERPLATE ( trailer ); BOILERPLATE ( train ); BOILERPLATE ( tram ); BOILERPLATE ( van ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type VehicleCategory\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const VehicleCategory & category ) { switch ( category ) { #define BOILERPLATE(NAME) case VehicleCategory::NAME: return os << #NAME; BOILERPLATE ( bicycle ); BOILERPLATE ( bus ); BOILERPLATE ( car ); BOILERPLATE ( motorbike ); BOILERPLATE ( semitrailer ); BOILERPLATE ( trailer ); BOILERPLATE ( train ); BOILERPLATE ( tram ); BOILERPLATE ( truck ); BOILERPLATE ( van ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class VehicleCategory holds unexpected value \" << static_cast < VehicleCategory :: value_type > ( category ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__VEHICLE_CATEGORY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/vehicle_category.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/vehicle__category_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxvehicle_categoryhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/vehicle_category.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/vehicle__category_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/vehicle__category_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::VehicleCategory","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/vehicle__category_8hpp/#defines","text":"Name BOILERPLATE (IDENTIFIER) BOILERPLATE (IDENTIFIER) BOILERPLATE (NAME)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/vehicle__category_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/vehicle__category_8hpp/#define-boilerplate","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ category . value = VehicleCategory :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/vehicle__category_8hpp/#define-boilerplate_1","text":"#define BOILERPLATE( IDENTIFIER ) if ( buffer == # IDENTIFIER ) { \\ category . value = VehicleCategory :: IDENTIFIER ; \\ return is ; \\ } static_assert ( true , \"\" )","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/vehicle__category_8hpp/#define-boilerplate_2","text":"#define BOILERPLATE( NAME ) case VehicleCategory :: NAME : return os << # NAME ;","title":"define BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Files/vehicle__category_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__VEHICLE_CATEGORY_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__VEHICLE_CATEGORY_HPP_ #include <openscenario_interpreter/object.hpp> #include <string> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ==== VehicleCategory ====================================================== * * <xsd:simpleType name=\"VehicleCategory\"> * <xsd:union> * <xsd:simpleType> * <xsd:restriction base=\"xsd:string\"> * <xsd:enumeration value=\"car\"/> * <xsd:enumeration value=\"van\"/> * <xsd:enumeration value=\"truck\"/> * <xsd:enumeration value=\"trailer\"/> * <xsd:enumeration value=\"semitrailer\"/> * <xsd:enumeration value=\"bus\"/> * <xsd:enumeration value=\"motorbike\"/> * <xsd:enumeration value=\"bicycle\"/> * <xsd:enumeration value=\"train\"/> * <xsd:enumeration value=\"tram\"/> * </xsd:restriction> * </xsd:simpleType> * <xsd:simpleType> * <xsd:restriction base=\"parameter\"/> * </xsd:simpleType> * </xsd:union> * </xsd:simpleType> * * ======================================================================== */ struct VehicleCategory { enum value_type { bicycle , bus , car , motorbike , semitrailer , trailer , train , tram , truck , van , } value ; explicit constexpr VehicleCategory ( value_type value = {}) : value { value } {} constexpr operator value_type () const noexcept { return value ; } }; template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , VehicleCategory & category ) { std :: string buffer {}; is >> buffer ; #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ category.value = VehicleCategory::IDENTIFIER; \\ return is; \\ } static_assert(true, \"\") BOILERPLATE ( bicycle ); BOILERPLATE ( bus ); BOILERPLATE ( car ); BOILERPLATE ( motorbike ); BOILERPLATE ( truck ); #undef BOILERPLATE #define BOILERPLATE(IDENTIFIER) \\ if (buffer == #IDENTIFIER) { \\ std::stringstream ss { \\ }; \\ ss << \"given value \\'\" << buffer << \\ \"\\' is valid OpenSCENARIO value of type VehicleCategory, but it is not supported\"; \\ throw ImplementationFault {ss.str()}; \\ } static_assert(true, \"\") BOILERPLATE ( semitrailer ); BOILERPLATE ( trailer ); BOILERPLATE ( train ); BOILERPLATE ( tram ); BOILERPLATE ( van ); #undef BOILERPLATE std :: stringstream ss {}; ss << \"unexpected value \\' \" << buffer << \" \\' specified as type VehicleCategory\" ; throw SyntaxError { ss . str ()}; } template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const VehicleCategory & category ) { switch ( category ) { #define BOILERPLATE(NAME) case VehicleCategory::NAME: return os << #NAME; BOILERPLATE ( bicycle ); BOILERPLATE ( bus ); BOILERPLATE ( car ); BOILERPLATE ( motorbike ); BOILERPLATE ( semitrailer ); BOILERPLATE ( trailer ); BOILERPLATE ( train ); BOILERPLATE ( tram ); BOILERPLATE ( truck ); BOILERPLATE ( van ); #undef BOILERPLATE default : std :: stringstream ss {}; ss << \"enum class VehicleCategory holds unexpected value \" << static_cast < VehicleCategory :: value_type > ( category ); throw ImplementationFault { ss . str ()}; } } } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__VEHICLE_CATEGORY_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/verbose_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/verbose.hpp # Defines # Name VERBOSE (...) Macro Documentation # define VERBOSE # #define VERBOSE( ... ) std :: cout << __VA_ARGS__ << std :: endl Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__UTILITY__VERBOSE_HPP_ #define OPENSCENARIO_INTERPRETER__UTILITY__VERBOSE_HPP_ #ifndef NDEBUG #define VERBOSE(...) std::cout << __VA_ARGS__ << std::endl #else #define VERBOSE(...) #endif #endif // OPENSCENARIO_INTERPRETER__UTILITY__VERBOSE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/verbose.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/verbose_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterutilityverbosehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/verbose.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/verbose_8hpp/#defines","text":"Name VERBOSE (...)","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/verbose_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/verbose_8hpp/#define-verbose","text":"#define VERBOSE( ... ) std :: cout << __VA_ARGS__ << std :: endl","title":"define VERBOSE"},{"location":"package/openscenario_interpreter/markdown/Files/verbose_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__UTILITY__VERBOSE_HPP_ #define OPENSCENARIO_INTERPRETER__UTILITY__VERBOSE_HPP_ #ifndef NDEBUG #define VERBOSE(...) std::cout << __VA_ARGS__ << std::endl #else #define VERBOSE(...) #endif #endif // OPENSCENARIO_INTERPRETER__UTILITY__VERBOSE_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/visibility_8h/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/visibility.h # Defines # Name OPENSCENARIO_INTERPRETER_PUBLIC_TYPE OPENSCENARIO_INTERPRETER_PUBLIC OPENSCENARIO_INTERPRETER_LOCAL OPENSCENARIO_INTERPRETER_IMPORT OPENSCENARIO_INTERPRETER_EXPORT Macro Documentation # define OPENSCENARIO_INTERPRETER_PUBLIC_TYPE # #define OPENSCENARIO_INTERPRETER_PUBLIC_TYPE define OPENSCENARIO_INTERPRETER_PUBLIC # #define OPENSCENARIO_INTERPRETER_PUBLIC define OPENSCENARIO_INTERPRETER_LOCAL # #define OPENSCENARIO_INTERPRETER_LOCAL define OPENSCENARIO_INTERPRETER_IMPORT # #define OPENSCENARIO_INTERPRETER_IMPORT define OPENSCENARIO_INTERPRETER_EXPORT # #define OPENSCENARIO_INTERPRETER_EXPORT __attribute__ ((visibility(\"default\"))) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__UTILITY__VISIBILITY_H_ #define OPENSCENARIO_INTERPRETER__UTILITY__VISIBILITY_H_ #ifdef __cplusplus extern \"C\" { #endif // This logic was borrowed (then namespaced) from the examples on the gcc wiki: // https://gcc.gnu.org/wiki/Visibility #if defined _WIN32 || defined __CYGWIN__ # ifdef __GNUC__ # define OPENSCENARIO_INTERPRETER_EXPORT __attribute__ ((dllexport)) # define OPENSCENARIO_INTERPRETER_IMPORT __attribute__ ((dllimport)) # else # define OPENSCENARIO_INTERPRETER_EXPORT __declspec(dllexport) # define OPENSCENARIO_INTERPRETER_IMPORT __declspec(dllimport) # endif # ifdef OPENSCENARIO_INTERPRETER_BUILDING_DLL # define OPENSCENARIO_INTERPRETER_PUBLIC OPENSCENARIO_INTERPRETER_EXPORT # else # define OPENSCENARIO_INTERPRETER_PUBLIC OPENSCENARIO_INTERPRETER_IMPORT # endif # define OPENSCENARIO_INTERPRETER_PUBLIC_TYPE OPENSCENARIO_INTERPRETER_PUBLIC # define OPENSCENARIO_INTERPRETER_LOCAL #else # define OPENSCENARIO_INTERPRETER_EXPORT __attribute__ ((visibility(\"default\"))) # define OPENSCENARIO_INTERPRETER_IMPORT # if __GNUC__ >= 4 # define OPENSCENARIO_INTERPRETER_PUBLIC __attribute__ ((visibility(\"default\"))) # define OPENSCENARIO_INTERPRETER_LOCAL __attribute__ ((visibility(\"hidden\"))) # else # define OPENSCENARIO_INTERPRETER_PUBLIC # define OPENSCENARIO_INTERPRETER_LOCAL # endif # define OPENSCENARIO_INTERPRETER_PUBLIC_TYPE #endif #ifdef __cplusplus } #endif #endif // OPENSCENARIO_INTERPRETER__UTILITY__VISIBILITY_H_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/visibility.h"},{"location":"package/openscenario_interpreter/markdown/Files/visibility_8h/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpreterutilityvisibilityh","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/utility/visibility.h"},{"location":"package/openscenario_interpreter/markdown/Files/visibility_8h/#defines","text":"Name OPENSCENARIO_INTERPRETER_PUBLIC_TYPE OPENSCENARIO_INTERPRETER_PUBLIC OPENSCENARIO_INTERPRETER_LOCAL OPENSCENARIO_INTERPRETER_IMPORT OPENSCENARIO_INTERPRETER_EXPORT","title":"Defines"},{"location":"package/openscenario_interpreter/markdown/Files/visibility_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_interpreter/markdown/Files/visibility_8h/#define-openscenario_interpreter_public_type","text":"#define OPENSCENARIO_INTERPRETER_PUBLIC_TYPE","title":"define OPENSCENARIO_INTERPRETER_PUBLIC_TYPE"},{"location":"package/openscenario_interpreter/markdown/Files/visibility_8h/#define-openscenario_interpreter_public","text":"#define OPENSCENARIO_INTERPRETER_PUBLIC","title":"define OPENSCENARIO_INTERPRETER_PUBLIC"},{"location":"package/openscenario_interpreter/markdown/Files/visibility_8h/#define-openscenario_interpreter_local","text":"#define OPENSCENARIO_INTERPRETER_LOCAL","title":"define OPENSCENARIO_INTERPRETER_LOCAL"},{"location":"package/openscenario_interpreter/markdown/Files/visibility_8h/#define-openscenario_interpreter_import","text":"#define OPENSCENARIO_INTERPRETER_IMPORT","title":"define OPENSCENARIO_INTERPRETER_IMPORT"},{"location":"package/openscenario_interpreter/markdown/Files/visibility_8h/#define-openscenario_interpreter_export","text":"#define OPENSCENARIO_INTERPRETER_EXPORT __attribute__ ((visibility(\"default\")))","title":"define OPENSCENARIO_INTERPRETER_EXPORT"},{"location":"package/openscenario_interpreter/markdown/Files/visibility_8h/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__UTILITY__VISIBILITY_H_ #define OPENSCENARIO_INTERPRETER__UTILITY__VISIBILITY_H_ #ifdef __cplusplus extern \"C\" { #endif // This logic was borrowed (then namespaced) from the examples on the gcc wiki: // https://gcc.gnu.org/wiki/Visibility #if defined _WIN32 || defined __CYGWIN__ # ifdef __GNUC__ # define OPENSCENARIO_INTERPRETER_EXPORT __attribute__ ((dllexport)) # define OPENSCENARIO_INTERPRETER_IMPORT __attribute__ ((dllimport)) # else # define OPENSCENARIO_INTERPRETER_EXPORT __declspec(dllexport) # define OPENSCENARIO_INTERPRETER_IMPORT __declspec(dllimport) # endif # ifdef OPENSCENARIO_INTERPRETER_BUILDING_DLL # define OPENSCENARIO_INTERPRETER_PUBLIC OPENSCENARIO_INTERPRETER_EXPORT # else # define OPENSCENARIO_INTERPRETER_PUBLIC OPENSCENARIO_INTERPRETER_IMPORT # endif # define OPENSCENARIO_INTERPRETER_PUBLIC_TYPE OPENSCENARIO_INTERPRETER_PUBLIC # define OPENSCENARIO_INTERPRETER_LOCAL #else # define OPENSCENARIO_INTERPRETER_EXPORT __attribute__ ((visibility(\"default\"))) # define OPENSCENARIO_INTERPRETER_IMPORT # if __GNUC__ >= 4 # define OPENSCENARIO_INTERPRETER_PUBLIC __attribute__ ((visibility(\"default\"))) # define OPENSCENARIO_INTERPRETER_LOCAL __attribute__ ((visibility(\"hidden\"))) # else # define OPENSCENARIO_INTERPRETER_PUBLIC # define OPENSCENARIO_INTERPRETER_LOCAL # endif # define OPENSCENARIO_INTERPRETER_PUBLIC_TYPE #endif #ifdef __cplusplus } #endif #endif // OPENSCENARIO_INTERPRETER__UTILITY__VISIBILITY_H_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/void__t_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/void_t.hpp # Namespaces # Name openscenario_interpreter::type_traits openscenario_interpreter Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__VOID_T_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__VOID_T_HPP_ #include <type_traits> namespace openscenario_interpreter { inline namespace type_traits { template < typename ... > using void_t = void ; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__VOID_T_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/void_t.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/void__t_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretertype_traitsvoid_thpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/type_traits/void_t.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/void__t_8hpp/#namespaces","text":"Name openscenario_interpreter::type_traits openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/void__t_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__TYPE_TRAITS__VOID_T_HPP_ #define OPENSCENARIO_INTERPRETER__TYPE_TRAITS__VOID_T_HPP_ #include <type_traits> namespace openscenario_interpreter { inline namespace type_traits { template < typename ... > using void_t = void ; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__TYPE_TRAITS__VOID_T_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/waypoint_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/waypoint.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::Waypoint Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__WAYPOINT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__WAYPOINT_HPP_ #include <openscenario_interpreter/syntax/position.hpp> #include <openscenario_interpreter/syntax/route_strategy.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- Waypoint --------------------------------------------------------------- * * <xsd:complexType name=\"Waypoint\"> * <xsd:sequence> * <xsd:element name=\"Position\" type=\"Position\"/> * </xsd:sequence> * <xsd:attribute name=\"routeStrategy\" type=\"RouteStrategy\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Waypoint { const RouteStrategy route_strategy ; const Position position ; template < typename Node , typename Scope > explicit Waypoint ( const Node & node , Scope & outer_scope ) : route_strategy ( readAttribute < RouteStrategy > ( \"routeStrategy\" , node , outer_scope )), position ( readElement < Position > ( \"Position\" , node , outer_scope )) {} explicit operator openscenario_msgs :: msg :: LaneletPose () const { auto convert = []( auto && position ) { return static_cast < openscenario_msgs :: msg :: LaneletPose > ( position ); }; return apply < openscenario_msgs :: msg :: LaneletPose > ( convert , position ); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__WAYPOINT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/waypoint.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/waypoint_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxwaypointhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/waypoint.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/waypoint_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/waypoint_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::Waypoint","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/waypoint_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__WAYPOINT_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__WAYPOINT_HPP_ #include <openscenario_interpreter/syntax/position.hpp> #include <openscenario_interpreter/syntax/route_strategy.hpp> #include <utility> namespace openscenario_interpreter { inline namespace syntax { /* ---- Waypoint --------------------------------------------------------------- * * <xsd:complexType name=\"Waypoint\"> * <xsd:sequence> * <xsd:element name=\"Position\" type=\"Position\"/> * </xsd:sequence> * <xsd:attribute name=\"routeStrategy\" type=\"RouteStrategy\" use=\"required\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct Waypoint { const RouteStrategy route_strategy ; const Position position ; template < typename Node , typename Scope > explicit Waypoint ( const Node & node , Scope & outer_scope ) : route_strategy ( readAttribute < RouteStrategy > ( \"routeStrategy\" , node , outer_scope )), position ( readElement < Position > ( \"Position\" , node , outer_scope )) {} explicit operator openscenario_msgs :: msg :: LaneletPose () const { auto convert = []( auto && position ) { return static_cast < openscenario_msgs :: msg :: LaneletPose > ( position ); }; return apply < openscenario_msgs :: msg :: LaneletPose > ( convert , position ); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__WAYPOINT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Files/world__position_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/world_position.hpp # Namespaces # Name openscenario_interpreter::syntax openscenario_interpreter Classes # Name struct openscenario_interpreter::syntax::WorldPosition Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__WORLD_POSITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__WORLD_POSITION_HPP_ #include <geometry_msgs/msg/pose.hpp> #include <geometry_msgs/msg/vector3.hpp> #include <openscenario_msgs/msg/lanelet_pose.hpp> #include <quaternion_operation/quaternion_operation.h> namespace openscenario_interpreter { inline namespace syntax { /* ---- WorldPosition ---------------------------------------------------------- * * <xsd:complexType name=\"WorldPosition\"> * <xsd:attribute name=\"x\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"y\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"z\" type=\"Double\" use=\"optional\"/> * <xsd:attribute name=\"h\" type=\"Double\" use=\"optional\"/> * <xsd:attribute name=\"p\" type=\"Double\" use=\"optional\"/> * <xsd:attribute name=\"r\" type=\"Double\" use=\"optional\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct WorldPosition { const Double x , y , z , h , p , r ; template < typename Node , typename Scope > explicit WorldPosition ( const Node & node , Scope & scope ) : x ( readAttribute < Double > ( \"x\" , node , scope )), y ( readAttribute < Double > ( \"y\" , node , scope )), z ( readAttribute < Double > ( \"z\" , node , scope , Double ())), h ( readAttribute < Double > ( \"h\" , node , scope , Double ())), // yaw p ( readAttribute < Double > ( \"p\" , node , scope , Double ())), r ( readAttribute < Double > ( \"r\" , node , scope , Double ())) {} explicit operator geometry_msgs :: msg :: Pose () const { geometry_msgs :: msg :: Vector3 vector {}; vector . x = r ; vector . y = p ; vector . z = h ; geometry_msgs :: msg :: Point point {}; point . x = x ; point . y = y ; point . z = z ; geometry_msgs :: msg :: Pose pose {}; pose . position = point ; pose . orientation = quaternion_operation :: convertEulerAngleToQuaternion ( vector ); return pose ; } explicit operator openscenario_msgs :: msg :: LaneletPose () const { THROW ( ImplementationFault ); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__WORLD_POSITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/world_position.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/world__position_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_interpreterincludeopenscenario_interpretersyntaxworld_positionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_interpreter/include/openscenario_interpreter/syntax/world_position.hpp"},{"location":"package/openscenario_interpreter/markdown/Files/world__position_8hpp/#namespaces","text":"Name openscenario_interpreter::syntax openscenario_interpreter","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Files/world__position_8hpp/#classes","text":"Name struct openscenario_interpreter::syntax::WorldPosition","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Files/world__position_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_INTERPRETER__SYNTAX__WORLD_POSITION_HPP_ #define OPENSCENARIO_INTERPRETER__SYNTAX__WORLD_POSITION_HPP_ #include <geometry_msgs/msg/pose.hpp> #include <geometry_msgs/msg/vector3.hpp> #include <openscenario_msgs/msg/lanelet_pose.hpp> #include <quaternion_operation/quaternion_operation.h> namespace openscenario_interpreter { inline namespace syntax { /* ---- WorldPosition ---------------------------------------------------------- * * <xsd:complexType name=\"WorldPosition\"> * <xsd:attribute name=\"x\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"y\" type=\"Double\" use=\"required\"/> * <xsd:attribute name=\"z\" type=\"Double\" use=\"optional\"/> * <xsd:attribute name=\"h\" type=\"Double\" use=\"optional\"/> * <xsd:attribute name=\"p\" type=\"Double\" use=\"optional\"/> * <xsd:attribute name=\"r\" type=\"Double\" use=\"optional\"/> * </xsd:complexType> * * -------------------------------------------------------------------------- */ struct WorldPosition { const Double x , y , z , h , p , r ; template < typename Node , typename Scope > explicit WorldPosition ( const Node & node , Scope & scope ) : x ( readAttribute < Double > ( \"x\" , node , scope )), y ( readAttribute < Double > ( \"y\" , node , scope )), z ( readAttribute < Double > ( \"z\" , node , scope , Double ())), h ( readAttribute < Double > ( \"h\" , node , scope , Double ())), // yaw p ( readAttribute < Double > ( \"p\" , node , scope , Double ())), r ( readAttribute < Double > ( \"r\" , node , scope , Double ())) {} explicit operator geometry_msgs :: msg :: Pose () const { geometry_msgs :: msg :: Vector3 vector {}; vector . x = r ; vector . y = p ; vector . z = h ; geometry_msgs :: msg :: Point point {}; point . x = x ; point . y = y ; point . z = z ; geometry_msgs :: msg :: Pose pose {}; pose . position = point ; pose . orientation = quaternion_operation :: convertEulerAngleToQuaternion ( vector ); return pose ; } explicit operator openscenario_msgs :: msg :: LaneletPose () const { THROW ( ImplementationFault ); } }; } } // namespace openscenario_interpreter #endif // OPENSCENARIO_INTERPRETER__SYNTAX__WORLD_POSITION_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_interpreter/markdown/Modules/","text":"Modules # Updated on 7 April 2021 at 00:31:57 UTC","title":"Modules"},{"location":"package/openscenario_interpreter/markdown/Modules/#modules","text":"Updated on 7 April 2021 at 00:31:57 UTC","title":"Modules"},{"location":"package/openscenario_interpreter/markdown/Namespaces/","text":"Namespaces # namespace openscenario_interpreter namespace concepts namespace console namespace background namespace foreground namespace functional namespace iterator namespace posix namespace reader namespace string namespace syntax namespace type_traits namespace utility Updated on 7 April 2021 at 00:31:57 UTC","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Namespaces/#namespaces","text":"namespace openscenario_interpreter namespace concepts namespace console namespace background namespace foreground namespace functional namespace iterator namespace posix namespace reader namespace string namespace syntax namespace type_traits namespace utility Updated on 7 April 2021 at 00:31:57 UTC","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/","text":"openscenario_interpreter # Namespaces # Name openscenario_interpreter::utility openscenario_interpreter::type_traits openscenario_interpreter::syntax openscenario_interpreter::string openscenario_interpreter::reader openscenario_interpreter::posix openscenario_interpreter::iterator openscenario_interpreter::functional openscenario_interpreter::console openscenario_interpreter::concepts Classes # Name struct openscenario_interpreter::Unspecified struct openscenario_interpreter::SyntaxError struct openscenario_interpreter::SemanticError struct openscenario_interpreter::Scope class openscenario_interpreter::Pointer class openscenario_interpreter::Interpreter struct openscenario_interpreter::ImplementationFault struct openscenario_interpreter::Expression struct openscenario_interpreter::Error struct openscenario_interpreter::ConnectionError Types # Name using std::is_default_constructible< Ts... > IsOptionalElement using Element Group using std::vector< Element > Elements using Pointer < Expression > Element using Element ComplexType Functions # Name template \\<typename ... Ts> decltype(auto) setController (Ts &&... xs) std::ostream & operator<< (std::ostream & os, const Unspecified & ) template \\<typename T ,typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Pointer < T > & pointer) template \\<typename T ,typename ... Ts> decltype(auto) constexpr make (Ts &&... xs) template \\<typename T > decltype(auto) constexpr make (T && x) template \\<typename ... Ts> decltype(auto) isReachedPosition (Ts &&... xs) template \\<typename ... Ts> decltype(auto) getRelativePose (Ts &&... xs) template \\<typename ... Ts> decltype(auto) getEntityStatus (Ts &&... xs) template \\<typename ... Ts> decltype(auto) connect (Ts &&... xs) STRIP_OPTIONAL (getBoundingBoxDistance , static_cast< value_type > 0) STRIP_OPTIONAL (getStandStillDuration , static_cast< value_type > 0) STRIP_OPTIONAL (getTimeHeadway , std::numeric_limits< value_type > ::quiet_NaN()) FORWARD_TO_SIMULATION_API (attachDetectionSensor ) FORWARD_TO_SIMULATION_API (attachLidarSensor ) FORWARD_TO_SIMULATION_API (checkCollision ) FORWARD_TO_SIMULATION_API (despawn ) FORWARD_TO_SIMULATION_API (getCurrentTime ) FORWARD_TO_SIMULATION_API (initialize ) FORWARD_TO_SIMULATION_API (isInLanelet ) FORWARD_TO_SIMULATION_API (requestAcquirePosition ) FORWARD_TO_SIMULATION_API (requestAssignRoute ) FORWARD_TO_SIMULATION_API (requestLaneChange ) FORWARD_TO_SIMULATION_API (requestWalkStraight ) FORWARD_TO_SIMULATION_API (setEntityStatus ) FORWARD_TO_SIMULATION_API (setTargetSpeed ) FORWARD_TO_SIMULATION_API (spawn ) FORWARD_TO_SIMULATION_API (toMapPose ) FORWARD_TO_SIMULATION_API (updateFrame ) Attributes # Name const Element unspecified std::aligned_storage< sizeof(scenario_simulator::API), alignof(scenario_simulator::API)>::type memory scenario_simulator::API & connection Types Documentation # using IsOptionalElement # using openscenario_interpreter :: IsOptionalElement = typedef std :: is_default_constructible < Ts ... > ; using Group # using openscenario_interpreter :: Group = typedef Element ; using Elements # using openscenario_interpreter :: Elements = typedef std :: vector < Element > ; using Element # using openscenario_interpreter :: Element = typedef Pointer < Expression > ; using ComplexType # using openscenario_interpreter :: ComplexType = typedef Element ; Functions Documentation # function setController # template < typename ... Ts > decltype ( auto ) setController ( Ts && ... xs ) function operator<< # std :: ostream & operator << ( std :: ostream & os , const Unspecified & ) function operator<< # template < typename T , typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Pointer < T > & pointer ) function make # template < typename T , typename ... Ts > inline decltype ( auto ) constexpr make ( Ts && ... xs ) function make # template < typename T > inline decltype ( auto ) constexpr make ( T && x ) function isReachedPosition # template < typename ... Ts > decltype ( auto ) isReachedPosition ( Ts && ... xs ) function getRelativePose # template < typename ... Ts > decltype ( auto ) getRelativePose ( Ts && ... xs ) function getEntityStatus # template < typename ... Ts > decltype ( auto ) getEntityStatus ( Ts && ... xs ) function connect # template < typename ... Ts > decltype ( auto ) connect ( Ts && ... xs ) function STRIP_OPTIONAL # STRIP_OPTIONAL ( getBoundingBoxDistance , static_cast < value_type > 0 ) function STRIP_OPTIONAL # STRIP_OPTIONAL ( getStandStillDuration , static_cast < value_type > 0 ) function STRIP_OPTIONAL # STRIP_OPTIONAL ( getTimeHeadway , std :: numeric_limits < value_type > :: quiet_NaN () ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( attachDetectionSensor ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( attachLidarSensor ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( checkCollision ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( despawn ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( getCurrentTime ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( initialize ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( isInLanelet ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( requestAcquirePosition ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( requestAssignRoute ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( requestLaneChange ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( requestWalkStraight ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( setEntityStatus ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( setTargetSpeed ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( spawn ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( toMapPose ) function FORWARD_TO_SIMULATION_API # FORWARD_TO_SIMULATION_API ( updateFrame ) Attributes Documentation # variable unspecified # const Element unspecified { make < [ Unspecified ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1Unspecified ) > () }; variable memory # static std :: aligned_storage < sizeof ( scenario_simulator :: API ), alignof ( scenario_simulator :: API ) >:: type memory ; variable connection # scenario_simulator :: API & connection { reinterpret_cast < scenario_simulator :: API &> ( memory ) }; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#openscenario_interpreter","text":"","title":"openscenario_interpreter"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#namespaces","text":"Name openscenario_interpreter::utility openscenario_interpreter::type_traits openscenario_interpreter::syntax openscenario_interpreter::string openscenario_interpreter::reader openscenario_interpreter::posix openscenario_interpreter::iterator openscenario_interpreter::functional openscenario_interpreter::console openscenario_interpreter::concepts","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#classes","text":"Name struct openscenario_interpreter::Unspecified struct openscenario_interpreter::SyntaxError struct openscenario_interpreter::SemanticError struct openscenario_interpreter::Scope class openscenario_interpreter::Pointer class openscenario_interpreter::Interpreter struct openscenario_interpreter::ImplementationFault struct openscenario_interpreter::Expression struct openscenario_interpreter::Error struct openscenario_interpreter::ConnectionError","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#types","text":"Name using std::is_default_constructible< Ts... > IsOptionalElement using Element Group using std::vector< Element > Elements using Pointer < Expression > Element using Element ComplexType","title":"Types"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#functions","text":"Name template \\<typename ... Ts> decltype(auto) setController (Ts &&... xs) std::ostream & operator<< (std::ostream & os, const Unspecified & ) template \\<typename T ,typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Pointer < T > & pointer) template \\<typename T ,typename ... Ts> decltype(auto) constexpr make (Ts &&... xs) template \\<typename T > decltype(auto) constexpr make (T && x) template \\<typename ... Ts> decltype(auto) isReachedPosition (Ts &&... xs) template \\<typename ... Ts> decltype(auto) getRelativePose (Ts &&... xs) template \\<typename ... Ts> decltype(auto) getEntityStatus (Ts &&... xs) template \\<typename ... Ts> decltype(auto) connect (Ts &&... xs) STRIP_OPTIONAL (getBoundingBoxDistance , static_cast< value_type > 0) STRIP_OPTIONAL (getStandStillDuration , static_cast< value_type > 0) STRIP_OPTIONAL (getTimeHeadway , std::numeric_limits< value_type > ::quiet_NaN()) FORWARD_TO_SIMULATION_API (attachDetectionSensor ) FORWARD_TO_SIMULATION_API (attachLidarSensor ) FORWARD_TO_SIMULATION_API (checkCollision ) FORWARD_TO_SIMULATION_API (despawn ) FORWARD_TO_SIMULATION_API (getCurrentTime ) FORWARD_TO_SIMULATION_API (initialize ) FORWARD_TO_SIMULATION_API (isInLanelet ) FORWARD_TO_SIMULATION_API (requestAcquirePosition ) FORWARD_TO_SIMULATION_API (requestAssignRoute ) FORWARD_TO_SIMULATION_API (requestLaneChange ) FORWARD_TO_SIMULATION_API (requestWalkStraight ) FORWARD_TO_SIMULATION_API (setEntityStatus ) FORWARD_TO_SIMULATION_API (setTargetSpeed ) FORWARD_TO_SIMULATION_API (spawn ) FORWARD_TO_SIMULATION_API (toMapPose ) FORWARD_TO_SIMULATION_API (updateFrame )","title":"Functions"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#attributes","text":"Name const Element unspecified std::aligned_storage< sizeof(scenario_simulator::API), alignof(scenario_simulator::API)>::type memory scenario_simulator::API & connection","title":"Attributes"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#types-documentation","text":"","title":"Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#using-isoptionalelement","text":"using openscenario_interpreter :: IsOptionalElement = typedef std :: is_default_constructible < Ts ... > ;","title":"using IsOptionalElement"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#using-group","text":"using openscenario_interpreter :: Group = typedef Element ;","title":"using Group"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#using-elements","text":"using openscenario_interpreter :: Elements = typedef std :: vector < Element > ;","title":"using Elements"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#using-element","text":"using openscenario_interpreter :: Element = typedef Pointer < Expression > ;","title":"using Element"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#using-complextype","text":"using openscenario_interpreter :: ComplexType = typedef Element ;","title":"using ComplexType"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-setcontroller","text":"template < typename ... Ts > decltype ( auto ) setController ( Ts && ... xs )","title":"function setController"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-operator","text":"std :: ostream & operator << ( std :: ostream & os , const Unspecified & )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-operator_1","text":"template < typename T , typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Pointer < T > & pointer )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-make","text":"template < typename T , typename ... Ts > inline decltype ( auto ) constexpr make ( Ts && ... xs )","title":"function make"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-make_1","text":"template < typename T > inline decltype ( auto ) constexpr make ( T && x )","title":"function make"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-isreachedposition","text":"template < typename ... Ts > decltype ( auto ) isReachedPosition ( Ts && ... xs )","title":"function isReachedPosition"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-getrelativepose","text":"template < typename ... Ts > decltype ( auto ) getRelativePose ( Ts && ... xs )","title":"function getRelativePose"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-getentitystatus","text":"template < typename ... Ts > decltype ( auto ) getEntityStatus ( Ts && ... xs )","title":"function getEntityStatus"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-connect","text":"template < typename ... Ts > decltype ( auto ) connect ( Ts && ... xs )","title":"function connect"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-strip_optional","text":"STRIP_OPTIONAL ( getBoundingBoxDistance , static_cast < value_type > 0 )","title":"function STRIP_OPTIONAL"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-strip_optional_1","text":"STRIP_OPTIONAL ( getStandStillDuration , static_cast < value_type > 0 )","title":"function STRIP_OPTIONAL"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-strip_optional_2","text":"STRIP_OPTIONAL ( getTimeHeadway , std :: numeric_limits < value_type > :: quiet_NaN () )","title":"function STRIP_OPTIONAL"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api","text":"FORWARD_TO_SIMULATION_API ( attachDetectionSensor )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api_1","text":"FORWARD_TO_SIMULATION_API ( attachLidarSensor )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api_2","text":"FORWARD_TO_SIMULATION_API ( checkCollision )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api_3","text":"FORWARD_TO_SIMULATION_API ( despawn )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api_4","text":"FORWARD_TO_SIMULATION_API ( getCurrentTime )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api_5","text":"FORWARD_TO_SIMULATION_API ( initialize )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api_6","text":"FORWARD_TO_SIMULATION_API ( isInLanelet )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api_7","text":"FORWARD_TO_SIMULATION_API ( requestAcquirePosition )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api_8","text":"FORWARD_TO_SIMULATION_API ( requestAssignRoute )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api_9","text":"FORWARD_TO_SIMULATION_API ( requestLaneChange )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api_10","text":"FORWARD_TO_SIMULATION_API ( requestWalkStraight )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api_11","text":"FORWARD_TO_SIMULATION_API ( setEntityStatus )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api_12","text":"FORWARD_TO_SIMULATION_API ( setTargetSpeed )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api_13","text":"FORWARD_TO_SIMULATION_API ( spawn )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api_14","text":"FORWARD_TO_SIMULATION_API ( toMapPose )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#function-forward_to_simulation_api_15","text":"FORWARD_TO_SIMULATION_API ( updateFrame )","title":"function FORWARD_TO_SIMULATION_API"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#variable-unspecified","text":"const Element unspecified { make < [ Unspecified ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1Unspecified ) > () };","title":"variable unspecified"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#variable-memory","text":"static std :: aligned_storage < sizeof ( scenario_simulator :: API ), alignof ( scenario_simulator :: API ) >:: type memory ;","title":"variable memory"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter/#variable-connection","text":"scenario_simulator :: API & connection { reinterpret_cast < scenario_simulator :: API &> ( memory ) }; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable connection"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1concepts/","text":"openscenario_interpreter::concepts # Classes # Name struct openscenario_interpreter::concepts::HasStreamOutputOperator< T, void_t< decltype(std::declval< std::ostream & >()<< std::declval< const T & >())> > struct openscenario_interpreter::concepts::HasStreamOutputOperator Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::concepts"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1concepts/#openscenario_interpreterconcepts","text":"","title":"openscenario_interpreter::concepts"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1concepts/#classes","text":"Name struct openscenario_interpreter::concepts::HasStreamOutputOperator< T, void_t< decltype(std::declval< std::ostream & >()<< std::declval< const T & >())> > struct openscenario_interpreter::concepts::HasStreamOutputOperator Updated on 7 April 2021 at 00:31:57 UTC","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/","text":"openscenario_interpreter::console # Namespaces # Name openscenario_interpreter::console::foreground openscenario_interpreter::console::background Functions # Name template \\<typename ... Ts> auto & escape_sequence (std::basic_ostream< Ts... > & os, const std::string & code) BOILERPLATE (\"[0m\" , reset ) BOILERPLATE (\"[1m\" , bold ) BOILERPLATE (\"[2m\" , faint ) BOILERPLATE (\"[3m\" , italic ) BOILERPLATE (\"[4m\" , underline ) BOILERPLATE (\"[5m\" , slow_blink ) BOILERPLATE (\"[6m\" , rapid_blink ) BOILERPLATE (\"[7m\" , reverse ) BOILERPLATE (\"[8m\" , conceal ) Attributes # Name auto is_console Functions Documentation # function escape_sequence # template < typename ... Ts > auto & escape_sequence ( std :: basic_ostream < Ts ... > & os , const std :: string & code ) function BOILERPLATE # BOILERPLATE ( \"[0m\" , reset ) function BOILERPLATE # BOILERPLATE ( \"[1m\" , bold ) function BOILERPLATE # BOILERPLATE ( \"[2m\" , faint ) function BOILERPLATE # BOILERPLATE ( \"[3m\" , italic ) function BOILERPLATE # BOILERPLATE ( \"[4m\" , underline ) function BOILERPLATE # BOILERPLATE ( \"[5m\" , slow_blink ) function BOILERPLATE # BOILERPLATE ( \"[6m\" , rapid_blink ) function BOILERPLATE # BOILERPLATE ( \"[7m\" , reverse ) function BOILERPLATE # BOILERPLATE ( \"[8m\" , conceal ) Attributes Documentation # variable is_console # auto is_console = []( const auto & os ) { if ( os . rdbuf () == std :: cout . rdbuf ()) { static const auto result { static_cast < bool > ( :: isatty ( STDOUT_FILENO ))}; return result ; } else if ( os . rdbuf () == std :: cerr . rdbuf ()) { static const auto result { static_cast < bool > ( :: isatty ( STDERR_FILENO ))}; return result ; } else { return false ; } }; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::console"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#openscenario_interpreterconsole","text":"","title":"openscenario_interpreter::console"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#namespaces","text":"Name openscenario_interpreter::console::foreground openscenario_interpreter::console::background","title":"Namespaces"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#functions","text":"Name template \\<typename ... Ts> auto & escape_sequence (std::basic_ostream< Ts... > & os, const std::string & code) BOILERPLATE (\"[0m\" , reset ) BOILERPLATE (\"[1m\" , bold ) BOILERPLATE (\"[2m\" , faint ) BOILERPLATE (\"[3m\" , italic ) BOILERPLATE (\"[4m\" , underline ) BOILERPLATE (\"[5m\" , slow_blink ) BOILERPLATE (\"[6m\" , rapid_blink ) BOILERPLATE (\"[7m\" , reverse ) BOILERPLATE (\"[8m\" , conceal )","title":"Functions"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#attributes","text":"Name auto is_console","title":"Attributes"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#function-escape_sequence","text":"template < typename ... Ts > auto & escape_sequence ( std :: basic_ostream < Ts ... > & os , const std :: string & code )","title":"function escape_sequence"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#function-boilerplate","text":"BOILERPLATE ( \"[0m\" , reset )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#function-boilerplate_1","text":"BOILERPLATE ( \"[1m\" , bold )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#function-boilerplate_2","text":"BOILERPLATE ( \"[2m\" , faint )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#function-boilerplate_3","text":"BOILERPLATE ( \"[3m\" , italic )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#function-boilerplate_4","text":"BOILERPLATE ( \"[4m\" , underline )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#function-boilerplate_5","text":"BOILERPLATE ( \"[5m\" , slow_blink )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#function-boilerplate_6","text":"BOILERPLATE ( \"[6m\" , rapid_blink )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#function-boilerplate_7","text":"BOILERPLATE ( \"[7m\" , reverse )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#function-boilerplate_8","text":"BOILERPLATE ( \"[8m\" , conceal )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console/#variable-is_console","text":"auto is_console = []( const auto & os ) { if ( os . rdbuf () == std :: cout . rdbuf ()) { static const auto result { static_cast < bool > ( :: isatty ( STDOUT_FILENO ))}; return result ; } else if ( os . rdbuf () == std :: cerr . rdbuf ()) { static const auto result { static_cast < bool > ( :: isatty ( STDERR_FILENO ))}; return result ; } else { return false ; } }; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable is_console"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1background/","text":"openscenario_interpreter::console::background # Functions # Name BOILERPLATE (\"[40m\" , black ) BOILERPLATE (\"[41m\" , red ) BOILERPLATE (\"[42m\" , green ) BOILERPLATE (\"[43m\" , yellow ) BOILERPLATE (\"[44m\" , blue ) BOILERPLATE (\"[45m\" , magenta ) BOILERPLATE (\"[46m\" , cyan ) BOILERPLATE (\"[47m\" , white ) Functions Documentation # function BOILERPLATE # BOILERPLATE ( \"[40m\" , black ) function BOILERPLATE # BOILERPLATE ( \"[41m\" , red ) function BOILERPLATE # BOILERPLATE ( \"[42m\" , green ) function BOILERPLATE # BOILERPLATE ( \"[43m\" , yellow ) function BOILERPLATE # BOILERPLATE ( \"[44m\" , blue ) function BOILERPLATE # BOILERPLATE ( \"[45m\" , magenta ) function BOILERPLATE # BOILERPLATE ( \"[46m\" , cyan ) function BOILERPLATE # BOILERPLATE ( \"[47m\" , white ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::console::background"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1background/#openscenario_interpreterconsolebackground","text":"","title":"openscenario_interpreter::console::background"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1background/#functions","text":"Name BOILERPLATE (\"[40m\" , black ) BOILERPLATE (\"[41m\" , red ) BOILERPLATE (\"[42m\" , green ) BOILERPLATE (\"[43m\" , yellow ) BOILERPLATE (\"[44m\" , blue ) BOILERPLATE (\"[45m\" , magenta ) BOILERPLATE (\"[46m\" , cyan ) BOILERPLATE (\"[47m\" , white )","title":"Functions"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1background/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1background/#function-boilerplate","text":"BOILERPLATE ( \"[40m\" , black )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1background/#function-boilerplate_1","text":"BOILERPLATE ( \"[41m\" , red )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1background/#function-boilerplate_2","text":"BOILERPLATE ( \"[42m\" , green )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1background/#function-boilerplate_3","text":"BOILERPLATE ( \"[43m\" , yellow )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1background/#function-boilerplate_4","text":"BOILERPLATE ( \"[44m\" , blue )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1background/#function-boilerplate_5","text":"BOILERPLATE ( \"[45m\" , magenta )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1background/#function-boilerplate_6","text":"BOILERPLATE ( \"[46m\" , cyan )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1background/#function-boilerplate_7","text":"BOILERPLATE ( \"[47m\" , white ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1foreground/","text":"openscenario_interpreter::console::foreground # Functions # Name BOILERPLATE (\"[30m\" , black ) BOILERPLATE (\"[31m\" , red ) BOILERPLATE (\"[32m\" , green ) BOILERPLATE (\"[33m\" , yellow ) BOILERPLATE (\"[34m\" , blue ) BOILERPLATE (\"[35m\" , magenta ) BOILERPLATE (\"[36m\" , cyan ) BOILERPLATE (\"[37m\" , white ) Functions Documentation # function BOILERPLATE # BOILERPLATE ( \"[30m\" , black ) function BOILERPLATE # BOILERPLATE ( \"[31m\" , red ) function BOILERPLATE # BOILERPLATE ( \"[32m\" , green ) function BOILERPLATE # BOILERPLATE ( \"[33m\" , yellow ) function BOILERPLATE # BOILERPLATE ( \"[34m\" , blue ) function BOILERPLATE # BOILERPLATE ( \"[35m\" , magenta ) function BOILERPLATE # BOILERPLATE ( \"[36m\" , cyan ) function BOILERPLATE # BOILERPLATE ( \"[37m\" , white ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::console::foreground"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1foreground/#openscenario_interpreterconsoleforeground","text":"","title":"openscenario_interpreter::console::foreground"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1foreground/#functions","text":"Name BOILERPLATE (\"[30m\" , black ) BOILERPLATE (\"[31m\" , red ) BOILERPLATE (\"[32m\" , green ) BOILERPLATE (\"[33m\" , yellow ) BOILERPLATE (\"[34m\" , blue ) BOILERPLATE (\"[35m\" , magenta ) BOILERPLATE (\"[36m\" , cyan ) BOILERPLATE (\"[37m\" , white )","title":"Functions"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1foreground/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1foreground/#function-boilerplate","text":"BOILERPLATE ( \"[30m\" , black )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1foreground/#function-boilerplate_1","text":"BOILERPLATE ( \"[31m\" , red )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1foreground/#function-boilerplate_2","text":"BOILERPLATE ( \"[32m\" , green )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1foreground/#function-boilerplate_3","text":"BOILERPLATE ( \"[33m\" , yellow )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1foreground/#function-boilerplate_4","text":"BOILERPLATE ( \"[34m\" , blue )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1foreground/#function-boilerplate_5","text":"BOILERPLATE ( \"[35m\" , magenta )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1foreground/#function-boilerplate_6","text":"BOILERPLATE ( \"[36m\" , cyan )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1console_1_1foreground/#function-boilerplate_7","text":"BOILERPLATE ( \"[37m\" , white ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1functional/","text":"openscenario_interpreter::functional # Functions # Name template \\<typename F ,typename T > decltype(auto) constexpr fold_right (F && , T && x) template \\<typename F ,typename T ,typename ... Ts> decltype(auto) constexpr fold_right (F && f, T && x, Ts &&... xs) template \\<typename F ,typename T > decltype(auto) constexpr fold_left (F && , T && x) template \\<typename F ,typename T ,typename U ,typename ... Ts> decltype(auto) constexpr fold_left (F && f, T && x, U && y, Ts &&... xs) Functions Documentation # function fold_right # template < typename F , typename T > decltype ( auto ) constexpr fold_right ( F && , T && x ) function fold_right # template < typename F , typename T , typename ... Ts > decltype ( auto ) constexpr fold_right ( F && f , T && x , Ts && ... xs ) function fold_left # template < typename F , typename T > decltype ( auto ) constexpr fold_left ( F && , T && x ) function fold_left # template < typename F , typename T , typename U , typename ... Ts > decltype ( auto ) constexpr fold_left ( F && f , T && x , U && y , Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::functional"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1functional/#openscenario_interpreterfunctional","text":"","title":"openscenario_interpreter::functional"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1functional/#functions","text":"Name template \\<typename F ,typename T > decltype(auto) constexpr fold_right (F && , T && x) template \\<typename F ,typename T ,typename ... Ts> decltype(auto) constexpr fold_right (F && f, T && x, Ts &&... xs) template \\<typename F ,typename T > decltype(auto) constexpr fold_left (F && , T && x) template \\<typename F ,typename T ,typename U ,typename ... Ts> decltype(auto) constexpr fold_left (F && f, T && x, U && y, Ts &&... xs)","title":"Functions"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1functional/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1functional/#function-fold_right","text":"template < typename F , typename T > decltype ( auto ) constexpr fold_right ( F && , T && x )","title":"function fold_right"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1functional/#function-fold_right_1","text":"template < typename F , typename T , typename ... Ts > decltype ( auto ) constexpr fold_right ( F && f , T && x , Ts && ... xs )","title":"function fold_right"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1functional/#function-fold_left","text":"template < typename F , typename T > decltype ( auto ) constexpr fold_left ( F && , T && x )","title":"function fold_left"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1functional/#function-fold_left_1","text":"template < typename F , typename T , typename U , typename ... Ts > decltype ( auto ) constexpr fold_left ( F && f , T && x , U && y , Ts && ... xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function fold_left"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1iterator/","text":"openscenario_interpreter::iterator # Functions # Name template \\<typename T > auto size (const T & range) Functions Documentation # function size # template < typename T > auto size ( const T & range ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::iterator"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1iterator/#openscenario_interpreteriterator","text":"","title":"openscenario_interpreter::iterator"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1iterator/#functions","text":"Name template \\<typename T > auto size (const T & range)","title":"Functions"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1iterator/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1iterator/#function-size","text":"template < typename T > auto size ( const T & range ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function size"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1posix/","text":"openscenario_interpreter::posix # Functions # Name auto fork_exec (const std::vector< std::string > & f_xs) auto fork_exec (const std::string & f_xs) auto fork_exec (const std::string & f, const std::string & xs) auto execvp (const std::vector< std::string > & f_xs) Functions Documentation # function fork_exec # auto fork_exec ( const std :: vector < std :: string > & f_xs ) function fork_exec # auto fork_exec ( const std :: string & f_xs ) function fork_exec # auto fork_exec ( const std :: string & f , const std :: string & xs ) function execvp # auto execvp ( const std :: vector < std :: string > & f_xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::posix"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1posix/#openscenario_interpreterposix","text":"","title":"openscenario_interpreter::posix"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1posix/#functions","text":"Name auto fork_exec (const std::vector< std::string > & f_xs) auto fork_exec (const std::string & f_xs) auto fork_exec (const std::string & f, const std::string & xs) auto execvp (const std::vector< std::string > & f_xs)","title":"Functions"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1posix/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1posix/#function-fork_exec","text":"auto fork_exec ( const std :: vector < std :: string > & f_xs )","title":"function fork_exec"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1posix/#function-fork_exec_1","text":"auto fork_exec ( const std :: string & f_xs )","title":"function fork_exec"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1posix/#function-fork_exec_2","text":"auto fork_exec ( const std :: string & f , const std :: string & xs )","title":"function fork_exec"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1posix/#function-execvp","text":"auto execvp ( const std :: vector < std :: string > & f_xs ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function execvp"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1reader/","text":"openscenario_interpreter::reader # Functions # Name template \\<typename Scope > auto substitute (std::string attribute, Scope & scope) template \\<typename T ,typename Node ,typename ... Ts> auto readElement (const std::string & name, const Node & parent, Ts &&... xs) template \\<typename T ,typename Node ,typename Scope > T readContent (const Node & node, const Scope & ) template \\<typename T ,typename Node ,typename Scope > T readAttribute (const std::string & name, const Node & node, const Scope & scope) template \\<typename T ,typename Node ,typename Scope > T readAttribute (const std::string & name, const Node & node, const Scope & scope, T && value) template \\<typename Node ,typename ... Ts> decltype(auto) choice (const Node & node, Ts &&... xs) template \\<typename Node ,typename Callee > void callWithElements (const Node & parent, const std::string & name, typename std::iterator_traits< typename Node::iterator >::difference_type min_occurs, typename std::iterator_traits< typename Node::iterator >::difference_type max_occurs, Callee && call_with) template \\<typename Callee > decltype(auto) callWithElement (const pugi::xml_node & parent, const std::string & name, Callee && call_with) Attributes # Name constexpr auto unbounded Functions Documentation # function substitute # template < typename Scope > auto substitute ( std :: string attribute , Scope & scope ) function readElement # template < typename T , typename Node , typename ... Ts > auto readElement ( const std :: string & name , const Node & parent , Ts && ... xs ) function readContent # template < typename T , typename Node , typename Scope > T readContent ( const Node & node , const Scope & ) function readAttribute # template < typename T , typename Node , typename Scope > T readAttribute ( const std :: string & name , const Node & node , const Scope & scope ) function readAttribute # template < typename T , typename Node , typename Scope > T readAttribute ( const std :: string & name , const Node & node , const Scope & scope , T && value ) function choice # template < typename Node , typename ... Ts > decltype ( auto ) choice ( const Node & node , Ts && ... xs ) function callWithElements # template < typename Node , typename Callee > void callWithElements ( const Node & parent , const std :: string & name , typename std :: iterator_traits < typename Node :: iterator >:: difference_type min_occurs , typename std :: iterator_traits < typename Node :: iterator >:: difference_type max_occurs , Callee && call_with ) function callWithElement # template < typename Callee > decltype ( auto ) callWithElement ( const pugi :: xml_node & parent , const std :: string & name , Callee && call_with ) Attributes Documentation # variable unbounded # constexpr auto unbounded { std :: numeric_limits < typename std :: iterator_traits < typename pugi :: xml_node :: iterator >:: difference_type >:: max () }; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::reader"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1reader/#openscenario_interpreterreader","text":"","title":"openscenario_interpreter::reader"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1reader/#functions","text":"Name template \\<typename Scope > auto substitute (std::string attribute, Scope & scope) template \\<typename T ,typename Node ,typename ... Ts> auto readElement (const std::string & name, const Node & parent, Ts &&... xs) template \\<typename T ,typename Node ,typename Scope > T readContent (const Node & node, const Scope & ) template \\<typename T ,typename Node ,typename Scope > T readAttribute (const std::string & name, const Node & node, const Scope & scope) template \\<typename T ,typename Node ,typename Scope > T readAttribute (const std::string & name, const Node & node, const Scope & scope, T && value) template \\<typename Node ,typename ... Ts> decltype(auto) choice (const Node & node, Ts &&... xs) template \\<typename Node ,typename Callee > void callWithElements (const Node & parent, const std::string & name, typename std::iterator_traits< typename Node::iterator >::difference_type min_occurs, typename std::iterator_traits< typename Node::iterator >::difference_type max_occurs, Callee && call_with) template \\<typename Callee > decltype(auto) callWithElement (const pugi::xml_node & parent, const std::string & name, Callee && call_with)","title":"Functions"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1reader/#attributes","text":"Name constexpr auto unbounded","title":"Attributes"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1reader/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1reader/#function-substitute","text":"template < typename Scope > auto substitute ( std :: string attribute , Scope & scope )","title":"function substitute"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1reader/#function-readelement","text":"template < typename T , typename Node , typename ... Ts > auto readElement ( const std :: string & name , const Node & parent , Ts && ... xs )","title":"function readElement"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1reader/#function-readcontent","text":"template < typename T , typename Node , typename Scope > T readContent ( const Node & node , const Scope & )","title":"function readContent"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1reader/#function-readattribute","text":"template < typename T , typename Node , typename Scope > T readAttribute ( const std :: string & name , const Node & node , const Scope & scope )","title":"function readAttribute"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1reader/#function-readattribute_1","text":"template < typename T , typename Node , typename Scope > T readAttribute ( const std :: string & name , const Node & node , const Scope & scope , T && value )","title":"function readAttribute"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1reader/#function-choice","text":"template < typename Node , typename ... Ts > decltype ( auto ) choice ( const Node & node , Ts && ... xs )","title":"function choice"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1reader/#function-callwithelements","text":"template < typename Node , typename Callee > void callWithElements ( const Node & parent , const std :: string & name , typename std :: iterator_traits < typename Node :: iterator >:: difference_type min_occurs , typename std :: iterator_traits < typename Node :: iterator >:: difference_type max_occurs , Callee && call_with )","title":"function callWithElements"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1reader/#function-callwithelement","text":"template < typename Callee > decltype ( auto ) callWithElement ( const pugi :: xml_node & parent , const std :: string & name , Callee && call_with )","title":"function callWithElement"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1reader/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1reader/#variable-unbounded","text":"constexpr auto unbounded { std :: numeric_limits < typename std :: iterator_traits < typename pugi :: xml_node :: iterator >:: difference_type >:: max () }; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable unbounded"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1string/","text":"openscenario_interpreter::string # Functions # Name auto split (const std::string & target) Attributes # Name auto cat Functions Documentation # function split # auto split ( const std :: string & target ) Attributes Documentation # variable cat # auto cat = []( auto && ... xs ) { std :: stringstream ss {}; auto write = []( auto && os , auto && x ) { os . get () << x ; return std :: forward < decltype ( os ) > ( os ); }; fold_left ( write , std :: ref ( ss ), std :: forward < decltype ( xs ) > ( xs )...); return ss . str (); }; Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_interpreter::string"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1string/#openscenario_interpreterstring","text":"","title":"openscenario_interpreter::string"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1string/#functions","text":"Name auto split (const std::string & target)","title":"Functions"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1string/#attributes","text":"Name auto cat","title":"Attributes"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1string/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1string/#function-split","text":"auto split ( const std :: string & target )","title":"function split"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1string/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1string/#variable-cat","text":"auto cat = []( auto && ... xs ) { std :: stringstream ss {}; auto write = []( auto && os , auto && x ) { os . get () << x ; return std :: forward < decltype ( os ) > ( os ); }; fold_left ( write , std :: ref ( ss ), std :: forward < decltype ( xs ) > ( xs )...); return ss . str (); }; Updated on 7 April 2021 at 00:31:57 UTC","title":"variable cat"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/","text":"openscenario_interpreter::syntax # Classes # Name struct openscenario_interpreter::syntax::equal_to< T, typename std::enable_if< std::is_floating_point< T >::value >::type > struct openscenario_interpreter::syntax::equal_to struct openscenario_interpreter::syntax::WorldPosition struct openscenario_interpreter::syntax::Waypoint struct openscenario_interpreter::syntax::VehicleCategory struct openscenario_interpreter::syntax::Vehicle struct openscenario_interpreter::syntax::UserDefinedAction struct openscenario_interpreter::syntax::UnsignedShort struct openscenario_interpreter::syntax::UnsignedInteger struct openscenario_interpreter::syntax::TriggeringEntitiesRule struct openscenario_interpreter::syntax::TriggeringEntities struct openscenario_interpreter::syntax::Trigger struct openscenario_interpreter::syntax::TransitionDynamics struct openscenario_interpreter::syntax::TrafficSignals struct openscenario_interpreter::syntax::TrafficSignalStateAction struct openscenario_interpreter::syntax::TrafficSignalState struct openscenario_interpreter::syntax::TrafficSignalController struct openscenario_interpreter::syntax::TrafficSignalCondition struct openscenario_interpreter::syntax::TrafficSignalAction struct openscenario_interpreter::syntax::TimeHeadwayCondition struct openscenario_interpreter::syntax::TeleportAction struct openscenario_interpreter::syntax::StoryboardElementType struct openscenario_interpreter::syntax::StoryboardElementStateCondition struct openscenario_interpreter::syntax::StoryboardElementState class openscenario_interpreter::syntax::StoryboardElement struct openscenario_interpreter::syntax::Storyboard struct openscenario_interpreter::syntax::Story struct openscenario_interpreter::syntax::StandStillCondition struct openscenario_interpreter::syntax::SpeedTargetValueType struct openscenario_interpreter::syntax::SpeedCondition struct openscenario_interpreter::syntax::SpeedActionTarget struct openscenario_interpreter::syntax::SpeedAction struct openscenario_interpreter::syntax::SimulationTimeCondition struct openscenario_interpreter::syntax::SelectedEntities struct openscenario_interpreter::syntax::ScenarioObject struct openscenario_interpreter::syntax::ScenarioDefinition struct openscenario_interpreter::syntax::Rule struct openscenario_interpreter::syntax::RoutingAction struct openscenario_interpreter::syntax::RouteStrategy struct openscenario_interpreter::syntax::Route struct openscenario_interpreter::syntax::RoadNetwork struct openscenario_interpreter::syntax::RelativeWorldPosition struct openscenario_interpreter::syntax::RelativeTargetSpeed struct openscenario_interpreter::syntax::RelativeDistanceType struct openscenario_interpreter::syntax::RelativeDistanceCondition struct openscenario_interpreter::syntax::ReferenceContext struct openscenario_interpreter::syntax::RearAxle struct openscenario_interpreter::syntax::ReachPositionCondition struct openscenario_interpreter::syntax::Property struct openscenario_interpreter::syntax::Properties struct openscenario_interpreter::syntax::PrivateAction struct openscenario_interpreter::syntax::Private struct openscenario_interpreter::syntax::Priority struct openscenario_interpreter::syntax::Position struct openscenario_interpreter::syntax::Phase struct openscenario_interpreter::syntax::Performance struct openscenario_interpreter::syntax::PedestrianCategory struct openscenario_interpreter::syntax::Pedestrian struct openscenario_interpreter::syntax::ParameterType struct openscenario_interpreter::syntax::ParameterSetAction struct openscenario_interpreter::syntax::ParameterMultiplyByValueRule struct openscenario_interpreter::syntax::ParameterModifyAction struct openscenario_interpreter::syntax::ParameterDeclarations struct openscenario_interpreter::syntax::ParameterDeclaration struct openscenario_interpreter::syntax::ParameterCondition struct openscenario_interpreter::syntax::ParameterAddValueRule struct openscenario_interpreter::syntax::ParameterAction struct openscenario_interpreter::syntax::OverrideControllerValueAction struct openscenario_interpreter::syntax::Orientation struct openscenario_interpreter::syntax::OpenScenario struct openscenario_interpreter::syntax::ObjectType struct openscenario_interpreter::syntax::ObjectController struct openscenario_interpreter::syntax::ModifyRule struct openscenario_interpreter::syntax::ManeuverGroup struct openscenario_interpreter::syntax::Maneuver struct openscenario_interpreter::syntax::LongitudinalAction struct openscenario_interpreter::syntax::LateralAction struct openscenario_interpreter::syntax::LanePosition struct openscenario_interpreter::syntax::LaneChangeTarget struct openscenario_interpreter::syntax::LaneChangeAction struct openscenario_interpreter::syntax::Integer struct openscenario_interpreter::syntax::InitActions struct openscenario_interpreter::syntax::Init struct openscenario_interpreter::syntax::InfrastructureAction struct openscenario_interpreter::syntax::GlobalAction struct openscenario_interpreter::syntax::FrontAxle struct openscenario_interpreter::syntax::FileHeader struct openscenario_interpreter::syntax::File struct openscenario_interpreter::syntax::Event struct openscenario_interpreter::syntax::EntitySelection struct openscenario_interpreter::syntax::EntityRef struct openscenario_interpreter::syntax::EntityObject struct openscenario_interpreter::syntax::EntityCondition struct openscenario_interpreter::syntax::EntityAction struct openscenario_interpreter::syntax::Entities struct openscenario_interpreter::syntax::DynamicsShape struct openscenario_interpreter::syntax::DynamicsDimension struct openscenario_interpreter::syntax::Double struct openscenario_interpreter::syntax::DistanceCondition struct openscenario_interpreter::syntax::Directory struct openscenario_interpreter::syntax::Dimensions struct openscenario_interpreter::syntax::DeleteEntityAction struct openscenario_interpreter::syntax::CustomCommandAction struct openscenario_interpreter::syntax::ControllerAction struct openscenario_interpreter::syntax::Controller struct openscenario_interpreter::syntax::ConditionGroup struct openscenario_interpreter::syntax::ConditionEdge struct openscenario_interpreter::syntax::Condition struct openscenario_interpreter::syntax::Command struct openscenario_interpreter::syntax::CollisionCondition struct openscenario_interpreter::syntax::Center struct openscenario_interpreter::syntax::CatalogLocations struct openscenario_interpreter::syntax::CatalogLocation struct openscenario_interpreter::syntax::ByValueCondition struct openscenario_interpreter::syntax::ByType struct openscenario_interpreter::syntax::ByEntityCondition struct openscenario_interpreter::syntax::BoundingBox struct openscenario_interpreter::syntax::Boolean struct openscenario_interpreter::syntax::Axles struct openscenario_interpreter::syntax::Axle struct openscenario_interpreter::syntax::AssignRouteAction struct openscenario_interpreter::syntax::AssignControllerAction struct openscenario_interpreter::syntax::AdditionalAxle struct openscenario_interpreter::syntax::AddEntityAction struct openscenario_interpreter::syntax::Actors struct openscenario_interpreter::syntax::Action struct openscenario_interpreter::syntax::Act struct openscenario_interpreter::syntax::AcquirePositionAction struct openscenario_interpreter::syntax::AccelerationCondition struct openscenario_interpreter::syntax::AbsoluteTargetSpeed struct openscenario_interpreter::syntax::AbsoluteTargetLane Types # Name using UnsignedInteger UnsignedInt using std::string String using Properties DefaultController Functions # Name std::istream & operator>> (std::istream & is, Boolean & boolean) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, Command & command) std::istream & operator>> (std::istream & is, ConditionEdge & edge) std::istream & operator>> (std::istream & is, Double & rhs) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, DynamicsDimension & dimension) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, DynamicsShape & shape) std::istream & operator>> (std::istream & is, Integer & rhs) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, ParameterType & type) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, PedestrianCategory & category) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, Priority & priority) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, ReferenceContext & context) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, RelativeDistanceType & type) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, RouteStrategy & strategy) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, Rule & rule) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, SpeedTargetValueType & type) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, StoryboardElementState & state) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, StoryboardElementType & type) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, TriggeringEntitiesRule & rule) template \\<typename ... Ts> decltype(auto) operator>> (std::basic_istream< Ts... > & is, UnsignedInteger & rhs) template \\<typename ... Ts> decltype(auto) operator>> (std::basic_istream< Ts... > & is, UnsignedShort & rhs) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, VehicleCategory & category) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Axles & rhs) std::ostream & operator<< (std::ostream & os, const Boolean & boolean) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const BoundingBox & rhs) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Center & rhs) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Command & command) std::ostream & operator<< (std::ostream & os, const ConditionEdge & edge) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Dimensions & rhs) std::ostream & operator<< (std::ostream & os, const Double & rhs) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const DynamicsDimension & dimension) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const DynamicsShape & shape) std::ostream & operator<< (std::ostream & os, const Integer & rhs) std::ostream & operator<< (std::ostream & os, const ScenarioDefinition & ) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const OpenScenario & ) std::ostream & operator<< (std::ostream & os, const ParameterDeclaration & declaration) std::ostream & operator<< (std::ostream & os, const ParameterDeclarations & ) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const ParameterType & type) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Pedestrian & rhs) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const PedestrianCategory & category) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Performance & rhs) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Priority & priority) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const ReferenceContext & context) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const RelativeDistanceType & type) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const RouteStrategy & strategy) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Rule & rule) std::ostream & operator<< (std::ostream & os, const ScenarioObject & datum) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const SpeedTargetValueType & type) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const StoryboardElementState & state) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const StoryboardElementType & type) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const TriggeringEntitiesRule & rule) template \\<typename ... Ts> decltype(auto) operator<< (std::basic_ostream< Ts... > & os, const UnsignedInteger & rhs) template \\<typename ... Ts> decltype(auto) operator<< (std::basic_ostream< Ts... > & os, const UnsignedShort & rhs) std::ostream & operator<< (std::ostream & os, const Vehicle & rhs) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const VehicleCategory & category) auto asBoolean (bool value) template \\<typename R =void,typename F ,typename ... Ts> decltype(auto) apply (F && f, const Position & position, Ts &&... xs) BOILERPLATE ( Axle ) BOILERPLATE ( FrontAxle ) BOILERPLATE ( RearAxle ) BOILERPLATE ( AdditionalAxle ) ASSERT_DEFAULT_CONSTRUCTIBLE ( File ) ASSERT_DEFAULT_CONSTRUCTIBLE ( TrafficSignals ) Attributes # Name const auto true_v const auto stop_transition const auto start_transition const auto standby_state const auto skip_transition const auto running_state const auto false_v const auto end_transition const auto complete_state Types Documentation # using UnsignedInt # using openscenario_interpreter :: syntax :: UnsignedInt = typedef UnsignedInteger ; using String # using openscenario_interpreter :: syntax :: String = typedef std :: string ; using DefaultController # using openscenario_interpreter :: syntax :: DefaultController = typedef Properties ; Functions Documentation # function operator>> # std :: istream & operator >> ( std :: istream & is , Boolean & boolean ) function operator>> # template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , Command & command ) function operator>> # std :: istream & operator >> ( std :: istream & is , ConditionEdge & edge ) function operator>> # std :: istream & operator >> ( std :: istream & is , Double & rhs ) function operator>> # template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , DynamicsDimension & dimension ) function operator>> # template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , DynamicsShape & shape ) function operator>> # std :: istream & operator >> ( std :: istream & is , Integer & rhs ) function operator>> # template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , ParameterType & type ) function operator>> # template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , PedestrianCategory & category ) function operator>> # template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , Priority & priority ) function operator>> # template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , ReferenceContext & context ) function operator>> # template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , RelativeDistanceType & type ) function operator>> # template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , RouteStrategy & strategy ) function operator>> # template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , Rule & rule ) function operator>> # template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , SpeedTargetValueType & type ) function operator>> # template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , StoryboardElementState & state ) function operator>> # template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , StoryboardElementType & type ) function operator>> # template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , TriggeringEntitiesRule & rule ) function operator>> # template < typename ... Ts > decltype ( auto ) operator >> ( std :: basic_istream < Ts ... > & is , UnsignedInteger & rhs ) function operator>> # template < typename ... Ts > decltype ( auto ) operator >> ( std :: basic_istream < Ts ... > & is , UnsignedShort & rhs ) function operator>> # template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , VehicleCategory & category ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Axles & rhs ) function operator<< # std :: ostream & operator << ( std :: ostream & os , const Boolean & boolean ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const BoundingBox & rhs ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Center & rhs ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Command & command ) function operator<< # std :: ostream & operator << ( std :: ostream & os , const ConditionEdge & edge ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Dimensions & rhs ) function operator<< # std :: ostream & operator << ( std :: ostream & os , const Double & rhs ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const DynamicsDimension & dimension ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const DynamicsShape & shape ) function operator<< # std :: ostream & operator << ( std :: ostream & os , const Integer & rhs ) function operator<< # std :: ostream & operator << ( std :: ostream & os , const ScenarioDefinition & ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const OpenScenario & ) function operator<< # std :: ostream & operator << ( std :: ostream & os , const ParameterDeclaration & declaration ) function operator<< # std :: ostream & operator << ( std :: ostream & os , const ParameterDeclarations & ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const ParameterType & type ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Pedestrian & rhs ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const PedestrianCategory & category ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Performance & rhs ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Priority & priority ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const ReferenceContext & context ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const RelativeDistanceType & type ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const RouteStrategy & strategy ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Rule & rule ) function operator<< # std :: ostream & operator << ( std :: ostream & os , const ScenarioObject & datum ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const SpeedTargetValueType & type ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const StoryboardElementState & state ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const StoryboardElementType & type ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const TriggeringEntitiesRule & rule ) function operator<< # template < typename ... Ts > decltype ( auto ) operator << ( std :: basic_ostream < Ts ... > & os , const UnsignedInteger & rhs ) function operator<< # template < typename ... Ts > decltype ( auto ) operator << ( std :: basic_ostream < Ts ... > & os , const UnsignedShort & rhs ) function operator<< # std :: ostream & operator << ( std :: ostream & os , const Vehicle & rhs ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const VehicleCategory & category ) function asBoolean # auto asBoolean ( bool value ) function apply # template < typename R = void , typename F , typename ... Ts > decltype ( auto ) apply ( F && f , const Position & position , Ts && ... xs ) function BOILERPLATE # BOILERPLATE ( Axle ) function BOILERPLATE # BOILERPLATE ( FrontAxle ) function BOILERPLATE # BOILERPLATE ( RearAxle ) function BOILERPLATE # BOILERPLATE ( AdditionalAxle ) function ASSERT_DEFAULT_CONSTRUCTIBLE # ASSERT_DEFAULT_CONSTRUCTIBLE ( File ) function ASSERT_DEFAULT_CONSTRUCTIBLE # ASSERT_DEFAULT_CONSTRUCTIBLE ( TrafficSignals ) Attributes Documentation # variable true_v # static const auto true_v = make < [ Boolean ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1Boolean ) > ( true ); variable stop_transition # static const auto stop_transition { make < [ StoryboardElementState ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState ) > ( StoryboardElementState :: stopTransition )}; variable start_transition # static const auto start_transition { make < [ StoryboardElementState ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState ) > ( StoryboardElementState :: startTransition )}; variable standby_state # static const auto standby_state { make < [ StoryboardElementState ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState ) > ( StoryboardElementState :: standbyState )}; variable skip_transition # static const auto skip_transition { make < [ StoryboardElementState ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState ) > ( StoryboardElementState :: skipTransition )}; variable running_state # static const auto running_state { make < [ StoryboardElementState ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState ) > ( StoryboardElementState :: runningState )}; variable false_v # static const auto false_v = make < [ Boolean ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1Boolean ) > ( false ); variable end_transition # static const auto end_transition { make < [ StoryboardElementState ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState ) > ( StoryboardElementState :: endTransition )}; variable complete_state # static const auto complete_state { make < [ StoryboardElementState ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState ) > ( StoryboardElementState :: completeState )}; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::syntax"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#openscenario_interpretersyntax","text":"","title":"openscenario_interpreter::syntax"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#classes","text":"Name struct openscenario_interpreter::syntax::equal_to< T, typename std::enable_if< std::is_floating_point< T >::value >::type > struct openscenario_interpreter::syntax::equal_to struct openscenario_interpreter::syntax::WorldPosition struct openscenario_interpreter::syntax::Waypoint struct openscenario_interpreter::syntax::VehicleCategory struct openscenario_interpreter::syntax::Vehicle struct openscenario_interpreter::syntax::UserDefinedAction struct openscenario_interpreter::syntax::UnsignedShort struct openscenario_interpreter::syntax::UnsignedInteger struct openscenario_interpreter::syntax::TriggeringEntitiesRule struct openscenario_interpreter::syntax::TriggeringEntities struct openscenario_interpreter::syntax::Trigger struct openscenario_interpreter::syntax::TransitionDynamics struct openscenario_interpreter::syntax::TrafficSignals struct openscenario_interpreter::syntax::TrafficSignalStateAction struct openscenario_interpreter::syntax::TrafficSignalState struct openscenario_interpreter::syntax::TrafficSignalController struct openscenario_interpreter::syntax::TrafficSignalCondition struct openscenario_interpreter::syntax::TrafficSignalAction struct openscenario_interpreter::syntax::TimeHeadwayCondition struct openscenario_interpreter::syntax::TeleportAction struct openscenario_interpreter::syntax::StoryboardElementType struct openscenario_interpreter::syntax::StoryboardElementStateCondition struct openscenario_interpreter::syntax::StoryboardElementState class openscenario_interpreter::syntax::StoryboardElement struct openscenario_interpreter::syntax::Storyboard struct openscenario_interpreter::syntax::Story struct openscenario_interpreter::syntax::StandStillCondition struct openscenario_interpreter::syntax::SpeedTargetValueType struct openscenario_interpreter::syntax::SpeedCondition struct openscenario_interpreter::syntax::SpeedActionTarget struct openscenario_interpreter::syntax::SpeedAction struct openscenario_interpreter::syntax::SimulationTimeCondition struct openscenario_interpreter::syntax::SelectedEntities struct openscenario_interpreter::syntax::ScenarioObject struct openscenario_interpreter::syntax::ScenarioDefinition struct openscenario_interpreter::syntax::Rule struct openscenario_interpreter::syntax::RoutingAction struct openscenario_interpreter::syntax::RouteStrategy struct openscenario_interpreter::syntax::Route struct openscenario_interpreter::syntax::RoadNetwork struct openscenario_interpreter::syntax::RelativeWorldPosition struct openscenario_interpreter::syntax::RelativeTargetSpeed struct openscenario_interpreter::syntax::RelativeDistanceType struct openscenario_interpreter::syntax::RelativeDistanceCondition struct openscenario_interpreter::syntax::ReferenceContext struct openscenario_interpreter::syntax::RearAxle struct openscenario_interpreter::syntax::ReachPositionCondition struct openscenario_interpreter::syntax::Property struct openscenario_interpreter::syntax::Properties struct openscenario_interpreter::syntax::PrivateAction struct openscenario_interpreter::syntax::Private struct openscenario_interpreter::syntax::Priority struct openscenario_interpreter::syntax::Position struct openscenario_interpreter::syntax::Phase struct openscenario_interpreter::syntax::Performance struct openscenario_interpreter::syntax::PedestrianCategory struct openscenario_interpreter::syntax::Pedestrian struct openscenario_interpreter::syntax::ParameterType struct openscenario_interpreter::syntax::ParameterSetAction struct openscenario_interpreter::syntax::ParameterMultiplyByValueRule struct openscenario_interpreter::syntax::ParameterModifyAction struct openscenario_interpreter::syntax::ParameterDeclarations struct openscenario_interpreter::syntax::ParameterDeclaration struct openscenario_interpreter::syntax::ParameterCondition struct openscenario_interpreter::syntax::ParameterAddValueRule struct openscenario_interpreter::syntax::ParameterAction struct openscenario_interpreter::syntax::OverrideControllerValueAction struct openscenario_interpreter::syntax::Orientation struct openscenario_interpreter::syntax::OpenScenario struct openscenario_interpreter::syntax::ObjectType struct openscenario_interpreter::syntax::ObjectController struct openscenario_interpreter::syntax::ModifyRule struct openscenario_interpreter::syntax::ManeuverGroup struct openscenario_interpreter::syntax::Maneuver struct openscenario_interpreter::syntax::LongitudinalAction struct openscenario_interpreter::syntax::LateralAction struct openscenario_interpreter::syntax::LanePosition struct openscenario_interpreter::syntax::LaneChangeTarget struct openscenario_interpreter::syntax::LaneChangeAction struct openscenario_interpreter::syntax::Integer struct openscenario_interpreter::syntax::InitActions struct openscenario_interpreter::syntax::Init struct openscenario_interpreter::syntax::InfrastructureAction struct openscenario_interpreter::syntax::GlobalAction struct openscenario_interpreter::syntax::FrontAxle struct openscenario_interpreter::syntax::FileHeader struct openscenario_interpreter::syntax::File struct openscenario_interpreter::syntax::Event struct openscenario_interpreter::syntax::EntitySelection struct openscenario_interpreter::syntax::EntityRef struct openscenario_interpreter::syntax::EntityObject struct openscenario_interpreter::syntax::EntityCondition struct openscenario_interpreter::syntax::EntityAction struct openscenario_interpreter::syntax::Entities struct openscenario_interpreter::syntax::DynamicsShape struct openscenario_interpreter::syntax::DynamicsDimension struct openscenario_interpreter::syntax::Double struct openscenario_interpreter::syntax::DistanceCondition struct openscenario_interpreter::syntax::Directory struct openscenario_interpreter::syntax::Dimensions struct openscenario_interpreter::syntax::DeleteEntityAction struct openscenario_interpreter::syntax::CustomCommandAction struct openscenario_interpreter::syntax::ControllerAction struct openscenario_interpreter::syntax::Controller struct openscenario_interpreter::syntax::ConditionGroup struct openscenario_interpreter::syntax::ConditionEdge struct openscenario_interpreter::syntax::Condition struct openscenario_interpreter::syntax::Command struct openscenario_interpreter::syntax::CollisionCondition struct openscenario_interpreter::syntax::Center struct openscenario_interpreter::syntax::CatalogLocations struct openscenario_interpreter::syntax::CatalogLocation struct openscenario_interpreter::syntax::ByValueCondition struct openscenario_interpreter::syntax::ByType struct openscenario_interpreter::syntax::ByEntityCondition struct openscenario_interpreter::syntax::BoundingBox struct openscenario_interpreter::syntax::Boolean struct openscenario_interpreter::syntax::Axles struct openscenario_interpreter::syntax::Axle struct openscenario_interpreter::syntax::AssignRouteAction struct openscenario_interpreter::syntax::AssignControllerAction struct openscenario_interpreter::syntax::AdditionalAxle struct openscenario_interpreter::syntax::AddEntityAction struct openscenario_interpreter::syntax::Actors struct openscenario_interpreter::syntax::Action struct openscenario_interpreter::syntax::Act struct openscenario_interpreter::syntax::AcquirePositionAction struct openscenario_interpreter::syntax::AccelerationCondition struct openscenario_interpreter::syntax::AbsoluteTargetSpeed struct openscenario_interpreter::syntax::AbsoluteTargetLane","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#types","text":"Name using UnsignedInteger UnsignedInt using std::string String using Properties DefaultController","title":"Types"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#functions","text":"Name std::istream & operator>> (std::istream & is, Boolean & boolean) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, Command & command) std::istream & operator>> (std::istream & is, ConditionEdge & edge) std::istream & operator>> (std::istream & is, Double & rhs) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, DynamicsDimension & dimension) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, DynamicsShape & shape) std::istream & operator>> (std::istream & is, Integer & rhs) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, ParameterType & type) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, PedestrianCategory & category) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, Priority & priority) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, ReferenceContext & context) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, RelativeDistanceType & type) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, RouteStrategy & strategy) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, Rule & rule) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, SpeedTargetValueType & type) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, StoryboardElementState & state) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, StoryboardElementType & type) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, TriggeringEntitiesRule & rule) template \\<typename ... Ts> decltype(auto) operator>> (std::basic_istream< Ts... > & is, UnsignedInteger & rhs) template \\<typename ... Ts> decltype(auto) operator>> (std::basic_istream< Ts... > & is, UnsignedShort & rhs) template \\<typename ... Ts> std::basic_istream< Ts... > & operator>> (std::basic_istream< Ts... > & is, VehicleCategory & category) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Axles & rhs) std::ostream & operator<< (std::ostream & os, const Boolean & boolean) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const BoundingBox & rhs) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Center & rhs) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Command & command) std::ostream & operator<< (std::ostream & os, const ConditionEdge & edge) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Dimensions & rhs) std::ostream & operator<< (std::ostream & os, const Double & rhs) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const DynamicsDimension & dimension) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const DynamicsShape & shape) std::ostream & operator<< (std::ostream & os, const Integer & rhs) std::ostream & operator<< (std::ostream & os, const ScenarioDefinition & ) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const OpenScenario & ) std::ostream & operator<< (std::ostream & os, const ParameterDeclaration & declaration) std::ostream & operator<< (std::ostream & os, const ParameterDeclarations & ) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const ParameterType & type) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Pedestrian & rhs) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const PedestrianCategory & category) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Performance & rhs) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Priority & priority) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const ReferenceContext & context) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const RelativeDistanceType & type) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const RouteStrategy & strategy) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Rule & rule) std::ostream & operator<< (std::ostream & os, const ScenarioObject & datum) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const SpeedTargetValueType & type) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const StoryboardElementState & state) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const StoryboardElementType & type) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const TriggeringEntitiesRule & rule) template \\<typename ... Ts> decltype(auto) operator<< (std::basic_ostream< Ts... > & os, const UnsignedInteger & rhs) template \\<typename ... Ts> decltype(auto) operator<< (std::basic_ostream< Ts... > & os, const UnsignedShort & rhs) std::ostream & operator<< (std::ostream & os, const Vehicle & rhs) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const VehicleCategory & category) auto asBoolean (bool value) template \\<typename R =void,typename F ,typename ... Ts> decltype(auto) apply (F && f, const Position & position, Ts &&... xs) BOILERPLATE ( Axle ) BOILERPLATE ( FrontAxle ) BOILERPLATE ( RearAxle ) BOILERPLATE ( AdditionalAxle ) ASSERT_DEFAULT_CONSTRUCTIBLE ( File ) ASSERT_DEFAULT_CONSTRUCTIBLE ( TrafficSignals )","title":"Functions"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#attributes","text":"Name const auto true_v const auto stop_transition const auto start_transition const auto standby_state const auto skip_transition const auto running_state const auto false_v const auto end_transition const auto complete_state","title":"Attributes"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#types-documentation","text":"","title":"Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#using-unsignedint","text":"using openscenario_interpreter :: syntax :: UnsignedInt = typedef UnsignedInteger ;","title":"using UnsignedInt"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#using-string","text":"using openscenario_interpreter :: syntax :: String = typedef std :: string ;","title":"using String"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#using-defaultcontroller","text":"using openscenario_interpreter :: syntax :: DefaultController = typedef Properties ;","title":"using DefaultController"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator","text":"std :: istream & operator >> ( std :: istream & is , Boolean & boolean )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_1","text":"template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , Command & command )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_2","text":"std :: istream & operator >> ( std :: istream & is , ConditionEdge & edge )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_3","text":"std :: istream & operator >> ( std :: istream & is , Double & rhs )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_4","text":"template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , DynamicsDimension & dimension )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_5","text":"template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , DynamicsShape & shape )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_6","text":"std :: istream & operator >> ( std :: istream & is , Integer & rhs )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_7","text":"template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , ParameterType & type )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_8","text":"template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , PedestrianCategory & category )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_9","text":"template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , Priority & priority )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_10","text":"template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , ReferenceContext & context )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_11","text":"template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , RelativeDistanceType & type )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_12","text":"template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , RouteStrategy & strategy )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_13","text":"template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , Rule & rule )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_14","text":"template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , SpeedTargetValueType & type )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_15","text":"template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , StoryboardElementState & state )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_16","text":"template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , StoryboardElementType & type )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_17","text":"template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , TriggeringEntitiesRule & rule )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_18","text":"template < typename ... Ts > decltype ( auto ) operator >> ( std :: basic_istream < Ts ... > & is , UnsignedInteger & rhs )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_19","text":"template < typename ... Ts > decltype ( auto ) operator >> ( std :: basic_istream < Ts ... > & is , UnsignedShort & rhs )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_20","text":"template < typename ... Ts > std :: basic_istream < Ts ... > & operator >> ( std :: basic_istream < Ts ... > & is , VehicleCategory & category )","title":"function operator&gt;&gt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_21","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Axles & rhs )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_22","text":"std :: ostream & operator << ( std :: ostream & os , const Boolean & boolean )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_23","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const BoundingBox & rhs )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_24","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Center & rhs )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_25","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Command & command )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_26","text":"std :: ostream & operator << ( std :: ostream & os , const ConditionEdge & edge )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_27","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Dimensions & rhs )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_28","text":"std :: ostream & operator << ( std :: ostream & os , const Double & rhs )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_29","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const DynamicsDimension & dimension )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_30","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const DynamicsShape & shape )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_31","text":"std :: ostream & operator << ( std :: ostream & os , const Integer & rhs )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_32","text":"std :: ostream & operator << ( std :: ostream & os , const ScenarioDefinition & )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_33","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const OpenScenario & )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_34","text":"std :: ostream & operator << ( std :: ostream & os , const ParameterDeclaration & declaration )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_35","text":"std :: ostream & operator << ( std :: ostream & os , const ParameterDeclarations & )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_36","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const ParameterType & type )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_37","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Pedestrian & rhs )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_38","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const PedestrianCategory & category )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_39","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Performance & rhs )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_40","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Priority & priority )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_41","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const ReferenceContext & context )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_42","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const RelativeDistanceType & type )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_43","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const RouteStrategy & strategy )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_44","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Rule & rule )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_45","text":"std :: ostream & operator << ( std :: ostream & os , const ScenarioObject & datum )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_46","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const SpeedTargetValueType & type )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_47","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const StoryboardElementState & state )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_48","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const StoryboardElementType & type )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_49","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const TriggeringEntitiesRule & rule )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_50","text":"template < typename ... Ts > decltype ( auto ) operator << ( std :: basic_ostream < Ts ... > & os , const UnsignedInteger & rhs )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_51","text":"template < typename ... Ts > decltype ( auto ) operator << ( std :: basic_ostream < Ts ... > & os , const UnsignedShort & rhs )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_52","text":"std :: ostream & operator << ( std :: ostream & os , const Vehicle & rhs )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-operator_53","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const VehicleCategory & category )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-asboolean","text":"auto asBoolean ( bool value )","title":"function asBoolean"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-apply","text":"template < typename R = void , typename F , typename ... Ts > decltype ( auto ) apply ( F && f , const Position & position , Ts && ... xs )","title":"function apply"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-boilerplate","text":"BOILERPLATE ( Axle )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-boilerplate_1","text":"BOILERPLATE ( FrontAxle )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-boilerplate_2","text":"BOILERPLATE ( RearAxle )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-boilerplate_3","text":"BOILERPLATE ( AdditionalAxle )","title":"function BOILERPLATE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-assert_default_constructible","text":"ASSERT_DEFAULT_CONSTRUCTIBLE ( File )","title":"function ASSERT_DEFAULT_CONSTRUCTIBLE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#function-assert_default_constructible_1","text":"ASSERT_DEFAULT_CONSTRUCTIBLE ( TrafficSignals )","title":"function ASSERT_DEFAULT_CONSTRUCTIBLE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#variable-true_v","text":"static const auto true_v = make < [ Boolean ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1Boolean ) > ( true );","title":"variable true_v"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#variable-stop_transition","text":"static const auto stop_transition { make < [ StoryboardElementState ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState ) > ( StoryboardElementState :: stopTransition )};","title":"variable stop_transition"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#variable-start_transition","text":"static const auto start_transition { make < [ StoryboardElementState ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState ) > ( StoryboardElementState :: startTransition )};","title":"variable start_transition"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#variable-standby_state","text":"static const auto standby_state { make < [ StoryboardElementState ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState ) > ( StoryboardElementState :: standbyState )};","title":"variable standby_state"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#variable-skip_transition","text":"static const auto skip_transition { make < [ StoryboardElementState ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState ) > ( StoryboardElementState :: skipTransition )};","title":"variable skip_transition"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#variable-running_state","text":"static const auto running_state { make < [ StoryboardElementState ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState ) > ( StoryboardElementState :: runningState )};","title":"variable running_state"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#variable-false_v","text":"static const auto false_v = make < [ Boolean ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1Boolean ) > ( false );","title":"variable false_v"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#variable-end_transition","text":"static const auto end_transition { make < [ StoryboardElementState ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState ) > ( StoryboardElementState :: endTransition )};","title":"variable end_transition"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1syntax/#variable-complete_state","text":"static const auto complete_state { make < [ StoryboardElementState ]( / package / openscenario_interpreter / markdown / Classes / structopenscenario__interpreter_1_1syntax_1_1StoryboardElementState ) > ( StoryboardElementState :: completeState )}; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable complete_state"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1type__traits/","text":"openscenario_interpreter::type_traits # Classes # Name struct openscenario_interpreter::type_traits::IfNotNothrowDefaultConstructible< T, typename std::enable_if< std::is_nothrow_default_constructible< T >::value >::type > struct openscenario_interpreter::type_traits::IfNotNothrowDefaultConstructible struct openscenario_interpreter::type_traits::IfNotDefaultConstructible< T, typename std::enable_if< std::is_default_constructible< T >::value >::type > struct openscenario_interpreter::type_traits::IfNotDefaultConstructible struct openscenario_interpreter::type_traits::IfHasStreamOutputOperator< T, typename std::enable_if< HasStreamOutputOperator< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasStreamOutputOperator struct openscenario_interpreter::type_traits::IfHasMemberFunctionState< T, typename std::enable_if< HasMemberFunctionState< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionState struct openscenario_interpreter::type_traits::IfHasMemberFunctionStart< T, typename std::enable_if< HasMemberFunctionStart< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionStart struct openscenario_interpreter::type_traits::IfHasMemberFunctionEvaluate< T, typename std::enable_if< HasMemberFunctionEvaluate< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionEvaluate struct openscenario_interpreter::type_traits::IfHasMemberFunctionAccomplished< T, typename std::enable_if< HasMemberFunctionAccomplished< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionAccomplished struct openscenario_interpreter::type_traits::HasMemberFunctionState< T, void_t< decltype(std::declval< T >().state())> > struct openscenario_interpreter::type_traits::HasMemberFunctionState struct openscenario_interpreter::type_traits::HasMemberFunctionStart< T, void_t< decltype(std::declval< T >().start())> > struct openscenario_interpreter::type_traits::HasMemberFunctionStart struct openscenario_interpreter::type_traits::HasMemberFunctionEvaluate< T, void_t< decltype(std::declval< T >().evaluate())> > struct openscenario_interpreter::type_traits::HasMemberFunctionEvaluate struct openscenario_interpreter::type_traits::HasMemberFunctionAccomplished< T, void_t< decltype(std::declval< T >().accomplished())> > struct openscenario_interpreter::type_traits::HasMemberFunctionAccomplished Types # Name using void void_t Types Documentation # using void_t # using openscenario_interpreter :: type_traits :: void_t = typedef void ; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::type_traits"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1type__traits/#openscenario_interpretertype_traits","text":"","title":"openscenario_interpreter::type_traits"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1type__traits/#classes","text":"Name struct openscenario_interpreter::type_traits::IfNotNothrowDefaultConstructible< T, typename std::enable_if< std::is_nothrow_default_constructible< T >::value >::type > struct openscenario_interpreter::type_traits::IfNotNothrowDefaultConstructible struct openscenario_interpreter::type_traits::IfNotDefaultConstructible< T, typename std::enable_if< std::is_default_constructible< T >::value >::type > struct openscenario_interpreter::type_traits::IfNotDefaultConstructible struct openscenario_interpreter::type_traits::IfHasStreamOutputOperator< T, typename std::enable_if< HasStreamOutputOperator< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasStreamOutputOperator struct openscenario_interpreter::type_traits::IfHasMemberFunctionState< T, typename std::enable_if< HasMemberFunctionState< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionState struct openscenario_interpreter::type_traits::IfHasMemberFunctionStart< T, typename std::enable_if< HasMemberFunctionStart< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionStart struct openscenario_interpreter::type_traits::IfHasMemberFunctionEvaluate< T, typename std::enable_if< HasMemberFunctionEvaluate< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionEvaluate struct openscenario_interpreter::type_traits::IfHasMemberFunctionAccomplished< T, typename std::enable_if< HasMemberFunctionAccomplished< T >::value >::type > struct openscenario_interpreter::type_traits::IfHasMemberFunctionAccomplished struct openscenario_interpreter::type_traits::HasMemberFunctionState< T, void_t< decltype(std::declval< T >().state())> > struct openscenario_interpreter::type_traits::HasMemberFunctionState struct openscenario_interpreter::type_traits::HasMemberFunctionStart< T, void_t< decltype(std::declval< T >().start())> > struct openscenario_interpreter::type_traits::HasMemberFunctionStart struct openscenario_interpreter::type_traits::HasMemberFunctionEvaluate< T, void_t< decltype(std::declval< T >().evaluate())> > struct openscenario_interpreter::type_traits::HasMemberFunctionEvaluate struct openscenario_interpreter::type_traits::HasMemberFunctionAccomplished< T, void_t< decltype(std::declval< T >().accomplished())> > struct openscenario_interpreter::type_traits::HasMemberFunctionAccomplished","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1type__traits/#types","text":"Name using void void_t","title":"Types"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1type__traits/#types-documentation","text":"","title":"Types Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1type__traits/#using-void_t","text":"using openscenario_interpreter :: type_traits :: void_t = typedef void ; Updated on 7 April 2021 at 00:31:56 UTC","title":"using void_t"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/","text":"openscenario_interpreter::utility # Classes # Name struct openscenario_interpreter::utility::Indent struct openscenario_interpreter::utility::AttributeHighlighter Functions # Name template \\<typename ... Ts> decltype(auto) operator<< (std::basic_ostream< Ts... > & os, const AttributeHighlighter & highlight) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Indent & indent) template \\<typename T ,typename =typename std::enable_if ::value>::type> auto highlight (const std::string & name, const T & value) COMPOSE (caar , car , car ) COMPOSE (cadr , car , cdr ) COMPOSE (cdar , cdr , car ) COMPOSE (cddr , cdr , cdr ) Attributes # Name struct openscenario_interpreter::utility::Indent indent auto cdr auto car Functions Documentation # function operator<< # template < typename ... Ts > decltype ( auto ) operator << ( std :: basic_ostream < Ts ... > & os , const AttributeHighlighter & highlight ) function operator<< # template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Indent & indent ) function highlight # template < typename T , typename = typename std :: enable_if < HasStreamOutputOperator < T >:: value >:: type > auto highlight ( const std :: string & name , const T & value ) function COMPOSE # COMPOSE ( caar , car , car ) function COMPOSE # COMPOSE ( cadr , car , cdr ) function COMPOSE # COMPOSE ( cdar , cdr , car ) function COMPOSE # COMPOSE ( cddr , cdr , cdr ) Attributes Documentation # variable indent # struct openscenario_interpreter :: utility :: Indent indent ; variable cdr # auto cdr = [] ( auto && pare ) noexcept -> decltype ( auto ) { return std :: get < 1 > ( pare ); }; variable car # auto car = [] ( auto && pare ) noexcept -> decltype ( auto ) { return std :: get < 0 > ( pare ); }; Updated on 7 April 2021 at 00:31:56 UTC","title":"openscenario_interpreter::utility"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#openscenario_interpreterutility","text":"","title":"openscenario_interpreter::utility"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#classes","text":"Name struct openscenario_interpreter::utility::Indent struct openscenario_interpreter::utility::AttributeHighlighter","title":"Classes"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#functions","text":"Name template \\<typename ... Ts> decltype(auto) operator<< (std::basic_ostream< Ts... > & os, const AttributeHighlighter & highlight) template \\<typename ... Ts> std::basic_ostream< Ts... > & operator<< (std::basic_ostream< Ts... > & os, const Indent & indent) template \\<typename T ,typename =typename std::enable_if ::value>::type> auto highlight (const std::string & name, const T & value) COMPOSE (caar , car , car ) COMPOSE (cadr , car , cdr ) COMPOSE (cdar , cdr , car ) COMPOSE (cddr , cdr , cdr )","title":"Functions"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#attributes","text":"Name struct openscenario_interpreter::utility::Indent indent auto cdr auto car","title":"Attributes"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#function-operator","text":"template < typename ... Ts > decltype ( auto ) operator << ( std :: basic_ostream < Ts ... > & os , const AttributeHighlighter & highlight )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#function-operator_1","text":"template < typename ... Ts > std :: basic_ostream < Ts ... > & operator << ( std :: basic_ostream < Ts ... > & os , const Indent & indent )","title":"function operator&lt;&lt;"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#function-highlight","text":"template < typename T , typename = typename std :: enable_if < HasStreamOutputOperator < T >:: value >:: type > auto highlight ( const std :: string & name , const T & value )","title":"function highlight"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#function-compose","text":"COMPOSE ( caar , car , car )","title":"function COMPOSE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#function-compose_1","text":"COMPOSE ( cadr , car , cdr )","title":"function COMPOSE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#function-compose_2","text":"COMPOSE ( cdar , cdr , car )","title":"function COMPOSE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#function-compose_3","text":"COMPOSE ( cddr , cdr , cdr )","title":"function COMPOSE"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#variable-indent","text":"struct openscenario_interpreter :: utility :: Indent indent ;","title":"variable indent"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#variable-cdr","text":"auto cdr = [] ( auto && pare ) noexcept -> decltype ( auto ) { return std :: get < 1 > ( pare ); };","title":"variable cdr"},{"location":"package/openscenario_interpreter/markdown/Namespaces/namespaceopenscenario__interpreter_1_1utility/#variable-car","text":"auto car = [] ( auto && pare ) noexcept -> decltype ( auto ) { return std :: get < 0 > ( pare ); }; Updated on 7 April 2021 at 00:31:56 UTC","title":"variable car"},{"location":"package/openscenario_interpreter/markdown/Pages/","text":"Pages # Updated on 7 April 2021 at 00:31:57 UTC","title":"Pages"},{"location":"package/openscenario_interpreter/markdown/Pages/#pages","text":"Updated on 7 April 2021 at 00:31:57 UTC","title":"Pages"},{"location":"package/openscenario_visualization/markdown/","text":"ROS2 visualization component for OpenSCENARIO entities # Masaya Kataoka 2020-11-19 interface # ROS2 Topic interface| Name | Type | Pub/Sub | description | | -------- | -------- | -------- | -------- | | /entity/marker | visualization_msgs/msg/MarkerArray | Publish | Visualization results of the marker. | | /entity/status | openscenario_msgs/msg/EntityStatusWithTrajectoryArray | Subscribe | Topics for publishing entity status in simulation. | Updated on 7 April 2021 at 00:31:57 UTC","title":"ROS2 visualization component for OpenSCENARIO entities"},{"location":"package/openscenario_visualization/markdown/#ros2-visualization-component-for-openscenario-entities","text":"Masaya Kataoka 2020-11-19","title":"ROS2 visualization component for OpenSCENARIO entities"},{"location":"package/openscenario_visualization/markdown/#interface","text":"ROS2 Topic interface| Name | Type | Pub/Sub | description | | -------- | -------- | -------- | -------- | | /entity/marker | visualization_msgs/msg/MarkerArray | Publish | Visualization results of the marker. | | /entity/status | openscenario_msgs/msg/EntityStatusWithTrajectoryArray | Subscribe | Topics for publishing entity status in simulation. | Updated on 7 April 2021 at 00:31:57 UTC","title":"interface"},{"location":"package/openscenario_visualization/markdown/Classes/","text":"Classes # namespace openscenario_visualization class OpenscenarioVisualizationComponent ROS2 component for visualizing simulation result. Updated on 7 April 2021 at 00:31:57 UTC","title":"Classes"},{"location":"package/openscenario_visualization/markdown/Classes/#classes","text":"namespace openscenario_visualization class OpenscenarioVisualizationComponent ROS2 component for visualizing simulation result. Updated on 7 April 2021 at 00:31:57 UTC","title":"Classes"},{"location":"package/openscenario_visualization/markdown/Classes/classopenscenario__visualization_1_1OpenscenarioVisualizationComponent/","text":"openscenario_visualization::OpenscenarioVisualizationComponent # ROS2 component for visualizing simulation result. #include <openscenario_visualization_component.hpp> Inherits from Node Public Functions # Name OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC OpenscenarioVisualizationComponent (const rclcpp::NodeOptions & options) Public Functions Documentation # function OpenscenarioVisualizationComponent # explicit OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC OpenscenarioVisualizationComponent ( const rclcpp :: NodeOptions & options ) Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_visualization::OpenscenarioVisualizationComponent"},{"location":"package/openscenario_visualization/markdown/Classes/classopenscenario__visualization_1_1OpenscenarioVisualizationComponent/#openscenario_visualizationopenscenariovisualizationcomponent","text":"ROS2 component for visualizing simulation result. #include <openscenario_visualization_component.hpp> Inherits from Node","title":"openscenario_visualization::OpenscenarioVisualizationComponent"},{"location":"package/openscenario_visualization/markdown/Classes/classopenscenario__visualization_1_1OpenscenarioVisualizationComponent/#public-functions","text":"Name OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC OpenscenarioVisualizationComponent (const rclcpp::NodeOptions & options)","title":"Public Functions"},{"location":"package/openscenario_visualization/markdown/Classes/classopenscenario__visualization_1_1OpenscenarioVisualizationComponent/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/openscenario_visualization/markdown/Classes/classopenscenario__visualization_1_1OpenscenarioVisualizationComponent/#function-openscenariovisualizationcomponent","text":"explicit OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC OpenscenarioVisualizationComponent ( const rclcpp :: NodeOptions & options ) Updated on 7 April 2021 at 00:31:57 UTC","title":"function OpenscenarioVisualizationComponent"},{"location":"package/openscenario_visualization/markdown/Examples/","text":"Examples # Updated on 7 April 2021 at 00:31:57 UTC","title":"Examples"},{"location":"package/openscenario_visualization/markdown/Examples/#examples","text":"Updated on 7 April 2021 at 00:31:57 UTC","title":"Examples"},{"location":"package/openscenario_visualization/markdown/Files/","text":"Files # dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include/openscenario_visualization file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include/openscenario_visualization/openscenario_visualization_component.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src/openscenario_visualization_component.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src/openscenario_visualization_node.cpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_visualization/markdown/Files/#files","text":"dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include/openscenario_visualization file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include/openscenario_visualization/openscenario_visualization_component.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src/openscenario_visualization_component.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src/openscenario_visualization_node.cpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_visualization/markdown/Files/dir_240b308fbd556326a3604c6aa4adf1f1/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src/openscenario_visualization_node.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src/openscenario_visualization_component.cpp Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src"},{"location":"package/openscenario_visualization/markdown/Files/dir_240b308fbd556326a3604c6aa4adf1f1/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_visualizationsrc","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src"},{"location":"package/openscenario_visualization/markdown/Files/dir_240b308fbd556326a3604c6aa4adf1f1/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src/openscenario_visualization_node.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src/openscenario_visualization_component.cpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_visualization/markdown/Files/dir_3a741887da79dad9bbdd2505ded3dde8/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include/openscenario_visualization # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include/openscenario_visualization/openscenario_visualization_component.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include/openscenario_visualization"},{"location":"package/openscenario_visualization/markdown/Files/dir_3a741887da79dad9bbdd2505ded3dde8/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_visualizationincludeopenscenario_visualization","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include/openscenario_visualization"},{"location":"package/openscenario_visualization/markdown/Files/dir_3a741887da79dad9bbdd2505ded3dde8/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include/openscenario_visualization/openscenario_visualization_component.hpp Updated on 7 April 2021 at 00:31:57 UTC","title":"Files"},{"location":"package/openscenario_visualization/markdown/Files/dir_4c0d8b25e05102eecd9c74fa9bf42d6a/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include/openscenario_visualization Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include"},{"location":"package/openscenario_visualization/markdown/Files/dir_4c0d8b25e05102eecd9c74fa9bf42d6a/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_visualizationinclude","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include"},{"location":"package/openscenario_visualization/markdown/Files/dir_4c0d8b25e05102eecd9c74fa9bf42d6a/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include/openscenario_visualization Updated on 7 April 2021 at 00:31:57 UTC","title":"Directories"},{"location":"package/openscenario_visualization/markdown/Files/dir_b7e95a849abe11b669c96455e8cd78a9/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario"},{"location":"package/openscenario_visualization/markdown/Files/dir_b7e95a849abe11b669c96455e8cd78a9/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenario","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario"},{"location":"package/openscenario_visualization/markdown/Files/dir_b7e95a849abe11b669c96455e8cd78a9/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization Updated on 7 April 2021 at 00:31:57 UTC","title":"Directories"},{"location":"package/openscenario_visualization/markdown/Files/dir_ddf222effe56684e35bc2e7c277c4622/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization"},{"location":"package/openscenario_visualization/markdown/Files/dir_ddf222effe56684e35bc2e7c277c4622/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_visualization","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization"},{"location":"package/openscenario_visualization/markdown/Files/dir_ddf222effe56684e35bc2e7c277c4622/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include Updated on 7 April 2021 at 00:31:57 UTC","title":"Directories"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src/openscenario_visualization_component.cpp # Namespaces # Name openscenario_visualization Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <openscenario_visualization/openscenario_visualization_component.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <quaternion_operation/quaternion_operation.h> #include <rclcpp_components/register_node_macro.hpp> #include <algorithm> #include <cmath> #include <string> #include <vector> namespace openscenario_visualization { OpenscenarioVisualizationComponent :: OpenscenarioVisualizationComponent ( const rclcpp :: NodeOptions & options ) : Node ( \"openscenario_visualization\" , options ) { marker_pub_ = create_publisher < visualization_msgs :: msg :: MarkerArray > ( \"entity/marker\" , 1 ); entity_status_sub_ = this -> create_subscription < openscenario_msgs :: msg :: EntityStatusWithTrajectoryArray > ( \"entity/status\" , 1 , std :: bind ( & OpenscenarioVisualizationComponent :: entityStatusCallback , this , std :: placeholders :: _1 )); } void OpenscenarioVisualizationComponent :: entityStatusCallback ( const openscenario_msgs :: msg :: EntityStatusWithTrajectoryArray :: SharedPtr msg ) { visualization_msgs :: msg :: MarkerArray current_marker ; std :: vector < std :: string > entity_name_lists ; for ( const auto & data : msg -> data ) { entity_name_lists . emplace_back ( data . status . name ); } std :: vector < std :: string > erase_names ; for ( const auto & marker : markers_ ) { auto itr = std :: find ( entity_name_lists . begin (), entity_name_lists . end (), marker . first ); if ( itr == entity_name_lists . end ()) { auto delete_marker = generateDeleteMarker ( marker . first ); std :: copy ( delete_marker . markers . begin (), delete_marker . markers . end (), std :: back_inserter ( current_marker . markers )); erase_names . emplace_back ( marker . first ); } } for ( const auto & name : erase_names ) { markers_ . erase ( markers_ . find ( name )); } for ( const auto & data : msg -> data ) { auto marker_array = generateMarker ( data . status , data . waypoint , data . obstacle , data . obstacle_find ); std :: copy ( marker_array . markers . begin (), marker_array . markers . end (), std :: back_inserter ( current_marker . markers )); markers_ [ data . name ] = marker_array ; } marker_pub_ -> publish ( current_marker ); } const visualization_msgs :: msg :: MarkerArray OpenscenarioVisualizationComponent :: generateDeleteMarker ( std :: string ns ) { auto ret = visualization_msgs :: msg :: MarkerArray (); auto stamp = get_clock () -> now (); for ( const auto & marker : markers_ [ ns ]. markers ) { visualization_msgs :: msg :: Marker marker_msg ; marker_msg . action = marker_msg . DELETE ; marker_msg . header . frame_id = ns ; marker_msg . header . stamp = stamp ; marker_msg . ns = marker . ns ; marker_msg . id = marker . id ; ret . markers . emplace_back ( marker_msg ); } return ret ; } const visualization_msgs :: msg :: MarkerArray OpenscenarioVisualizationComponent :: generateMarker ( const openscenario_msgs :: msg :: EntityStatus & status , const openscenario_msgs :: msg :: WaypointsArray & waypoints , const openscenario_msgs :: msg :: Obstacle & obstacle , bool obstacle_find ) { auto ret = visualization_msgs :: msg :: MarkerArray (); auto stamp = get_clock () -> now (); std_msgs :: msg :: ColorRGBA color ; switch ( status . type . type ) { case status . type . EGO : color = color_utils :: makeColorMsg ( \"limegreen\" , 0.99 ); break ; case status . type . PEDESTRIAN : color = color_utils :: makeColorMsg ( \"orange\" , 0.99 ); break ; case status . type . VEHICLE : color = color_utils :: makeColorMsg ( \"lightskyblue\" , 0.99 ); break ; } visualization_msgs :: msg :: Marker bbox ; bbox . header . frame_id = status . name ; bbox . header . stamp = stamp ; bbox . ns = status . name ; bbox . id = 0 ; bbox . action = bbox . ADD ; bbox . pose . orientation . x = 0.0 ; bbox . pose . orientation . y = 0.0 ; bbox . pose . orientation . z = 0.0 ; bbox . pose . orientation . w = 1.0 ; bbox . type = bbox . LINE_LIST ; bbox . lifetime = rclcpp :: Duration ( 0.1 ); geometry_msgs :: msg :: Point p0 , p1 , p2 , p3 , p4 , p5 , p6 , p7 ; p0 . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 ; p0 . y = status . bounding_box . center . y + status . bounding_box . dimensions . y * 0.5 ; p0 . z = status . bounding_box . center . z + status . bounding_box . dimensions . z * 0.5 ; p1 . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 ; p1 . y = status . bounding_box . center . y + status . bounding_box . dimensions . y * 0.5 ; p1 . z = status . bounding_box . center . z - status . bounding_box . dimensions . z * 0.5 ; p2 . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 ; p2 . y = status . bounding_box . center . y - status . bounding_box . dimensions . y * 0.5 ; p2 . z = status . bounding_box . center . z + status . bounding_box . dimensions . z * 0.5 ; p3 . x = status . bounding_box . center . x - status . bounding_box . dimensions . x * 0.5 ; p3 . y = status . bounding_box . center . y + status . bounding_box . dimensions . y * 0.5 ; p3 . z = status . bounding_box . center . z + status . bounding_box . dimensions . z * 0.5 ; p4 . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 ; p4 . y = status . bounding_box . center . y - status . bounding_box . dimensions . y * 0.5 ; p4 . z = status . bounding_box . center . z - status . bounding_box . dimensions . z * 0.5 ; p5 . x = status . bounding_box . center . x - status . bounding_box . dimensions . x * 0.5 ; p5 . y = status . bounding_box . center . y + status . bounding_box . dimensions . y * 0.5 ; p5 . z = status . bounding_box . center . z - status . bounding_box . dimensions . z * 0.5 ; p6 . x = status . bounding_box . center . x - status . bounding_box . dimensions . x * 0.5 ; p6 . y = status . bounding_box . center . y - status . bounding_box . dimensions . y * 0.5 ; p6 . z = status . bounding_box . center . z + status . bounding_box . dimensions . z * 0.5 ; p7 . x = status . bounding_box . center . x - status . bounding_box . dimensions . x * 0.5 ; p7 . y = status . bounding_box . center . y - status . bounding_box . dimensions . y * 0.5 ; p7 . z = status . bounding_box . center . z - status . bounding_box . dimensions . z * 0.5 ; bbox . points . emplace_back ( p0 ); bbox . points . emplace_back ( p3 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p3 ); bbox . points . emplace_back ( p6 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p6 ); bbox . points . emplace_back ( p2 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p2 ); bbox . points . emplace_back ( p0 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p0 ); bbox . points . emplace_back ( p1 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p3 ); bbox . points . emplace_back ( p5 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p6 ); bbox . points . emplace_back ( p7 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p2 ); bbox . points . emplace_back ( p4 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p1 ); bbox . points . emplace_back ( p5 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p5 ); bbox . points . emplace_back ( p7 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p7 ); bbox . points . emplace_back ( p4 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p4 ); bbox . points . emplace_back ( p1 ); bbox . colors . emplace_back ( color ); bbox . color = color ; bbox . scale . x = 0.1 ; bbox . scale . y = 0.1 ; bbox . scale . z = 0.1 ; ret . markers . emplace_back ( bbox ); visualization_msgs :: msg :: Marker text ; text . header . frame_id = status . name ; text . header . stamp = stamp ; text . ns = status . name ; text . id = 1 ; text . action = text . ADD ; text . pose . position . x = status . bounding_box . center . x ; text . pose . position . y = status . bounding_box . center . y ; text . pose . position . z = status . bounding_box . center . z + status . bounding_box . dimensions . z * 0.5 + 1.0 ; text . pose . orientation . x = 0.0 ; text . pose . orientation . y = 0.0 ; text . pose . orientation . z = 0.0 ; text . pose . orientation . w = 1.0 ; text . type = text . TEXT_VIEW_FACING ; text . scale . x = 0.0 ; text . scale . y = 0.0 ; text . scale . z = 0.6 ; text . lifetime = rclcpp :: Duration ( 0.1 ); text . text = status . name ; text . color = color_utils :: makeColorMsg ( \"white\" , 0.99 ); ret . markers . emplace_back ( text ); visualization_msgs :: msg :: Marker arrow ; arrow . header . frame_id = status . name ; arrow . header . stamp = stamp ; arrow . ns = status . name ; arrow . id = 2 ; arrow . action = arrow . ADD ; // constexpr double arrow_size = 0.3; double arrow_size = 0.4 * status . bounding_box . dimensions . y ; constexpr double arrow_ratio = 1.0 ; geometry_msgs :: msg :: Point pf , pl , pr ; pf . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 + 1.0 ; pf . y = status . bounding_box . center . y ; pf . z = status . bounding_box . center . z - status . bounding_box . dimensions . z * 0.5 ; pl . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 + 1.0 - arrow_size * arrow_ratio ; pl . y = status . bounding_box . center . y + arrow_size ; pl . z = status . bounding_box . center . z - status . bounding_box . dimensions . z * 0.5 ; pr . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 + 1.0 - arrow_size * arrow_ratio ; pr . y = status . bounding_box . center . y - arrow_size ; pr . z = status . bounding_box . center . z - status . bounding_box . dimensions . z * 0.5 ; arrow . points = { pf , pl , pr }; arrow . colors = { color }; arrow . pose . orientation . x = 0.0 ; arrow . pose . orientation . y = 0.0 ; arrow . pose . orientation . z = 0.0 ; arrow . pose . orientation . w = 1.0 ; arrow . type = arrow . TRIANGLE_LIST ; arrow . scale . x = 1.0 ; arrow . scale . y = 1.0 ; arrow . scale . z = 1.0 ; arrow . lifetime = rclcpp :: Duration ( 0.1 ); arrow . color = color_utils :: makeColorMsg ( \"red\" , 0.99 ); ret . markers . emplace_back ( arrow ); visualization_msgs :: msg :: Marker text_action ; text_action . header . frame_id = status . name ; text_action . header . stamp = stamp ; text_action . ns = status . name ; text_action . id = 3 ; text_action . action = text_action . ADD ; text_action . pose . position . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 ; text_action . pose . position . y = status . bounding_box . center . y ; text_action . pose . position . z = status . bounding_box . center . z + status . bounding_box . dimensions . z * 0.5 + 0.5 ; text_action . pose . orientation . x = 0.0 ; text_action . pose . orientation . y = 0.0 ; text_action . pose . orientation . z = 0.0 ; text_action . pose . orientation . w = 1.0 ; text_action . type = text_action . TEXT_VIEW_FACING ; text_action . scale . x = 0.0 ; text_action . scale . y = 0.0 ; text_action . scale . z = 0.4 ; text_action . lifetime = rclcpp :: Duration ( 0.1 ); text_action . text = status . action_status . current_action ; text_action . color = color_utils :: makeColorMsg ( \"white\" , 0.99 ); ret . markers . emplace_back ( text_action ); if ( waypoints . waypoints . size () != 0 ) { simulation_api :: math :: CatmullRomSpline spline ( waypoints . waypoints ); visualization_msgs :: msg :: Marker waypoints_marker ; waypoints_marker . header . frame_id = \"map\" ; waypoints_marker . header . stamp = stamp ; waypoints_marker . ns = status . name ; waypoints_marker . id = 4 ; waypoints_marker . action = waypoints_marker . ADD ; waypoints_marker . type = waypoints_marker . TRIANGLE_LIST ; size_t num_points = 20 ; waypoints_marker . points = spline . getPolygon ( status . bounding_box . dimensions . y , num_points ); waypoints_marker . color = color ; waypoints_marker . color . a = 0.8 ; waypoints_marker . colors = std :: vector < std_msgs :: msg :: ColorRGBA > ( num_points * 2 , waypoints_marker . color ); waypoints_marker . scale . x = 1.0 ; waypoints_marker . scale . y = 1.0 ; waypoints_marker . scale . z = 1.0 ; ret . markers . emplace_back ( waypoints_marker ); if ( obstacle_find ) { visualization_msgs :: msg :: Marker obstacle_marker ; obstacle_marker . header . frame_id = \"map\" ; obstacle_marker . header . stamp = stamp ; obstacle_marker . ns = status . name ; obstacle_marker . id = 5 ; obstacle_marker . action = obstacle_marker . ADD ; obstacle_marker . type = obstacle_marker . CUBE ; obstacle_marker . pose = spline . getPose ( obstacle . s ); obstacle_marker . pose . position . z = obstacle_marker . pose . position . z + status . bounding_box . dimensions . z * 0.5 ; obstacle_marker . color = color_utils :: makeColorMsg ( \"red\" , 0.5 ); obstacle_marker . scale . x = 0.3 ; obstacle_marker . scale . y = status . bounding_box . dimensions . y + 0.3 ; obstacle_marker . scale . z = status . bounding_box . dimensions . z ; ret . markers . emplace_back ( obstacle_marker ); } else { visualization_msgs :: msg :: Marker obstacle_marker ; obstacle_marker . action = obstacle_marker . DELETE ; obstacle_marker . id = 5 ; obstacle_marker . ns = status . name ; ret . markers . emplace_back ( obstacle_marker ); } } else { visualization_msgs :: msg :: Marker waypoints_marker ; waypoints_marker . action = waypoints_marker . DELETE ; waypoints_marker . id = 4 ; waypoints_marker . ns = status . name ; ret . markers . emplace_back ( waypoints_marker ); visualization_msgs :: msg :: Marker obstacle_marker ; obstacle_marker . action = obstacle_marker . DELETE ; obstacle_marker . id = 5 ; obstacle_marker . ns = status . name ; ret . markers . emplace_back ( obstacle_marker ); } return ret ; } const visualization_msgs :: msg :: MarkerArray OpenscenarioVisualizationComponent :: generateDeleteMarker () const { visualization_msgs :: msg :: MarkerArray ret ; visualization_msgs :: msg :: Marker marker ; marker . action = marker . DELETEALL ; ret . markers . emplace_back ( marker ); return ret ; } } // namespace openscenario_visualization RCLCPP_COMPONENTS_REGISTER_NODE ( openscenario_visualization :: OpenscenarioVisualizationComponent ) Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src/openscenario_visualization_component.cpp"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_visualizationsrcopenscenario_visualization_componentcpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src/openscenario_visualization_component.cpp"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8cpp/#namespaces","text":"Name openscenario_visualization","title":"Namespaces"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <openscenario_visualization/openscenario_visualization_component.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <quaternion_operation/quaternion_operation.h> #include <rclcpp_components/register_node_macro.hpp> #include <algorithm> #include <cmath> #include <string> #include <vector> namespace openscenario_visualization { OpenscenarioVisualizationComponent :: OpenscenarioVisualizationComponent ( const rclcpp :: NodeOptions & options ) : Node ( \"openscenario_visualization\" , options ) { marker_pub_ = create_publisher < visualization_msgs :: msg :: MarkerArray > ( \"entity/marker\" , 1 ); entity_status_sub_ = this -> create_subscription < openscenario_msgs :: msg :: EntityStatusWithTrajectoryArray > ( \"entity/status\" , 1 , std :: bind ( & OpenscenarioVisualizationComponent :: entityStatusCallback , this , std :: placeholders :: _1 )); } void OpenscenarioVisualizationComponent :: entityStatusCallback ( const openscenario_msgs :: msg :: EntityStatusWithTrajectoryArray :: SharedPtr msg ) { visualization_msgs :: msg :: MarkerArray current_marker ; std :: vector < std :: string > entity_name_lists ; for ( const auto & data : msg -> data ) { entity_name_lists . emplace_back ( data . status . name ); } std :: vector < std :: string > erase_names ; for ( const auto & marker : markers_ ) { auto itr = std :: find ( entity_name_lists . begin (), entity_name_lists . end (), marker . first ); if ( itr == entity_name_lists . end ()) { auto delete_marker = generateDeleteMarker ( marker . first ); std :: copy ( delete_marker . markers . begin (), delete_marker . markers . end (), std :: back_inserter ( current_marker . markers )); erase_names . emplace_back ( marker . first ); } } for ( const auto & name : erase_names ) { markers_ . erase ( markers_ . find ( name )); } for ( const auto & data : msg -> data ) { auto marker_array = generateMarker ( data . status , data . waypoint , data . obstacle , data . obstacle_find ); std :: copy ( marker_array . markers . begin (), marker_array . markers . end (), std :: back_inserter ( current_marker . markers )); markers_ [ data . name ] = marker_array ; } marker_pub_ -> publish ( current_marker ); } const visualization_msgs :: msg :: MarkerArray OpenscenarioVisualizationComponent :: generateDeleteMarker ( std :: string ns ) { auto ret = visualization_msgs :: msg :: MarkerArray (); auto stamp = get_clock () -> now (); for ( const auto & marker : markers_ [ ns ]. markers ) { visualization_msgs :: msg :: Marker marker_msg ; marker_msg . action = marker_msg . DELETE ; marker_msg . header . frame_id = ns ; marker_msg . header . stamp = stamp ; marker_msg . ns = marker . ns ; marker_msg . id = marker . id ; ret . markers . emplace_back ( marker_msg ); } return ret ; } const visualization_msgs :: msg :: MarkerArray OpenscenarioVisualizationComponent :: generateMarker ( const openscenario_msgs :: msg :: EntityStatus & status , const openscenario_msgs :: msg :: WaypointsArray & waypoints , const openscenario_msgs :: msg :: Obstacle & obstacle , bool obstacle_find ) { auto ret = visualization_msgs :: msg :: MarkerArray (); auto stamp = get_clock () -> now (); std_msgs :: msg :: ColorRGBA color ; switch ( status . type . type ) { case status . type . EGO : color = color_utils :: makeColorMsg ( \"limegreen\" , 0.99 ); break ; case status . type . PEDESTRIAN : color = color_utils :: makeColorMsg ( \"orange\" , 0.99 ); break ; case status . type . VEHICLE : color = color_utils :: makeColorMsg ( \"lightskyblue\" , 0.99 ); break ; } visualization_msgs :: msg :: Marker bbox ; bbox . header . frame_id = status . name ; bbox . header . stamp = stamp ; bbox . ns = status . name ; bbox . id = 0 ; bbox . action = bbox . ADD ; bbox . pose . orientation . x = 0.0 ; bbox . pose . orientation . y = 0.0 ; bbox . pose . orientation . z = 0.0 ; bbox . pose . orientation . w = 1.0 ; bbox . type = bbox . LINE_LIST ; bbox . lifetime = rclcpp :: Duration ( 0.1 ); geometry_msgs :: msg :: Point p0 , p1 , p2 , p3 , p4 , p5 , p6 , p7 ; p0 . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 ; p0 . y = status . bounding_box . center . y + status . bounding_box . dimensions . y * 0.5 ; p0 . z = status . bounding_box . center . z + status . bounding_box . dimensions . z * 0.5 ; p1 . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 ; p1 . y = status . bounding_box . center . y + status . bounding_box . dimensions . y * 0.5 ; p1 . z = status . bounding_box . center . z - status . bounding_box . dimensions . z * 0.5 ; p2 . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 ; p2 . y = status . bounding_box . center . y - status . bounding_box . dimensions . y * 0.5 ; p2 . z = status . bounding_box . center . z + status . bounding_box . dimensions . z * 0.5 ; p3 . x = status . bounding_box . center . x - status . bounding_box . dimensions . x * 0.5 ; p3 . y = status . bounding_box . center . y + status . bounding_box . dimensions . y * 0.5 ; p3 . z = status . bounding_box . center . z + status . bounding_box . dimensions . z * 0.5 ; p4 . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 ; p4 . y = status . bounding_box . center . y - status . bounding_box . dimensions . y * 0.5 ; p4 . z = status . bounding_box . center . z - status . bounding_box . dimensions . z * 0.5 ; p5 . x = status . bounding_box . center . x - status . bounding_box . dimensions . x * 0.5 ; p5 . y = status . bounding_box . center . y + status . bounding_box . dimensions . y * 0.5 ; p5 . z = status . bounding_box . center . z - status . bounding_box . dimensions . z * 0.5 ; p6 . x = status . bounding_box . center . x - status . bounding_box . dimensions . x * 0.5 ; p6 . y = status . bounding_box . center . y - status . bounding_box . dimensions . y * 0.5 ; p6 . z = status . bounding_box . center . z + status . bounding_box . dimensions . z * 0.5 ; p7 . x = status . bounding_box . center . x - status . bounding_box . dimensions . x * 0.5 ; p7 . y = status . bounding_box . center . y - status . bounding_box . dimensions . y * 0.5 ; p7 . z = status . bounding_box . center . z - status . bounding_box . dimensions . z * 0.5 ; bbox . points . emplace_back ( p0 ); bbox . points . emplace_back ( p3 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p3 ); bbox . points . emplace_back ( p6 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p6 ); bbox . points . emplace_back ( p2 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p2 ); bbox . points . emplace_back ( p0 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p0 ); bbox . points . emplace_back ( p1 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p3 ); bbox . points . emplace_back ( p5 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p6 ); bbox . points . emplace_back ( p7 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p2 ); bbox . points . emplace_back ( p4 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p1 ); bbox . points . emplace_back ( p5 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p5 ); bbox . points . emplace_back ( p7 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p7 ); bbox . points . emplace_back ( p4 ); bbox . colors . emplace_back ( color ); bbox . points . emplace_back ( p4 ); bbox . points . emplace_back ( p1 ); bbox . colors . emplace_back ( color ); bbox . color = color ; bbox . scale . x = 0.1 ; bbox . scale . y = 0.1 ; bbox . scale . z = 0.1 ; ret . markers . emplace_back ( bbox ); visualization_msgs :: msg :: Marker text ; text . header . frame_id = status . name ; text . header . stamp = stamp ; text . ns = status . name ; text . id = 1 ; text . action = text . ADD ; text . pose . position . x = status . bounding_box . center . x ; text . pose . position . y = status . bounding_box . center . y ; text . pose . position . z = status . bounding_box . center . z + status . bounding_box . dimensions . z * 0.5 + 1.0 ; text . pose . orientation . x = 0.0 ; text . pose . orientation . y = 0.0 ; text . pose . orientation . z = 0.0 ; text . pose . orientation . w = 1.0 ; text . type = text . TEXT_VIEW_FACING ; text . scale . x = 0.0 ; text . scale . y = 0.0 ; text . scale . z = 0.6 ; text . lifetime = rclcpp :: Duration ( 0.1 ); text . text = status . name ; text . color = color_utils :: makeColorMsg ( \"white\" , 0.99 ); ret . markers . emplace_back ( text ); visualization_msgs :: msg :: Marker arrow ; arrow . header . frame_id = status . name ; arrow . header . stamp = stamp ; arrow . ns = status . name ; arrow . id = 2 ; arrow . action = arrow . ADD ; // constexpr double arrow_size = 0.3; double arrow_size = 0.4 * status . bounding_box . dimensions . y ; constexpr double arrow_ratio = 1.0 ; geometry_msgs :: msg :: Point pf , pl , pr ; pf . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 + 1.0 ; pf . y = status . bounding_box . center . y ; pf . z = status . bounding_box . center . z - status . bounding_box . dimensions . z * 0.5 ; pl . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 + 1.0 - arrow_size * arrow_ratio ; pl . y = status . bounding_box . center . y + arrow_size ; pl . z = status . bounding_box . center . z - status . bounding_box . dimensions . z * 0.5 ; pr . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 + 1.0 - arrow_size * arrow_ratio ; pr . y = status . bounding_box . center . y - arrow_size ; pr . z = status . bounding_box . center . z - status . bounding_box . dimensions . z * 0.5 ; arrow . points = { pf , pl , pr }; arrow . colors = { color }; arrow . pose . orientation . x = 0.0 ; arrow . pose . orientation . y = 0.0 ; arrow . pose . orientation . z = 0.0 ; arrow . pose . orientation . w = 1.0 ; arrow . type = arrow . TRIANGLE_LIST ; arrow . scale . x = 1.0 ; arrow . scale . y = 1.0 ; arrow . scale . z = 1.0 ; arrow . lifetime = rclcpp :: Duration ( 0.1 ); arrow . color = color_utils :: makeColorMsg ( \"red\" , 0.99 ); ret . markers . emplace_back ( arrow ); visualization_msgs :: msg :: Marker text_action ; text_action . header . frame_id = status . name ; text_action . header . stamp = stamp ; text_action . ns = status . name ; text_action . id = 3 ; text_action . action = text_action . ADD ; text_action . pose . position . x = status . bounding_box . center . x + status . bounding_box . dimensions . x * 0.5 ; text_action . pose . position . y = status . bounding_box . center . y ; text_action . pose . position . z = status . bounding_box . center . z + status . bounding_box . dimensions . z * 0.5 + 0.5 ; text_action . pose . orientation . x = 0.0 ; text_action . pose . orientation . y = 0.0 ; text_action . pose . orientation . z = 0.0 ; text_action . pose . orientation . w = 1.0 ; text_action . type = text_action . TEXT_VIEW_FACING ; text_action . scale . x = 0.0 ; text_action . scale . y = 0.0 ; text_action . scale . z = 0.4 ; text_action . lifetime = rclcpp :: Duration ( 0.1 ); text_action . text = status . action_status . current_action ; text_action . color = color_utils :: makeColorMsg ( \"white\" , 0.99 ); ret . markers . emplace_back ( text_action ); if ( waypoints . waypoints . size () != 0 ) { simulation_api :: math :: CatmullRomSpline spline ( waypoints . waypoints ); visualization_msgs :: msg :: Marker waypoints_marker ; waypoints_marker . header . frame_id = \"map\" ; waypoints_marker . header . stamp = stamp ; waypoints_marker . ns = status . name ; waypoints_marker . id = 4 ; waypoints_marker . action = waypoints_marker . ADD ; waypoints_marker . type = waypoints_marker . TRIANGLE_LIST ; size_t num_points = 20 ; waypoints_marker . points = spline . getPolygon ( status . bounding_box . dimensions . y , num_points ); waypoints_marker . color = color ; waypoints_marker . color . a = 0.8 ; waypoints_marker . colors = std :: vector < std_msgs :: msg :: ColorRGBA > ( num_points * 2 , waypoints_marker . color ); waypoints_marker . scale . x = 1.0 ; waypoints_marker . scale . y = 1.0 ; waypoints_marker . scale . z = 1.0 ; ret . markers . emplace_back ( waypoints_marker ); if ( obstacle_find ) { visualization_msgs :: msg :: Marker obstacle_marker ; obstacle_marker . header . frame_id = \"map\" ; obstacle_marker . header . stamp = stamp ; obstacle_marker . ns = status . name ; obstacle_marker . id = 5 ; obstacle_marker . action = obstacle_marker . ADD ; obstacle_marker . type = obstacle_marker . CUBE ; obstacle_marker . pose = spline . getPose ( obstacle . s ); obstacle_marker . pose . position . z = obstacle_marker . pose . position . z + status . bounding_box . dimensions . z * 0.5 ; obstacle_marker . color = color_utils :: makeColorMsg ( \"red\" , 0.5 ); obstacle_marker . scale . x = 0.3 ; obstacle_marker . scale . y = status . bounding_box . dimensions . y + 0.3 ; obstacle_marker . scale . z = status . bounding_box . dimensions . z ; ret . markers . emplace_back ( obstacle_marker ); } else { visualization_msgs :: msg :: Marker obstacle_marker ; obstacle_marker . action = obstacle_marker . DELETE ; obstacle_marker . id = 5 ; obstacle_marker . ns = status . name ; ret . markers . emplace_back ( obstacle_marker ); } } else { visualization_msgs :: msg :: Marker waypoints_marker ; waypoints_marker . action = waypoints_marker . DELETE ; waypoints_marker . id = 4 ; waypoints_marker . ns = status . name ; ret . markers . emplace_back ( waypoints_marker ); visualization_msgs :: msg :: Marker obstacle_marker ; obstacle_marker . action = obstacle_marker . DELETE ; obstacle_marker . id = 5 ; obstacle_marker . ns = status . name ; ret . markers . emplace_back ( obstacle_marker ); } return ret ; } const visualization_msgs :: msg :: MarkerArray OpenscenarioVisualizationComponent :: generateDeleteMarker () const { visualization_msgs :: msg :: MarkerArray ret ; visualization_msgs :: msg :: Marker marker ; marker . action = marker . DELETEALL ; ret . markers . emplace_back ( marker ); return ret ; } } // namespace openscenario_visualization RCLCPP_COMPONENTS_REGISTER_NODE ( openscenario_visualization :: OpenscenarioVisualizationComponent ) Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include/openscenario_visualization/openscenario_visualization_component.hpp # Namespaces # Name openscenario_visualization Classes # Name class openscenario_visualization::OpenscenarioVisualizationComponent ROS2 component for visualizing simulation result. Defines # Name OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC_TYPE OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_LOCAL OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_IMPORT OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_EXPORT definition of visualizer component Macro Documentation # define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC_TYPE # #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC_TYPE define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC # #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_LOCAL # #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_LOCAL define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_IMPORT # #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_IMPORT define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_EXPORT # #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_EXPORT __attribute__(( \\ visibility(\"default\"))) definition of visualizer component Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_VISUALIZATION__OPENSCENARIO_VISUALIZATION_COMPONENT_HPP_ #define OPENSCENARIO_VISUALIZATION__OPENSCENARIO_VISUALIZATION_COMPONENT_HPP_ #if __cplusplus extern \"C\" { #endif // The below macros are taken from https://gcc.gnu.org/wiki/Visibility and from // demos/composition/include/composition/visibility_control.h at https://github.com/ros2/demos #if defined _WIN32 || defined __CYGWIN__ #ifdef __GNUC__ #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_EXPORT __attribute__(( \\ dllexport)) #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_IMPORT __attribute__(( \\ dllimport)) #else #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_EXPORT __declspec(dllexport) #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_IMPORT __declspec(dllimport) #endif #ifdef OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_BUILDING_DLL #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC \\ OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_EXPORT #else #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC \\ OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_IMPORT #endif #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC_TYPE \\ OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_LOCAL #else #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_EXPORT __attribute__(( \\ visibility(\"default\"))) #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_IMPORT #if __GNUC__ >= 4 #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC __attribute__(( \\ visibility(\"default\"))) #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_LOCAL __attribute__(( \\ visibility(\"hidden\"))) #else #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_LOCAL #endif #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC_TYPE #endif #if __cplusplus } // extern \"C\" #endif #include <openscenario_msgs/msg/entity_status_with_trajectory_array.hpp> #include <visualization_msgs/msg/marker_array.hpp> #include <rclcpp/rclcpp.hpp> #include <simulation_api/color_utils/color_utils.hpp> #include <unordered_map> #include <string> namespace openscenario_visualization { class OpenscenarioVisualizationComponent : public rclcpp :: Node { public : OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC explicit OpenscenarioVisualizationComponent ( const rclcpp :: NodeOptions & ); private : void entityStatusCallback ( const openscenario_msgs :: msg :: EntityStatusWithTrajectoryArray :: SharedPtr msg ); const visualization_msgs :: msg :: MarkerArray generateDeleteMarker ( std :: string ns ); const visualization_msgs :: msg :: MarkerArray generateDeleteMarker () const ; const visualization_msgs :: msg :: MarkerArray generateMarker ( const openscenario_msgs :: msg :: EntityStatus & status , const openscenario_msgs :: msg :: WaypointsArray & waypoints , const openscenario_msgs :: msg :: Obstacle & obstacle , bool obstacle_find ); rclcpp :: Publisher < visualization_msgs :: msg :: MarkerArray >:: SharedPtr marker_pub_ ; rclcpp :: Subscription < openscenario_msgs :: msg :: EntityStatusWithTrajectoryArray >:: SharedPtr entity_status_sub_ ; std :: unordered_map < std :: string , visualization_msgs :: msg :: MarkerArray > markers_ ; }; } // namespace openscenario_visualization #endif // OPENSCENARIO_VISUALIZATION__OPENSCENARIO_VISUALIZATION_COMPONENT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include/openscenario_visualization/openscenario_visualization_component.hpp"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_visualizationincludeopenscenario_visualizationopenscenario_visualization_componenthpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/include/openscenario_visualization/openscenario_visualization_component.hpp"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8hpp/#namespaces","text":"Name openscenario_visualization","title":"Namespaces"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8hpp/#classes","text":"Name class openscenario_visualization::OpenscenarioVisualizationComponent ROS2 component for visualizing simulation result.","title":"Classes"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8hpp/#defines","text":"Name OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC_TYPE OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_LOCAL OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_IMPORT OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_EXPORT definition of visualizer component","title":"Defines"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8hpp/#define-openscenario_visualization_openscenario_visualization_component_public_type","text":"#define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC_TYPE","title":"define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC_TYPE"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8hpp/#define-openscenario_visualization_openscenario_visualization_component_public","text":"#define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC","title":"define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8hpp/#define-openscenario_visualization_openscenario_visualization_component_local","text":"#define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_LOCAL","title":"define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_LOCAL"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8hpp/#define-openscenario_visualization_openscenario_visualization_component_import","text":"#define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_IMPORT","title":"define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_IMPORT"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8hpp/#define-openscenario_visualization_openscenario_visualization_component_export","text":"#define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_EXPORT __attribute__(( \\ visibility(\"default\"))) definition of visualizer component","title":"define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_EXPORT"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__component_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef OPENSCENARIO_VISUALIZATION__OPENSCENARIO_VISUALIZATION_COMPONENT_HPP_ #define OPENSCENARIO_VISUALIZATION__OPENSCENARIO_VISUALIZATION_COMPONENT_HPP_ #if __cplusplus extern \"C\" { #endif // The below macros are taken from https://gcc.gnu.org/wiki/Visibility and from // demos/composition/include/composition/visibility_control.h at https://github.com/ros2/demos #if defined _WIN32 || defined __CYGWIN__ #ifdef __GNUC__ #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_EXPORT __attribute__(( \\ dllexport)) #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_IMPORT __attribute__(( \\ dllimport)) #else #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_EXPORT __declspec(dllexport) #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_IMPORT __declspec(dllimport) #endif #ifdef OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_BUILDING_DLL #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC \\ OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_EXPORT #else #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC \\ OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_IMPORT #endif #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC_TYPE \\ OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_LOCAL #else #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_EXPORT __attribute__(( \\ visibility(\"default\"))) #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_IMPORT #if __GNUC__ >= 4 #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC __attribute__(( \\ visibility(\"default\"))) #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_LOCAL __attribute__(( \\ visibility(\"hidden\"))) #else #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_LOCAL #endif #define OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC_TYPE #endif #if __cplusplus } // extern \"C\" #endif #include <openscenario_msgs/msg/entity_status_with_trajectory_array.hpp> #include <visualization_msgs/msg/marker_array.hpp> #include <rclcpp/rclcpp.hpp> #include <simulation_api/color_utils/color_utils.hpp> #include <unordered_map> #include <string> namespace openscenario_visualization { class OpenscenarioVisualizationComponent : public rclcpp :: Node { public : OPENSCENARIO_VISUALIZATION_OPENSCENARIO_VISUALIZATION_COMPONENT_PUBLIC explicit OpenscenarioVisualizationComponent ( const rclcpp :: NodeOptions & ); private : void entityStatusCallback ( const openscenario_msgs :: msg :: EntityStatusWithTrajectoryArray :: SharedPtr msg ); const visualization_msgs :: msg :: MarkerArray generateDeleteMarker ( std :: string ns ); const visualization_msgs :: msg :: MarkerArray generateDeleteMarker () const ; const visualization_msgs :: msg :: MarkerArray generateMarker ( const openscenario_msgs :: msg :: EntityStatus & status , const openscenario_msgs :: msg :: WaypointsArray & waypoints , const openscenario_msgs :: msg :: Obstacle & obstacle , bool obstacle_find ); rclcpp :: Publisher < visualization_msgs :: msg :: MarkerArray >:: SharedPtr marker_pub_ ; rclcpp :: Subscription < openscenario_msgs :: msg :: EntityStatusWithTrajectoryArray >:: SharedPtr entity_status_sub_ ; std :: unordered_map < std :: string , visualization_msgs :: msg :: MarkerArray > markers_ ; }; } // namespace openscenario_visualization #endif // OPENSCENARIO_VISUALIZATION__OPENSCENARIO_VISUALIZATION_COMPONENT_HPP_ Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__node_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src/openscenario_visualization_node.cpp # Functions # Name int main (int argc, char * argv[]) Functions Documentation # function main # int main ( int argc , char * argv [] ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <openscenario_visualization/openscenario_visualization_component.hpp> #include <rclcpp/rclcpp.hpp> #include <memory> int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: NodeOptions options ; auto component = std :: make_shared < openscenario_visualization :: OpenscenarioVisualizationComponent > ( options ); rclcpp :: spin ( component -> get_node_base_interface ()); rclcpp :: shutdown (); return 0 ; } Updated on 7 April 2021 at 00:31:57 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src/openscenario_visualization_node.cpp"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__node_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2openscenarioopenscenario_visualizationsrcopenscenario_visualization_nodecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/openscenario/openscenario_visualization/src/openscenario_visualization_node.cpp"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__node_8cpp/#functions","text":"Name int main (int argc, char * argv[])","title":"Functions"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__node_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__node_8cpp/#function-main","text":"int main ( int argc , char * argv [] )","title":"function main"},{"location":"package/openscenario_visualization/markdown/Files/openscenario__visualization__node_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <openscenario_visualization/openscenario_visualization_component.hpp> #include <rclcpp/rclcpp.hpp> #include <memory> int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: NodeOptions options ; auto component = std :: make_shared < openscenario_visualization :: OpenscenarioVisualizationComponent > ( options ); rclcpp :: spin ( component -> get_node_base_interface ()); rclcpp :: shutdown (); return 0 ; } Updated on 7 April 2021 at 00:31:57 UTC","title":"Source code"},{"location":"package/openscenario_visualization/markdown/Modules/","text":"Modules # Updated on 7 April 2021 at 00:31:57 UTC","title":"Modules"},{"location":"package/openscenario_visualization/markdown/Modules/#modules","text":"Updated on 7 April 2021 at 00:31:57 UTC","title":"Modules"},{"location":"package/openscenario_visualization/markdown/Namespaces/","text":"Namespaces # namespace openscenario_visualization Updated on 7 April 2021 at 00:31:57 UTC","title":"Namespaces"},{"location":"package/openscenario_visualization/markdown/Namespaces/#namespaces","text":"namespace openscenario_visualization Updated on 7 April 2021 at 00:31:57 UTC","title":"Namespaces"},{"location":"package/openscenario_visualization/markdown/Namespaces/namespaceopenscenario__visualization/","text":"openscenario_visualization # Classes # Name class openscenario_visualization::OpenscenarioVisualizationComponent ROS2 component for visualizing simulation result. Updated on 7 April 2021 at 00:31:57 UTC","title":"openscenario_visualization"},{"location":"package/openscenario_visualization/markdown/Namespaces/namespaceopenscenario__visualization/#openscenario_visualization","text":"","title":"openscenario_visualization"},{"location":"package/openscenario_visualization/markdown/Namespaces/namespaceopenscenario__visualization/#classes","text":"Name class openscenario_visualization::OpenscenarioVisualizationComponent ROS2 component for visualizing simulation result. Updated on 7 April 2021 at 00:31:57 UTC","title":"Classes"},{"location":"package/openscenario_visualization/markdown/Pages/","text":"Pages # page ROS2 visualization component for OpenSCENARIO entities Updated on 7 April 2021 at 00:31:57 UTC","title":"Pages"},{"location":"package/openscenario_visualization/markdown/Pages/#pages","text":"page ROS2 visualization component for OpenSCENARIO entities Updated on 7 April 2021 at 00:31:57 UTC","title":"Pages"},{"location":"package/scenario_simulator/markdown/Classes/","text":"Classes # namespace scenario_simulator class DetectionSensor class LidarSensor class Raycaster class ScenarioSimulator class SensorSimulation class SimulationRuntimeError struct Triangle struct Vertex namespace primitives class Box class Primitive namespace return_code Updated on 7 April 2021 at 00:31:55 UTC","title":"Classes"},{"location":"package/scenario_simulator/markdown/Classes/#classes","text":"namespace scenario_simulator class DetectionSensor class LidarSensor class Raycaster class ScenarioSimulator class SensorSimulation class SimulationRuntimeError struct Triangle struct Vertex namespace primitives class Box class Primitive namespace return_code Updated on 7 April 2021 at 00:31:55 UTC","title":"Classes"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1DetectionSensor/","text":"scenario_simulator::DetectionSensor # Public Functions # Name void update (double current_time, const std::vector< openscenario_msgs::EntityStatus > & status, const rclcpp::Time & stamp, const std::vector< std::string > & detected_objects) DetectionSensor (const simulation_api_schema::DetectionSensorConfiguration & configuration, std::shared_ptr< rclcpp::Publisher< autoware_perception_msgs::msg::DynamicObjectArray >> publisher_ptr) Public Functions Documentation # function update # void update ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp , const std :: vector < std :: string > & detected_objects ) function DetectionSensor # DetectionSensor ( const simulation_api_schema :: DetectionSensorConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < autoware_perception_msgs :: msg :: DynamicObjectArray >> publisher_ptr ) Updated on 7 April 2021 at 00:31:55 UTC","title":"scenario_simulator::DetectionSensor"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1DetectionSensor/#scenario_simulatordetectionsensor","text":"","title":"scenario_simulator::DetectionSensor"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1DetectionSensor/#public-functions","text":"Name void update (double current_time, const std::vector< openscenario_msgs::EntityStatus > & status, const rclcpp::Time & stamp, const std::vector< std::string > & detected_objects) DetectionSensor (const simulation_api_schema::DetectionSensorConfiguration & configuration, std::shared_ptr< rclcpp::Publisher< autoware_perception_msgs::msg::DynamicObjectArray >> publisher_ptr)","title":"Public Functions"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1DetectionSensor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1DetectionSensor/#function-update","text":"void update ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp , const std :: vector < std :: string > & detected_objects )","title":"function update"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1DetectionSensor/#function-detectionsensor","text":"DetectionSensor ( const simulation_api_schema :: DetectionSensorConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < autoware_perception_msgs :: msg :: DynamicObjectArray >> publisher_ptr ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function DetectionSensor"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1LidarSensor/","text":"scenario_simulator::LidarSensor # Public Functions # Name void update (double current_time, const std::vector< openscenario_msgs::EntityStatus > & status, const rclcpp::Time & stamp) const std::vector< std::string > & getDetectedObjects () const LidarSensor (const simulation_api_schema::LidarConfiguration & configuration, std::shared_ptr< rclcpp::Publisher< sensor_msgs::msg::PointCloud2 >> publisher_ptr) Public Functions Documentation # function update # void update ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp ) function getDetectedObjects # const std :: vector < std :: string > & getDetectedObjects () const function LidarSensor # LidarSensor ( const simulation_api_schema :: LidarConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < sensor_msgs :: msg :: PointCloud2 >> publisher_ptr ) Updated on 7 April 2021 at 00:31:55 UTC","title":"scenario_simulator::LidarSensor"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1LidarSensor/#scenario_simulatorlidarsensor","text":"","title":"scenario_simulator::LidarSensor"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1LidarSensor/#public-functions","text":"Name void update (double current_time, const std::vector< openscenario_msgs::EntityStatus > & status, const rclcpp::Time & stamp) const std::vector< std::string > & getDetectedObjects () const LidarSensor (const simulation_api_schema::LidarConfiguration & configuration, std::shared_ptr< rclcpp::Publisher< sensor_msgs::msg::PointCloud2 >> publisher_ptr)","title":"Public Functions"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1LidarSensor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1LidarSensor/#function-update","text":"void update ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp )","title":"function update"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1LidarSensor/#function-getdetectedobjects","text":"const std :: vector < std :: string > & getDetectedObjects () const","title":"function getDetectedObjects"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1LidarSensor/#function-lidarsensor","text":"LidarSensor ( const simulation_api_schema :: LidarConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < sensor_msgs :: msg :: PointCloud2 >> publisher_ptr ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function LidarSensor"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1Raycaster/","text":"scenario_simulator::Raycaster # Public Functions # Name ~Raycaster () const sensor_msgs::msg::PointCloud2 raycast (std::string frame_id, const rclcpp::Time & stamp, geometry_msgs::msg::Pose origin, double horizontal_resolution, std::vector< double > vertical_angles, double horizontal_angle_start =0, double horizontal_angle_end =2 *M_PI, double max_distance =100, double min_distance =0) const std::vector< std::string > & getDetectedObject () const template \\<typename T ,typename ... Ts> void addPrimitive (std::string name, Ts &&... xs) Raycaster () Raycaster (std::string embree_config) Public Functions Documentation # function ~Raycaster # ~ Raycaster () function raycast # const sensor_msgs :: msg :: PointCloud2 raycast ( std :: string frame_id , const rclcpp :: Time & stamp , geometry_msgs :: msg :: Pose origin , double horizontal_resolution , std :: vector < double > vertical_angles , double horizontal_angle_start = 0 , double horizontal_angle_end = 2 * M_PI , double max_distance = 100 , double min_distance = 0 ) function getDetectedObject # const std :: vector < std :: string > & getDetectedObject () const function addPrimitive # template < typename T , typename ... Ts > inline void addPrimitive ( std :: string name , Ts && ... xs ) function Raycaster # Raycaster () function Raycaster # explicit Raycaster ( std :: string embree_config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"scenario_simulator::Raycaster"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1Raycaster/#scenario_simulatorraycaster","text":"","title":"scenario_simulator::Raycaster"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1Raycaster/#public-functions","text":"Name ~Raycaster () const sensor_msgs::msg::PointCloud2 raycast (std::string frame_id, const rclcpp::Time & stamp, geometry_msgs::msg::Pose origin, double horizontal_resolution, std::vector< double > vertical_angles, double horizontal_angle_start =0, double horizontal_angle_end =2 *M_PI, double max_distance =100, double min_distance =0) const std::vector< std::string > & getDetectedObject () const template \\<typename T ,typename ... Ts> void addPrimitive (std::string name, Ts &&... xs) Raycaster () Raycaster (std::string embree_config)","title":"Public Functions"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1Raycaster/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1Raycaster/#function-raycaster","text":"~ Raycaster ()","title":"function ~Raycaster"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1Raycaster/#function-raycast","text":"const sensor_msgs :: msg :: PointCloud2 raycast ( std :: string frame_id , const rclcpp :: Time & stamp , geometry_msgs :: msg :: Pose origin , double horizontal_resolution , std :: vector < double > vertical_angles , double horizontal_angle_start = 0 , double horizontal_angle_end = 2 * M_PI , double max_distance = 100 , double min_distance = 0 )","title":"function raycast"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1Raycaster/#function-getdetectedobject","text":"const std :: vector < std :: string > & getDetectedObject () const","title":"function getDetectedObject"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1Raycaster/#function-addprimitive","text":"template < typename T , typename ... Ts > inline void addPrimitive ( std :: string name , Ts && ... xs )","title":"function addPrimitive"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1Raycaster/#function-raycaster_1","text":"Raycaster ()","title":"function Raycaster"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1Raycaster/#function-raycaster_2","text":"explicit Raycaster ( std :: string embree_config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function Raycaster"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1ScenarioSimulator/","text":"scenario_simulator::ScenarioSimulator # Inherits from Node Public Functions # Name ~ScenarioSimulator () SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC ScenarioSimulator (const rclcpp::NodeOptions & options) Public Functions Documentation # function ~ScenarioSimulator # ~ ScenarioSimulator () function ScenarioSimulator # explicit SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC ScenarioSimulator ( const rclcpp :: NodeOptions & options ) Updated on 7 April 2021 at 00:31:55 UTC","title":"scenario_simulator::ScenarioSimulator"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1ScenarioSimulator/#scenario_simulatorscenariosimulator","text":"Inherits from Node","title":"scenario_simulator::ScenarioSimulator"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1ScenarioSimulator/#public-functions","text":"Name ~ScenarioSimulator () SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC ScenarioSimulator (const rclcpp::NodeOptions & options)","title":"Public Functions"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1ScenarioSimulator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1ScenarioSimulator/#function-scenariosimulator","text":"~ ScenarioSimulator ()","title":"function ~ScenarioSimulator"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1ScenarioSimulator/#function-scenariosimulator_1","text":"explicit SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC ScenarioSimulator ( const rclcpp :: NodeOptions & options ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function ScenarioSimulator"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1SensorSimulation/","text":"scenario_simulator::SensorSimulation # Public Functions # Name void updateSensorFrame (double current_time, const std::vector< openscenario_msgs::EntityStatus > & status) void attachLidarSensor (const simulation_api_schema::LidarConfiguration & configuration, std::shared_ptr< rclcpp::Publisher< sensor_msgs::msg::PointCloud2 >> publisher_ptr) void attachDetectionSensor (const simulation_api_schema::DetectionSensorConfiguration & configuration, std::shared_ptr< rclcpp::Publisher< autoware_perception_msgs::msg::DynamicObjectArray >> publisher_ptr) SensorSimulation (const std::shared_ptr< rclcpp::Clock > & clock_ptr) Public Functions Documentation # function updateSensorFrame # void updateSensorFrame ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status ) function attachLidarSensor # void attachLidarSensor ( const simulation_api_schema :: LidarConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < sensor_msgs :: msg :: PointCloud2 >> publisher_ptr ) function attachDetectionSensor # void attachDetectionSensor ( const simulation_api_schema :: DetectionSensorConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < autoware_perception_msgs :: msg :: DynamicObjectArray >> publisher_ptr ) function SensorSimulation # explicit SensorSimulation ( const std :: shared_ptr < rclcpp :: Clock > & clock_ptr ) Updated on 7 April 2021 at 00:31:55 UTC","title":"scenario_simulator::SensorSimulation"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1SensorSimulation/#scenario_simulatorsensorsimulation","text":"","title":"scenario_simulator::SensorSimulation"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1SensorSimulation/#public-functions","text":"Name void updateSensorFrame (double current_time, const std::vector< openscenario_msgs::EntityStatus > & status) void attachLidarSensor (const simulation_api_schema::LidarConfiguration & configuration, std::shared_ptr< rclcpp::Publisher< sensor_msgs::msg::PointCloud2 >> publisher_ptr) void attachDetectionSensor (const simulation_api_schema::DetectionSensorConfiguration & configuration, std::shared_ptr< rclcpp::Publisher< autoware_perception_msgs::msg::DynamicObjectArray >> publisher_ptr) SensorSimulation (const std::shared_ptr< rclcpp::Clock > & clock_ptr)","title":"Public Functions"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1SensorSimulation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1SensorSimulation/#function-updatesensorframe","text":"void updateSensorFrame ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status )","title":"function updateSensorFrame"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1SensorSimulation/#function-attachlidarsensor","text":"void attachLidarSensor ( const simulation_api_schema :: LidarConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < sensor_msgs :: msg :: PointCloud2 >> publisher_ptr )","title":"function attachLidarSensor"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1SensorSimulation/#function-attachdetectionsensor","text":"void attachDetectionSensor ( const simulation_api_schema :: DetectionSensorConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < autoware_perception_msgs :: msg :: DynamicObjectArray >> publisher_ptr )","title":"function attachDetectionSensor"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1SensorSimulation/#function-sensorsimulation","text":"explicit SensorSimulation ( const std :: shared_ptr < rclcpp :: Clock > & clock_ptr ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function SensorSimulation"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1SimulationRuntimeError/","text":"scenario_simulator::SimulationRuntimeError # Inherits from runtime_error Public Functions # Name SimulationRuntimeError (const char * message) Public Functions Documentation # function SimulationRuntimeError # inline explicit SimulationRuntimeError ( const char * message ) Updated on 7 April 2021 at 00:31:55 UTC","title":"scenario_simulator::SimulationRuntimeError"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1SimulationRuntimeError/#scenario_simulatorsimulationruntimeerror","text":"Inherits from runtime_error","title":"scenario_simulator::SimulationRuntimeError"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1SimulationRuntimeError/#public-functions","text":"Name SimulationRuntimeError (const char * message)","title":"Public Functions"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1SimulationRuntimeError/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1SimulationRuntimeError/#function-simulationruntimeerror","text":"inline explicit SimulationRuntimeError ( const char * message ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function SimulationRuntimeError"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Box/","text":"scenario_simulator::primitives::Box # Inherits from scenario_simulator::primitives::Primitive Public Functions # Name ~Box () =default Box (float depth, float width, float height, geometry_msgs::msg::Pose pose) Public Attributes # Name const float width const float height const float depth Additional inherited members # Public Functions inherited from scenario_simulator::primitives::Primitive Name virtual ~Primitive () =default std::vector< Vertex > getVertex () const std::vector< Triangle > getTriangles () const unsigned int addToScene (RTCDevice device, RTCScene scene) Primitive (std::string type, geometry_msgs::msg::Pose pose) Protected Functions inherited from scenario_simulator::primitives::Primitive Name std::vector< Vertex > transform () const Public Attributes inherited from scenario_simulator::primitives::Primitive Name const std::string type const geometry_msgs::msg::Pose pose Protected Attributes inherited from scenario_simulator::primitives::Primitive Name std::vector< Vertex > vertices_ std::vector< Triangle > triangles_ Public Functions Documentation # function ~Box # ~ Box () = default function Box # explicit Box ( float depth , float width , float height , geometry_msgs :: msg :: Pose pose ) Public Attributes Documentation # variable width # const float width ; variable height # const float height ; variable depth # const float depth ; Updated on 7 April 2021 at 00:31:55 UTC","title":"scenario_simulator::primitives::Box"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Box/#scenario_simulatorprimitivesbox","text":"Inherits from scenario_simulator::primitives::Primitive","title":"scenario_simulator::primitives::Box"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Box/#public-functions","text":"Name ~Box () =default Box (float depth, float width, float height, geometry_msgs::msg::Pose pose)","title":"Public Functions"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Box/#public-attributes","text":"Name const float width const float height const float depth","title":"Public Attributes"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Box/#additional-inherited-members","text":"Public Functions inherited from scenario_simulator::primitives::Primitive Name virtual ~Primitive () =default std::vector< Vertex > getVertex () const std::vector< Triangle > getTriangles () const unsigned int addToScene (RTCDevice device, RTCScene scene) Primitive (std::string type, geometry_msgs::msg::Pose pose) Protected Functions inherited from scenario_simulator::primitives::Primitive Name std::vector< Vertex > transform () const Public Attributes inherited from scenario_simulator::primitives::Primitive Name const std::string type const geometry_msgs::msg::Pose pose Protected Attributes inherited from scenario_simulator::primitives::Primitive Name std::vector< Vertex > vertices_ std::vector< Triangle > triangles_","title":"Additional inherited members"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Box/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Box/#function-box","text":"~ Box () = default","title":"function ~Box"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Box/#function-box_1","text":"explicit Box ( float depth , float width , float height , geometry_msgs :: msg :: Pose pose )","title":"function Box"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Box/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Box/#variable-width","text":"const float width ;","title":"variable width"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Box/#variable-height","text":"const float height ;","title":"variable height"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Box/#variable-depth","text":"const float depth ; Updated on 7 April 2021 at 00:31:55 UTC","title":"variable depth"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/","text":"scenario_simulator::primitives::Primitive # Inherited by scenario_simulator::primitives::Box Public Functions # Name virtual ~Primitive () =default std::vector< Vertex > getVertex () const std::vector< Triangle > getTriangles () const unsigned int addToScene (RTCDevice device, RTCScene scene) Primitive (std::string type, geometry_msgs::msg::Pose pose) Protected Functions # Name std::vector< Vertex > transform () const Public Attributes # Name const std::string type const geometry_msgs::msg::Pose pose Protected Attributes # Name std::vector< Vertex > vertices_ std::vector< Triangle > triangles_ Public Functions Documentation # function ~Primitive # virtual ~ Primitive () = default function getVertex # std :: vector < Vertex > getVertex () const function getTriangles # std :: vector < Triangle > getTriangles () const function addToScene # unsigned int addToScene ( RTCDevice device , RTCScene scene ) function Primitive # Primitive ( std :: string type , geometry_msgs :: msg :: Pose pose ) Protected Functions Documentation # function transform # std :: vector < Vertex > transform () const Public Attributes Documentation # variable type # const std :: string type ; variable pose # const geometry_msgs :: msg :: Pose pose ; Protected Attributes Documentation # variable vertices_ # std :: vector < Vertex > vertices_ ; variable triangles_ # std :: vector < Triangle > triangles_ ; Updated on 7 April 2021 at 00:31:55 UTC","title":"scenario_simulator::primitives::Primitive"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#scenario_simulatorprimitivesprimitive","text":"Inherited by scenario_simulator::primitives::Box","title":"scenario_simulator::primitives::Primitive"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#public-functions","text":"Name virtual ~Primitive () =default std::vector< Vertex > getVertex () const std::vector< Triangle > getTriangles () const unsigned int addToScene (RTCDevice device, RTCScene scene) Primitive (std::string type, geometry_msgs::msg::Pose pose)","title":"Public Functions"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#protected-functions","text":"Name std::vector< Vertex > transform () const","title":"Protected Functions"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#public-attributes","text":"Name const std::string type const geometry_msgs::msg::Pose pose","title":"Public Attributes"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#protected-attributes","text":"Name std::vector< Vertex > vertices_ std::vector< Triangle > triangles_","title":"Protected Attributes"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#function-primitive","text":"virtual ~ Primitive () = default","title":"function ~Primitive"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#function-getvertex","text":"std :: vector < Vertex > getVertex () const","title":"function getVertex"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#function-gettriangles","text":"std :: vector < Triangle > getTriangles () const","title":"function getTriangles"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#function-addtoscene","text":"unsigned int addToScene ( RTCDevice device , RTCScene scene )","title":"function addToScene"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#function-primitive_1","text":"Primitive ( std :: string type , geometry_msgs :: msg :: Pose pose )","title":"function Primitive"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#function-transform","text":"std :: vector < Vertex > transform () const","title":"function transform"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#variable-type","text":"const std :: string type ;","title":"variable type"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#variable-pose","text":"const geometry_msgs :: msg :: Pose pose ;","title":"variable pose"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#variable-vertices_","text":"std :: vector < Vertex > vertices_ ;","title":"variable vertices_"},{"location":"package/scenario_simulator/markdown/Classes/classscenario__simulator_1_1primitives_1_1Primitive/#variable-triangles_","text":"std :: vector < Triangle > triangles_ ; Updated on 7 April 2021 at 00:31:55 UTC","title":"variable triangles_"},{"location":"package/scenario_simulator/markdown/Classes/structscenario__simulator_1_1Triangle/","text":"scenario_simulator::Triangle # Public Attributes # Name unsigned int v2 unsigned int v1 unsigned int v0 Public Attributes Documentation # variable v2 # unsigned int v2 ; variable v1 # unsigned int v1 ; variable v0 # unsigned int v0 ; Updated on 7 April 2021 at 00:31:55 UTC","title":"scenario_simulator::Triangle"},{"location":"package/scenario_simulator/markdown/Classes/structscenario__simulator_1_1Triangle/#scenario_simulatortriangle","text":"","title":"scenario_simulator::Triangle"},{"location":"package/scenario_simulator/markdown/Classes/structscenario__simulator_1_1Triangle/#public-attributes","text":"Name unsigned int v2 unsigned int v1 unsigned int v0","title":"Public Attributes"},{"location":"package/scenario_simulator/markdown/Classes/structscenario__simulator_1_1Triangle/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/scenario_simulator/markdown/Classes/structscenario__simulator_1_1Triangle/#variable-v2","text":"unsigned int v2 ;","title":"variable v2"},{"location":"package/scenario_simulator/markdown/Classes/structscenario__simulator_1_1Triangle/#variable-v1","text":"unsigned int v1 ;","title":"variable v1"},{"location":"package/scenario_simulator/markdown/Classes/structscenario__simulator_1_1Triangle/#variable-v0","text":"unsigned int v0 ; Updated on 7 April 2021 at 00:31:55 UTC","title":"variable v0"},{"location":"package/scenario_simulator/markdown/Classes/structscenario__simulator_1_1Vertex/","text":"scenario_simulator::Vertex # Public Attributes # Name float z float y float x Public Attributes Documentation # variable z # float z ; variable y # float y ; variable x # float x ; Updated on 7 April 2021 at 00:31:55 UTC","title":"scenario_simulator::Vertex"},{"location":"package/scenario_simulator/markdown/Classes/structscenario__simulator_1_1Vertex/#scenario_simulatorvertex","text":"","title":"scenario_simulator::Vertex"},{"location":"package/scenario_simulator/markdown/Classes/structscenario__simulator_1_1Vertex/#public-attributes","text":"Name float z float y float x","title":"Public Attributes"},{"location":"package/scenario_simulator/markdown/Classes/structscenario__simulator_1_1Vertex/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/scenario_simulator/markdown/Classes/structscenario__simulator_1_1Vertex/#variable-z","text":"float z ;","title":"variable z"},{"location":"package/scenario_simulator/markdown/Classes/structscenario__simulator_1_1Vertex/#variable-y","text":"float y ;","title":"variable y"},{"location":"package/scenario_simulator/markdown/Classes/structscenario__simulator_1_1Vertex/#variable-x","text":"float x ; Updated on 7 April 2021 at 00:31:55 UTC","title":"variable x"},{"location":"package/scenario_simulator/markdown/Examples/","text":"Examples # Updated on 7 April 2021 at 00:31:55 UTC","title":"Examples"},{"location":"package/scenario_simulator/markdown/Examples/#examples","text":"Updated on 7 April 2021 at 00:31:55 UTC","title":"Examples"},{"location":"package/scenario_simulator/markdown/Files/","text":"Files # dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/detection_sensor file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/detection_sensor/detection_sensor.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar/lidar_sensor.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar/raycaster.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives/box.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives/primitive.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/sensor_simulation.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/constants.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/exception.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/scenario_simulator.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/detection_sensor file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/detection_sensor/detection_sensor.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar/lidar_sensor.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar/raycaster.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives/box.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives/primitive.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/sensor_simulation.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/scenario_simulator.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/scenario_simulator_node.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/scenario_simulator/markdown/Files/#files","text":"dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/detection_sensor file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/detection_sensor/detection_sensor.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar/lidar_sensor.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar/raycaster.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives/box.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives/primitive.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/sensor_simulation.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/constants.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/exception.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/scenario_simulator.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/detection_sensor file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/detection_sensor/detection_sensor.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar/lidar_sensor.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar/raycaster.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives/box.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives/primitive.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/sensor_simulation.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/scenario_simulator.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/scenario_simulator_node.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/scenario_simulator/markdown/Files/box_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives/box.cpp # Namespaces # Name scenario_simulator::primitives scenario_simulator Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <scenario_simulator/sensor_simulation/primitives/box.hpp> #include <vector> #include <string> #include <iostream> namespace scenario_simulator { namespace primitives { Box :: Box ( float depth , float width , float height , geometry_msgs :: msg :: Pose pose ) : Primitive ( \"Box\" , pose ), depth ( depth ), width ( width ), height ( height ) { vertices_ = std :: vector < Vertex > ( 8 ); vertices_ [ 0 ]. x = -0.5 * depth ; vertices_ [ 0 ]. y = -0.5 * width ; vertices_ [ 0 ]. z = -0.5 * height ; vertices_ [ 1 ]. x = -0.5 * depth ; vertices_ [ 1 ]. y = -0.5 * width ; vertices_ [ 1 ]. z = + 0.5 * height ; vertices_ [ 2 ]. x = -0.5 * depth ; vertices_ [ 2 ]. y = + 0.5 * width ; vertices_ [ 2 ]. z = -0.5 * height ; vertices_ [ 3 ]. x = -0.5 * depth ; vertices_ [ 3 ]. y = + 0.5 * width ; vertices_ [ 3 ]. z = + 0.5 * height ; vertices_ [ 4 ]. x = + 0.5 * depth ; vertices_ [ 4 ]. y = -0.5 * width ; vertices_ [ 4 ]. z = -0.5 * height ; vertices_ [ 5 ]. x = + 0.5 * depth ; vertices_ [ 5 ]. y = -0.5 * width ; vertices_ [ 5 ]. z = + 0.5 * height ; vertices_ [ 6 ]. x = + 0.5 * depth ; vertices_ [ 6 ]. y = + 0.5 * width ; vertices_ [ 6 ]. z = -0.5 * height ; vertices_ [ 7 ]. x = + 0.5 * depth ; vertices_ [ 7 ]. y = + 0.5 * width ; vertices_ [ 7 ]. z = + 0.5 * height ; triangles_ = std :: vector < Triangle > ( 12 ); triangles_ [ 0 ]. v0 = 0 ; triangles_ [ 0 ]. v1 = 1 ; triangles_ [ 0 ]. v2 = 2 ; triangles_ [ 1 ]. v0 = 1 ; triangles_ [ 1 ]. v1 = 3 ; triangles_ [ 1 ]. v2 = 2 ; triangles_ [ 2 ]. v0 = 4 ; triangles_ [ 2 ]. v1 = 6 ; triangles_ [ 2 ]. v2 = 5 ; triangles_ [ 3 ]. v0 = 5 ; triangles_ [ 3 ]. v1 = 6 ; triangles_ [ 3 ]. v2 = 7 ; triangles_ [ 4 ]. v0 = 0 ; triangles_ [ 4 ]. v1 = 4 ; triangles_ [ 4 ]. v2 = 1 ; triangles_ [ 5 ]. v0 = 1 ; triangles_ [ 5 ]. v1 = 4 ; triangles_ [ 5 ]. v2 = 5 ; triangles_ [ 6 ]. v0 = 2 ; triangles_ [ 6 ]. v1 = 3 ; triangles_ [ 6 ]. v2 = 6 ; triangles_ [ 7 ]. v0 = 3 ; triangles_ [ 7 ]. v1 = 7 ; triangles_ [ 7 ]. v2 = 6 ; triangles_ [ 8 ]. v0 = 0 ; triangles_ [ 8 ]. v1 = 2 ; triangles_ [ 8 ]. v2 = 4 ; triangles_ [ 9 ]. v0 = 2 ; triangles_ [ 9 ]. v1 = 6 ; triangles_ [ 9 ]. v2 = 4 ; triangles_ [ 10 ]. v0 = 1 ; triangles_ [ 10 ]. v1 = 5 ; triangles_ [ 10 ]. v2 = 3 ; triangles_ [ 11 ]. v0 = 3 ; triangles_ [ 11 ]. v1 = 5 ; triangles_ [ 11 ]. v2 = 7 ; transform (); } } // namespace primitives } // namespace scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives/box.cpp"},{"location":"package/scenario_simulator/markdown/Files/box_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorsrcsensor_simulationprimitivesboxcpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives/box.cpp"},{"location":"package/scenario_simulator/markdown/Files/box_8cpp/#namespaces","text":"Name scenario_simulator::primitives scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/box_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <scenario_simulator/sensor_simulation/primitives/box.hpp> #include <vector> #include <string> #include <iostream> namespace scenario_simulator { namespace primitives { Box :: Box ( float depth , float width , float height , geometry_msgs :: msg :: Pose pose ) : Primitive ( \"Box\" , pose ), depth ( depth ), width ( width ), height ( height ) { vertices_ = std :: vector < Vertex > ( 8 ); vertices_ [ 0 ]. x = -0.5 * depth ; vertices_ [ 0 ]. y = -0.5 * width ; vertices_ [ 0 ]. z = -0.5 * height ; vertices_ [ 1 ]. x = -0.5 * depth ; vertices_ [ 1 ]. y = -0.5 * width ; vertices_ [ 1 ]. z = + 0.5 * height ; vertices_ [ 2 ]. x = -0.5 * depth ; vertices_ [ 2 ]. y = + 0.5 * width ; vertices_ [ 2 ]. z = -0.5 * height ; vertices_ [ 3 ]. x = -0.5 * depth ; vertices_ [ 3 ]. y = + 0.5 * width ; vertices_ [ 3 ]. z = + 0.5 * height ; vertices_ [ 4 ]. x = + 0.5 * depth ; vertices_ [ 4 ]. y = -0.5 * width ; vertices_ [ 4 ]. z = -0.5 * height ; vertices_ [ 5 ]. x = + 0.5 * depth ; vertices_ [ 5 ]. y = -0.5 * width ; vertices_ [ 5 ]. z = + 0.5 * height ; vertices_ [ 6 ]. x = + 0.5 * depth ; vertices_ [ 6 ]. y = + 0.5 * width ; vertices_ [ 6 ]. z = -0.5 * height ; vertices_ [ 7 ]. x = + 0.5 * depth ; vertices_ [ 7 ]. y = + 0.5 * width ; vertices_ [ 7 ]. z = + 0.5 * height ; triangles_ = std :: vector < Triangle > ( 12 ); triangles_ [ 0 ]. v0 = 0 ; triangles_ [ 0 ]. v1 = 1 ; triangles_ [ 0 ]. v2 = 2 ; triangles_ [ 1 ]. v0 = 1 ; triangles_ [ 1 ]. v1 = 3 ; triangles_ [ 1 ]. v2 = 2 ; triangles_ [ 2 ]. v0 = 4 ; triangles_ [ 2 ]. v1 = 6 ; triangles_ [ 2 ]. v2 = 5 ; triangles_ [ 3 ]. v0 = 5 ; triangles_ [ 3 ]. v1 = 6 ; triangles_ [ 3 ]. v2 = 7 ; triangles_ [ 4 ]. v0 = 0 ; triangles_ [ 4 ]. v1 = 4 ; triangles_ [ 4 ]. v2 = 1 ; triangles_ [ 5 ]. v0 = 1 ; triangles_ [ 5 ]. v1 = 4 ; triangles_ [ 5 ]. v2 = 5 ; triangles_ [ 6 ]. v0 = 2 ; triangles_ [ 6 ]. v1 = 3 ; triangles_ [ 6 ]. v2 = 6 ; triangles_ [ 7 ]. v0 = 3 ; triangles_ [ 7 ]. v1 = 7 ; triangles_ [ 7 ]. v2 = 6 ; triangles_ [ 8 ]. v0 = 0 ; triangles_ [ 8 ]. v1 = 2 ; triangles_ [ 8 ]. v2 = 4 ; triangles_ [ 9 ]. v0 = 2 ; triangles_ [ 9 ]. v1 = 6 ; triangles_ [ 9 ]. v2 = 4 ; triangles_ [ 10 ]. v0 = 1 ; triangles_ [ 10 ]. v1 = 5 ; triangles_ [ 10 ]. v2 = 3 ; triangles_ [ 11 ]. v0 = 3 ; triangles_ [ 11 ]. v1 = 5 ; triangles_ [ 11 ]. v2 = 7 ; transform (); } } // namespace primitives } // namespace scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/box_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives/box.hpp # Namespaces # Name scenario_simulator::primitives scenario_simulator Classes # Name class scenario_simulator::primitives::Box Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__SENSOR_SIMULATION__PRIMITIVES__BOX_HPP_ #define SCENARIO_SIMULATOR__SENSOR_SIMULATION__PRIMITIVES__BOX_HPP_ #include <scenario_simulator/sensor_simulation/primitives/primitive.hpp> #include <simulation_api_schema.pb.h> namespace scenario_simulator { namespace primitives { class Box : public Primitive { public : explicit Box ( float depth , float width , float height , geometry_msgs :: msg :: Pose pose ); ~ Box () = default ; const float depth ; const float width ; const float height ; }; } // namespace primitives } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__SENSOR_SIMULATION__PRIMITIVES__BOX_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives/box.hpp"},{"location":"package/scenario_simulator/markdown/Files/box_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorincludescenario_simulatorsensor_simulationprimitivesboxhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives/box.hpp"},{"location":"package/scenario_simulator/markdown/Files/box_8hpp/#namespaces","text":"Name scenario_simulator::primitives scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/box_8hpp/#classes","text":"Name class scenario_simulator::primitives::Box","title":"Classes"},{"location":"package/scenario_simulator/markdown/Files/box_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__SENSOR_SIMULATION__PRIMITIVES__BOX_HPP_ #define SCENARIO_SIMULATOR__SENSOR_SIMULATION__PRIMITIVES__BOX_HPP_ #include <scenario_simulator/sensor_simulation/primitives/primitive.hpp> #include <simulation_api_schema.pb.h> namespace scenario_simulator { namespace primitives { class Box : public Primitive { public : explicit Box ( float depth , float width , float height , geometry_msgs :: msg :: Pose pose ); ~ Box () = default ; const float depth ; const float width ; const float height ; }; } // namespace primitives } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__SENSOR_SIMULATION__PRIMITIVES__BOX_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/constants_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/constants.hpp # Namespaces # Name scenario_simulator::return_code scenario_simulator Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__CONSTANTS_HPP_ #define SCENARIO_SIMULATOR__CONSTANTS_HPP_ namespace scenario_simulator { namespace return_code { constexpr int SUCCESS = 0 ; constexpr int FAIL = 1 ; } } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__CONSTANTS_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/constants.hpp"},{"location":"package/scenario_simulator/markdown/Files/constants_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorincludescenario_simulatorconstantshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/constants.hpp"},{"location":"package/scenario_simulator/markdown/Files/constants_8hpp/#namespaces","text":"Name scenario_simulator::return_code scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/constants_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__CONSTANTS_HPP_ #define SCENARIO_SIMULATOR__CONSTANTS_HPP_ namespace scenario_simulator { namespace return_code { constexpr int SUCCESS = 0 ; constexpr int FAIL = 1 ; } } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__CONSTANTS_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/detection__sensor_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/detection_sensor/detection_sensor.cpp # Namespaces # Name scenario_simulator Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <scenario_simulator/sensor_simulation/detection_sensor/detection_sensor.hpp> #include <simulation_interface/conversions.hpp> #include <boost/uuid/uuid.hpp> #include <boost/uuid/uuid_io.hpp> #include <boost/uuid/uuid_generators.hpp> #include <memory> #include <string> #include <algorithm> #include <vector> namespace scenario_simulator { DetectionSensor :: DetectionSensor ( const simulation_api_schema :: DetectionSensorConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < autoware_perception_msgs :: msg :: DynamicObjectArray >> publisher_ptr ) : configuration_ ( configuration ), publisher_ptr_ ( publisher_ptr ) { last_update_stamp_ = 0 ; } void DetectionSensor :: update ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp , const std :: vector < std :: string > & detected_objects ) { if (( current_time - last_update_stamp_ ) >= configuration_ . update_duration ()) { autoware_perception_msgs :: msg :: DynamicObjectArray msg ; msg . header . stamp = stamp ; msg . header . frame_id = configuration_ . entity (); last_update_stamp_ = current_time ; for ( const auto & s : status ) { auto result = std :: find ( detected_objects . begin (), detected_objects . end (), s . name ()); if ( result != detected_objects . end ()) { autoware_perception_msgs :: msg :: DynamicObject object ; if ( s . type () == openscenario_msgs :: EntityType :: EGO ) { object . semantic . type = object . semantic . CAR ; object . semantic . confidence = 1 ; } else if ( s . type () == openscenario_msgs :: EntityType :: VEHICLE ) { object . semantic . type = object . semantic . CAR ; object . semantic . confidence = 1 ; } else if ( s . type () == openscenario_msgs :: EntityType :: PEDESTRIAN ) { object . semantic . type = object . semantic . PEDESTRIAN ; object . semantic . confidence = 1 ; } boost :: uuids :: uuid base = boost :: uuids :: string_generator ()( \"0123456789abcdef0123456789abcdef\" ); boost :: uuids :: name_generator gen ( base ); boost :: uuids :: uuid uuid = gen ( s . name ()); std :: copy ( uuid . begin (), uuid . end (), object . id . uuid . begin ()); simulation_interface :: toMsg ( s . bounding_box (). dimensions (), object . shape . dimensions ); object . shape . type = object . shape . BOUNDING_BOX ; object . state . orientation_reliable = true ; simulation_interface :: toMsg ( s . action_status (). twist (), object . state . twist_covariance . twist ); object . state . twist_reliable = true ; simulation_interface :: toMsg ( s . action_status (). accel (), object . state . acceleration_covariance . accel ); object . state . acceleration_reliable = true ; msg . objects . emplace_back ( object ); } } publisher_ptr_ -> publish ( msg ); } } } // namespace scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/detection_sensor/detection_sensor.cpp"},{"location":"package/scenario_simulator/markdown/Files/detection__sensor_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorsrcsensor_simulationdetection_sensordetection_sensorcpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/detection_sensor/detection_sensor.cpp"},{"location":"package/scenario_simulator/markdown/Files/detection__sensor_8cpp/#namespaces","text":"Name scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/detection__sensor_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <scenario_simulator/sensor_simulation/detection_sensor/detection_sensor.hpp> #include <simulation_interface/conversions.hpp> #include <boost/uuid/uuid.hpp> #include <boost/uuid/uuid_io.hpp> #include <boost/uuid/uuid_generators.hpp> #include <memory> #include <string> #include <algorithm> #include <vector> namespace scenario_simulator { DetectionSensor :: DetectionSensor ( const simulation_api_schema :: DetectionSensorConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < autoware_perception_msgs :: msg :: DynamicObjectArray >> publisher_ptr ) : configuration_ ( configuration ), publisher_ptr_ ( publisher_ptr ) { last_update_stamp_ = 0 ; } void DetectionSensor :: update ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp , const std :: vector < std :: string > & detected_objects ) { if (( current_time - last_update_stamp_ ) >= configuration_ . update_duration ()) { autoware_perception_msgs :: msg :: DynamicObjectArray msg ; msg . header . stamp = stamp ; msg . header . frame_id = configuration_ . entity (); last_update_stamp_ = current_time ; for ( const auto & s : status ) { auto result = std :: find ( detected_objects . begin (), detected_objects . end (), s . name ()); if ( result != detected_objects . end ()) { autoware_perception_msgs :: msg :: DynamicObject object ; if ( s . type () == openscenario_msgs :: EntityType :: EGO ) { object . semantic . type = object . semantic . CAR ; object . semantic . confidence = 1 ; } else if ( s . type () == openscenario_msgs :: EntityType :: VEHICLE ) { object . semantic . type = object . semantic . CAR ; object . semantic . confidence = 1 ; } else if ( s . type () == openscenario_msgs :: EntityType :: PEDESTRIAN ) { object . semantic . type = object . semantic . PEDESTRIAN ; object . semantic . confidence = 1 ; } boost :: uuids :: uuid base = boost :: uuids :: string_generator ()( \"0123456789abcdef0123456789abcdef\" ); boost :: uuids :: name_generator gen ( base ); boost :: uuids :: uuid uuid = gen ( s . name ()); std :: copy ( uuid . begin (), uuid . end (), object . id . uuid . begin ()); simulation_interface :: toMsg ( s . bounding_box (). dimensions (), object . shape . dimensions ); object . shape . type = object . shape . BOUNDING_BOX ; object . state . orientation_reliable = true ; simulation_interface :: toMsg ( s . action_status (). twist (), object . state . twist_covariance . twist ); object . state . twist_reliable = true ; simulation_interface :: toMsg ( s . action_status (). accel (), object . state . acceleration_covariance . accel ); object . state . acceleration_reliable = true ; msg . objects . emplace_back ( object ); } } publisher_ptr_ -> publish ( msg ); } } } // namespace scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/detection__sensor_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/detection_sensor/detection_sensor.hpp # Namespaces # Name scenario_simulator Classes # Name class scenario_simulator::DetectionSensor Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__SENSOR_SIMULATION__DETECTION_SENSOR__DETECTION_SENSOR_HPP_ #define SCENARIO_SIMULATOR__SENSOR_SIMULATION__DETECTION_SENSOR__DETECTION_SENSOR_HPP_ #include <simulation_api_schema.pb.h> #include <rclcpp/rclcpp.hpp> #include <autoware_perception_msgs/msg/dynamic_object_array.hpp> #include <memory> #include <string> #include <vector> namespace scenario_simulator { class DetectionSensor { public : DetectionSensor ( const simulation_api_schema :: DetectionSensorConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < autoware_perception_msgs :: msg :: DynamicObjectArray >> publisher_ptr ); void update ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp , const std :: vector < std :: string > & detected_objects ); private : simulation_api_schema :: DetectionSensorConfiguration configuration_ ; std :: shared_ptr < rclcpp :: Publisher < autoware_perception_msgs :: msg :: DynamicObjectArray >> publisher_ptr_ ; double last_update_stamp_ ; }; } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__SENSOR_SIMULATION__DETECTION_SENSOR__DETECTION_SENSOR_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/detection_sensor/detection_sensor.hpp"},{"location":"package/scenario_simulator/markdown/Files/detection__sensor_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorincludescenario_simulatorsensor_simulationdetection_sensordetection_sensorhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/detection_sensor/detection_sensor.hpp"},{"location":"package/scenario_simulator/markdown/Files/detection__sensor_8hpp/#namespaces","text":"Name scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/detection__sensor_8hpp/#classes","text":"Name class scenario_simulator::DetectionSensor","title":"Classes"},{"location":"package/scenario_simulator/markdown/Files/detection__sensor_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__SENSOR_SIMULATION__DETECTION_SENSOR__DETECTION_SENSOR_HPP_ #define SCENARIO_SIMULATOR__SENSOR_SIMULATION__DETECTION_SENSOR__DETECTION_SENSOR_HPP_ #include <simulation_api_schema.pb.h> #include <rclcpp/rclcpp.hpp> #include <autoware_perception_msgs/msg/dynamic_object_array.hpp> #include <memory> #include <string> #include <vector> namespace scenario_simulator { class DetectionSensor { public : DetectionSensor ( const simulation_api_schema :: DetectionSensorConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < autoware_perception_msgs :: msg :: DynamicObjectArray >> publisher_ptr ); void update ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp , const std :: vector < std :: string > & detected_objects ); private : simulation_api_schema :: DetectionSensorConfiguration configuration_ ; std :: shared_ptr < rclcpp :: Publisher < autoware_perception_msgs :: msg :: DynamicObjectArray >> publisher_ptr_ ; double last_update_stamp_ ; }; } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__SENSOR_SIMULATION__DETECTION_SENSOR__DETECTION_SENSOR_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/dir_0b4ae7c21424fa817b5ae1a4d99081c2/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/detection_sensor Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/sensor_simulation.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation"},{"location":"package/scenario_simulator/markdown/Files/dir_0b4ae7c21424fa817b5ae1a4d99081c2/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorincludescenario_simulatorsensor_simulation","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation"},{"location":"package/scenario_simulator/markdown/Files/dir_0b4ae7c21424fa817b5ae1a4d99081c2/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/detection_sensor","title":"Directories"},{"location":"package/scenario_simulator/markdown/Files/dir_0b4ae7c21424fa817b5ae1a4d99081c2/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/sensor_simulation.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/scenario_simulator/markdown/Files/dir_20fa0c23d39d4fe3e5575b6965f865a4/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include"},{"location":"package/scenario_simulator/markdown/Files/dir_20fa0c23d39d4fe3e5575b6965f865a4/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorinclude","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include"},{"location":"package/scenario_simulator/markdown/Files/dir_20fa0c23d39d4fe3e5575b6965f865a4/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"Directories"},{"location":"package/scenario_simulator/markdown/Files/dir_3a1bd3702eca397e6a02e435fa858e54/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/detection_sensor # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/detection_sensor/detection_sensor.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/detection_sensor"},{"location":"package/scenario_simulator/markdown/Files/dir_3a1bd3702eca397e6a02e435fa858e54/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorincludescenario_simulatorsensor_simulationdetection_sensor","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/detection_sensor"},{"location":"package/scenario_simulator/markdown/Files/dir_3a1bd3702eca397e6a02e435fa858e54/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/detection_sensor/detection_sensor.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/scenario_simulator/markdown/Files/dir_4117eee221ed85568c68a5edaa4ed180/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/detection_sensor # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/detection_sensor/detection_sensor.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/detection_sensor"},{"location":"package/scenario_simulator/markdown/Files/dir_4117eee221ed85568c68a5edaa4ed180/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorsrcsensor_simulationdetection_sensor","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/detection_sensor"},{"location":"package/scenario_simulator/markdown/Files/dir_4117eee221ed85568c68a5edaa4ed180/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/detection_sensor/detection_sensor.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/scenario_simulator/markdown/Files/dir_523099071df9c48ae635fb065e22d598/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/detection_sensor Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/sensor_simulation.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation"},{"location":"package/scenario_simulator/markdown/Files/dir_523099071df9c48ae635fb065e22d598/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorsrcsensor_simulation","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation"},{"location":"package/scenario_simulator/markdown/Files/dir_523099071df9c48ae635fb065e22d598/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/detection_sensor","title":"Directories"},{"location":"package/scenario_simulator/markdown/Files/dir_523099071df9c48ae635fb065e22d598/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/sensor_simulation.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/scenario_simulator/markdown/Files/dir_5569101f21e14836a81e1c1079d22a3e/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/scenario_simulator.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/exception.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/constants.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator"},{"location":"package/scenario_simulator/markdown/Files/dir_5569101f21e14836a81e1c1079d22a3e/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorincludescenario_simulator","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator"},{"location":"package/scenario_simulator/markdown/Files/dir_5569101f21e14836a81e1c1079d22a3e/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation","title":"Directories"},{"location":"package/scenario_simulator/markdown/Files/dir_5569101f21e14836a81e1c1079d22a3e/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/scenario_simulator.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/exception.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/constants.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/scenario_simulator/markdown/Files/dir_7487f41de01cca700e4de80b884d7106/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation"},{"location":"package/scenario_simulator/markdown/Files/dir_7487f41de01cca700e4de80b884d7106/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulation","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation"},{"location":"package/scenario_simulator/markdown/Files/dir_7487f41de01cca700e4de80b884d7106/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"Directories"},{"location":"package/scenario_simulator/markdown/Files/dir_783bd4747d0224350fd68d85ad2d4e5d/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/scenario_simulator_node.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/scenario_simulator.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src"},{"location":"package/scenario_simulator/markdown/Files/dir_783bd4747d0224350fd68d85ad2d4e5d/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorsrc","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src"},{"location":"package/scenario_simulator/markdown/Files/dir_783bd4747d0224350fd68d85ad2d4e5d/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation","title":"Directories"},{"location":"package/scenario_simulator/markdown/Files/dir_783bd4747d0224350fd68d85ad2d4e5d/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/scenario_simulator_node.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/scenario_simulator.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/scenario_simulator/markdown/Files/dir_856edb957f469f2f6afd3d544cd9321a/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives/primitive.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives/box.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives"},{"location":"package/scenario_simulator/markdown/Files/dir_856edb957f469f2f6afd3d544cd9321a/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorsrcsensor_simulationprimitives","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives"},{"location":"package/scenario_simulator/markdown/Files/dir_856edb957f469f2f6afd3d544cd9321a/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives/primitive.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives/box.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/scenario_simulator/markdown/Files/dir_87770a22932f4093de0a381a9c74db0d/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives/primitive.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives/box.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives"},{"location":"package/scenario_simulator/markdown/Files/dir_87770a22932f4093de0a381a9c74db0d/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorincludescenario_simulatorsensor_simulationprimitives","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives"},{"location":"package/scenario_simulator/markdown/Files/dir_87770a22932f4093de0a381a9c74db0d/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives/primitive.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives/box.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/scenario_simulator/markdown/Files/dir_994073e56c3447403fbf31b5bb657719/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar/raycaster.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar/lidar_sensor.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar"},{"location":"package/scenario_simulator/markdown/Files/dir_994073e56c3447403fbf31b5bb657719/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorincludescenario_simulatorsensor_simulationlidar","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar"},{"location":"package/scenario_simulator/markdown/Files/dir_994073e56c3447403fbf31b5bb657719/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar/raycaster.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar/lidar_sensor.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/scenario_simulator/markdown/Files/dir_b2d415c35017390a71dc83c78655cb99/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator"},{"location":"package/scenario_simulator/markdown/Files/dir_b2d415c35017390a71dc83c78655cb99/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulator","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator"},{"location":"package/scenario_simulator/markdown/Files/dir_b2d415c35017390a71dc83c78655cb99/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include Updated on 7 April 2021 at 00:31:55 UTC","title":"Directories"},{"location":"package/scenario_simulator/markdown/Files/dir_ca7ed1fbfaeeeacae970333381c86906/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar/raycaster.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar/lidar_sensor.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar"},{"location":"package/scenario_simulator/markdown/Files/dir_ca7ed1fbfaeeeacae970333381c86906/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorsrcsensor_simulationlidar","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar"},{"location":"package/scenario_simulator/markdown/Files/dir_ca7ed1fbfaeeeacae970333381c86906/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar/raycaster.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar/lidar_sensor.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/scenario_simulator/markdown/Files/exception_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/exception.hpp # Namespaces # Name scenario_simulator Classes # Name class scenario_simulator::SimulationRuntimeError Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__EXCEPTION_HPP_ #define SCENARIO_SIMULATOR__EXCEPTION_HPP_ #include <stdexcept> namespace scenario_simulator { class SimulationRuntimeError : public std :: runtime_error { public : explicit SimulationRuntimeError ( const char * message ) : runtime_error ( message ) {} private : }; } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__EXCEPTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/exception.hpp"},{"location":"package/scenario_simulator/markdown/Files/exception_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorincludescenario_simulatorexceptionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/exception.hpp"},{"location":"package/scenario_simulator/markdown/Files/exception_8hpp/#namespaces","text":"Name scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/exception_8hpp/#classes","text":"Name class scenario_simulator::SimulationRuntimeError","title":"Classes"},{"location":"package/scenario_simulator/markdown/Files/exception_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__EXCEPTION_HPP_ #define SCENARIO_SIMULATOR__EXCEPTION_HPP_ #include <stdexcept> namespace scenario_simulator { class SimulationRuntimeError : public std :: runtime_error { public : explicit SimulationRuntimeError ( const char * message ) : runtime_error ( message ) {} private : }; } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__EXCEPTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/lidar__sensor_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar/lidar_sensor.cpp # Namespaces # Name scenario_simulator Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <scenario_simulator/exception.hpp> #include <scenario_simulator/sensor_simulation/lidar/lidar_sensor.hpp> #include <scenario_simulator/sensor_simulation/lidar/raycaster.hpp> #include <simulation_interface/conversions.hpp> #include <quaternion_operation/quaternion_operation.h> #include <boost/optional.hpp> #include <vector> #include <memory> #include <string> namespace scenario_simulator { LidarSensor :: LidarSensor ( const simulation_api_schema :: LidarConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < sensor_msgs :: msg :: PointCloud2 >> publisher_ptr ) : configuration_ ( configuration ), publisher_ptr_ ( publisher_ptr ) { last_update_stamp_ = 0 ; } const std :: vector < std :: string > & LidarSensor :: getDetectedObjects () const { return detected_objects_ ; } void LidarSensor :: update ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp ) { if (( current_time - last_update_stamp_ ) >= configuration_ . scan_duration ()) { last_update_stamp_ = current_time ; publisher_ptr_ -> publish ( raycast ( status , stamp )); } else { detected_objects_ = {}; } } const sensor_msgs :: msg :: PointCloud2 LidarSensor :: raycast ( const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp ) { Raycaster raycaster ; boost :: optional < geometry_msgs :: msg :: Pose > ego_pose ; for ( const auto & s : status ) { if ( configuration_ . entity () == s . name ()) { geometry_msgs :: msg :: Pose pose ; simulation_interface :: toMsg ( s . pose (), pose ); ego_pose = pose ; } else { geometry_msgs :: msg :: Pose pose ; simulation_interface :: toMsg ( s . pose (), pose ); auto rotation = quaternion_operation :: getRotationMatrix ( pose . orientation ); geometry_msgs :: msg :: Point center_point ; simulation_interface :: toMsg ( s . bounding_box (). center (), center_point ); Eigen :: Vector3d center ( center_point . x , center_point . y , center_point . z ); center = rotation * center ; pose . position . x = pose . position . x + center . x (); pose . position . y = pose . position . y + center . y (); pose . position . z = pose . position . z + center . z (); raycaster . addPrimitive < scenario_simulator :: primitives :: Box > ( s . name (), s . bounding_box (). dimensions (). x (), s . bounding_box (). dimensions (). y (), s . bounding_box (). dimensions (). z (), pose ); } } if ( ego_pose ) { std :: vector < double > vertical_angles ; for ( const auto v : configuration_ . vertical_angles ()) { vertical_angles . emplace_back ( v ); } const auto poincloud = raycaster . raycast ( configuration_ . entity (), stamp , ego_pose . get (), configuration_ . horizontal_resolution (), vertical_angles ); detected_objects_ = raycaster . getDetectedObject (); return poincloud ; } throw scenario_simulator :: SimulationRuntimeError ( \"failed to found ego vehicle\" ); } } // namespace scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar/lidar_sensor.cpp"},{"location":"package/scenario_simulator/markdown/Files/lidar__sensor_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorsrcsensor_simulationlidarlidar_sensorcpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar/lidar_sensor.cpp"},{"location":"package/scenario_simulator/markdown/Files/lidar__sensor_8cpp/#namespaces","text":"Name scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/lidar__sensor_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <scenario_simulator/exception.hpp> #include <scenario_simulator/sensor_simulation/lidar/lidar_sensor.hpp> #include <scenario_simulator/sensor_simulation/lidar/raycaster.hpp> #include <simulation_interface/conversions.hpp> #include <quaternion_operation/quaternion_operation.h> #include <boost/optional.hpp> #include <vector> #include <memory> #include <string> namespace scenario_simulator { LidarSensor :: LidarSensor ( const simulation_api_schema :: LidarConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < sensor_msgs :: msg :: PointCloud2 >> publisher_ptr ) : configuration_ ( configuration ), publisher_ptr_ ( publisher_ptr ) { last_update_stamp_ = 0 ; } const std :: vector < std :: string > & LidarSensor :: getDetectedObjects () const { return detected_objects_ ; } void LidarSensor :: update ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp ) { if (( current_time - last_update_stamp_ ) >= configuration_ . scan_duration ()) { last_update_stamp_ = current_time ; publisher_ptr_ -> publish ( raycast ( status , stamp )); } else { detected_objects_ = {}; } } const sensor_msgs :: msg :: PointCloud2 LidarSensor :: raycast ( const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp ) { Raycaster raycaster ; boost :: optional < geometry_msgs :: msg :: Pose > ego_pose ; for ( const auto & s : status ) { if ( configuration_ . entity () == s . name ()) { geometry_msgs :: msg :: Pose pose ; simulation_interface :: toMsg ( s . pose (), pose ); ego_pose = pose ; } else { geometry_msgs :: msg :: Pose pose ; simulation_interface :: toMsg ( s . pose (), pose ); auto rotation = quaternion_operation :: getRotationMatrix ( pose . orientation ); geometry_msgs :: msg :: Point center_point ; simulation_interface :: toMsg ( s . bounding_box (). center (), center_point ); Eigen :: Vector3d center ( center_point . x , center_point . y , center_point . z ); center = rotation * center ; pose . position . x = pose . position . x + center . x (); pose . position . y = pose . position . y + center . y (); pose . position . z = pose . position . z + center . z (); raycaster . addPrimitive < scenario_simulator :: primitives :: Box > ( s . name (), s . bounding_box (). dimensions (). x (), s . bounding_box (). dimensions (). y (), s . bounding_box (). dimensions (). z (), pose ); } } if ( ego_pose ) { std :: vector < double > vertical_angles ; for ( const auto v : configuration_ . vertical_angles ()) { vertical_angles . emplace_back ( v ); } const auto poincloud = raycaster . raycast ( configuration_ . entity (), stamp , ego_pose . get (), configuration_ . horizontal_resolution (), vertical_angles ); detected_objects_ = raycaster . getDetectedObject (); return poincloud ; } throw scenario_simulator :: SimulationRuntimeError ( \"failed to found ego vehicle\" ); } } // namespace scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/lidar__sensor_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar/lidar_sensor.hpp # Namespaces # Name scenario_simulator Classes # Name class scenario_simulator::LidarSensor Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__SENSOR_SIMULATION__LIDAR__LIDAR_SENSOR_HPP_ #define SCENARIO_SIMULATOR__SENSOR_SIMULATION__LIDAR__LIDAR_SENSOR_HPP_ #include <simulation_api_schema.pb.h> #include <rclcpp/rclcpp.hpp> #include <sensor_msgs/msg/point_cloud2.hpp> #include <vector> #include <string> #include <memory> namespace scenario_simulator { class LidarSensor { public : LidarSensor ( const simulation_api_schema :: LidarConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < sensor_msgs :: msg :: PointCloud2 >> publisher_ptr ); void update ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp ); const std :: vector < std :: string > & getDetectedObjects () const ; private : simulation_api_schema :: LidarConfiguration configuration_ ; std :: shared_ptr < rclcpp :: Publisher < sensor_msgs :: msg :: PointCloud2 >> publisher_ptr_ ; const sensor_msgs :: msg :: PointCloud2 raycast ( const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp ); double last_update_stamp_ ; std :: vector < std :: string > detected_objects_ ; }; } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__SENSOR_SIMULATION__LIDAR__LIDAR_SENSOR_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar/lidar_sensor.hpp"},{"location":"package/scenario_simulator/markdown/Files/lidar__sensor_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorincludescenario_simulatorsensor_simulationlidarlidar_sensorhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar/lidar_sensor.hpp"},{"location":"package/scenario_simulator/markdown/Files/lidar__sensor_8hpp/#namespaces","text":"Name scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/lidar__sensor_8hpp/#classes","text":"Name class scenario_simulator::LidarSensor","title":"Classes"},{"location":"package/scenario_simulator/markdown/Files/lidar__sensor_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__SENSOR_SIMULATION__LIDAR__LIDAR_SENSOR_HPP_ #define SCENARIO_SIMULATOR__SENSOR_SIMULATION__LIDAR__LIDAR_SENSOR_HPP_ #include <simulation_api_schema.pb.h> #include <rclcpp/rclcpp.hpp> #include <sensor_msgs/msg/point_cloud2.hpp> #include <vector> #include <string> #include <memory> namespace scenario_simulator { class LidarSensor { public : LidarSensor ( const simulation_api_schema :: LidarConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < sensor_msgs :: msg :: PointCloud2 >> publisher_ptr ); void update ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp ); const std :: vector < std :: string > & getDetectedObjects () const ; private : simulation_api_schema :: LidarConfiguration configuration_ ; std :: shared_ptr < rclcpp :: Publisher < sensor_msgs :: msg :: PointCloud2 >> publisher_ptr_ ; const sensor_msgs :: msg :: PointCloud2 raycast ( const std :: vector < openscenario_msgs :: EntityStatus > & status , const rclcpp :: Time & stamp ); double last_update_stamp_ ; std :: vector < std :: string > detected_objects_ ; }; } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__SENSOR_SIMULATION__LIDAR__LIDAR_SENSOR_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/primitive_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives/primitive.cpp # Namespaces # Name scenario_simulator::primitives scenario_simulator Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <scenario_simulator/sensor_simulation/primitives/primitive.hpp> #include <quaternion_operation/quaternion_operation.h> #include <algorithm> #include <string> #include <vector> #include <iostream> namespace scenario_simulator { namespace primitives { Primitive :: Primitive ( std :: string type , geometry_msgs :: msg :: Pose pose ) : type ( type ), pose ( pose ) {} Vertex Primitive :: transform ( Vertex v ) const { auto mat = quaternion_operation :: getRotationMatrix ( pose . orientation ); Eigen :: VectorXd point ( 3 ); point ( 0 ) = v . x ; point ( 1 ) = v . y ; point ( 2 ) = v . z ; point = mat * point ; point ( 0 ) = point ( 0 ) + pose . position . x ; point ( 1 ) = point ( 1 ) + pose . position . y ; point ( 2 ) = point ( 2 ) + pose . position . z ; Vertex ret ; ret . x = point ( 0 ); ret . y = point ( 1 ); ret . z = point ( 2 ); return ret ; } std :: vector < Vertex > Primitive :: transform () const { std :: vector < Vertex > ret ; for ( auto & v : vertices_ ) { ret . emplace_back ( transform ( v )); } return ret ; } std :: vector < Vertex > Primitive :: getVertex () const { return transform (); } std :: vector < Triangle > Primitive :: getTriangles () const { return triangles_ ; } unsigned int Primitive :: addToScene ( RTCDevice device , RTCScene scene ) { RTCGeometry mesh = rtcNewGeometry ( device , RTC_GEOMETRY_TYPE_TRIANGLE ); const auto transformed_vertices = transform (); Vertex * vertices = static_cast < Vertex *> ( rtcSetNewGeometryBuffer ( mesh , RTC_BUFFER_TYPE_VERTEX , 0 , RTC_FORMAT_FLOAT3 , sizeof ( Vertex ), transformed_vertices . size ())); for ( size_t i = 0 ; i < transformed_vertices . size (); i ++ ) { vertices [ i ] = transformed_vertices [ i ]; } Triangle * triangles = static_cast < Triangle *> ( rtcSetNewGeometryBuffer ( mesh , RTC_BUFFER_TYPE_INDEX , 0 , RTC_FORMAT_UINT3 , sizeof ( Triangle ), triangles_ . size ())); for ( size_t i = 0 ; i < triangles_ . size (); i ++ ) { triangles [ i ] = triangles_ [ i ]; } rtcCommitGeometry ( mesh ); unsigned int geometry_id = rtcAttachGeometry ( scene , mesh ); rtcReleaseGeometry ( mesh ); return geometry_id ; } } // namespace primitives } // namespace scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives/primitive.cpp"},{"location":"package/scenario_simulator/markdown/Files/primitive_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorsrcsensor_simulationprimitivesprimitivecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/primitives/primitive.cpp"},{"location":"package/scenario_simulator/markdown/Files/primitive_8cpp/#namespaces","text":"Name scenario_simulator::primitives scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/primitive_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <scenario_simulator/sensor_simulation/primitives/primitive.hpp> #include <quaternion_operation/quaternion_operation.h> #include <algorithm> #include <string> #include <vector> #include <iostream> namespace scenario_simulator { namespace primitives { Primitive :: Primitive ( std :: string type , geometry_msgs :: msg :: Pose pose ) : type ( type ), pose ( pose ) {} Vertex Primitive :: transform ( Vertex v ) const { auto mat = quaternion_operation :: getRotationMatrix ( pose . orientation ); Eigen :: VectorXd point ( 3 ); point ( 0 ) = v . x ; point ( 1 ) = v . y ; point ( 2 ) = v . z ; point = mat * point ; point ( 0 ) = point ( 0 ) + pose . position . x ; point ( 1 ) = point ( 1 ) + pose . position . y ; point ( 2 ) = point ( 2 ) + pose . position . z ; Vertex ret ; ret . x = point ( 0 ); ret . y = point ( 1 ); ret . z = point ( 2 ); return ret ; } std :: vector < Vertex > Primitive :: transform () const { std :: vector < Vertex > ret ; for ( auto & v : vertices_ ) { ret . emplace_back ( transform ( v )); } return ret ; } std :: vector < Vertex > Primitive :: getVertex () const { return transform (); } std :: vector < Triangle > Primitive :: getTriangles () const { return triangles_ ; } unsigned int Primitive :: addToScene ( RTCDevice device , RTCScene scene ) { RTCGeometry mesh = rtcNewGeometry ( device , RTC_GEOMETRY_TYPE_TRIANGLE ); const auto transformed_vertices = transform (); Vertex * vertices = static_cast < Vertex *> ( rtcSetNewGeometryBuffer ( mesh , RTC_BUFFER_TYPE_VERTEX , 0 , RTC_FORMAT_FLOAT3 , sizeof ( Vertex ), transformed_vertices . size ())); for ( size_t i = 0 ; i < transformed_vertices . size (); i ++ ) { vertices [ i ] = transformed_vertices [ i ]; } Triangle * triangles = static_cast < Triangle *> ( rtcSetNewGeometryBuffer ( mesh , RTC_BUFFER_TYPE_INDEX , 0 , RTC_FORMAT_UINT3 , sizeof ( Triangle ), triangles_ . size ())); for ( size_t i = 0 ; i < triangles_ . size (); i ++ ) { triangles [ i ] = triangles_ [ i ]; } rtcCommitGeometry ( mesh ); unsigned int geometry_id = rtcAttachGeometry ( scene , mesh ); rtcReleaseGeometry ( mesh ); return geometry_id ; } } // namespace primitives } // namespace scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/primitive_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives/primitive.hpp # Namespaces # Name scenario_simulator::primitives scenario_simulator Classes # Name class scenario_simulator::primitives::Primitive struct scenario_simulator::Vertex struct scenario_simulator::Triangle Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__SENSOR_SIMULATION__PRIMITIVES__PRIMITIVE_HPP_ #define SCENARIO_SIMULATOR__SENSOR_SIMULATION__PRIMITIVES__PRIMITIVE_HPP_ #include <geometry_msgs/msg/pose.hpp> #include <embree3/rtcore.h> #include <string> #include <vector> #include <algorithm> namespace scenario_simulator { struct Vertex { float x ; float y ; float z ; }; struct Triangle { unsigned int v0 ; unsigned int v1 ; unsigned int v2 ; }; namespace primitives { class Primitive { public : Primitive ( std :: string type , geometry_msgs :: msg :: Pose pose ); virtual ~ Primitive () = default ; const std :: string type ; const geometry_msgs :: msg :: Pose pose ; unsigned int addToScene ( RTCDevice device , RTCScene scene ); std :: vector < Vertex > getVertex () const ; std :: vector < Triangle > getTriangles () const ; protected : std :: vector < Vertex > transform () const ; std :: vector < Vertex > vertices_ ; std :: vector < Triangle > triangles_ ; private : Vertex transform ( Vertex v ) const ; }; } // namespace primitives } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__SENSOR_SIMULATION__PRIMITIVES__PRIMITIVE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives/primitive.hpp"},{"location":"package/scenario_simulator/markdown/Files/primitive_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorincludescenario_simulatorsensor_simulationprimitivesprimitivehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/primitives/primitive.hpp"},{"location":"package/scenario_simulator/markdown/Files/primitive_8hpp/#namespaces","text":"Name scenario_simulator::primitives scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/primitive_8hpp/#classes","text":"Name class scenario_simulator::primitives::Primitive struct scenario_simulator::Vertex struct scenario_simulator::Triangle","title":"Classes"},{"location":"package/scenario_simulator/markdown/Files/primitive_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__SENSOR_SIMULATION__PRIMITIVES__PRIMITIVE_HPP_ #define SCENARIO_SIMULATOR__SENSOR_SIMULATION__PRIMITIVES__PRIMITIVE_HPP_ #include <geometry_msgs/msg/pose.hpp> #include <embree3/rtcore.h> #include <string> #include <vector> #include <algorithm> namespace scenario_simulator { struct Vertex { float x ; float y ; float z ; }; struct Triangle { unsigned int v0 ; unsigned int v1 ; unsigned int v2 ; }; namespace primitives { class Primitive { public : Primitive ( std :: string type , geometry_msgs :: msg :: Pose pose ); virtual ~ Primitive () = default ; const std :: string type ; const geometry_msgs :: msg :: Pose pose ; unsigned int addToScene ( RTCDevice device , RTCScene scene ); std :: vector < Vertex > getVertex () const ; std :: vector < Triangle > getTriangles () const ; protected : std :: vector < Vertex > transform () const ; std :: vector < Vertex > vertices_ ; std :: vector < Triangle > triangles_ ; private : Vertex transform ( Vertex v ) const ; }; } // namespace primitives } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__SENSOR_SIMULATION__PRIMITIVES__PRIMITIVE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/raycaster_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar/raycaster.cpp # Namespaces # Name scenario_simulator Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <scenario_simulator/sensor_simulation/lidar/raycaster.hpp> #include <scenario_simulator/sensor_simulation/lidar/lidar_sensor.hpp> #include <quaternion_operation/quaternion_operation.h> #include <unordered_map> #include <string> #include <algorithm> #include <vector> #include <utility> #include <iostream> namespace scenario_simulator { Raycaster :: Raycaster () : primitive_ptrs_ ( 0 ), device_ ( nullptr ), scene_ ( nullptr ), engine_ ( seed_gen_ ()) { device_ = rtcNewDevice ( nullptr ); } Raycaster :: Raycaster ( std :: string embree_config ) : primitive_ptrs_ ( 0 ), device_ ( nullptr ), scene_ ( nullptr ), engine_ ( seed_gen_ ()) { device_ = rtcNewDevice ( embree_config . c_str ()); } Raycaster ::~ Raycaster () { rtcReleaseDevice ( device_ ); } const sensor_msgs :: msg :: PointCloud2 Raycaster :: raycast ( std :: string frame_id , const rclcpp :: Time & stamp , geometry_msgs :: msg :: Pose origin , double horizontal_resolution , std :: vector < double > vertical_angles , double horizontal_angle_start , double horizontal_angle_end , double max_distance , double min_distance ) { std :: vector < geometry_msgs :: msg :: Quaternion > directions ; double horizontal_angle = horizontal_angle_start ; while ( horizontal_angle <= ( horizontal_angle_end )) { horizontal_angle = horizontal_angle + horizontal_resolution ; for ( const auto vertical_angle : vertical_angles ) { geometry_msgs :: msg :: Vector3 rpy ; rpy . x = 0 ; rpy . y = vertical_angle ; rpy . z = horizontal_angle ; auto quat = quaternion_operation :: convertEulerAngleToQuaternion ( rpy ); directions . emplace_back ( quat ); } } return raycast ( frame_id , stamp , origin , directions , max_distance , min_distance ); } const std :: vector < std :: string > & Raycaster :: getDetectedObject () const { return detected_objects_ ; } const sensor_msgs :: msg :: PointCloud2 Raycaster :: raycast ( std :: string frame_id , const rclcpp :: Time & stamp , geometry_msgs :: msg :: Pose origin , std :: vector < geometry_msgs :: msg :: Quaternion > directions , double max_distance , double min_distance ) { detected_objects_ = {}; std :: vector < unsigned int > detected_ids = {}; scene_ = rtcNewScene ( device_ ); pcl :: PointCloud < pcl :: PointXYZI >:: Ptr cloud ( new pcl :: PointCloud < pcl :: PointXYZI > ()); for ( auto & pair : primitive_ptrs_ ) { auto id = pair . second -> addToScene ( device_ , scene_ ); geometry_ids_ . insert ({ id , pair . first }); } rtcCommitScene ( scene_ ); RTCIntersectContext context ; rtcInitIntersectContext ( & context ); for ( const auto & direction : directions ) { RTCRayHit rayhit ; rayhit . ray . org_x = origin . position . x ; rayhit . ray . org_y = origin . position . y ; rayhit . ray . org_z = origin . position . z ; rayhit . ray . tfar = max_distance ; rayhit . ray . tnear = min_distance ; rayhit . ray . flags = false ; const auto ray_direction = origin . orientation * direction ; const auto rotation_mat = quaternion_operation :: getRotationMatrix ( ray_direction ); const Eigen :: Vector3d rotated_direction = rotation_mat * Eigen :: Vector3d ( 1.0 , 0.0 , 0.0 ); rayhit . ray . dir_x = rotated_direction [ 0 ]; rayhit . ray . dir_y = rotated_direction [ 1 ]; rayhit . ray . dir_z = rotated_direction [ 2 ]; rayhit . hit . geomID = RTC_INVALID_GEOMETRY_ID ; rtcIntersect1 ( scene_ , & context , & rayhit ); if ( rayhit . hit . geomID != RTC_INVALID_GEOMETRY_ID ) { double distance = rayhit . ray . tfar ; const Eigen :: Vector3d vector = quaternion_operation :: getRotationMatrix ( direction ) * Eigen :: Vector3d ( 1.0 , 0.0 , 0.0 ) * distance ; pcl :: PointXYZI p ; { p . x = vector [ 0 ]; p . y = vector [ 1 ]; p . z = vector [ 2 ]; } cloud -> emplace_back ( p ); if ( std :: count ( detected_ids . begin (), detected_ids . end (), rayhit . hit . geomID ) == 0 ) { detected_ids . emplace_back ( rayhit . hit . geomID ); } } } for ( const auto & id : detected_ids ) { detected_objects_ . emplace_back ( geometry_ids_ [ id ]); } sensor_msgs :: msg :: PointCloud2 pointcloud_msg ; pcl :: toROSMsg ( * cloud , pointcloud_msg ); rtcReleaseScene ( scene_ ); pointcloud_msg . header . frame_id = frame_id ; pointcloud_msg . header . stamp = stamp ; return pointcloud_msg ; } } // namespace scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar/raycaster.cpp"},{"location":"package/scenario_simulator/markdown/Files/raycaster_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorsrcsensor_simulationlidarraycastercpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/lidar/raycaster.cpp"},{"location":"package/scenario_simulator/markdown/Files/raycaster_8cpp/#namespaces","text":"Name scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/raycaster_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <scenario_simulator/sensor_simulation/lidar/raycaster.hpp> #include <scenario_simulator/sensor_simulation/lidar/lidar_sensor.hpp> #include <quaternion_operation/quaternion_operation.h> #include <unordered_map> #include <string> #include <algorithm> #include <vector> #include <utility> #include <iostream> namespace scenario_simulator { Raycaster :: Raycaster () : primitive_ptrs_ ( 0 ), device_ ( nullptr ), scene_ ( nullptr ), engine_ ( seed_gen_ ()) { device_ = rtcNewDevice ( nullptr ); } Raycaster :: Raycaster ( std :: string embree_config ) : primitive_ptrs_ ( 0 ), device_ ( nullptr ), scene_ ( nullptr ), engine_ ( seed_gen_ ()) { device_ = rtcNewDevice ( embree_config . c_str ()); } Raycaster ::~ Raycaster () { rtcReleaseDevice ( device_ ); } const sensor_msgs :: msg :: PointCloud2 Raycaster :: raycast ( std :: string frame_id , const rclcpp :: Time & stamp , geometry_msgs :: msg :: Pose origin , double horizontal_resolution , std :: vector < double > vertical_angles , double horizontal_angle_start , double horizontal_angle_end , double max_distance , double min_distance ) { std :: vector < geometry_msgs :: msg :: Quaternion > directions ; double horizontal_angle = horizontal_angle_start ; while ( horizontal_angle <= ( horizontal_angle_end )) { horizontal_angle = horizontal_angle + horizontal_resolution ; for ( const auto vertical_angle : vertical_angles ) { geometry_msgs :: msg :: Vector3 rpy ; rpy . x = 0 ; rpy . y = vertical_angle ; rpy . z = horizontal_angle ; auto quat = quaternion_operation :: convertEulerAngleToQuaternion ( rpy ); directions . emplace_back ( quat ); } } return raycast ( frame_id , stamp , origin , directions , max_distance , min_distance ); } const std :: vector < std :: string > & Raycaster :: getDetectedObject () const { return detected_objects_ ; } const sensor_msgs :: msg :: PointCloud2 Raycaster :: raycast ( std :: string frame_id , const rclcpp :: Time & stamp , geometry_msgs :: msg :: Pose origin , std :: vector < geometry_msgs :: msg :: Quaternion > directions , double max_distance , double min_distance ) { detected_objects_ = {}; std :: vector < unsigned int > detected_ids = {}; scene_ = rtcNewScene ( device_ ); pcl :: PointCloud < pcl :: PointXYZI >:: Ptr cloud ( new pcl :: PointCloud < pcl :: PointXYZI > ()); for ( auto & pair : primitive_ptrs_ ) { auto id = pair . second -> addToScene ( device_ , scene_ ); geometry_ids_ . insert ({ id , pair . first }); } rtcCommitScene ( scene_ ); RTCIntersectContext context ; rtcInitIntersectContext ( & context ); for ( const auto & direction : directions ) { RTCRayHit rayhit ; rayhit . ray . org_x = origin . position . x ; rayhit . ray . org_y = origin . position . y ; rayhit . ray . org_z = origin . position . z ; rayhit . ray . tfar = max_distance ; rayhit . ray . tnear = min_distance ; rayhit . ray . flags = false ; const auto ray_direction = origin . orientation * direction ; const auto rotation_mat = quaternion_operation :: getRotationMatrix ( ray_direction ); const Eigen :: Vector3d rotated_direction = rotation_mat * Eigen :: Vector3d ( 1.0 , 0.0 , 0.0 ); rayhit . ray . dir_x = rotated_direction [ 0 ]; rayhit . ray . dir_y = rotated_direction [ 1 ]; rayhit . ray . dir_z = rotated_direction [ 2 ]; rayhit . hit . geomID = RTC_INVALID_GEOMETRY_ID ; rtcIntersect1 ( scene_ , & context , & rayhit ); if ( rayhit . hit . geomID != RTC_INVALID_GEOMETRY_ID ) { double distance = rayhit . ray . tfar ; const Eigen :: Vector3d vector = quaternion_operation :: getRotationMatrix ( direction ) * Eigen :: Vector3d ( 1.0 , 0.0 , 0.0 ) * distance ; pcl :: PointXYZI p ; { p . x = vector [ 0 ]; p . y = vector [ 1 ]; p . z = vector [ 2 ]; } cloud -> emplace_back ( p ); if ( std :: count ( detected_ids . begin (), detected_ids . end (), rayhit . hit . geomID ) == 0 ) { detected_ids . emplace_back ( rayhit . hit . geomID ); } } } for ( const auto & id : detected_ids ) { detected_objects_ . emplace_back ( geometry_ids_ [ id ]); } sensor_msgs :: msg :: PointCloud2 pointcloud_msg ; pcl :: toROSMsg ( * cloud , pointcloud_msg ); rtcReleaseScene ( scene_ ); pointcloud_msg . header . frame_id = frame_id ; pointcloud_msg . header . stamp = stamp ; return pointcloud_msg ; } } // namespace scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/raycaster_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar/raycaster.hpp # Namespaces # Name scenario_simulator Classes # Name class scenario_simulator::Raycaster Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__SENSOR_SIMULATION__LIDAR__RAYCASTER_HPP_ #define SCENARIO_SIMULATOR__SENSOR_SIMULATION__LIDAR__RAYCASTER_HPP_ #include <scenario_simulator/sensor_simulation/primitives/box.hpp> #include <scenario_simulator/sensor_simulation/primitives/primitive.hpp> #include <embree3/rtcore.h> #include <pcl_conversions/pcl_conversions.h> #include <geometry_msgs/msg/pose.hpp> #include <geometry_msgs/msg/vector3.hpp> #include <sensor_msgs/msg/point_cloud2.hpp> #include <unordered_map> #include <vector> #include <string> #include <memory> #include <utility> #include <random> namespace scenario_simulator { class Raycaster { public : Raycaster (); explicit Raycaster ( std :: string embree_config ); ~ Raycaster (); template < typename T , typename ... Ts > void addPrimitive ( std :: string name , Ts && ... xs ) { if ( primitive_ptrs_ . count ( name ) != 0 ) { throw std :: runtime_error ( \"primitive \" + name + \" already exist.\" ); } auto primitive_ptr = std :: make_unique < T > ( std :: forward < Ts > ( xs )...); primitive_ptrs_ . emplace ( name , std :: move ( primitive_ptr )); } const sensor_msgs :: msg :: PointCloud2 raycast ( std :: string frame_id , const rclcpp :: Time & stamp , geometry_msgs :: msg :: Pose origin , double horizontal_resolution , std :: vector < double > vertical_angles , double horizontal_angle_start = 0 , double horizontal_angle_end = 2 * M_PI , double max_distance = 100 , double min_distance = 0 ); const std :: vector < std :: string > & getDetectedObject () const ; private : std :: unordered_map < std :: string , std :: unique_ptr < primitives :: Primitive >> primitive_ptrs_ ; RTCDevice device_ ; RTCScene scene_ ; std :: random_device seed_gen_ ; std :: default_random_engine engine_ ; const sensor_msgs :: msg :: PointCloud2 raycast ( std :: string frame_id , const rclcpp :: Time & stamp , geometry_msgs :: msg :: Pose origin , std :: vector < geometry_msgs :: msg :: Quaternion > directions , double max_distance = 100 , double min_distance = 0 ); std :: vector < std :: string > detected_objects_ ; std :: unordered_map < unsigned int , std :: string > geometry_ids_ ; }; } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__SENSOR_SIMULATION__LIDAR__RAYCASTER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar/raycaster.hpp"},{"location":"package/scenario_simulator/markdown/Files/raycaster_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorincludescenario_simulatorsensor_simulationlidarraycasterhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/lidar/raycaster.hpp"},{"location":"package/scenario_simulator/markdown/Files/raycaster_8hpp/#namespaces","text":"Name scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/raycaster_8hpp/#classes","text":"Name class scenario_simulator::Raycaster","title":"Classes"},{"location":"package/scenario_simulator/markdown/Files/raycaster_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__SENSOR_SIMULATION__LIDAR__RAYCASTER_HPP_ #define SCENARIO_SIMULATOR__SENSOR_SIMULATION__LIDAR__RAYCASTER_HPP_ #include <scenario_simulator/sensor_simulation/primitives/box.hpp> #include <scenario_simulator/sensor_simulation/primitives/primitive.hpp> #include <embree3/rtcore.h> #include <pcl_conversions/pcl_conversions.h> #include <geometry_msgs/msg/pose.hpp> #include <geometry_msgs/msg/vector3.hpp> #include <sensor_msgs/msg/point_cloud2.hpp> #include <unordered_map> #include <vector> #include <string> #include <memory> #include <utility> #include <random> namespace scenario_simulator { class Raycaster { public : Raycaster (); explicit Raycaster ( std :: string embree_config ); ~ Raycaster (); template < typename T , typename ... Ts > void addPrimitive ( std :: string name , Ts && ... xs ) { if ( primitive_ptrs_ . count ( name ) != 0 ) { throw std :: runtime_error ( \"primitive \" + name + \" already exist.\" ); } auto primitive_ptr = std :: make_unique < T > ( std :: forward < Ts > ( xs )...); primitive_ptrs_ . emplace ( name , std :: move ( primitive_ptr )); } const sensor_msgs :: msg :: PointCloud2 raycast ( std :: string frame_id , const rclcpp :: Time & stamp , geometry_msgs :: msg :: Pose origin , double horizontal_resolution , std :: vector < double > vertical_angles , double horizontal_angle_start = 0 , double horizontal_angle_end = 2 * M_PI , double max_distance = 100 , double min_distance = 0 ); const std :: vector < std :: string > & getDetectedObject () const ; private : std :: unordered_map < std :: string , std :: unique_ptr < primitives :: Primitive >> primitive_ptrs_ ; RTCDevice device_ ; RTCScene scene_ ; std :: random_device seed_gen_ ; std :: default_random_engine engine_ ; const sensor_msgs :: msg :: PointCloud2 raycast ( std :: string frame_id , const rclcpp :: Time & stamp , geometry_msgs :: msg :: Pose origin , std :: vector < geometry_msgs :: msg :: Quaternion > directions , double max_distance = 100 , double min_distance = 0 ); std :: vector < std :: string > detected_objects_ ; std :: unordered_map < unsigned int , std :: string > geometry_ids_ ; }; } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__SENSOR_SIMULATION__LIDAR__RAYCASTER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/scenario_simulator.cpp # Namespaces # Name scenario_simulator Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <scenario_simulator/scenario_simulator.hpp> #include <scenario_simulator/exception.hpp> #include <rclcpp_components/register_node_macro.hpp> #include <simulation_interface/conversions.hpp> #include <quaternion_operation/quaternion_operation.h> #include <pugixml.hpp> #include <geometry_msgs/msg/pose_stamped.hpp> #include <rclcpp/rclcpp.hpp> #include <limits> #include <memory> #include <utility> #include <vector> #include <string> namespace scenario_simulator { ScenarioSimulator :: ScenarioSimulator ( const rclcpp :: NodeOptions & options ) : Node ( \"scenario_simulator\" , options ), sensor_sim_ ( get_clock ()), server_ ( simulation_interface :: protocol , simulation_interface :: HostName :: ANY , std :: bind ( & ScenarioSimulator :: initialize , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: updateFrame , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: updateSensorFrame , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: spawnVehicleEntity , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: spawnPedestrianEntity , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: despawnEntity , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: updateEntityStatus , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: attachLidarSensor , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: attachDetectionSensor , this , std :: placeholders :: _1 , std :: placeholders :: _2 )) { } ScenarioSimulator ::~ ScenarioSimulator () {} void ScenarioSimulator :: initialize ( const simulation_api_schema :: InitializeRequest & req , simulation_api_schema :: InitializeResponse & res ) { initialized_ = true ; realtime_factor_ = req . realtime_factor (); step_time_ = req . step_time (); res = simulation_api_schema :: InitializeResponse (); res . mutable_result () -> set_success ( true ); res . mutable_result () -> set_description ( \"succeed to initialize simulation\" ); ego_vehicles_ = {}; vehicles_ = {}; pedestrians_ = {}; } void ScenarioSimulator :: updateFrame ( const simulation_api_schema :: UpdateFrameRequest & req , simulation_api_schema :: UpdateFrameResponse & res ) { res = simulation_api_schema :: UpdateFrameResponse (); if ( ! initialized_ ) { res . mutable_result () -> set_description ( \"simulator have not initialized yet.\" ); res . mutable_result () -> set_success ( false ); return ; } current_time_ = req . current_time (); res . mutable_result () -> set_success ( true ); res . mutable_result () -> set_description ( \"succeed to update frame\" ); } void ScenarioSimulator :: updateEntityStatus ( const simulation_api_schema :: UpdateEntityStatusRequest & req , simulation_api_schema :: UpdateEntityStatusResponse & res ) { entity_status_ = {}; for ( const auto proto : req . status ()) { entity_status_ . emplace_back ( proto ); } res = simulation_api_schema :: UpdateEntityStatusResponse (); res . mutable_result () -> set_success ( true ); res . mutable_result () -> set_description ( \"\" ); } void ScenarioSimulator :: spawnVehicleEntity ( const simulation_api_schema :: SpawnVehicleEntityRequest & req , simulation_api_schema :: SpawnVehicleEntityResponse & res ) { if ( ego_vehicles_ . size () != 0 && req . is_ego ()) { throw SimulationRuntimeError ( \"multi ego does not support\" ); } if ( req . is_ego ()) { ego_vehicles_ . emplace_back ( req . parameters ()); } else { vehicles_ . emplace_back ( req . parameters ()); } res = simulation_api_schema :: SpawnVehicleEntityResponse (); res . mutable_result () -> set_success ( true ); res . mutable_result () -> set_description ( \"\" ); } void ScenarioSimulator :: spawnPedestrianEntity ( const simulation_api_schema :: SpawnPedestrianEntityRequest & req , simulation_api_schema :: SpawnPedestrianEntityResponse & res ) { pedestrians_ . emplace_back ( req . parameters ()); res = simulation_api_schema :: SpawnPedestrianEntityResponse (); res . mutable_result () -> set_success ( true ); res . mutable_result () -> set_description ( \"\" ); } void ScenarioSimulator :: despawnEntity ( const simulation_api_schema :: DespawnEntityRequest & req , simulation_api_schema :: DespawnEntityResponse & res ) { bool found = false ; res = simulation_api_schema :: DespawnEntityResponse (); std :: vector < openscenario_msgs :: VehicleParameters > vehicles ; for ( const auto vehicle : vehicles_ ) { if ( vehicle . name () != req . name ()) { vehicles . emplace_back ( vehicle ); } else { found = true ; } } vehicles_ = vehicles ; std :: vector < openscenario_msgs :: PedestrianParameters > pedestrians ; for ( const auto pedestrian : pedestrians_ ) { if ( pedestrian . name () != req . name ()) { pedestrians . emplace_back ( pedestrian ); } else { found = true ; } } pedestrians_ = pedestrians ; if ( found ) { res . mutable_result () -> set_success ( true ); } else { res . mutable_result () -> set_success ( false ); } } void ScenarioSimulator :: attachDetectionSensor ( const simulation_api_schema :: AttachDetectionSensorRequest & req , simulation_api_schema :: AttachDetectionSensorResponse & res ) { const auto pub = this -> create_publisher < autoware_perception_msgs :: msg :: DynamicObjectArray > ( req . configuration (). topic_name (), 1 ); sensor_sim_ . attachDetectionSensor ( req . configuration (), pub ); res = simulation_api_schema :: AttachDetectionSensorResponse (); res . mutable_result () -> set_success ( true ); } void ScenarioSimulator :: attachLidarSensor ( const simulation_api_schema :: AttachLidarSensorRequest & req , simulation_api_schema :: AttachLidarSensorResponse & res ) { const auto pub = this -> create_publisher < sensor_msgs :: msg :: PointCloud2 > ( req . configuration (). topic_name (), 1 ); sensor_sim_ . attachLidarSensor ( req . configuration (), pub ); res = simulation_api_schema :: AttachLidarSensorResponse (); res . mutable_result () -> set_success ( true ); } void ScenarioSimulator :: updateSensorFrame ( const simulation_api_schema :: UpdateSensorFrameRequest & req , simulation_api_schema :: UpdateSensorFrameResponse & res ) { constexpr double e = std :: numeric_limits < double >:: epsilon (); if ( std :: abs ( req . current_time () - current_time_ ) > e ) { res . mutable_result () -> set_success ( false ); res . mutable_result () -> set_description ( \"timestamp does not match\" ); } sensor_sim_ . updateSensorFrame ( current_time_ , entity_status_ ); res = simulation_api_schema :: UpdateSensorFrameResponse (); res . mutable_result () -> set_success ( true ); } } // namespace scenario_simulator RCLCPP_COMPONENTS_REGISTER_NODE ( scenario_simulator :: ScenarioSimulator ) Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/scenario_simulator.cpp"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorsrcscenario_simulatorcpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/scenario_simulator.cpp"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8cpp/#namespaces","text":"Name scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <scenario_simulator/scenario_simulator.hpp> #include <scenario_simulator/exception.hpp> #include <rclcpp_components/register_node_macro.hpp> #include <simulation_interface/conversions.hpp> #include <quaternion_operation/quaternion_operation.h> #include <pugixml.hpp> #include <geometry_msgs/msg/pose_stamped.hpp> #include <rclcpp/rclcpp.hpp> #include <limits> #include <memory> #include <utility> #include <vector> #include <string> namespace scenario_simulator { ScenarioSimulator :: ScenarioSimulator ( const rclcpp :: NodeOptions & options ) : Node ( \"scenario_simulator\" , options ), sensor_sim_ ( get_clock ()), server_ ( simulation_interface :: protocol , simulation_interface :: HostName :: ANY , std :: bind ( & ScenarioSimulator :: initialize , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: updateFrame , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: updateSensorFrame , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: spawnVehicleEntity , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: spawnPedestrianEntity , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: despawnEntity , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: updateEntityStatus , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: attachLidarSensor , this , std :: placeholders :: _1 , std :: placeholders :: _2 ), std :: bind ( & ScenarioSimulator :: attachDetectionSensor , this , std :: placeholders :: _1 , std :: placeholders :: _2 )) { } ScenarioSimulator ::~ ScenarioSimulator () {} void ScenarioSimulator :: initialize ( const simulation_api_schema :: InitializeRequest & req , simulation_api_schema :: InitializeResponse & res ) { initialized_ = true ; realtime_factor_ = req . realtime_factor (); step_time_ = req . step_time (); res = simulation_api_schema :: InitializeResponse (); res . mutable_result () -> set_success ( true ); res . mutable_result () -> set_description ( \"succeed to initialize simulation\" ); ego_vehicles_ = {}; vehicles_ = {}; pedestrians_ = {}; } void ScenarioSimulator :: updateFrame ( const simulation_api_schema :: UpdateFrameRequest & req , simulation_api_schema :: UpdateFrameResponse & res ) { res = simulation_api_schema :: UpdateFrameResponse (); if ( ! initialized_ ) { res . mutable_result () -> set_description ( \"simulator have not initialized yet.\" ); res . mutable_result () -> set_success ( false ); return ; } current_time_ = req . current_time (); res . mutable_result () -> set_success ( true ); res . mutable_result () -> set_description ( \"succeed to update frame\" ); } void ScenarioSimulator :: updateEntityStatus ( const simulation_api_schema :: UpdateEntityStatusRequest & req , simulation_api_schema :: UpdateEntityStatusResponse & res ) { entity_status_ = {}; for ( const auto proto : req . status ()) { entity_status_ . emplace_back ( proto ); } res = simulation_api_schema :: UpdateEntityStatusResponse (); res . mutable_result () -> set_success ( true ); res . mutable_result () -> set_description ( \"\" ); } void ScenarioSimulator :: spawnVehicleEntity ( const simulation_api_schema :: SpawnVehicleEntityRequest & req , simulation_api_schema :: SpawnVehicleEntityResponse & res ) { if ( ego_vehicles_ . size () != 0 && req . is_ego ()) { throw SimulationRuntimeError ( \"multi ego does not support\" ); } if ( req . is_ego ()) { ego_vehicles_ . emplace_back ( req . parameters ()); } else { vehicles_ . emplace_back ( req . parameters ()); } res = simulation_api_schema :: SpawnVehicleEntityResponse (); res . mutable_result () -> set_success ( true ); res . mutable_result () -> set_description ( \"\" ); } void ScenarioSimulator :: spawnPedestrianEntity ( const simulation_api_schema :: SpawnPedestrianEntityRequest & req , simulation_api_schema :: SpawnPedestrianEntityResponse & res ) { pedestrians_ . emplace_back ( req . parameters ()); res = simulation_api_schema :: SpawnPedestrianEntityResponse (); res . mutable_result () -> set_success ( true ); res . mutable_result () -> set_description ( \"\" ); } void ScenarioSimulator :: despawnEntity ( const simulation_api_schema :: DespawnEntityRequest & req , simulation_api_schema :: DespawnEntityResponse & res ) { bool found = false ; res = simulation_api_schema :: DespawnEntityResponse (); std :: vector < openscenario_msgs :: VehicleParameters > vehicles ; for ( const auto vehicle : vehicles_ ) { if ( vehicle . name () != req . name ()) { vehicles . emplace_back ( vehicle ); } else { found = true ; } } vehicles_ = vehicles ; std :: vector < openscenario_msgs :: PedestrianParameters > pedestrians ; for ( const auto pedestrian : pedestrians_ ) { if ( pedestrian . name () != req . name ()) { pedestrians . emplace_back ( pedestrian ); } else { found = true ; } } pedestrians_ = pedestrians ; if ( found ) { res . mutable_result () -> set_success ( true ); } else { res . mutable_result () -> set_success ( false ); } } void ScenarioSimulator :: attachDetectionSensor ( const simulation_api_schema :: AttachDetectionSensorRequest & req , simulation_api_schema :: AttachDetectionSensorResponse & res ) { const auto pub = this -> create_publisher < autoware_perception_msgs :: msg :: DynamicObjectArray > ( req . configuration (). topic_name (), 1 ); sensor_sim_ . attachDetectionSensor ( req . configuration (), pub ); res = simulation_api_schema :: AttachDetectionSensorResponse (); res . mutable_result () -> set_success ( true ); } void ScenarioSimulator :: attachLidarSensor ( const simulation_api_schema :: AttachLidarSensorRequest & req , simulation_api_schema :: AttachLidarSensorResponse & res ) { const auto pub = this -> create_publisher < sensor_msgs :: msg :: PointCloud2 > ( req . configuration (). topic_name (), 1 ); sensor_sim_ . attachLidarSensor ( req . configuration (), pub ); res = simulation_api_schema :: AttachLidarSensorResponse (); res . mutable_result () -> set_success ( true ); } void ScenarioSimulator :: updateSensorFrame ( const simulation_api_schema :: UpdateSensorFrameRequest & req , simulation_api_schema :: UpdateSensorFrameResponse & res ) { constexpr double e = std :: numeric_limits < double >:: epsilon (); if ( std :: abs ( req . current_time () - current_time_ ) > e ) { res . mutable_result () -> set_success ( false ); res . mutable_result () -> set_description ( \"timestamp does not match\" ); } sensor_sim_ . updateSensorFrame ( current_time_ , entity_status_ ); res = simulation_api_schema :: UpdateSensorFrameResponse (); res . mutable_result () -> set_success ( true ); } } // namespace scenario_simulator RCLCPP_COMPONENTS_REGISTER_NODE ( scenario_simulator :: ScenarioSimulator ) Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/scenario_simulator.hpp # Namespaces # Name scenario_simulator Classes # Name class scenario_simulator::ScenarioSimulator Defines # Name SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC_TYPE SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_LOCAL SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_IMPORT SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_EXPORT Macro Documentation # define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC_TYPE # #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC_TYPE define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC # #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_LOCAL # #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_LOCAL define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_IMPORT # #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_IMPORT define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_EXPORT # #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_EXPORT __attribute__((visibility(\"default\"))) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__SCENARIO_SIMULATOR_HPP_ #define SCENARIO_SIMULATOR__SCENARIO_SIMULATOR_HPP_ #include <scenario_simulator/sensor_simulation/sensor_simulation.hpp> #include <scenario_simulator/sensor_simulation/lidar/raycaster.hpp> #include <scenario_simulator/sensor_simulation/lidar/lidar_sensor.hpp> #include <simulation_interface/zmq_server.hpp> #include <simulation_interface/zmq_multi_server.hpp> #include <visualization_msgs/msg/marker_array.hpp> #include <rclcpp/rclcpp.hpp> #include <tf2/LinearMath/Quaternion.h> #include <tf2_ros/transform_broadcaster.h> #include <geometry_msgs/msg/transform_stamped.hpp> #include <geometry_msgs/msg/pose_stamped.hpp> #include <map> #include <memory> #include <thread> #include <vector> #include <string> #if __cplusplus extern \"C\" { #endif // The below macros are taken from https://gcc.gnu.org/wiki/Visibility and from // demos/composition/include/composition/visibility_control.h at https://github.com/ros2/demos #if defined _WIN32 || defined __CYGWIN__ #ifdef __GNUC__ #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_EXPORT __attribute__((dllexport)) #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_IMPORT __attribute__((dllimport)) #else #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_EXPORT __declspec(dllexport) #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_IMPORT __declspec(dllimport) #endif #ifdef SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_BUILDING_DLL #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC \\ SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_EXPORT #else #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC \\ SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_IMPORT #endif #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC_TYPE \\ SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_LOCAL #else #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_EXPORT \\ __attribute__((visibility(\"default\"))) #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_IMPORT #if __GNUC__ >= 4 #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC \\ __attribute__((visibility(\"default\"))) #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_LOCAL \\ __attribute__((visibility(\"hidden\"))) #else #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_LOCAL #endif #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC_TYPE #endif #if __cplusplus } // extern \"C\" #endif namespace scenario_simulator { class ScenarioSimulator : public rclcpp :: Node { public : SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC explicit ScenarioSimulator ( const rclcpp :: NodeOptions & options ); ~ ScenarioSimulator (); private : SensorSimulation sensor_sim_ ; void initialize ( const simulation_api_schema :: InitializeRequest & req , simulation_api_schema :: InitializeResponse & res ); void updateFrame ( const simulation_api_schema :: UpdateFrameRequest & req , simulation_api_schema :: UpdateFrameResponse & res ); void updateEntityStatus ( const simulation_api_schema :: UpdateEntityStatusRequest & req , simulation_api_schema :: UpdateEntityStatusResponse & res ); void spawnVehicleEntity ( const simulation_api_schema :: SpawnVehicleEntityRequest & req , simulation_api_schema :: SpawnVehicleEntityResponse & res ); void spawnPedestrianEntity ( const simulation_api_schema :: SpawnPedestrianEntityRequest & req , simulation_api_schema :: SpawnPedestrianEntityResponse & res ); void despawnEntity ( const simulation_api_schema :: DespawnEntityRequest & req , simulation_api_schema :: DespawnEntityResponse & res ); void attachDetectionSensor ( const simulation_api_schema :: AttachDetectionSensorRequest & req , simulation_api_schema :: AttachDetectionSensorResponse & res ); void attachLidarSensor ( const simulation_api_schema :: AttachLidarSensorRequest & req , simulation_api_schema :: AttachLidarSensorResponse & res ); void updateSensorFrame ( const simulation_api_schema :: UpdateSensorFrameRequest & req , simulation_api_schema :: UpdateSensorFrameResponse & res ); std :: vector < openscenario_msgs :: VehicleParameters > ego_vehicles_ ; std :: vector < openscenario_msgs :: VehicleParameters > vehicles_ ; std :: vector < openscenario_msgs :: PedestrianParameters > pedestrians_ ; double realtime_factor_ ; double step_time_ ; double current_time_ ; bool initialized_ ; std :: vector < openscenario_msgs :: EntityStatus > entity_status_ ; zeromq :: MultiServer server_ ; }; } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__SCENARIO_SIMULATOR_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/scenario_simulator.hpp"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorincludescenario_simulatorscenario_simulatorhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/scenario_simulator.hpp"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8hpp/#namespaces","text":"Name scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8hpp/#classes","text":"Name class scenario_simulator::ScenarioSimulator","title":"Classes"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8hpp/#defines","text":"Name SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC_TYPE SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_LOCAL SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_IMPORT SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_EXPORT","title":"Defines"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8hpp/#define-scenario_simulator_scenario_simulator_component_public_type","text":"#define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC_TYPE","title":"define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC_TYPE"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8hpp/#define-scenario_simulator_scenario_simulator_component_public","text":"#define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC","title":"define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8hpp/#define-scenario_simulator_scenario_simulator_component_local","text":"#define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_LOCAL","title":"define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_LOCAL"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8hpp/#define-scenario_simulator_scenario_simulator_component_import","text":"#define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_IMPORT","title":"define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_IMPORT"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8hpp/#define-scenario_simulator_scenario_simulator_component_export","text":"#define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_EXPORT __attribute__((visibility(\"default\")))","title":"define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_EXPORT"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__SCENARIO_SIMULATOR_HPP_ #define SCENARIO_SIMULATOR__SCENARIO_SIMULATOR_HPP_ #include <scenario_simulator/sensor_simulation/sensor_simulation.hpp> #include <scenario_simulator/sensor_simulation/lidar/raycaster.hpp> #include <scenario_simulator/sensor_simulation/lidar/lidar_sensor.hpp> #include <simulation_interface/zmq_server.hpp> #include <simulation_interface/zmq_multi_server.hpp> #include <visualization_msgs/msg/marker_array.hpp> #include <rclcpp/rclcpp.hpp> #include <tf2/LinearMath/Quaternion.h> #include <tf2_ros/transform_broadcaster.h> #include <geometry_msgs/msg/transform_stamped.hpp> #include <geometry_msgs/msg/pose_stamped.hpp> #include <map> #include <memory> #include <thread> #include <vector> #include <string> #if __cplusplus extern \"C\" { #endif // The below macros are taken from https://gcc.gnu.org/wiki/Visibility and from // demos/composition/include/composition/visibility_control.h at https://github.com/ros2/demos #if defined _WIN32 || defined __CYGWIN__ #ifdef __GNUC__ #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_EXPORT __attribute__((dllexport)) #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_IMPORT __attribute__((dllimport)) #else #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_EXPORT __declspec(dllexport) #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_IMPORT __declspec(dllimport) #endif #ifdef SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_BUILDING_DLL #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC \\ SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_EXPORT #else #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC \\ SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_IMPORT #endif #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC_TYPE \\ SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_LOCAL #else #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_EXPORT \\ __attribute__((visibility(\"default\"))) #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_IMPORT #if __GNUC__ >= 4 #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC \\ __attribute__((visibility(\"default\"))) #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_LOCAL \\ __attribute__((visibility(\"hidden\"))) #else #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_LOCAL #endif #define SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC_TYPE #endif #if __cplusplus } // extern \"C\" #endif namespace scenario_simulator { class ScenarioSimulator : public rclcpp :: Node { public : SCENARIO_SIMULATOR_SCENARIO_SIMULATOR_COMPONENT_PUBLIC explicit ScenarioSimulator ( const rclcpp :: NodeOptions & options ); ~ ScenarioSimulator (); private : SensorSimulation sensor_sim_ ; void initialize ( const simulation_api_schema :: InitializeRequest & req , simulation_api_schema :: InitializeResponse & res ); void updateFrame ( const simulation_api_schema :: UpdateFrameRequest & req , simulation_api_schema :: UpdateFrameResponse & res ); void updateEntityStatus ( const simulation_api_schema :: UpdateEntityStatusRequest & req , simulation_api_schema :: UpdateEntityStatusResponse & res ); void spawnVehicleEntity ( const simulation_api_schema :: SpawnVehicleEntityRequest & req , simulation_api_schema :: SpawnVehicleEntityResponse & res ); void spawnPedestrianEntity ( const simulation_api_schema :: SpawnPedestrianEntityRequest & req , simulation_api_schema :: SpawnPedestrianEntityResponse & res ); void despawnEntity ( const simulation_api_schema :: DespawnEntityRequest & req , simulation_api_schema :: DespawnEntityResponse & res ); void attachDetectionSensor ( const simulation_api_schema :: AttachDetectionSensorRequest & req , simulation_api_schema :: AttachDetectionSensorResponse & res ); void attachLidarSensor ( const simulation_api_schema :: AttachLidarSensorRequest & req , simulation_api_schema :: AttachLidarSensorResponse & res ); void updateSensorFrame ( const simulation_api_schema :: UpdateSensorFrameRequest & req , simulation_api_schema :: UpdateSensorFrameResponse & res ); std :: vector < openscenario_msgs :: VehicleParameters > ego_vehicles_ ; std :: vector < openscenario_msgs :: VehicleParameters > vehicles_ ; std :: vector < openscenario_msgs :: PedestrianParameters > pedestrians_ ; double realtime_factor_ ; double step_time_ ; double current_time_ ; bool initialized_ ; std :: vector < openscenario_msgs :: EntityStatus > entity_status_ ; zeromq :: MultiServer server_ ; }; } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__SCENARIO_SIMULATOR_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator__node_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/scenario_simulator_node.cpp # Functions # Name int main (int argc, char * argv[]) Functions Documentation # function main # int main ( int argc , char * argv [] ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <rclcpp/rclcpp.hpp> #include <scenario_simulator/scenario_simulator.hpp> #include <memory> #include <string> int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: NodeOptions options ; auto component = std :: make_shared < scenario_simulator :: ScenarioSimulator > ( options ); rclcpp :: spin ( component ); rclcpp :: shutdown (); return 0 ; } Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/scenario_simulator_node.cpp"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator__node_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorsrcscenario_simulator_nodecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/scenario_simulator_node.cpp"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator__node_8cpp/#functions","text":"Name int main (int argc, char * argv[])","title":"Functions"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator__node_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator__node_8cpp/#function-main","text":"int main ( int argc , char * argv [] )","title":"function main"},{"location":"package/scenario_simulator/markdown/Files/scenario__simulator__node_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <rclcpp/rclcpp.hpp> #include <scenario_simulator/scenario_simulator.hpp> #include <memory> #include <string> int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: NodeOptions options ; auto component = std :: make_shared < scenario_simulator :: ScenarioSimulator > ( options ); rclcpp :: spin ( component ); rclcpp :: shutdown (); return 0 ; } Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/sensor__simulation_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/sensor_simulation.cpp # Namespaces # Name scenario_simulator Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <scenario_simulator/sensor_simulation/sensor_simulation.hpp> #include <memory> #include <vector> #include <string> namespace scenario_simulator { SensorSimulation :: SensorSimulation ( const std :: shared_ptr < rclcpp :: Clock > & clock_ptr ) : clock_ptr_ ( clock_ptr ) {} void SensorSimulation :: attachLidarSensor ( const simulation_api_schema :: LidarConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < sensor_msgs :: msg :: PointCloud2 >> publisher_ptr ) { LidarSensor lidar_sensor ( configuration , publisher_ptr ); lidar_sensors_ . push_back ( lidar_sensor ); } void SensorSimulation :: attachDetectionSensor ( const simulation_api_schema :: DetectionSensorConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < autoware_perception_msgs :: msg :: DynamicObjectArray >> publisher_ptr ) { DetectionSensor detection_sensor ( configuration , publisher_ptr ); detection_sensors_ . push_back ( detection_sensor ); } void SensorSimulation :: updateSensorFrame ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status ) { std :: vector < std :: string > detected_objects = {}; const auto now = clock_ptr_ -> now (); for ( auto & sensor : lidar_sensors_ ) { sensor . update ( current_time , status , now ); const auto objects = sensor . getDetectedObjects (); for ( const auto & obj : objects ) { if ( std :: count ( detected_objects . begin (), detected_objects . end (), obj ) == 0 ) { detected_objects . emplace_back ( obj ); } } } for ( auto & sensor : detection_sensors_ ) { sensor . update ( current_time , status , now , detected_objects ); } } } // namespace scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/sensor_simulation.cpp"},{"location":"package/scenario_simulator/markdown/Files/sensor__simulation_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorsrcsensor_simulationsensor_simulationcpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/src/sensor_simulation/sensor_simulation.cpp"},{"location":"package/scenario_simulator/markdown/Files/sensor__simulation_8cpp/#namespaces","text":"Name scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/sensor__simulation_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <scenario_simulator/sensor_simulation/sensor_simulation.hpp> #include <memory> #include <vector> #include <string> namespace scenario_simulator { SensorSimulation :: SensorSimulation ( const std :: shared_ptr < rclcpp :: Clock > & clock_ptr ) : clock_ptr_ ( clock_ptr ) {} void SensorSimulation :: attachLidarSensor ( const simulation_api_schema :: LidarConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < sensor_msgs :: msg :: PointCloud2 >> publisher_ptr ) { LidarSensor lidar_sensor ( configuration , publisher_ptr ); lidar_sensors_ . push_back ( lidar_sensor ); } void SensorSimulation :: attachDetectionSensor ( const simulation_api_schema :: DetectionSensorConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < autoware_perception_msgs :: msg :: DynamicObjectArray >> publisher_ptr ) { DetectionSensor detection_sensor ( configuration , publisher_ptr ); detection_sensors_ . push_back ( detection_sensor ); } void SensorSimulation :: updateSensorFrame ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status ) { std :: vector < std :: string > detected_objects = {}; const auto now = clock_ptr_ -> now (); for ( auto & sensor : lidar_sensors_ ) { sensor . update ( current_time , status , now ); const auto objects = sensor . getDetectedObjects (); for ( const auto & obj : objects ) { if ( std :: count ( detected_objects . begin (), detected_objects . end (), obj ) == 0 ) { detected_objects . emplace_back ( obj ); } } } for ( auto & sensor : detection_sensors_ ) { sensor . update ( current_time , status , now , detected_objects ); } } } // namespace scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Files/sensor__simulation_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/sensor_simulation.hpp # Namespaces # Name scenario_simulator Classes # Name class scenario_simulator::SensorSimulation Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__SENSOR_SIMULATION__SENSOR_SIMULATION_HPP_ #define SCENARIO_SIMULATOR__SENSOR_SIMULATION__SENSOR_SIMULATION_HPP_ #include <scenario_simulator/sensor_simulation/lidar/lidar_sensor.hpp> #include <scenario_simulator/sensor_simulation/detection_sensor/detection_sensor.hpp> #include <simulation_api_schema.pb.h> #include <rclcpp/rclcpp.hpp> #include <memory> #include <vector> namespace scenario_simulator { class SensorSimulation { public : explicit SensorSimulation ( const std :: shared_ptr < rclcpp :: Clock > & clock_ptr ); void attachLidarSensor ( const simulation_api_schema :: LidarConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < sensor_msgs :: msg :: PointCloud2 >> publisher_ptr ); void attachDetectionSensor ( const simulation_api_schema :: DetectionSensorConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < autoware_perception_msgs :: msg :: DynamicObjectArray >> publisher_ptr ); void updateSensorFrame ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status ); private : std :: vector < LidarSensor > lidar_sensors_ ; std :: vector < DetectionSensor > detection_sensors_ ; std :: shared_ptr < rclcpp :: Clock > clock_ptr_ ; }; } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__SENSOR_SIMULATION__SENSOR_SIMULATION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/sensor_simulation.hpp"},{"location":"package/scenario_simulator/markdown/Files/sensor__simulation_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationscenario_simulatorincludescenario_simulatorsensor_simulationsensor_simulationhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/scenario_simulator/include/scenario_simulator/sensor_simulation/sensor_simulation.hpp"},{"location":"package/scenario_simulator/markdown/Files/sensor__simulation_8hpp/#namespaces","text":"Name scenario_simulator","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Files/sensor__simulation_8hpp/#classes","text":"Name class scenario_simulator::SensorSimulation","title":"Classes"},{"location":"package/scenario_simulator/markdown/Files/sensor__simulation_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SCENARIO_SIMULATOR__SENSOR_SIMULATION__SENSOR_SIMULATION_HPP_ #define SCENARIO_SIMULATOR__SENSOR_SIMULATION__SENSOR_SIMULATION_HPP_ #include <scenario_simulator/sensor_simulation/lidar/lidar_sensor.hpp> #include <scenario_simulator/sensor_simulation/detection_sensor/detection_sensor.hpp> #include <simulation_api_schema.pb.h> #include <rclcpp/rclcpp.hpp> #include <memory> #include <vector> namespace scenario_simulator { class SensorSimulation { public : explicit SensorSimulation ( const std :: shared_ptr < rclcpp :: Clock > & clock_ptr ); void attachLidarSensor ( const simulation_api_schema :: LidarConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < sensor_msgs :: msg :: PointCloud2 >> publisher_ptr ); void attachDetectionSensor ( const simulation_api_schema :: DetectionSensorConfiguration & configuration , std :: shared_ptr < rclcpp :: Publisher < autoware_perception_msgs :: msg :: DynamicObjectArray >> publisher_ptr ); void updateSensorFrame ( double current_time , const std :: vector < openscenario_msgs :: EntityStatus > & status ); private : std :: vector < LidarSensor > lidar_sensors_ ; std :: vector < DetectionSensor > detection_sensors_ ; std :: shared_ptr < rclcpp :: Clock > clock_ptr_ ; }; } // namespace scenario_simulator #endif // SCENARIO_SIMULATOR__SENSOR_SIMULATION__SENSOR_SIMULATION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/scenario_simulator/markdown/Modules/","text":"Modules # Updated on 7 April 2021 at 00:31:55 UTC","title":"Modules"},{"location":"package/scenario_simulator/markdown/Modules/#modules","text":"Updated on 7 April 2021 at 00:31:55 UTC","title":"Modules"},{"location":"package/scenario_simulator/markdown/Namespaces/","text":"Namespaces # namespace scenario_simulator namespace primitives namespace return_code Updated on 7 April 2021 at 00:31:55 UTC","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Namespaces/#namespaces","text":"namespace scenario_simulator namespace primitives namespace return_code Updated on 7 April 2021 at 00:31:55 UTC","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Namespaces/namespacescenario__simulator/","text":"scenario_simulator # Namespaces # Name scenario_simulator::return_code scenario_simulator::primitives Classes # Name struct scenario_simulator::Vertex struct scenario_simulator::Triangle class scenario_simulator::SimulationRuntimeError class scenario_simulator::SensorSimulation class scenario_simulator::ScenarioSimulator class scenario_simulator::Raycaster class scenario_simulator::LidarSensor class scenario_simulator::DetectionSensor Updated on 7 April 2021 at 00:31:55 UTC","title":"scenario_simulator"},{"location":"package/scenario_simulator/markdown/Namespaces/namespacescenario__simulator/#scenario_simulator","text":"","title":"scenario_simulator"},{"location":"package/scenario_simulator/markdown/Namespaces/namespacescenario__simulator/#namespaces","text":"Name scenario_simulator::return_code scenario_simulator::primitives","title":"Namespaces"},{"location":"package/scenario_simulator/markdown/Namespaces/namespacescenario__simulator/#classes","text":"Name struct scenario_simulator::Vertex struct scenario_simulator::Triangle class scenario_simulator::SimulationRuntimeError class scenario_simulator::SensorSimulation class scenario_simulator::ScenarioSimulator class scenario_simulator::Raycaster class scenario_simulator::LidarSensor class scenario_simulator::DetectionSensor Updated on 7 April 2021 at 00:31:55 UTC","title":"Classes"},{"location":"package/scenario_simulator/markdown/Namespaces/namespacescenario__simulator_1_1primitives/","text":"scenario_simulator::primitives # Classes # Name class scenario_simulator::primitives::Primitive class scenario_simulator::primitives::Box Updated on 7 April 2021 at 00:31:55 UTC","title":"scenario_simulator::primitives"},{"location":"package/scenario_simulator/markdown/Namespaces/namespacescenario__simulator_1_1primitives/#scenario_simulatorprimitives","text":"","title":"scenario_simulator::primitives"},{"location":"package/scenario_simulator/markdown/Namespaces/namespacescenario__simulator_1_1primitives/#classes","text":"Name class scenario_simulator::primitives::Primitive class scenario_simulator::primitives::Box Updated on 7 April 2021 at 00:31:55 UTC","title":"Classes"},{"location":"package/scenario_simulator/markdown/Namespaces/namespacescenario__simulator_1_1return__code/","text":"scenario_simulator::return_code # Attributes # Name constexpr int SUCCESS constexpr int FAIL Attributes Documentation # variable SUCCESS # constexpr int SUCCESS = 0 ; variable FAIL # constexpr int FAIL = 1 ; Updated on 7 April 2021 at 00:31:55 UTC","title":"scenario_simulator::return_code"},{"location":"package/scenario_simulator/markdown/Namespaces/namespacescenario__simulator_1_1return__code/#scenario_simulatorreturn_code","text":"","title":"scenario_simulator::return_code"},{"location":"package/scenario_simulator/markdown/Namespaces/namespacescenario__simulator_1_1return__code/#attributes","text":"Name constexpr int SUCCESS constexpr int FAIL","title":"Attributes"},{"location":"package/scenario_simulator/markdown/Namespaces/namespacescenario__simulator_1_1return__code/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"package/scenario_simulator/markdown/Namespaces/namespacescenario__simulator_1_1return__code/#variable-success","text":"constexpr int SUCCESS = 0 ;","title":"variable SUCCESS"},{"location":"package/scenario_simulator/markdown/Namespaces/namespacescenario__simulator_1_1return__code/#variable-fail","text":"constexpr int FAIL = 1 ; Updated on 7 April 2021 at 00:31:55 UTC","title":"variable FAIL"},{"location":"package/scenario_simulator/markdown/Pages/","text":"Pages # Updated on 7 April 2021 at 00:31:55 UTC","title":"Pages"},{"location":"package/scenario_simulator/markdown/Pages/#pages","text":"Updated on 7 April 2021 at 00:31:55 UTC","title":"Pages"},{"location":"package/simulation_api/markdown/Classes/","text":"Classes # class CatmullRomSplineVisualization class ScenarioRunnerMoc class SimModelIdealAccel class SimModelIdealSteer class SimModelIdealTwist class SimModelInterface class SimModelTimeDelaySteer class SimModelTimeDelaySteerAccel class SimModelTimeDelayTwist namespace color_utils namespace entity_behavior class ActionNode class BehaviorTreeRuntimeError class PedestrianActionNode class VehicleActionNode namespace pedestrian class BehaviorTree class FollowLaneAction class WalkStraightAction namespace vehicle class BehaviorTree class LaneChangeAction namespace follow_lane_sequence class FollowFrontEntityAction class FollowLaneAction class StopAtCrossingEntityAction class StopAtStopLineAction class StopAtTrafficLightAction class YieldAction namespace hdmap_utils class HdMapError class HdMapUtils namespace metrics class MetricBase class MetricsCalculationError class MetricsManager class MomentaryStopMetric class ReactionTimeMetric class SpecificationViolationError class TraveledDistanceMetric namespace scenario_simulator class API class ExecutionFailedError namespace sim_model_util class simple_planning_simulator calculate ideal twist dynamics namespace simulation_api class RoutePlanner class SimulationRuntimeError class SplineInterpolationError class TrafficLight class TrafficLightManager class TrafficLightPhase namespace entity struct Axle struct Axles struct BoundingBox struct Center struct Dimensions class EgoEntity class EntityBase class EntityManager class EntityMarkerQoS class LaneletMarkerQoS class PedestrianEntity struct PedestrianParameters struct Performance class VehicleEntity struct VehicleParameters namespace helper class StopWatch namespace math class CatmullRomSpline class HermiteCurve class PolynomialSolver class SplineInterpolationError namespace traffic class TraffiModuleBase class TrafficController class TrafficSink class wf_simulator calculate ideal steering dynamics Updated on 7 April 2021 at 00:31:55 UTC","title":"Classes"},{"location":"package/simulation_api/markdown/Classes/#classes","text":"class CatmullRomSplineVisualization class ScenarioRunnerMoc class SimModelIdealAccel class SimModelIdealSteer class SimModelIdealTwist class SimModelInterface class SimModelTimeDelaySteer class SimModelTimeDelaySteerAccel class SimModelTimeDelayTwist namespace color_utils namespace entity_behavior class ActionNode class BehaviorTreeRuntimeError class PedestrianActionNode class VehicleActionNode namespace pedestrian class BehaviorTree class FollowLaneAction class WalkStraightAction namespace vehicle class BehaviorTree class LaneChangeAction namespace follow_lane_sequence class FollowFrontEntityAction class FollowLaneAction class StopAtCrossingEntityAction class StopAtStopLineAction class StopAtTrafficLightAction class YieldAction namespace hdmap_utils class HdMapError class HdMapUtils namespace metrics class MetricBase class MetricsCalculationError class MetricsManager class MomentaryStopMetric class ReactionTimeMetric class SpecificationViolationError class TraveledDistanceMetric namespace scenario_simulator class API class ExecutionFailedError namespace sim_model_util class simple_planning_simulator calculate ideal twist dynamics namespace simulation_api class RoutePlanner class SimulationRuntimeError class SplineInterpolationError class TrafficLight class TrafficLightManager class TrafficLightPhase namespace entity struct Axle struct Axles struct BoundingBox struct Center struct Dimensions class EgoEntity class EntityBase class EntityManager class EntityMarkerQoS class LaneletMarkerQoS class PedestrianEntity struct PedestrianParameters struct Performance class VehicleEntity struct VehicleParameters namespace helper class StopWatch namespace math class CatmullRomSpline class HermiteCurve class PolynomialSolver class SplineInterpolationError namespace traffic class TraffiModuleBase class TrafficController class TrafficSink class wf_simulator calculate ideal steering dynamics Updated on 7 April 2021 at 00:31:55 UTC","title":"Classes"},{"location":"package/simulation_api/markdown/Classes/classCatmullRomSplineVisualization/","text":"CatmullRomSplineVisualization # Inherits from Node Public Functions # Name CatmullRomSplineVisualization (const rclcpp::NodeOptions & option) Public Functions Documentation # function CatmullRomSplineVisualization # inline explicit CatmullRomSplineVisualization ( const rclcpp :: NodeOptions & option ) Updated on 7 April 2021 at 00:31:55 UTC","title":"CatmullRomSplineVisualization"},{"location":"package/simulation_api/markdown/Classes/classCatmullRomSplineVisualization/#catmullromsplinevisualization","text":"Inherits from Node","title":"CatmullRomSplineVisualization"},{"location":"package/simulation_api/markdown/Classes/classCatmullRomSplineVisualization/#public-functions","text":"Name CatmullRomSplineVisualization (const rclcpp::NodeOptions & option)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classCatmullRomSplineVisualization/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classCatmullRomSplineVisualization/#function-catmullromsplinevisualization","text":"inline explicit CatmullRomSplineVisualization ( const rclcpp :: NodeOptions & option ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function CatmullRomSplineVisualization"},{"location":"package/simulation_api/markdown/Classes/classScenarioRunnerMoc/","text":"ScenarioRunnerMoc # Inherits from Node Public Functions # Name ScenarioRunnerMoc (const rclcpp::NodeOptions & option) Public Functions Documentation # function ScenarioRunnerMoc # inline explicit ScenarioRunnerMoc ( const rclcpp :: NodeOptions & option ) Updated on 7 April 2021 at 00:31:55 UTC","title":"ScenarioRunnerMoc"},{"location":"package/simulation_api/markdown/Classes/classScenarioRunnerMoc/#scenariorunnermoc","text":"Inherits from Node","title":"ScenarioRunnerMoc"},{"location":"package/simulation_api/markdown/Classes/classScenarioRunnerMoc/#public-functions","text":"Name ScenarioRunnerMoc (const rclcpp::NodeOptions & option)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classScenarioRunnerMoc/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classScenarioRunnerMoc/#function-scenariorunnermoc","text":"inline explicit ScenarioRunnerMoc ( const rclcpp :: NodeOptions & option ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function ScenarioRunnerMoc"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealAccel/","text":"SimModelIdealAccel # Inherits from SimModelInterface Public Functions # Name ~SimModelIdealAccel () =default destructor SimModelIdealAccel (double wheelbase) constructor Additional inherited members # Public Functions inherited from SimModelInterface Name ~SimModelInterface () =default destructor void updateRungeKutta (const double & dt, const Eigen::VectorXd & input) update vehicle states with Runge-Kutta methods void updateEuler (const double & dt, const Eigen::VectorXd & input) update vehicle states with Euler methods void setState (const Eigen::VectorXd & state) set state vector of model void setInput (const Eigen::VectorXd & input) set input vector of model void getState (Eigen::VectorXd & state) get state vector of model void getInput (Eigen::VectorXd & input) get input vector of model SimModelInterface (int dim_x, int dim_u) constructor Protected Attributes inherited from SimModelInterface Name Eigen::VectorXd state_ vehicle state vector Eigen::VectorXd input_ vehicle input vector const int dim_x_ dimension of state x const int dim_u_ dimension of input u Public Functions Documentation # function ~SimModelIdealAccel # ~ SimModelIdealAccel () = default destructor function SimModelIdealAccel # explicit SimModelIdealAccel ( double wheelbase ) constructor Parameters : wheelbase vehicle wheelbase length [m] Updated on 7 April 2021 at 00:31:55 UTC","title":"SimModelIdealAccel"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealAccel/#simmodelidealaccel","text":"Inherits from SimModelInterface","title":"SimModelIdealAccel"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealAccel/#public-functions","text":"Name ~SimModelIdealAccel () =default destructor SimModelIdealAccel (double wheelbase) constructor","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealAccel/#additional-inherited-members","text":"Public Functions inherited from SimModelInterface Name ~SimModelInterface () =default destructor void updateRungeKutta (const double & dt, const Eigen::VectorXd & input) update vehicle states with Runge-Kutta methods void updateEuler (const double & dt, const Eigen::VectorXd & input) update vehicle states with Euler methods void setState (const Eigen::VectorXd & state) set state vector of model void setInput (const Eigen::VectorXd & input) set input vector of model void getState (Eigen::VectorXd & state) get state vector of model void getInput (Eigen::VectorXd & input) get input vector of model SimModelInterface (int dim_x, int dim_u) constructor Protected Attributes inherited from SimModelInterface Name Eigen::VectorXd state_ vehicle state vector Eigen::VectorXd input_ vehicle input vector const int dim_x_ dimension of state x const int dim_u_ dimension of input u","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealAccel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealAccel/#function-simmodelidealaccel","text":"~ SimModelIdealAccel () = default destructor","title":"function ~SimModelIdealAccel"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealAccel/#function-simmodelidealaccel_1","text":"explicit SimModelIdealAccel ( double wheelbase ) constructor Parameters : wheelbase vehicle wheelbase length [m] Updated on 7 April 2021 at 00:31:55 UTC","title":"function SimModelIdealAccel"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealSteer/","text":"SimModelIdealSteer # Inherits from SimModelInterface Public Functions # Name ~SimModelIdealSteer () =default destructor SimModelIdealSteer (double wheelbase) constructor Additional inherited members # Public Functions inherited from SimModelInterface Name ~SimModelInterface () =default destructor void updateRungeKutta (const double & dt, const Eigen::VectorXd & input) update vehicle states with Runge-Kutta methods void updateEuler (const double & dt, const Eigen::VectorXd & input) update vehicle states with Euler methods void setState (const Eigen::VectorXd & state) set state vector of model void setInput (const Eigen::VectorXd & input) set input vector of model void getState (Eigen::VectorXd & state) get state vector of model void getInput (Eigen::VectorXd & input) get input vector of model SimModelInterface (int dim_x, int dim_u) constructor Protected Attributes inherited from SimModelInterface Name Eigen::VectorXd state_ vehicle state vector Eigen::VectorXd input_ vehicle input vector const int dim_x_ dimension of state x const int dim_u_ dimension of input u Public Functions Documentation # function ~SimModelIdealSteer # ~ SimModelIdealSteer () = default destructor function SimModelIdealSteer # explicit SimModelIdealSteer ( double wheelbase ) constructor Parameters : wheelbase vehicle wheelbase length [m] Updated on 7 April 2021 at 00:31:55 UTC","title":"SimModelIdealSteer"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealSteer/#simmodelidealsteer","text":"Inherits from SimModelInterface","title":"SimModelIdealSteer"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealSteer/#public-functions","text":"Name ~SimModelIdealSteer () =default destructor SimModelIdealSteer (double wheelbase) constructor","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealSteer/#additional-inherited-members","text":"Public Functions inherited from SimModelInterface Name ~SimModelInterface () =default destructor void updateRungeKutta (const double & dt, const Eigen::VectorXd & input) update vehicle states with Runge-Kutta methods void updateEuler (const double & dt, const Eigen::VectorXd & input) update vehicle states with Euler methods void setState (const Eigen::VectorXd & state) set state vector of model void setInput (const Eigen::VectorXd & input) set input vector of model void getState (Eigen::VectorXd & state) get state vector of model void getInput (Eigen::VectorXd & input) get input vector of model SimModelInterface (int dim_x, int dim_u) constructor Protected Attributes inherited from SimModelInterface Name Eigen::VectorXd state_ vehicle state vector Eigen::VectorXd input_ vehicle input vector const int dim_x_ dimension of state x const int dim_u_ dimension of input u","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealSteer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealSteer/#function-simmodelidealsteer","text":"~ SimModelIdealSteer () = default destructor","title":"function ~SimModelIdealSteer"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealSteer/#function-simmodelidealsteer_1","text":"explicit SimModelIdealSteer ( double wheelbase ) constructor Parameters : wheelbase vehicle wheelbase length [m] Updated on 7 April 2021 at 00:31:55 UTC","title":"function SimModelIdealSteer"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealTwist/","text":"SimModelIdealTwist # Inherits from SimModelInterface Public Functions # Name ~SimModelIdealTwist () =default destructor SimModelIdealTwist () constructor Additional inherited members # Public Functions inherited from SimModelInterface Name ~SimModelInterface () =default destructor void updateRungeKutta (const double & dt, const Eigen::VectorXd & input) update vehicle states with Runge-Kutta methods void updateEuler (const double & dt, const Eigen::VectorXd & input) update vehicle states with Euler methods void setState (const Eigen::VectorXd & state) set state vector of model void setInput (const Eigen::VectorXd & input) set input vector of model void getState (Eigen::VectorXd & state) get state vector of model void getInput (Eigen::VectorXd & input) get input vector of model SimModelInterface (int dim_x, int dim_u) constructor Protected Attributes inherited from SimModelInterface Name Eigen::VectorXd state_ vehicle state vector Eigen::VectorXd input_ vehicle input vector const int dim_x_ dimension of state x const int dim_u_ dimension of input u Public Functions Documentation # function ~SimModelIdealTwist # ~ SimModelIdealTwist () = default destructor function SimModelIdealTwist # SimModelIdealTwist () constructor Updated on 7 April 2021 at 00:31:55 UTC","title":"SimModelIdealTwist"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealTwist/#simmodelidealtwist","text":"Inherits from SimModelInterface","title":"SimModelIdealTwist"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealTwist/#public-functions","text":"Name ~SimModelIdealTwist () =default destructor SimModelIdealTwist () constructor","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealTwist/#additional-inherited-members","text":"Public Functions inherited from SimModelInterface Name ~SimModelInterface () =default destructor void updateRungeKutta (const double & dt, const Eigen::VectorXd & input) update vehicle states with Runge-Kutta methods void updateEuler (const double & dt, const Eigen::VectorXd & input) update vehicle states with Euler methods void setState (const Eigen::VectorXd & state) set state vector of model void setInput (const Eigen::VectorXd & input) set input vector of model void getState (Eigen::VectorXd & state) get state vector of model void getInput (Eigen::VectorXd & input) get input vector of model SimModelInterface (int dim_x, int dim_u) constructor Protected Attributes inherited from SimModelInterface Name Eigen::VectorXd state_ vehicle state vector Eigen::VectorXd input_ vehicle input vector const int dim_x_ dimension of state x const int dim_u_ dimension of input u","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealTwist/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealTwist/#function-simmodelidealtwist","text":"~ SimModelIdealTwist () = default destructor","title":"function ~SimModelIdealTwist"},{"location":"package/simulation_api/markdown/Classes/classSimModelIdealTwist/#function-simmodelidealtwist_1","text":"SimModelIdealTwist () constructor Updated on 7 April 2021 at 00:31:55 UTC","title":"function SimModelIdealTwist"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/","text":"SimModelInterface # Inherited by SimModelIdealAccel , SimModelIdealSteer , SimModelIdealTwist , SimModelTimeDelaySteer , SimModelTimeDelaySteerAccel , SimModelTimeDelayTwist Public Functions # Name ~SimModelInterface () =default destructor void updateRungeKutta (const double & dt, const Eigen::VectorXd & input) update vehicle states with Runge-Kutta methods void updateEuler (const double & dt, const Eigen::VectorXd & input) update vehicle states with Euler methods virtual void update (const double & dt) =0 update vehicle states void setState (const Eigen::VectorXd & state) set state vector of model void setInput (const Eigen::VectorXd & input) set input vector of model virtual double getYaw () =0 get vehicle angle yaw virtual double getY () =0 get vehicle position y virtual double getX () =0 get vehicle position x virtual double getWz () =0 get vehicle angular-velocity wz virtual double getVx () =0 get vehicle velocity vx virtual double getSteer () =0 get vehicle steering angle void getState (Eigen::VectorXd & state) get state vector of model void getInput (Eigen::VectorXd & input) get input vector of model virtual Eigen::VectorXd calcModel (const Eigen::VectorXd & state, const Eigen::VectorXd & input) =0 calculate derivative of states with vehicle model SimModelInterface (int dim_x, int dim_u) constructor Protected Attributes # Name Eigen::VectorXd state_ vehicle state vector Eigen::VectorXd input_ vehicle input vector const int dim_x_ dimension of state x const int dim_u_ dimension of input u Public Functions Documentation # function ~SimModelInterface # ~ SimModelInterface () = default destructor function updateRungeKutta # void updateRungeKutta ( const double & dt , const Eigen :: VectorXd & input ) update vehicle states with Runge-Kutta methods Parameters : dt delta time [s] input vehicle input function updateEuler # void updateEuler ( const double & dt , const Eigen :: VectorXd & input ) update vehicle states with Euler methods Parameters : dt delta time [s] input vehicle input function update # virtual void update ( const double & dt ) = 0 update vehicle states Parameters : dt delta time [s] Reimplemented by : SimModelIdealTwist::update , SimModelTimeDelayTwist::update , SimModelIdealSteer::update , SimModelTimeDelaySteer::update , SimModelIdealAccel::update , SimModelTimeDelaySteerAccel::update function setState # void setState ( const Eigen :: VectorXd & state ) set state vector of model Parameters : state state vector function setInput # void setInput ( const Eigen :: VectorXd & input ) set input vector of model Parameters : input input vector function getYaw # virtual double getYaw () = 0 get vehicle angle yaw Reimplemented by : SimModelIdealTwist::getYaw , SimModelTimeDelayTwist::getYaw , SimModelIdealSteer::getYaw , SimModelTimeDelaySteer::getYaw , SimModelIdealAccel::getYaw , SimModelTimeDelaySteerAccel::getYaw function getY # virtual double getY () = 0 get vehicle position y Reimplemented by : SimModelIdealTwist::getY , SimModelTimeDelayTwist::getY , SimModelIdealSteer::getY , SimModelTimeDelaySteer::getY , SimModelIdealAccel::getY , SimModelTimeDelaySteerAccel::getY function getX # virtual double getX () = 0 get vehicle position x Reimplemented by : SimModelIdealTwist::getX , SimModelTimeDelayTwist::getX , SimModelIdealSteer::getX , SimModelTimeDelaySteer::getX , SimModelIdealAccel::getX , SimModelTimeDelaySteerAccel::getX function getWz # virtual double getWz () = 0 get vehicle angular-velocity wz Reimplemented by : SimModelIdealTwist::getWz , SimModelTimeDelayTwist::getWz , SimModelIdealSteer::getWz , SimModelTimeDelaySteer::getWz , SimModelIdealAccel::getWz , SimModelTimeDelaySteerAccel::getWz function getVx # virtual double getVx () = 0 get vehicle velocity vx Reimplemented by : SimModelIdealTwist::getVx , SimModelTimeDelayTwist::getVx , SimModelIdealSteer::getVx , SimModelTimeDelaySteer::getVx , SimModelIdealAccel::getVx , SimModelTimeDelaySteerAccel::getVx function getSteer # virtual double getSteer () = 0 get vehicle steering angle Reimplemented by : SimModelIdealTwist::getSteer , SimModelTimeDelayTwist::getSteer , SimModelIdealSteer::getSteer , SimModelTimeDelaySteer::getSteer , SimModelIdealAccel::getSteer , SimModelTimeDelaySteerAccel::getSteer function getState # void getState ( Eigen :: VectorXd & state ) get state vector of model Parameters : state state vector function getInput # void getInput ( Eigen :: VectorXd & input ) get input vector of model Parameters : input input vector function calcModel # virtual Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) = 0 calculate derivative of states with vehicle model Parameters : state current model state input input vector to model Reimplemented by : SimModelIdealTwist::calcModel , SimModelTimeDelayTwist::calcModel , SimModelIdealSteer::calcModel , SimModelTimeDelaySteer::calcModel , SimModelIdealAccel::calcModel , SimModelTimeDelaySteerAccel::calcModel function SimModelInterface # SimModelInterface ( int dim_x , int dim_u ) constructor Parameters : dim_x dimension of state x dim_u dimension of input u Protected Attributes Documentation # variable state_ # Eigen :: VectorXd state_ ; vehicle state vector variable input_ # Eigen :: VectorXd input_ ; vehicle input vector variable dim_x_ # const int dim_x_ ; dimension of state x variable dim_u_ # const int dim_u_ ; dimension of input u Updated on 7 April 2021 at 00:31:55 UTC","title":"SimModelInterface"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#simmodelinterface","text":"Inherited by SimModelIdealAccel , SimModelIdealSteer , SimModelIdealTwist , SimModelTimeDelaySteer , SimModelTimeDelaySteerAccel , SimModelTimeDelayTwist","title":"SimModelInterface"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#public-functions","text":"Name ~SimModelInterface () =default destructor void updateRungeKutta (const double & dt, const Eigen::VectorXd & input) update vehicle states with Runge-Kutta methods void updateEuler (const double & dt, const Eigen::VectorXd & input) update vehicle states with Euler methods virtual void update (const double & dt) =0 update vehicle states void setState (const Eigen::VectorXd & state) set state vector of model void setInput (const Eigen::VectorXd & input) set input vector of model virtual double getYaw () =0 get vehicle angle yaw virtual double getY () =0 get vehicle position y virtual double getX () =0 get vehicle position x virtual double getWz () =0 get vehicle angular-velocity wz virtual double getVx () =0 get vehicle velocity vx virtual double getSteer () =0 get vehicle steering angle void getState (Eigen::VectorXd & state) get state vector of model void getInput (Eigen::VectorXd & input) get input vector of model virtual Eigen::VectorXd calcModel (const Eigen::VectorXd & state, const Eigen::VectorXd & input) =0 calculate derivative of states with vehicle model SimModelInterface (int dim_x, int dim_u) constructor","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#protected-attributes","text":"Name Eigen::VectorXd state_ vehicle state vector Eigen::VectorXd input_ vehicle input vector const int dim_x_ dimension of state x const int dim_u_ dimension of input u","title":"Protected Attributes"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-simmodelinterface","text":"~ SimModelInterface () = default destructor","title":"function ~SimModelInterface"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-updaterungekutta","text":"void updateRungeKutta ( const double & dt , const Eigen :: VectorXd & input ) update vehicle states with Runge-Kutta methods Parameters : dt delta time [s] input vehicle input","title":"function updateRungeKutta"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-updateeuler","text":"void updateEuler ( const double & dt , const Eigen :: VectorXd & input ) update vehicle states with Euler methods Parameters : dt delta time [s] input vehicle input","title":"function updateEuler"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-update","text":"virtual void update ( const double & dt ) = 0 update vehicle states Parameters : dt delta time [s] Reimplemented by : SimModelIdealTwist::update , SimModelTimeDelayTwist::update , SimModelIdealSteer::update , SimModelTimeDelaySteer::update , SimModelIdealAccel::update , SimModelTimeDelaySteerAccel::update","title":"function update"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-setstate","text":"void setState ( const Eigen :: VectorXd & state ) set state vector of model Parameters : state state vector","title":"function setState"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-setinput","text":"void setInput ( const Eigen :: VectorXd & input ) set input vector of model Parameters : input input vector","title":"function setInput"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-getyaw","text":"virtual double getYaw () = 0 get vehicle angle yaw Reimplemented by : SimModelIdealTwist::getYaw , SimModelTimeDelayTwist::getYaw , SimModelIdealSteer::getYaw , SimModelTimeDelaySteer::getYaw , SimModelIdealAccel::getYaw , SimModelTimeDelaySteerAccel::getYaw","title":"function getYaw"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-gety","text":"virtual double getY () = 0 get vehicle position y Reimplemented by : SimModelIdealTwist::getY , SimModelTimeDelayTwist::getY , SimModelIdealSteer::getY , SimModelTimeDelaySteer::getY , SimModelIdealAccel::getY , SimModelTimeDelaySteerAccel::getY","title":"function getY"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-getx","text":"virtual double getX () = 0 get vehicle position x Reimplemented by : SimModelIdealTwist::getX , SimModelTimeDelayTwist::getX , SimModelIdealSteer::getX , SimModelTimeDelaySteer::getX , SimModelIdealAccel::getX , SimModelTimeDelaySteerAccel::getX","title":"function getX"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-getwz","text":"virtual double getWz () = 0 get vehicle angular-velocity wz Reimplemented by : SimModelIdealTwist::getWz , SimModelTimeDelayTwist::getWz , SimModelIdealSteer::getWz , SimModelTimeDelaySteer::getWz , SimModelIdealAccel::getWz , SimModelTimeDelaySteerAccel::getWz","title":"function getWz"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-getvx","text":"virtual double getVx () = 0 get vehicle velocity vx Reimplemented by : SimModelIdealTwist::getVx , SimModelTimeDelayTwist::getVx , SimModelIdealSteer::getVx , SimModelTimeDelaySteer::getVx , SimModelIdealAccel::getVx , SimModelTimeDelaySteerAccel::getVx","title":"function getVx"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-getsteer","text":"virtual double getSteer () = 0 get vehicle steering angle Reimplemented by : SimModelIdealTwist::getSteer , SimModelTimeDelayTwist::getSteer , SimModelIdealSteer::getSteer , SimModelTimeDelaySteer::getSteer , SimModelIdealAccel::getSteer , SimModelTimeDelaySteerAccel::getSteer","title":"function getSteer"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-getstate","text":"void getState ( Eigen :: VectorXd & state ) get state vector of model Parameters : state state vector","title":"function getState"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-getinput","text":"void getInput ( Eigen :: VectorXd & input ) get input vector of model Parameters : input input vector","title":"function getInput"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-calcmodel","text":"virtual Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) = 0 calculate derivative of states with vehicle model Parameters : state current model state input input vector to model Reimplemented by : SimModelIdealTwist::calcModel , SimModelTimeDelayTwist::calcModel , SimModelIdealSteer::calcModel , SimModelTimeDelaySteer::calcModel , SimModelIdealAccel::calcModel , SimModelTimeDelaySteerAccel::calcModel","title":"function calcModel"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#function-simmodelinterface_1","text":"SimModelInterface ( int dim_x , int dim_u ) constructor Parameters : dim_x dimension of state x dim_u dimension of input u","title":"function SimModelInterface"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#variable-state_","text":"Eigen :: VectorXd state_ ; vehicle state vector","title":"variable state_"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#variable-input_","text":"Eigen :: VectorXd input_ ; vehicle input vector","title":"variable input_"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#variable-dim_x_","text":"const int dim_x_ ; dimension of state x","title":"variable dim_x_"},{"location":"package/simulation_api/markdown/Classes/classSimModelInterface/#variable-dim_u_","text":"const int dim_u_ ; dimension of input u Updated on 7 April 2021 at 00:31:55 UTC","title":"variable dim_u_"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelaySteer/","text":"SimModelTimeDelaySteer # Inherits from SimModelInterface Public Functions # Name ~SimModelTimeDelaySteer () =default default destructor SimModelTimeDelaySteer (double vx_lim, double steer_lim, double vx_rate_lim, double steer_rate_lim, double wheelbase, double dt, double vx_delay, double vx_time_constant, double steer_delay, double steer_time_constant, double deadzone_delta_steer) constructor Additional inherited members # Public Functions inherited from SimModelInterface Name ~SimModelInterface () =default destructor void updateRungeKutta (const double & dt, const Eigen::VectorXd & input) update vehicle states with Runge-Kutta methods void updateEuler (const double & dt, const Eigen::VectorXd & input) update vehicle states with Euler methods void setState (const Eigen::VectorXd & state) set state vector of model void setInput (const Eigen::VectorXd & input) set input vector of model void getState (Eigen::VectorXd & state) get state vector of model void getInput (Eigen::VectorXd & input) get input vector of model SimModelInterface (int dim_x, int dim_u) constructor Protected Attributes inherited from SimModelInterface Name Eigen::VectorXd state_ vehicle state vector Eigen::VectorXd input_ vehicle input vector const int dim_x_ dimension of state x const int dim_u_ dimension of input u Public Functions Documentation # function ~SimModelTimeDelaySteer # ~ SimModelTimeDelaySteer () = default default destructor function SimModelTimeDelaySteer # SimModelTimeDelaySteer ( double vx_lim , double steer_lim , double vx_rate_lim , double steer_rate_lim , double wheelbase , double dt , double vx_delay , double vx_time_constant , double steer_delay , double steer_time_constant , double deadzone_delta_steer ) constructor Parameters : vx_lim velocity limit [m/s] steer_lim steering limit [rad] vx_rate_lim acceleration limit [m/ss] steer_rate_lim steering angular velocity limit [rad/ss] wheelbase vehicle wheelbase length [m] dt delta time information to set input buffer for delay vx_delay time delay for velocity command [s] vx_time_constant time constant for 1D model of velocity dynamics steer_delay time delay for steering command [s] steer_time_constant time constant for 1D model of steering dynamics deadzone_delta_steer deadzone value of steer Updated on 7 April 2021 at 00:31:55 UTC","title":"SimModelTimeDelaySteer"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelaySteer/#simmodeltimedelaysteer","text":"Inherits from SimModelInterface","title":"SimModelTimeDelaySteer"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelaySteer/#public-functions","text":"Name ~SimModelTimeDelaySteer () =default default destructor SimModelTimeDelaySteer (double vx_lim, double steer_lim, double vx_rate_lim, double steer_rate_lim, double wheelbase, double dt, double vx_delay, double vx_time_constant, double steer_delay, double steer_time_constant, double deadzone_delta_steer) constructor","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelaySteer/#additional-inherited-members","text":"Public Functions inherited from SimModelInterface Name ~SimModelInterface () =default destructor void updateRungeKutta (const double & dt, const Eigen::VectorXd & input) update vehicle states with Runge-Kutta methods void updateEuler (const double & dt, const Eigen::VectorXd & input) update vehicle states with Euler methods void setState (const Eigen::VectorXd & state) set state vector of model void setInput (const Eigen::VectorXd & input) set input vector of model void getState (Eigen::VectorXd & state) get state vector of model void getInput (Eigen::VectorXd & input) get input vector of model SimModelInterface (int dim_x, int dim_u) constructor Protected Attributes inherited from SimModelInterface Name Eigen::VectorXd state_ vehicle state vector Eigen::VectorXd input_ vehicle input vector const int dim_x_ dimension of state x const int dim_u_ dimension of input u","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelaySteer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelaySteer/#function-simmodeltimedelaysteer","text":"~ SimModelTimeDelaySteer () = default default destructor","title":"function ~SimModelTimeDelaySteer"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelaySteer/#function-simmodeltimedelaysteer_1","text":"SimModelTimeDelaySteer ( double vx_lim , double steer_lim , double vx_rate_lim , double steer_rate_lim , double wheelbase , double dt , double vx_delay , double vx_time_constant , double steer_delay , double steer_time_constant , double deadzone_delta_steer ) constructor Parameters : vx_lim velocity limit [m/s] steer_lim steering limit [rad] vx_rate_lim acceleration limit [m/ss] steer_rate_lim steering angular velocity limit [rad/ss] wheelbase vehicle wheelbase length [m] dt delta time information to set input buffer for delay vx_delay time delay for velocity command [s] vx_time_constant time constant for 1D model of velocity dynamics steer_delay time delay for steering command [s] steer_time_constant time constant for 1D model of steering dynamics deadzone_delta_steer deadzone value of steer Updated on 7 April 2021 at 00:31:55 UTC","title":"function SimModelTimeDelaySteer"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelaySteerAccel/","text":"SimModelTimeDelaySteerAccel # Inherits from SimModelInterface Public Functions # Name ~SimModelTimeDelaySteerAccel () =default default destructor SimModelTimeDelaySteerAccel (double vx_lim, double steer_lim, double vx_rate_lim, double steer_rate_lim, double wheelbase, double dt, double acc_delay, double acc_time_constant, double steer_delay, double steer_time_constant, double deadzone_delta_steer) constructor Additional inherited members # Public Functions inherited from SimModelInterface Name ~SimModelInterface () =default destructor void updateRungeKutta (const double & dt, const Eigen::VectorXd & input) update vehicle states with Runge-Kutta methods void updateEuler (const double & dt, const Eigen::VectorXd & input) update vehicle states with Euler methods void setState (const Eigen::VectorXd & state) set state vector of model void setInput (const Eigen::VectorXd & input) set input vector of model void getState (Eigen::VectorXd & state) get state vector of model void getInput (Eigen::VectorXd & input) get input vector of model SimModelInterface (int dim_x, int dim_u) constructor Protected Attributes inherited from SimModelInterface Name Eigen::VectorXd state_ vehicle state vector Eigen::VectorXd input_ vehicle input vector const int dim_x_ dimension of state x const int dim_u_ dimension of input u Public Functions Documentation # function ~SimModelTimeDelaySteerAccel # ~ SimModelTimeDelaySteerAccel () = default default destructor function SimModelTimeDelaySteerAccel # SimModelTimeDelaySteerAccel ( double vx_lim , double steer_lim , double vx_rate_lim , double steer_rate_lim , double wheelbase , double dt , double acc_delay , double acc_time_constant , double steer_delay , double steer_time_constant , double deadzone_delta_steer ) constructor Parameters : vx_lim velocity limit [m/s] steer_lim steering limit [rad] vx_rate_lim acceleration limit [m/ss] steer_rate_lim steering angular velocity limit [rad/ss] wheelbase vehicle wheelbase length [m] dt delta time information to set input buffer for delay acc_delay time delay for accel command [s] acc_time_constant time constant for 1D model of accel dynamics steer_delay time delay for steering command [s] steer_time_constant time constant for 1D model of steering dynamics deadzone_delta_steer deadzone value of steer Updated on 7 April 2021 at 00:31:55 UTC","title":"SimModelTimeDelaySteerAccel"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelaySteerAccel/#simmodeltimedelaysteeraccel","text":"Inherits from SimModelInterface","title":"SimModelTimeDelaySteerAccel"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelaySteerAccel/#public-functions","text":"Name ~SimModelTimeDelaySteerAccel () =default default destructor SimModelTimeDelaySteerAccel (double vx_lim, double steer_lim, double vx_rate_lim, double steer_rate_lim, double wheelbase, double dt, double acc_delay, double acc_time_constant, double steer_delay, double steer_time_constant, double deadzone_delta_steer) constructor","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelaySteerAccel/#additional-inherited-members","text":"Public Functions inherited from SimModelInterface Name ~SimModelInterface () =default destructor void updateRungeKutta (const double & dt, const Eigen::VectorXd & input) update vehicle states with Runge-Kutta methods void updateEuler (const double & dt, const Eigen::VectorXd & input) update vehicle states with Euler methods void setState (const Eigen::VectorXd & state) set state vector of model void setInput (const Eigen::VectorXd & input) set input vector of model void getState (Eigen::VectorXd & state) get state vector of model void getInput (Eigen::VectorXd & input) get input vector of model SimModelInterface (int dim_x, int dim_u) constructor Protected Attributes inherited from SimModelInterface Name Eigen::VectorXd state_ vehicle state vector Eigen::VectorXd input_ vehicle input vector const int dim_x_ dimension of state x const int dim_u_ dimension of input u","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelaySteerAccel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelaySteerAccel/#function-simmodeltimedelaysteeraccel","text":"~ SimModelTimeDelaySteerAccel () = default default destructor","title":"function ~SimModelTimeDelaySteerAccel"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelaySteerAccel/#function-simmodeltimedelaysteeraccel_1","text":"SimModelTimeDelaySteerAccel ( double vx_lim , double steer_lim , double vx_rate_lim , double steer_rate_lim , double wheelbase , double dt , double acc_delay , double acc_time_constant , double steer_delay , double steer_time_constant , double deadzone_delta_steer ) constructor Parameters : vx_lim velocity limit [m/s] steer_lim steering limit [rad] vx_rate_lim acceleration limit [m/ss] steer_rate_lim steering angular velocity limit [rad/ss] wheelbase vehicle wheelbase length [m] dt delta time information to set input buffer for delay acc_delay time delay for accel command [s] acc_time_constant time constant for 1D model of accel dynamics steer_delay time delay for steering command [s] steer_time_constant time constant for 1D model of steering dynamics deadzone_delta_steer deadzone value of steer Updated on 7 April 2021 at 00:31:55 UTC","title":"function SimModelTimeDelaySteerAccel"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelayTwist/","text":"SimModelTimeDelayTwist # Inherits from SimModelInterface Public Functions # Name ~SimModelTimeDelayTwist () =default default destructor SimModelTimeDelayTwist (double vx_lim, double angvel_lim, double vx_rate_lim, double wz_rate_lim, double dt, double vx_delay, double vx_time_constant, double wz_delay, double wz_time_constant, double deadzone_delta_steer) constructor Additional inherited members # Public Functions inherited from SimModelInterface Name ~SimModelInterface () =default destructor void updateRungeKutta (const double & dt, const Eigen::VectorXd & input) update vehicle states with Runge-Kutta methods void updateEuler (const double & dt, const Eigen::VectorXd & input) update vehicle states with Euler methods void setState (const Eigen::VectorXd & state) set state vector of model void setInput (const Eigen::VectorXd & input) set input vector of model void getState (Eigen::VectorXd & state) get state vector of model void getInput (Eigen::VectorXd & input) get input vector of model SimModelInterface (int dim_x, int dim_u) constructor Protected Attributes inherited from SimModelInterface Name Eigen::VectorXd state_ vehicle state vector Eigen::VectorXd input_ vehicle input vector const int dim_x_ dimension of state x const int dim_u_ dimension of input u Public Functions Documentation # function ~SimModelTimeDelayTwist # ~ SimModelTimeDelayTwist () = default default destructor function SimModelTimeDelayTwist # SimModelTimeDelayTwist ( double vx_lim , double angvel_lim , double vx_rate_lim , double wz_rate_lim , double dt , double vx_delay , double vx_time_constant , double wz_delay , double wz_time_constant , double deadzone_delta_steer ) constructor Parameters : vx_lim velocity limit [m/s] angvel_lim angular velocity limit [m/s] vx_rate_lim acceleration limit [m/ss] wz_rate_lim angular acceleration limit [rad/ss] dt delta time information to set input buffer for delay vx_delay time delay for velocity command [s] vx_time_constant time constant for 1D model of velocity dynamics wx_delay time delay for angular-velocity command [s] wz_time_constant time constant for 1D model of angular-velocity dynamics deadzone_delta_steer deadzone value of steer Updated on 7 April 2021 at 00:31:55 UTC","title":"SimModelTimeDelayTwist"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelayTwist/#simmodeltimedelaytwist","text":"Inherits from SimModelInterface","title":"SimModelTimeDelayTwist"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelayTwist/#public-functions","text":"Name ~SimModelTimeDelayTwist () =default default destructor SimModelTimeDelayTwist (double vx_lim, double angvel_lim, double vx_rate_lim, double wz_rate_lim, double dt, double vx_delay, double vx_time_constant, double wz_delay, double wz_time_constant, double deadzone_delta_steer) constructor","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelayTwist/#additional-inherited-members","text":"Public Functions inherited from SimModelInterface Name ~SimModelInterface () =default destructor void updateRungeKutta (const double & dt, const Eigen::VectorXd & input) update vehicle states with Runge-Kutta methods void updateEuler (const double & dt, const Eigen::VectorXd & input) update vehicle states with Euler methods void setState (const Eigen::VectorXd & state) set state vector of model void setInput (const Eigen::VectorXd & input) set input vector of model void getState (Eigen::VectorXd & state) get state vector of model void getInput (Eigen::VectorXd & input) get input vector of model SimModelInterface (int dim_x, int dim_u) constructor Protected Attributes inherited from SimModelInterface Name Eigen::VectorXd state_ vehicle state vector Eigen::VectorXd input_ vehicle input vector const int dim_x_ dimension of state x const int dim_u_ dimension of input u","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelayTwist/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelayTwist/#function-simmodeltimedelaytwist","text":"~ SimModelTimeDelayTwist () = default default destructor","title":"function ~SimModelTimeDelayTwist"},{"location":"package/simulation_api/markdown/Classes/classSimModelTimeDelayTwist/#function-simmodeltimedelaytwist_1","text":"SimModelTimeDelayTwist ( double vx_lim , double angvel_lim , double vx_rate_lim , double wz_rate_lim , double dt , double vx_delay , double vx_time_constant , double wz_delay , double wz_time_constant , double deadzone_delta_steer ) constructor Parameters : vx_lim velocity limit [m/s] angvel_lim angular velocity limit [m/s] vx_rate_lim acceleration limit [m/ss] wz_rate_lim angular acceleration limit [rad/ss] dt delta time information to set input buffer for delay vx_delay time delay for velocity command [s] vx_time_constant time constant for 1D model of velocity dynamics wx_delay time delay for angular-velocity command [s] wz_time_constant time constant for 1D model of angular-velocity dynamics deadzone_delta_steer deadzone value of steer Updated on 7 April 2021 at 00:31:55 UTC","title":"function SimModelTimeDelayTwist"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/","text":"entity_behavior::ActionNode # Inherits from ActionNodeBase Inherited by entity_behavior::PedestrianActionNode , entity_behavior::VehicleActionNode Public Functions # Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () BT::PortsList providedPorts () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const void getBlackBoardValues () bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes # Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time Public Functions Documentation # function ~ActionNode # ~ ActionNode () override = default function stopAtEndOfRoad # openscenario_msgs :: msg :: EntityStatus stopAtEndOfRoad () function providedPorts # static inline BT :: PortsList providedPorts () function halt # inline void halt () override You don't need to override this. function getYieldStopDistance # boost :: optional < double > getYieldStopDistance ( const std :: vector < std :: int64_t > & following_lanelets ) function getRightOfWayEntities # std :: vector < openscenario_msgs :: msg :: EntityStatus > getRightOfWayEntities () function getRightOfWayEntities # std :: vector < openscenario_msgs :: msg :: EntityStatus > getRightOfWayEntities ( const std :: vector < std :: int64_t > & following_lanelets ) function getOtherEntityStatus # std :: vector < openscenario_msgs :: msg :: EntityStatus > getOtherEntityStatus ( std :: int64_t lanelet_id ) function getHorizon # double getHorizon () const function getFrontEntityStatus # boost :: optional < openscenario_msgs :: msg :: EntityStatus > getFrontEntityStatus () function getDistanceToTrafficLightStopLine # boost :: optional < double > getDistanceToTrafficLightStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ) function getDistanceToStopLine # boost :: optional < double > getDistanceToStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ) function getDistanceToFrontEntity # boost :: optional < double > getDistanceToFrontEntity () function getDistanceToConflictingEntity # boost :: optional < double > getDistanceToConflictingEntity ( const std :: vector < std :: int64_t > & following_lanelets ) const function getDistanceToConflictingEntity # boost :: optional < double > getDistanceToConflictingEntity ( const std :: vector < std :: int64_t > & route_lanelets , const simulation_api :: math :: CatmullRomSpline & spline ) function getConflictingEntityStatusOnRoute # std :: vector < openscenario_msgs :: msg :: EntityStatus > getConflictingEntityStatusOnRoute ( const std :: vector < std :: int64_t > & route_lanelets ) const function getConflictingEntityStatus # boost :: optional < openscenario_msgs :: msg :: EntityStatus > getConflictingEntityStatus ( const std :: vector < std :: int64_t > & following_lanelets ) const function getBlackBoardValues # void getBlackBoardValues () function foundConflictingEntity # bool foundConflictingEntity ( const std :: vector < std :: int64_t > & following_lanelets ) const function executeTick # BT :: NodeStatus executeTick () override throws if the derived class return RUNNING. function calculateStopDistance # double calculateStopDistance () const function ActionNode # ActionNode ( const std :: string & name , const BT :: NodeConfiguration & config ) Public Attributes Documentation # variable updated_status # openscenario_msgs :: msg :: EntityStatus updated_status ; variable traffic_light_manager # std :: shared_ptr < simulation_api :: TrafficLightManager > traffic_light_manager ; variable target_speed # boost :: optional < double > target_speed ; variable step_time # double step_time ; variable route_lanelets # std :: vector < std :: int64_t > route_lanelets ; variable request # std :: string request ; variable other_entity_status # std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > other_entity_status ; variable hdmap_utils # std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils ; variable entity_type_list # std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > entity_type_list ; variable entity_status # openscenario_msgs :: msg :: EntityStatus entity_status ; variable current_time # double current_time ; Updated on 7 April 2021 at 00:31:55 UTC","title":"entity_behavior::ActionNode"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#entity_behavioractionnode","text":"Inherits from ActionNodeBase Inherited by entity_behavior::PedestrianActionNode , entity_behavior::VehicleActionNode","title":"entity_behavior::ActionNode"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#public-functions","text":"Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () BT::PortsList providedPorts () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const void getBlackBoardValues () bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#public-attributes","text":"Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-actionnode","text":"~ ActionNode () override = default","title":"function ~ActionNode"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-stopatendofroad","text":"openscenario_msgs :: msg :: EntityStatus stopAtEndOfRoad ()","title":"function stopAtEndOfRoad"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-providedports","text":"static inline BT :: PortsList providedPorts ()","title":"function providedPorts"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-halt","text":"inline void halt () override You don't need to override this.","title":"function halt"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-getyieldstopdistance","text":"boost :: optional < double > getYieldStopDistance ( const std :: vector < std :: int64_t > & following_lanelets )","title":"function getYieldStopDistance"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-getrightofwayentities","text":"std :: vector < openscenario_msgs :: msg :: EntityStatus > getRightOfWayEntities ()","title":"function getRightOfWayEntities"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-getrightofwayentities_1","text":"std :: vector < openscenario_msgs :: msg :: EntityStatus > getRightOfWayEntities ( const std :: vector < std :: int64_t > & following_lanelets )","title":"function getRightOfWayEntities"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-getotherentitystatus","text":"std :: vector < openscenario_msgs :: msg :: EntityStatus > getOtherEntityStatus ( std :: int64_t lanelet_id )","title":"function getOtherEntityStatus"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-gethorizon","text":"double getHorizon () const","title":"function getHorizon"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-getfrontentitystatus","text":"boost :: optional < openscenario_msgs :: msg :: EntityStatus > getFrontEntityStatus ()","title":"function getFrontEntityStatus"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-getdistancetotrafficlightstopline","text":"boost :: optional < double > getDistanceToTrafficLightStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints )","title":"function getDistanceToTrafficLightStopLine"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-getdistancetostopline","text":"boost :: optional < double > getDistanceToStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints )","title":"function getDistanceToStopLine"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-getdistancetofrontentity","text":"boost :: optional < double > getDistanceToFrontEntity ()","title":"function getDistanceToFrontEntity"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-getdistancetoconflictingentity","text":"boost :: optional < double > getDistanceToConflictingEntity ( const std :: vector < std :: int64_t > & following_lanelets ) const","title":"function getDistanceToConflictingEntity"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-getdistancetoconflictingentity_1","text":"boost :: optional < double > getDistanceToConflictingEntity ( const std :: vector < std :: int64_t > & route_lanelets , const simulation_api :: math :: CatmullRomSpline & spline )","title":"function getDistanceToConflictingEntity"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-getconflictingentitystatusonroute","text":"std :: vector < openscenario_msgs :: msg :: EntityStatus > getConflictingEntityStatusOnRoute ( const std :: vector < std :: int64_t > & route_lanelets ) const","title":"function getConflictingEntityStatusOnRoute"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-getconflictingentitystatus","text":"boost :: optional < openscenario_msgs :: msg :: EntityStatus > getConflictingEntityStatus ( const std :: vector < std :: int64_t > & following_lanelets ) const","title":"function getConflictingEntityStatus"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-getblackboardvalues","text":"void getBlackBoardValues ()","title":"function getBlackBoardValues"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-foundconflictingentity","text":"bool foundConflictingEntity ( const std :: vector < std :: int64_t > & following_lanelets ) const","title":"function foundConflictingEntity"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-executetick","text":"BT :: NodeStatus executeTick () override throws if the derived class return RUNNING.","title":"function executeTick"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-calculatestopdistance","text":"double calculateStopDistance () const","title":"function calculateStopDistance"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#function-actionnode_1","text":"ActionNode ( const std :: string & name , const BT :: NodeConfiguration & config )","title":"function ActionNode"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#variable-updated_status","text":"openscenario_msgs :: msg :: EntityStatus updated_status ;","title":"variable updated_status"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#variable-traffic_light_manager","text":"std :: shared_ptr < simulation_api :: TrafficLightManager > traffic_light_manager ;","title":"variable traffic_light_manager"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#variable-target_speed","text":"boost :: optional < double > target_speed ;","title":"variable target_speed"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#variable-step_time","text":"double step_time ;","title":"variable step_time"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#variable-route_lanelets","text":"std :: vector < std :: int64_t > route_lanelets ;","title":"variable route_lanelets"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#variable-request","text":"std :: string request ;","title":"variable request"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#variable-other_entity_status","text":"std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > other_entity_status ;","title":"variable other_entity_status"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#variable-hdmap_utils","text":"std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils ;","title":"variable hdmap_utils"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#variable-entity_type_list","text":"std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > entity_type_list ;","title":"variable entity_type_list"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#variable-entity_status","text":"openscenario_msgs :: msg :: EntityStatus entity_status ;","title":"variable entity_status"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1ActionNode/#variable-current_time","text":"double current_time ; Updated on 7 April 2021 at 00:31:55 UTC","title":"variable current_time"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1BehaviorTreeRuntimeError/","text":"entity_behavior::BehaviorTreeRuntimeError # Inherits from runtime_error Public Functions # Name BehaviorTreeRuntimeError (const char * message) Public Functions Documentation # function BehaviorTreeRuntimeError # inline explicit BehaviorTreeRuntimeError ( const char * message ) Updated on 7 April 2021 at 00:31:55 UTC","title":"entity_behavior::BehaviorTreeRuntimeError"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1BehaviorTreeRuntimeError/#entity_behaviorbehaviortreeruntimeerror","text":"Inherits from runtime_error","title":"entity_behavior::BehaviorTreeRuntimeError"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1BehaviorTreeRuntimeError/#public-functions","text":"Name BehaviorTreeRuntimeError (const char * message)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1BehaviorTreeRuntimeError/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1BehaviorTreeRuntimeError/#function-behaviortreeruntimeerror","text":"inline explicit BehaviorTreeRuntimeError ( const char * message ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function BehaviorTreeRuntimeError"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1PedestrianActionNode/","text":"entity_behavior::PedestrianActionNode # Inherits from entity_behavior::ActionNode , ActionNodeBase Inherited by entity_behavior::pedestrian::FollowLaneAction , entity_behavior::pedestrian::WalkStraightAction Public Functions # Name BT::PortsList providedPorts () void getBlackBoardValues () openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) PedestrianActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes # Name openscenario_msgs::msg::PedestrianParameters pedestrian_parameters Additional inherited members # Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time Public Functions Documentation # function providedPorts # static inline BT :: PortsList providedPorts () function getBlackBoardValues # void getBlackBoardValues () function calculateEntityStatusUpdatedInWorldFrame # openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdatedInWorldFrame ( double target_speed ) function calculateEntityStatusUpdated # openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdated ( double target_speed ) function PedestrianActionNode # PedestrianActionNode ( const std :: string & name , const BT :: NodeConfiguration & config ) Public Attributes Documentation # variable pedestrian_parameters # openscenario_msgs :: msg :: PedestrianParameters pedestrian_parameters ; Updated on 7 April 2021 at 00:31:55 UTC","title":"entity_behavior::PedestrianActionNode"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1PedestrianActionNode/#entity_behaviorpedestrianactionnode","text":"Inherits from entity_behavior::ActionNode , ActionNodeBase Inherited by entity_behavior::pedestrian::FollowLaneAction , entity_behavior::pedestrian::WalkStraightAction","title":"entity_behavior::PedestrianActionNode"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1PedestrianActionNode/#public-functions","text":"Name BT::PortsList providedPorts () void getBlackBoardValues () openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) PedestrianActionNode (const std::string & name, const BT::NodeConfiguration & config)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1PedestrianActionNode/#public-attributes","text":"Name openscenario_msgs::msg::PedestrianParameters pedestrian_parameters","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1PedestrianActionNode/#additional-inherited-members","text":"Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1PedestrianActionNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1PedestrianActionNode/#function-providedports","text":"static inline BT :: PortsList providedPorts ()","title":"function providedPorts"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1PedestrianActionNode/#function-getblackboardvalues","text":"void getBlackBoardValues ()","title":"function getBlackBoardValues"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1PedestrianActionNode/#function-calculateentitystatusupdatedinworldframe","text":"openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdatedInWorldFrame ( double target_speed )","title":"function calculateEntityStatusUpdatedInWorldFrame"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1PedestrianActionNode/#function-calculateentitystatusupdated","text":"openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdated ( double target_speed )","title":"function calculateEntityStatusUpdated"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1PedestrianActionNode/#function-pedestrianactionnode","text":"PedestrianActionNode ( const std :: string & name , const BT :: NodeConfiguration & config )","title":"function PedestrianActionNode"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1PedestrianActionNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1PedestrianActionNode/#variable-pedestrian_parameters","text":"openscenario_msgs :: msg :: PedestrianParameters pedestrian_parameters ; Updated on 7 April 2021 at 00:31:55 UTC","title":"variable pedestrian_parameters"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/","text":"entity_behavior::VehicleActionNode # Inherits from entity_behavior::ActionNode , ActionNodeBase Inherited by entity_behavior::vehicle::follow_lane_sequence::FollowFrontEntityAction , entity_behavior::vehicle::follow_lane_sequence::FollowLaneAction , entity_behavior::vehicle::follow_lane_sequence::StopAtCrossingEntityAction , entity_behavior::vehicle::follow_lane_sequence::StopAtStopLineAction , entity_behavior::vehicle::follow_lane_sequence::StopAtTrafficLightAction , entity_behavior::vehicle::follow_lane_sequence::YieldAction , entity_behavior::vehicle::LaneChangeAction Public Functions # Name ~VehicleActionNode () override =default BT::PortsList providedPorts () void getBlackBoardValues () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () =0 virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) =0 openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes # Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model Additional inherited members # Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time Public Functions Documentation # function ~VehicleActionNode # ~ VehicleActionNode () override = default function providedPorts # static inline BT :: PortsList providedPorts () function getBlackBoardValues # void getBlackBoardValues () function calculateWaypoints # virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () = 0 Reimplemented by : entity_behavior::vehicle::follow_lane_sequence::FollowFrontEntityAction::calculateWaypoints , entity_behavior::vehicle::follow_lane_sequence::YieldAction::calculateWaypoints , entity_behavior::vehicle::follow_lane_sequence::FollowLaneAction::calculateWaypoints , entity_behavior::vehicle::follow_lane_sequence::StopAtTrafficLightAction::calculateWaypoints , entity_behavior::vehicle::follow_lane_sequence::StopAtStopLineAction::calculateWaypoints , entity_behavior::vehicle::follow_lane_sequence::StopAtCrossingEntityAction::calculateWaypoints , entity_behavior::vehicle::LaneChangeAction::calculateWaypoints function calculateObstacle # virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) = 0 Reimplemented by : entity_behavior::vehicle::follow_lane_sequence::FollowFrontEntityAction::calculateObstacle , entity_behavior::vehicle::follow_lane_sequence::YieldAction::calculateObstacle , entity_behavior::vehicle::follow_lane_sequence::FollowLaneAction::calculateObstacle , entity_behavior::vehicle::follow_lane_sequence::StopAtTrafficLightAction::calculateObstacle , entity_behavior::vehicle::follow_lane_sequence::StopAtStopLineAction::calculateObstacle , entity_behavior::vehicle::follow_lane_sequence::StopAtCrossingEntityAction::calculateObstacle , entity_behavior::vehicle::LaneChangeAction::calculateObstacle function calculateEntityStatusUpdatedInWorldFrame # openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdatedInWorldFrame ( double target_speed ) function calculateEntityStatusUpdated # openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdated ( double target_speed ) function calculateEntityStatusUpdated # openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdated ( double target_speed , const std :: vector < std :: int64_t > & following_lanelets ) function VehicleActionNode # VehicleActionNode ( const std :: string & name , const BT :: NodeConfiguration & config ) Public Attributes Documentation # variable vehicle_parameters # openscenario_msgs :: msg :: VehicleParameters vehicle_parameters ; variable driver_model # openscenario_msgs :: msg :: DriverModel driver_model ; Updated on 7 April 2021 at 00:31:55 UTC","title":"entity_behavior::VehicleActionNode"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#entity_behaviorvehicleactionnode","text":"Inherits from entity_behavior::ActionNode , ActionNodeBase Inherited by entity_behavior::vehicle::follow_lane_sequence::FollowFrontEntityAction , entity_behavior::vehicle::follow_lane_sequence::FollowLaneAction , entity_behavior::vehicle::follow_lane_sequence::StopAtCrossingEntityAction , entity_behavior::vehicle::follow_lane_sequence::StopAtStopLineAction , entity_behavior::vehicle::follow_lane_sequence::StopAtTrafficLightAction , entity_behavior::vehicle::follow_lane_sequence::YieldAction , entity_behavior::vehicle::LaneChangeAction","title":"entity_behavior::VehicleActionNode"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#public-functions","text":"Name ~VehicleActionNode () override =default BT::PortsList providedPorts () void getBlackBoardValues () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () =0 virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) =0 openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#public-attributes","text":"Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#additional-inherited-members","text":"Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#function-vehicleactionnode","text":"~ VehicleActionNode () override = default","title":"function ~VehicleActionNode"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#function-providedports","text":"static inline BT :: PortsList providedPorts ()","title":"function providedPorts"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#function-getblackboardvalues","text":"void getBlackBoardValues ()","title":"function getBlackBoardValues"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#function-calculatewaypoints","text":"virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () = 0 Reimplemented by : entity_behavior::vehicle::follow_lane_sequence::FollowFrontEntityAction::calculateWaypoints , entity_behavior::vehicle::follow_lane_sequence::YieldAction::calculateWaypoints , entity_behavior::vehicle::follow_lane_sequence::FollowLaneAction::calculateWaypoints , entity_behavior::vehicle::follow_lane_sequence::StopAtTrafficLightAction::calculateWaypoints , entity_behavior::vehicle::follow_lane_sequence::StopAtStopLineAction::calculateWaypoints , entity_behavior::vehicle::follow_lane_sequence::StopAtCrossingEntityAction::calculateWaypoints , entity_behavior::vehicle::LaneChangeAction::calculateWaypoints","title":"function calculateWaypoints"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#function-calculateobstacle","text":"virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) = 0 Reimplemented by : entity_behavior::vehicle::follow_lane_sequence::FollowFrontEntityAction::calculateObstacle , entity_behavior::vehicle::follow_lane_sequence::YieldAction::calculateObstacle , entity_behavior::vehicle::follow_lane_sequence::FollowLaneAction::calculateObstacle , entity_behavior::vehicle::follow_lane_sequence::StopAtTrafficLightAction::calculateObstacle , entity_behavior::vehicle::follow_lane_sequence::StopAtStopLineAction::calculateObstacle , entity_behavior::vehicle::follow_lane_sequence::StopAtCrossingEntityAction::calculateObstacle , entity_behavior::vehicle::LaneChangeAction::calculateObstacle","title":"function calculateObstacle"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#function-calculateentitystatusupdatedinworldframe","text":"openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdatedInWorldFrame ( double target_speed )","title":"function calculateEntityStatusUpdatedInWorldFrame"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#function-calculateentitystatusupdated","text":"openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdated ( double target_speed )","title":"function calculateEntityStatusUpdated"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#function-calculateentitystatusupdated_1","text":"openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdated ( double target_speed , const std :: vector < std :: int64_t > & following_lanelets )","title":"function calculateEntityStatusUpdated"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#function-vehicleactionnode_1","text":"VehicleActionNode ( const std :: string & name , const BT :: NodeConfiguration & config )","title":"function VehicleActionNode"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#variable-vehicle_parameters","text":"openscenario_msgs :: msg :: VehicleParameters vehicle_parameters ;","title":"variable vehicle_parameters"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1VehicleActionNode/#variable-driver_model","text":"openscenario_msgs :: msg :: DriverModel driver_model ; Updated on 7 April 2021 at 00:31:55 UTC","title":"variable driver_model"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1BehaviorTree/","text":"entity_behavior::pedestrian::BehaviorTree # Public Functions # Name BT::NodeStatus tick (double current_time, double step_time) template \\<typename T > void setValueToBlackBoard (std::string key, T value) void setRequest (std::string request) openscenario_msgs::msg::EntityStatus getUpdatedStatus () const std::string getCurrentAction () const BehaviorTree () Public Functions Documentation # function tick # BT :: NodeStatus tick ( double current_time , double step_time ) function setValueToBlackBoard # template < typename T > inline void setValueToBlackBoard ( std :: string key , T value ) function setRequest # void setRequest ( std :: string request ) function getUpdatedStatus # inline openscenario_msgs :: msg :: EntityStatus getUpdatedStatus () function getCurrentAction # inline const std :: string getCurrentAction () const function BehaviorTree # BehaviorTree () Updated on 7 April 2021 at 00:31:55 UTC","title":"entity_behavior::pedestrian::BehaviorTree"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1BehaviorTree/#entity_behaviorpedestrianbehaviortree","text":"","title":"entity_behavior::pedestrian::BehaviorTree"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1BehaviorTree/#public-functions","text":"Name BT::NodeStatus tick (double current_time, double step_time) template \\<typename T > void setValueToBlackBoard (std::string key, T value) void setRequest (std::string request) openscenario_msgs::msg::EntityStatus getUpdatedStatus () const std::string getCurrentAction () const BehaviorTree ()","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1BehaviorTree/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1BehaviorTree/#function-tick","text":"BT :: NodeStatus tick ( double current_time , double step_time )","title":"function tick"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1BehaviorTree/#function-setvaluetoblackboard","text":"template < typename T > inline void setValueToBlackBoard ( std :: string key , T value )","title":"function setValueToBlackBoard"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1BehaviorTree/#function-setrequest","text":"void setRequest ( std :: string request )","title":"function setRequest"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1BehaviorTree/#function-getupdatedstatus","text":"inline openscenario_msgs :: msg :: EntityStatus getUpdatedStatus ()","title":"function getUpdatedStatus"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1BehaviorTree/#function-getcurrentaction","text":"inline const std :: string getCurrentAction () const","title":"function getCurrentAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1BehaviorTree/#function-behaviortree","text":"BehaviorTree () Updated on 7 April 2021 at 00:31:55 UTC","title":"function BehaviorTree"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1FollowLaneAction/","text":"entity_behavior::pedestrian::FollowLaneAction # Inherits from entity_behavior::PedestrianActionNode , entity_behavior::ActionNode , ActionNodeBase Public Functions # Name BT::NodeStatus tick () override BT::PortsList providedPorts () void getBlackBoardValues () FollowLaneAction (const std::string & name, const BT::NodeConfiguration & config) Additional inherited members # Public Functions inherited from entity_behavior::PedestrianActionNode Name openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) PedestrianActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::PedestrianActionNode Name openscenario_msgs::msg::PedestrianParameters pedestrian_parameters Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time Public Functions Documentation # function tick # BT :: NodeStatus tick () override function providedPorts # static inline BT :: PortsList providedPorts () function getBlackBoardValues # void getBlackBoardValues () function FollowLaneAction # FollowLaneAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"entity_behavior::pedestrian::FollowLaneAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1FollowLaneAction/#entity_behaviorpedestrianfollowlaneaction","text":"Inherits from entity_behavior::PedestrianActionNode , entity_behavior::ActionNode , ActionNodeBase","title":"entity_behavior::pedestrian::FollowLaneAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1FollowLaneAction/#public-functions","text":"Name BT::NodeStatus tick () override BT::PortsList providedPorts () void getBlackBoardValues () FollowLaneAction (const std::string & name, const BT::NodeConfiguration & config)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1FollowLaneAction/#additional-inherited-members","text":"Public Functions inherited from entity_behavior::PedestrianActionNode Name openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) PedestrianActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::PedestrianActionNode Name openscenario_msgs::msg::PedestrianParameters pedestrian_parameters Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1FollowLaneAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1FollowLaneAction/#function-tick","text":"BT :: NodeStatus tick () override","title":"function tick"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1FollowLaneAction/#function-providedports","text":"static inline BT :: PortsList providedPorts ()","title":"function providedPorts"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1FollowLaneAction/#function-getblackboardvalues","text":"void getBlackBoardValues ()","title":"function getBlackBoardValues"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1FollowLaneAction/#function-followlaneaction","text":"FollowLaneAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function FollowLaneAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1WalkStraightAction/","text":"entity_behavior::pedestrian::WalkStraightAction # Inherits from entity_behavior::PedestrianActionNode , entity_behavior::ActionNode , ActionNodeBase Public Functions # Name BT::NodeStatus tick () override BT::PortsList providedPorts () void getBlackBoardValues () WalkStraightAction (const std::string & name, const BT::NodeConfiguration & config) Additional inherited members # Public Functions inherited from entity_behavior::PedestrianActionNode Name openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) PedestrianActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::PedestrianActionNode Name openscenario_msgs::msg::PedestrianParameters pedestrian_parameters Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time Public Functions Documentation # function tick # BT :: NodeStatus tick () override function providedPorts # static inline BT :: PortsList providedPorts () function getBlackBoardValues # void getBlackBoardValues () function WalkStraightAction # WalkStraightAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"entity_behavior::pedestrian::WalkStraightAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1WalkStraightAction/#entity_behaviorpedestrianwalkstraightaction","text":"Inherits from entity_behavior::PedestrianActionNode , entity_behavior::ActionNode , ActionNodeBase","title":"entity_behavior::pedestrian::WalkStraightAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1WalkStraightAction/#public-functions","text":"Name BT::NodeStatus tick () override BT::PortsList providedPorts () void getBlackBoardValues () WalkStraightAction (const std::string & name, const BT::NodeConfiguration & config)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1WalkStraightAction/#additional-inherited-members","text":"Public Functions inherited from entity_behavior::PedestrianActionNode Name openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) PedestrianActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::PedestrianActionNode Name openscenario_msgs::msg::PedestrianParameters pedestrian_parameters Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1WalkStraightAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1WalkStraightAction/#function-tick","text":"BT :: NodeStatus tick () override","title":"function tick"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1WalkStraightAction/#function-providedports","text":"static inline BT :: PortsList providedPorts ()","title":"function providedPorts"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1WalkStraightAction/#function-getblackboardvalues","text":"void getBlackBoardValues ()","title":"function getBlackBoardValues"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1pedestrian_1_1WalkStraightAction/#function-walkstraightaction","text":"WalkStraightAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function WalkStraightAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1BehaviorTree/","text":"entity_behavior::vehicle::BehaviorTree # Public Functions # Name BT::NodeStatus tick (double current_time, double step_time) template \\<typename T > void setValueToBlackBoard (std::string key, T value) void setRequest (std::string request) openscenario_msgs::msg::WaypointsArray getWaypoints () openscenario_msgs::msg::EntityStatus getUpdatedStatus () boost::optional< openscenario_msgs::msg::Obstacle > getObstacle () const std::string getCurrentAction () const BehaviorTree () Public Functions Documentation # function tick # BT :: NodeStatus tick ( double current_time , double step_time ) function setValueToBlackBoard # template < typename T > inline void setValueToBlackBoard ( std :: string key , T value ) function setRequest # void setRequest ( std :: string request ) function getWaypoints # inline openscenario_msgs :: msg :: WaypointsArray getWaypoints () function getUpdatedStatus # inline openscenario_msgs :: msg :: EntityStatus getUpdatedStatus () function getObstacle # inline boost :: optional < openscenario_msgs :: msg :: Obstacle > getObstacle () function getCurrentAction # inline const std :: string getCurrentAction () const function BehaviorTree # BehaviorTree () Updated on 7 April 2021 at 00:31:55 UTC","title":"entity_behavior::vehicle::BehaviorTree"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1BehaviorTree/#entity_behaviorvehiclebehaviortree","text":"","title":"entity_behavior::vehicle::BehaviorTree"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1BehaviorTree/#public-functions","text":"Name BT::NodeStatus tick (double current_time, double step_time) template \\<typename T > void setValueToBlackBoard (std::string key, T value) void setRequest (std::string request) openscenario_msgs::msg::WaypointsArray getWaypoints () openscenario_msgs::msg::EntityStatus getUpdatedStatus () boost::optional< openscenario_msgs::msg::Obstacle > getObstacle () const std::string getCurrentAction () const BehaviorTree ()","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1BehaviorTree/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1BehaviorTree/#function-tick","text":"BT :: NodeStatus tick ( double current_time , double step_time )","title":"function tick"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1BehaviorTree/#function-setvaluetoblackboard","text":"template < typename T > inline void setValueToBlackBoard ( std :: string key , T value )","title":"function setValueToBlackBoard"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1BehaviorTree/#function-setrequest","text":"void setRequest ( std :: string request )","title":"function setRequest"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1BehaviorTree/#function-getwaypoints","text":"inline openscenario_msgs :: msg :: WaypointsArray getWaypoints ()","title":"function getWaypoints"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1BehaviorTree/#function-getupdatedstatus","text":"inline openscenario_msgs :: msg :: EntityStatus getUpdatedStatus ()","title":"function getUpdatedStatus"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1BehaviorTree/#function-getobstacle","text":"inline boost :: optional < openscenario_msgs :: msg :: Obstacle > getObstacle ()","title":"function getObstacle"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1BehaviorTree/#function-getcurrentaction","text":"inline const std :: string getCurrentAction () const","title":"function getCurrentAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1BehaviorTree/#function-behaviortree","text":"BehaviorTree () Updated on 7 April 2021 at 00:31:55 UTC","title":"function BehaviorTree"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1LaneChangeAction/","text":"entity_behavior::vehicle::LaneChangeAction # Inherits from entity_behavior::VehicleActionNode , entity_behavior::ActionNode , ActionNodeBase Public Functions # Name BT::NodeStatus tick () override BT::PortsList providedPorts () void getBlackBoardValues () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () override virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) override LaneChangeAction (const std::string & name, const BT::NodeConfiguration & config) Additional inherited members # Public Functions inherited from entity_behavior::VehicleActionNode Name ~VehicleActionNode () override =default openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::VehicleActionNode Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time Public Functions Documentation # function tick # BT :: NodeStatus tick () override function providedPorts # static inline BT :: PortsList providedPorts () function getBlackBoardValues # void getBlackBoardValues () function calculateWaypoints # virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override Reimplements : entity_behavior::VehicleActionNode::calculateWaypoints function calculateObstacle # virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override Reimplements : entity_behavior::VehicleActionNode::calculateObstacle function LaneChangeAction # LaneChangeAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"entity_behavior::vehicle::LaneChangeAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1LaneChangeAction/#entity_behaviorvehiclelanechangeaction","text":"Inherits from entity_behavior::VehicleActionNode , entity_behavior::ActionNode , ActionNodeBase","title":"entity_behavior::vehicle::LaneChangeAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1LaneChangeAction/#public-functions","text":"Name BT::NodeStatus tick () override BT::PortsList providedPorts () void getBlackBoardValues () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () override virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) override LaneChangeAction (const std::string & name, const BT::NodeConfiguration & config)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1LaneChangeAction/#additional-inherited-members","text":"Public Functions inherited from entity_behavior::VehicleActionNode Name ~VehicleActionNode () override =default openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::VehicleActionNode Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1LaneChangeAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1LaneChangeAction/#function-tick","text":"BT :: NodeStatus tick () override","title":"function tick"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1LaneChangeAction/#function-providedports","text":"static inline BT :: PortsList providedPorts ()","title":"function providedPorts"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1LaneChangeAction/#function-getblackboardvalues","text":"void getBlackBoardValues ()","title":"function getBlackBoardValues"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1LaneChangeAction/#function-calculatewaypoints","text":"virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override Reimplements : entity_behavior::VehicleActionNode::calculateWaypoints","title":"function calculateWaypoints"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1LaneChangeAction/#function-calculateobstacle","text":"virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override Reimplements : entity_behavior::VehicleActionNode::calculateObstacle","title":"function calculateObstacle"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1LaneChangeAction/#function-lanechangeaction","text":"LaneChangeAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function LaneChangeAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowFrontEntityAction/","text":"entity_behavior::vehicle::follow_lane_sequence::FollowFrontEntityAction # Inherits from entity_behavior::VehicleActionNode , entity_behavior::ActionNode , ActionNodeBase Public Functions # Name BT::NodeStatus tick () override BT::PortsList providedPorts () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () override virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) override FollowFrontEntityAction (const std::string & name, const BT::NodeConfiguration & config) Additional inherited members # Public Functions inherited from entity_behavior::VehicleActionNode Name ~VehicleActionNode () override =default void getBlackBoardValues () openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::VehicleActionNode Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const void getBlackBoardValues () bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time Public Functions Documentation # function tick # BT :: NodeStatus tick () override function providedPorts # static inline BT :: PortsList providedPorts () function calculateWaypoints # virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override Reimplements : entity_behavior::VehicleActionNode::calculateWaypoints function calculateObstacle # virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override Reimplements : entity_behavior::VehicleActionNode::calculateObstacle function FollowFrontEntityAction # FollowFrontEntityAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"entity_behavior::vehicle::follow_lane_sequence::FollowFrontEntityAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowFrontEntityAction/#entity_behaviorvehiclefollow_lane_sequencefollowfrontentityaction","text":"Inherits from entity_behavior::VehicleActionNode , entity_behavior::ActionNode , ActionNodeBase","title":"entity_behavior::vehicle::follow_lane_sequence::FollowFrontEntityAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowFrontEntityAction/#public-functions","text":"Name BT::NodeStatus tick () override BT::PortsList providedPorts () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () override virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) override FollowFrontEntityAction (const std::string & name, const BT::NodeConfiguration & config)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowFrontEntityAction/#additional-inherited-members","text":"Public Functions inherited from entity_behavior::VehicleActionNode Name ~VehicleActionNode () override =default void getBlackBoardValues () openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::VehicleActionNode Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const void getBlackBoardValues () bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowFrontEntityAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowFrontEntityAction/#function-tick","text":"BT :: NodeStatus tick () override","title":"function tick"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowFrontEntityAction/#function-providedports","text":"static inline BT :: PortsList providedPorts ()","title":"function providedPorts"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowFrontEntityAction/#function-calculatewaypoints","text":"virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override Reimplements : entity_behavior::VehicleActionNode::calculateWaypoints","title":"function calculateWaypoints"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowFrontEntityAction/#function-calculateobstacle","text":"virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override Reimplements : entity_behavior::VehicleActionNode::calculateObstacle","title":"function calculateObstacle"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowFrontEntityAction/#function-followfrontentityaction","text":"FollowFrontEntityAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function FollowFrontEntityAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowLaneAction/","text":"entity_behavior::vehicle::follow_lane_sequence::FollowLaneAction # Inherits from entity_behavior::VehicleActionNode , entity_behavior::ActionNode , ActionNodeBase Public Functions # Name BT::NodeStatus tick () override BT::PortsList providedPorts () void getBlackBoardValues () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () override virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) override FollowLaneAction (const std::string & name, const BT::NodeConfiguration & config) Additional inherited members # Public Functions inherited from entity_behavior::VehicleActionNode Name ~VehicleActionNode () override =default openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::VehicleActionNode Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time Public Functions Documentation # function tick # BT :: NodeStatus tick () override function providedPorts # static inline BT :: PortsList providedPorts () function getBlackBoardValues # void getBlackBoardValues () function calculateWaypoints # virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override Reimplements : entity_behavior::VehicleActionNode::calculateWaypoints function calculateObstacle # virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override Reimplements : entity_behavior::VehicleActionNode::calculateObstacle function FollowLaneAction # FollowLaneAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"entity_behavior::vehicle::follow_lane_sequence::FollowLaneAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowLaneAction/#entity_behaviorvehiclefollow_lane_sequencefollowlaneaction","text":"Inherits from entity_behavior::VehicleActionNode , entity_behavior::ActionNode , ActionNodeBase","title":"entity_behavior::vehicle::follow_lane_sequence::FollowLaneAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowLaneAction/#public-functions","text":"Name BT::NodeStatus tick () override BT::PortsList providedPorts () void getBlackBoardValues () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () override virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) override FollowLaneAction (const std::string & name, const BT::NodeConfiguration & config)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowLaneAction/#additional-inherited-members","text":"Public Functions inherited from entity_behavior::VehicleActionNode Name ~VehicleActionNode () override =default openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::VehicleActionNode Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowLaneAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowLaneAction/#function-tick","text":"BT :: NodeStatus tick () override","title":"function tick"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowLaneAction/#function-providedports","text":"static inline BT :: PortsList providedPorts ()","title":"function providedPorts"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowLaneAction/#function-getblackboardvalues","text":"void getBlackBoardValues ()","title":"function getBlackBoardValues"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowLaneAction/#function-calculatewaypoints","text":"virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override Reimplements : entity_behavior::VehicleActionNode::calculateWaypoints","title":"function calculateWaypoints"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowLaneAction/#function-calculateobstacle","text":"virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override Reimplements : entity_behavior::VehicleActionNode::calculateObstacle","title":"function calculateObstacle"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1FollowLaneAction/#function-followlaneaction","text":"FollowLaneAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function FollowLaneAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtCrossingEntityAction/","text":"entity_behavior::vehicle::follow_lane_sequence::StopAtCrossingEntityAction # Inherits from entity_behavior::VehicleActionNode , entity_behavior::ActionNode , ActionNodeBase Public Functions # Name BT::NodeStatus tick () override BT::PortsList providedPorts () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () override boost::optional< double > calculateTargetSpeed (double current_velocity) virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) override StopAtCrossingEntityAction (const std::string & name, const BT::NodeConfiguration & config) Additional inherited members # Public Functions inherited from entity_behavior::VehicleActionNode Name ~VehicleActionNode () override =default void getBlackBoardValues () openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::VehicleActionNode Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const void getBlackBoardValues () bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time Public Functions Documentation # function tick # BT :: NodeStatus tick () override function providedPorts # static inline BT :: PortsList providedPorts () function calculateWaypoints # virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override Reimplements : entity_behavior::VehicleActionNode::calculateWaypoints function calculateTargetSpeed # boost :: optional < double > calculateTargetSpeed ( double current_velocity ) function calculateObstacle # virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override Reimplements : entity_behavior::VehicleActionNode::calculateObstacle function StopAtCrossingEntityAction # StopAtCrossingEntityAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"entity_behavior::vehicle::follow_lane_sequence::StopAtCrossingEntityAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtCrossingEntityAction/#entity_behaviorvehiclefollow_lane_sequencestopatcrossingentityaction","text":"Inherits from entity_behavior::VehicleActionNode , entity_behavior::ActionNode , ActionNodeBase","title":"entity_behavior::vehicle::follow_lane_sequence::StopAtCrossingEntityAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtCrossingEntityAction/#public-functions","text":"Name BT::NodeStatus tick () override BT::PortsList providedPorts () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () override boost::optional< double > calculateTargetSpeed (double current_velocity) virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) override StopAtCrossingEntityAction (const std::string & name, const BT::NodeConfiguration & config)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtCrossingEntityAction/#additional-inherited-members","text":"Public Functions inherited from entity_behavior::VehicleActionNode Name ~VehicleActionNode () override =default void getBlackBoardValues () openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::VehicleActionNode Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const void getBlackBoardValues () bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtCrossingEntityAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtCrossingEntityAction/#function-tick","text":"BT :: NodeStatus tick () override","title":"function tick"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtCrossingEntityAction/#function-providedports","text":"static inline BT :: PortsList providedPorts ()","title":"function providedPorts"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtCrossingEntityAction/#function-calculatewaypoints","text":"virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override Reimplements : entity_behavior::VehicleActionNode::calculateWaypoints","title":"function calculateWaypoints"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtCrossingEntityAction/#function-calculatetargetspeed","text":"boost :: optional < double > calculateTargetSpeed ( double current_velocity )","title":"function calculateTargetSpeed"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtCrossingEntityAction/#function-calculateobstacle","text":"virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override Reimplements : entity_behavior::VehicleActionNode::calculateObstacle","title":"function calculateObstacle"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtCrossingEntityAction/#function-stopatcrossingentityaction","text":"StopAtCrossingEntityAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function StopAtCrossingEntityAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtStopLineAction/","text":"entity_behavior::vehicle::follow_lane_sequence::StopAtStopLineAction # Inherits from entity_behavior::VehicleActionNode , entity_behavior::ActionNode , ActionNodeBase Public Functions # Name BT::NodeStatus tick () override BT::PortsList providedPorts () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () override boost::optional< double > calculateTargetSpeed (double current_velocity) virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) override StopAtStopLineAction (const std::string & name, const BT::NodeConfiguration & config) Additional inherited members # Public Functions inherited from entity_behavior::VehicleActionNode Name ~VehicleActionNode () override =default void getBlackBoardValues () openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::VehicleActionNode Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const void getBlackBoardValues () bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time Public Functions Documentation # function tick # BT :: NodeStatus tick () override function providedPorts # static inline BT :: PortsList providedPorts () function calculateWaypoints # virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override Reimplements : entity_behavior::VehicleActionNode::calculateWaypoints function calculateTargetSpeed # boost :: optional < double > calculateTargetSpeed ( double current_velocity ) function calculateObstacle # virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override Reimplements : entity_behavior::VehicleActionNode::calculateObstacle function StopAtStopLineAction # StopAtStopLineAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"entity_behavior::vehicle::follow_lane_sequence::StopAtStopLineAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtStopLineAction/#entity_behaviorvehiclefollow_lane_sequencestopatstoplineaction","text":"Inherits from entity_behavior::VehicleActionNode , entity_behavior::ActionNode , ActionNodeBase","title":"entity_behavior::vehicle::follow_lane_sequence::StopAtStopLineAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtStopLineAction/#public-functions","text":"Name BT::NodeStatus tick () override BT::PortsList providedPorts () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () override boost::optional< double > calculateTargetSpeed (double current_velocity) virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) override StopAtStopLineAction (const std::string & name, const BT::NodeConfiguration & config)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtStopLineAction/#additional-inherited-members","text":"Public Functions inherited from entity_behavior::VehicleActionNode Name ~VehicleActionNode () override =default void getBlackBoardValues () openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::VehicleActionNode Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const void getBlackBoardValues () bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtStopLineAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtStopLineAction/#function-tick","text":"BT :: NodeStatus tick () override","title":"function tick"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtStopLineAction/#function-providedports","text":"static inline BT :: PortsList providedPorts ()","title":"function providedPorts"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtStopLineAction/#function-calculatewaypoints","text":"virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override Reimplements : entity_behavior::VehicleActionNode::calculateWaypoints","title":"function calculateWaypoints"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtStopLineAction/#function-calculatetargetspeed","text":"boost :: optional < double > calculateTargetSpeed ( double current_velocity )","title":"function calculateTargetSpeed"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtStopLineAction/#function-calculateobstacle","text":"virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override Reimplements : entity_behavior::VehicleActionNode::calculateObstacle","title":"function calculateObstacle"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtStopLineAction/#function-stopatstoplineaction","text":"StopAtStopLineAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function StopAtStopLineAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtTrafficLightAction/","text":"entity_behavior::vehicle::follow_lane_sequence::StopAtTrafficLightAction # Inherits from entity_behavior::VehicleActionNode , entity_behavior::ActionNode , ActionNodeBase Public Functions # Name BT::NodeStatus tick () override BT::PortsList providedPorts () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () override boost::optional< double > calculateTargetSpeed (double current_velocity) virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) override StopAtTrafficLightAction (const std::string & name, const BT::NodeConfiguration & config) Additional inherited members # Public Functions inherited from entity_behavior::VehicleActionNode Name ~VehicleActionNode () override =default void getBlackBoardValues () openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::VehicleActionNode Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const void getBlackBoardValues () bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time Public Functions Documentation # function tick # BT :: NodeStatus tick () override function providedPorts # static inline BT :: PortsList providedPorts () function calculateWaypoints # virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override Reimplements : entity_behavior::VehicleActionNode::calculateWaypoints function calculateTargetSpeed # boost :: optional < double > calculateTargetSpeed ( double current_velocity ) function calculateObstacle # virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override Reimplements : entity_behavior::VehicleActionNode::calculateObstacle function StopAtTrafficLightAction # StopAtTrafficLightAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"entity_behavior::vehicle::follow_lane_sequence::StopAtTrafficLightAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtTrafficLightAction/#entity_behaviorvehiclefollow_lane_sequencestopattrafficlightaction","text":"Inherits from entity_behavior::VehicleActionNode , entity_behavior::ActionNode , ActionNodeBase","title":"entity_behavior::vehicle::follow_lane_sequence::StopAtTrafficLightAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtTrafficLightAction/#public-functions","text":"Name BT::NodeStatus tick () override BT::PortsList providedPorts () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () override boost::optional< double > calculateTargetSpeed (double current_velocity) virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) override StopAtTrafficLightAction (const std::string & name, const BT::NodeConfiguration & config)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtTrafficLightAction/#additional-inherited-members","text":"Public Functions inherited from entity_behavior::VehicleActionNode Name ~VehicleActionNode () override =default void getBlackBoardValues () openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::VehicleActionNode Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const void getBlackBoardValues () bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtTrafficLightAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtTrafficLightAction/#function-tick","text":"BT :: NodeStatus tick () override","title":"function tick"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtTrafficLightAction/#function-providedports","text":"static inline BT :: PortsList providedPorts ()","title":"function providedPorts"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtTrafficLightAction/#function-calculatewaypoints","text":"virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override Reimplements : entity_behavior::VehicleActionNode::calculateWaypoints","title":"function calculateWaypoints"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtTrafficLightAction/#function-calculatetargetspeed","text":"boost :: optional < double > calculateTargetSpeed ( double current_velocity )","title":"function calculateTargetSpeed"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtTrafficLightAction/#function-calculateobstacle","text":"virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override Reimplements : entity_behavior::VehicleActionNode::calculateObstacle","title":"function calculateObstacle"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1StopAtTrafficLightAction/#function-stopattrafficlightaction","text":"StopAtTrafficLightAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:55 UTC","title":"function StopAtTrafficLightAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1YieldAction/","text":"entity_behavior::vehicle::follow_lane_sequence::YieldAction # Inherits from entity_behavior::VehicleActionNode , entity_behavior::ActionNode , ActionNodeBase Public Functions # Name BT::NodeStatus tick () override BT::PortsList providedPorts () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () override boost::optional< double > calculateTargetSpeed () virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) override YieldAction (const std::string & name, const BT::NodeConfiguration & config) Additional inherited members # Public Functions inherited from entity_behavior::VehicleActionNode Name ~VehicleActionNode () override =default void getBlackBoardValues () openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::VehicleActionNode Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const void getBlackBoardValues () bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time Public Functions Documentation # function tick # BT :: NodeStatus tick () override function providedPorts # static inline BT :: PortsList providedPorts () function calculateWaypoints # virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override Reimplements : entity_behavior::VehicleActionNode::calculateWaypoints function calculateTargetSpeed # boost :: optional < double > calculateTargetSpeed () function calculateObstacle # virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override Reimplements : entity_behavior::VehicleActionNode::calculateObstacle function YieldAction # YieldAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:54 UTC","title":"entity_behavior::vehicle::follow_lane_sequence::YieldAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1YieldAction/#entity_behaviorvehiclefollow_lane_sequenceyieldaction","text":"Inherits from entity_behavior::VehicleActionNode , entity_behavior::ActionNode , ActionNodeBase","title":"entity_behavior::vehicle::follow_lane_sequence::YieldAction"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1YieldAction/#public-functions","text":"Name BT::NodeStatus tick () override BT::PortsList providedPorts () virtual const openscenario_msgs::msg::WaypointsArray calculateWaypoints () override boost::optional< double > calculateTargetSpeed () virtual const boost::optional< openscenario_msgs::msg::Obstacle > calculateObstacle (const openscenario_msgs::msg::WaypointsArray & waypoints) override YieldAction (const std::string & name, const BT::NodeConfiguration & config)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1YieldAction/#additional-inherited-members","text":"Public Functions inherited from entity_behavior::VehicleActionNode Name ~VehicleActionNode () override =default void getBlackBoardValues () openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdatedInWorldFrame (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed) openscenario_msgs::msg::EntityStatus calculateEntityStatusUpdated (double target_speed, const std::vector< std::int64_t > & following_lanelets) VehicleActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::VehicleActionNode Name openscenario_msgs::msg::VehicleParameters vehicle_parameters openscenario_msgs::msg::DriverModel driver_model Public Functions inherited from entity_behavior::ActionNode Name ~ActionNode () override =default openscenario_msgs::msg::EntityStatus stopAtEndOfRoad () void halt () override You don't need to override this. boost::optional< double > getYieldStopDistance (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities () std::vector< openscenario_msgs::msg::EntityStatus > getRightOfWayEntities (const std::vector< std::int64_t > & following_lanelets) std::vector< openscenario_msgs::msg::EntityStatus > getOtherEntityStatus (std::int64_t lanelet_id) double getHorizon () const boost::optional< openscenario_msgs::msg::EntityStatus > getFrontEntityStatus () boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) boost::optional< double > getDistanceToFrontEntity () boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const boost::optional< double > getDistanceToConflictingEntity (const std::vector< std::int64_t > & route_lanelets, const simulation_api::math::CatmullRomSpline & spline) std::vector< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatusOnRoute (const std::vector< std::int64_t > & route_lanelets) const boost::optional< openscenario_msgs::msg::EntityStatus > getConflictingEntityStatus (const std::vector< std::int64_t > & following_lanelets) const void getBlackBoardValues () bool foundConflictingEntity (const std::vector< std::int64_t > & following_lanelets) const BT::NodeStatus executeTick () override throws if the derived class return RUNNING. double calculateStopDistance () const ActionNode (const std::string & name, const BT::NodeConfiguration & config) Public Attributes inherited from entity_behavior::ActionNode Name openscenario_msgs::msg::EntityStatus updated_status std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager boost::optional< double > target_speed double step_time std::vector< std::int64_t > route_lanelets std::string request std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_entity_status std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list openscenario_msgs::msg::EntityStatus entity_status double current_time","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1YieldAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1YieldAction/#function-tick","text":"BT :: NodeStatus tick () override","title":"function tick"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1YieldAction/#function-providedports","text":"static inline BT :: PortsList providedPorts ()","title":"function providedPorts"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1YieldAction/#function-calculatewaypoints","text":"virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override Reimplements : entity_behavior::VehicleActionNode::calculateWaypoints","title":"function calculateWaypoints"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1YieldAction/#function-calculatetargetspeed","text":"boost :: optional < double > calculateTargetSpeed ()","title":"function calculateTargetSpeed"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1YieldAction/#function-calculateobstacle","text":"virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override Reimplements : entity_behavior::VehicleActionNode::calculateObstacle","title":"function calculateObstacle"},{"location":"package/simulation_api/markdown/Classes/classentity__behavior_1_1vehicle_1_1follow__lane__sequence_1_1YieldAction/#function-yieldaction","text":"YieldAction ( const std :: string & name , const BT :: NodeConfiguration & config ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function YieldAction"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapError/","text":"hdmap_utils::HdMapError # Inherits from runtime_error Public Functions # Name HdMapError (const char * message) Public Functions Documentation # function HdMapError # inline explicit HdMapError ( const char * message ) Updated on 7 April 2021 at 00:31:54 UTC","title":"hdmap_utils::HdMapError"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapError/#hdmap_utilshdmaperror","text":"Inherits from runtime_error","title":"hdmap_utils::HdMapError"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapError/#public-functions","text":"Name HdMapError (const char * message)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapError/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapError/#function-hdmaperror","text":"inline explicit HdMapError ( const char * message ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function HdMapError"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/","text":"hdmap_utils::HdMapUtils # Public Functions # Name geometry_msgs::msg::PoseStamped toMapPose (std::int64_t lanelet_id, double s, double offset, geometry_msgs::msg::Quaternion quat) geometry_msgs::msg::PoseStamped toMapPose (openscenario_msgs::msg::LaneletPose lanlet_pose) geometry_msgs::msg::PoseStamped toMapPose (std::int64_t lanelet_id, double s, double offset) std::vector< geometry_msgs::msg::Point > toMapPoints (std::int64_t lanelet_id, std::vector< double > s) const autoware_auto_msgs::msg::HADMapBin toMapBin () boost::optional< openscenario_msgs::msg::LaneletPose > toLaneletPose (geometry_msgs::msg::Pose pose) bool isInRoute (std::int64_t lanelet_id, std::vector< std::int64_t > route) const bool isInLanelet (std::int64_t lanelet_id, double s) void insertMarkerArray (visualization_msgs::msg::MarkerArray & a1, const visualization_msgs::msg::MarkerArray & a2) const const std::vector< geometry_msgs::msg::Point > getTrafficLightStopLinePoints (std::int64_t traffic_light_id) const const boost::optional< std::int64_t > getTrafficLightStopLineId (const std::int64_t & traffic_light_id) const const std::vector< std::int64_t > getTrafficLightIdsOnPath (const std::vector< std::int64_t > & route_lanelets) const const std::vector< std::int64_t > getTrafficLightIds () const const boost::optional< geometry_msgs::msg::Point > getTrafficLightBulbPosition (std::int64_t traffic_light_id, simulation_api::TrafficLightColor color) const boost::optional< geometry_msgs::msg::Vector3 > getTangentVector (std::int64_t lanelet_id, double s) const std::vector< geometry_msgs::msg::Point > getStopLinePolygon (std::int64_t lanelet_id) double getSpeedLimit (std::vector< std::int64_t > lanelet_ids) std::vector< std::int64_t > getRoute (std::int64_t from_lanelet_id, std::int64_t to_lanelet_id) const std::vector< std::int64_t > getRightOfWayLaneletIds (std::int64_t lanelet_id) const const std::unordered_map< std::int64_t, std::vector< std::int64_t > > getRightOfWayLaneletIds (std::vector< std::int64_t > lanelet_ids) const std::vector< std::int64_t > getPreviousLanelets (std::int64_t lanelet_id, double distance =100) std::vector< std::int64_t > getPreviousLaneletIds (std::int64_t lanelet_id, std::string turn_direction) std::vector< std::int64_t > getPreviousLaneletIds (std::int64_t lanelet_id) const std::vector< std::int64_t > getNextLaneletIds (std::int64_t lanelet_id, std::string turn_direction) std::vector< std::int64_t > getNextLaneletIds (std::int64_t lanelet_id) const boost::optional< double > getLongitudinalDistance (openscenario_msgs::msg::LaneletPose from, openscenario_msgs::msg::LaneletPose to) boost::optional< double > getLongitudinalDistance (std::int64_t from_lanelet_id, double from_s, std::int64_t to_lanelet_id, double to_s) const std::vector< geometry_msgs::msg::Point > getLaneletPolygon (std::int64_t lanelet_id) double getLaneletLength (std::int64_t lanelet_id) const const std::vector< std::int64_t > getLaneletIds () boost::optional< int > getLaneChangeableLenletId (std::int64_t lanelet_id, std::string direction) boost::optional< std::pair< simulation_api::math::HermiteCurve , double > > getLaneChangeTrajectory (geometry_msgs::msg::Pose from_pose, std::int64_t to_lanelet_id) boost::optional< simulation_api::math::HermiteCurve > getLaneChangeTrajectory (geometry_msgs::msg::Pose from_pose, std::int64_t to_lanelet_id, double to_s, double tangent_vector_size =100) double getHeight (const openscenario_msgs::msg::LaneletPose & lanelet_pose) std::vector< std::int64_t > getFollowingLanelets (std::int64_t lanelet_id, double distance =100, bool include_self =true) std::vector< std::int64_t > getFollowingLanelets (std::int64_t lanelet_id, std::vector< std::int64_t > candidate_lanelet_ids, double distance =100, bool include_self =true) const boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< geometry_msgs::msg::Point > & waypoints, const std::int64_t & traffic_light_id) const const boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) const boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) std::vector< std::int64_t > getConflictingCrosswalkIds (std::vector< std::int64_t > lanelet_ids) const boost::optional< double > getCollisionPointInLaneCoordinate (std::int64_t lanelet_id, std::int64_t crossing_lanelet_id) boost::optional< std::int64_t > getClosetLanletId (geometry_msgs::msg::Pose pose, double distance_thresh =30.0) std::vector< geometry_msgs::msg::Point > getCenterPoints (std::int64_t lanelet_id) std::vector< geometry_msgs::msg::Point > getCenterPoints (std::vector< std::int64_t > lanelet_ids) const visualization_msgs::msg::MarkerArray generateMarker () const std::vector< geometry_msgs::msg::Point > clipTrajectoryFromLaneletIds (std::int64_t lanelet_id, double s, std::vector< std::int64_t > lanelet_ids, double foward_distance =20) bool canChangeLane (std::int64_t from_lanelet_id, std::int64_t to_lanelet_id) HdMapUtils (std::string lanelet_path, geographic_msgs::msg::GeoPoint origin) Public Functions Documentation # function toMapPose # geometry_msgs :: msg :: PoseStamped toMapPose ( std :: int64_t lanelet_id , double s , double offset , geometry_msgs :: msg :: Quaternion quat ) function toMapPose # geometry_msgs :: msg :: PoseStamped toMapPose ( openscenario_msgs :: msg :: LaneletPose lanlet_pose ) function toMapPose # geometry_msgs :: msg :: PoseStamped toMapPose ( std :: int64_t lanelet_id , double s , double offset ) function toMapPoints # std :: vector < geometry_msgs :: msg :: Point > toMapPoints ( std :: int64_t lanelet_id , std :: vector < double > s ) function toMapBin # const autoware_auto_msgs :: msg :: HADMapBin toMapBin () function toLaneletPose # boost :: optional < openscenario_msgs :: msg :: LaneletPose > toLaneletPose ( geometry_msgs :: msg :: Pose pose ) function isInRoute # bool isInRoute ( std :: int64_t lanelet_id , std :: vector < std :: int64_t > route ) const function isInLanelet # bool isInLanelet ( std :: int64_t lanelet_id , double s ) function insertMarkerArray # void insertMarkerArray ( visualization_msgs :: msg :: MarkerArray & a1 , const visualization_msgs :: msg :: MarkerArray & a2 ) const function getTrafficLightStopLinePoints # const std :: vector < geometry_msgs :: msg :: Point > getTrafficLightStopLinePoints ( std :: int64_t traffic_light_id ) const function getTrafficLightStopLineId # const boost :: optional < std :: int64_t > getTrafficLightStopLineId ( const std :: int64_t & traffic_light_id ) const function getTrafficLightIdsOnPath # const std :: vector < std :: int64_t > getTrafficLightIdsOnPath ( const std :: vector < std :: int64_t > & route_lanelets ) const function getTrafficLightIds # const std :: vector < std :: int64_t > getTrafficLightIds () const function getTrafficLightBulbPosition # const boost :: optional < geometry_msgs :: msg :: Point > getTrafficLightBulbPosition ( std :: int64_t traffic_light_id , simulation_api :: TrafficLightColor color ) const function getTangentVector # boost :: optional < geometry_msgs :: msg :: Vector3 > getTangentVector ( std :: int64_t lanelet_id , double s ) function getStopLinePolygon # const std :: vector < geometry_msgs :: msg :: Point > getStopLinePolygon ( std :: int64_t lanelet_id ) function getSpeedLimit # double getSpeedLimit ( std :: vector < std :: int64_t > lanelet_ids ) function getRoute # std :: vector < std :: int64_t > getRoute ( std :: int64_t from_lanelet_id , std :: int64_t to_lanelet_id ) function getRightOfWayLaneletIds # const std :: vector < std :: int64_t > getRightOfWayLaneletIds ( std :: int64_t lanelet_id ) const function getRightOfWayLaneletIds # const std :: unordered_map < std :: int64_t , std :: vector < std :: int64_t > > getRightOfWayLaneletIds ( std :: vector < std :: int64_t > lanelet_ids ) const function getPreviousLanelets # std :: vector < std :: int64_t > getPreviousLanelets ( std :: int64_t lanelet_id , double distance = 100 ) function getPreviousLaneletIds # std :: vector < std :: int64_t > getPreviousLaneletIds ( std :: int64_t lanelet_id , std :: string turn_direction ) function getPreviousLaneletIds # std :: vector < std :: int64_t > getPreviousLaneletIds ( std :: int64_t lanelet_id ) const function getNextLaneletIds # std :: vector < std :: int64_t > getNextLaneletIds ( std :: int64_t lanelet_id , std :: string turn_direction ) function getNextLaneletIds # std :: vector < std :: int64_t > getNextLaneletIds ( std :: int64_t lanelet_id ) const function getLongitudinalDistance # boost :: optional < double > getLongitudinalDistance ( openscenario_msgs :: msg :: LaneletPose from , openscenario_msgs :: msg :: LaneletPose to ) function getLongitudinalDistance # boost :: optional < double > getLongitudinalDistance ( std :: int64_t from_lanelet_id , double from_s , std :: int64_t to_lanelet_id , double to_s ) function getLaneletPolygon # const std :: vector < geometry_msgs :: msg :: Point > getLaneletPolygon ( std :: int64_t lanelet_id ) function getLaneletLength # double getLaneletLength ( std :: int64_t lanelet_id ) const function getLaneletIds # const std :: vector < std :: int64_t > getLaneletIds () function getLaneChangeableLenletId # boost :: optional < int > getLaneChangeableLenletId ( std :: int64_t lanelet_id , std :: string direction ) function getLaneChangeTrajectory # boost :: optional < std :: pair < simulation_api :: math :: HermiteCurve , double > > getLaneChangeTrajectory ( geometry_msgs :: msg :: Pose from_pose , std :: int64_t to_lanelet_id ) function getLaneChangeTrajectory # boost :: optional < simulation_api :: math :: HermiteCurve > getLaneChangeTrajectory ( geometry_msgs :: msg :: Pose from_pose , std :: int64_t to_lanelet_id , double to_s , double tangent_vector_size = 100 ) function getHeight # double getHeight ( const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ) function getFollowingLanelets # std :: vector < std :: int64_t > getFollowingLanelets ( std :: int64_t lanelet_id , double distance = 100 , bool include_self = true ) function getFollowingLanelets # std :: vector < std :: int64_t > getFollowingLanelets ( std :: int64_t lanelet_id , std :: vector < std :: int64_t > candidate_lanelet_ids , double distance = 100 , bool include_self = true ) function getDistanceToTrafficLightStopLine # const boost :: optional < double > getDistanceToTrafficLightStopLine ( const std :: vector < geometry_msgs :: msg :: Point > & waypoints , const std :: int64_t & traffic_light_id ) const function getDistanceToTrafficLightStopLine # const boost :: optional < double > getDistanceToTrafficLightStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ) const function getDistanceToStopLine # boost :: optional < double > getDistanceToStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ) function getConflictingCrosswalkIds # std :: vector < std :: int64_t > getConflictingCrosswalkIds ( std :: vector < std :: int64_t > lanelet_ids ) const function getCollisionPointInLaneCoordinate # boost :: optional < double > getCollisionPointInLaneCoordinate ( std :: int64_t lanelet_id , std :: int64_t crossing_lanelet_id ) function getClosetLanletId # boost :: optional < std :: int64_t > getClosetLanletId ( geometry_msgs :: msg :: Pose pose , double distance_thresh = 30.0 ) function getCenterPoints # std :: vector < geometry_msgs :: msg :: Point > getCenterPoints ( std :: int64_t lanelet_id ) function getCenterPoints # std :: vector < geometry_msgs :: msg :: Point > getCenterPoints ( std :: vector < std :: int64_t > lanelet_ids ) function generateMarker # const visualization_msgs :: msg :: MarkerArray generateMarker () const function clipTrajectoryFromLaneletIds # std :: vector < geometry_msgs :: msg :: Point > clipTrajectoryFromLaneletIds ( std :: int64_t lanelet_id , double s , std :: vector < std :: int64_t > lanelet_ids , double foward_distance = 20 ) function canChangeLane # bool canChangeLane ( std :: int64_t from_lanelet_id , std :: int64_t to_lanelet_id ) function HdMapUtils # explicit HdMapUtils ( std :: string lanelet_path , geographic_msgs :: msg :: GeoPoint origin ) Updated on 7 April 2021 at 00:31:54 UTC","title":"hdmap_utils::HdMapUtils"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#hdmap_utilshdmaputils","text":"","title":"hdmap_utils::HdMapUtils"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#public-functions","text":"Name geometry_msgs::msg::PoseStamped toMapPose (std::int64_t lanelet_id, double s, double offset, geometry_msgs::msg::Quaternion quat) geometry_msgs::msg::PoseStamped toMapPose (openscenario_msgs::msg::LaneletPose lanlet_pose) geometry_msgs::msg::PoseStamped toMapPose (std::int64_t lanelet_id, double s, double offset) std::vector< geometry_msgs::msg::Point > toMapPoints (std::int64_t lanelet_id, std::vector< double > s) const autoware_auto_msgs::msg::HADMapBin toMapBin () boost::optional< openscenario_msgs::msg::LaneletPose > toLaneletPose (geometry_msgs::msg::Pose pose) bool isInRoute (std::int64_t lanelet_id, std::vector< std::int64_t > route) const bool isInLanelet (std::int64_t lanelet_id, double s) void insertMarkerArray (visualization_msgs::msg::MarkerArray & a1, const visualization_msgs::msg::MarkerArray & a2) const const std::vector< geometry_msgs::msg::Point > getTrafficLightStopLinePoints (std::int64_t traffic_light_id) const const boost::optional< std::int64_t > getTrafficLightStopLineId (const std::int64_t & traffic_light_id) const const std::vector< std::int64_t > getTrafficLightIdsOnPath (const std::vector< std::int64_t > & route_lanelets) const const std::vector< std::int64_t > getTrafficLightIds () const const boost::optional< geometry_msgs::msg::Point > getTrafficLightBulbPosition (std::int64_t traffic_light_id, simulation_api::TrafficLightColor color) const boost::optional< geometry_msgs::msg::Vector3 > getTangentVector (std::int64_t lanelet_id, double s) const std::vector< geometry_msgs::msg::Point > getStopLinePolygon (std::int64_t lanelet_id) double getSpeedLimit (std::vector< std::int64_t > lanelet_ids) std::vector< std::int64_t > getRoute (std::int64_t from_lanelet_id, std::int64_t to_lanelet_id) const std::vector< std::int64_t > getRightOfWayLaneletIds (std::int64_t lanelet_id) const const std::unordered_map< std::int64_t, std::vector< std::int64_t > > getRightOfWayLaneletIds (std::vector< std::int64_t > lanelet_ids) const std::vector< std::int64_t > getPreviousLanelets (std::int64_t lanelet_id, double distance =100) std::vector< std::int64_t > getPreviousLaneletIds (std::int64_t lanelet_id, std::string turn_direction) std::vector< std::int64_t > getPreviousLaneletIds (std::int64_t lanelet_id) const std::vector< std::int64_t > getNextLaneletIds (std::int64_t lanelet_id, std::string turn_direction) std::vector< std::int64_t > getNextLaneletIds (std::int64_t lanelet_id) const boost::optional< double > getLongitudinalDistance (openscenario_msgs::msg::LaneletPose from, openscenario_msgs::msg::LaneletPose to) boost::optional< double > getLongitudinalDistance (std::int64_t from_lanelet_id, double from_s, std::int64_t to_lanelet_id, double to_s) const std::vector< geometry_msgs::msg::Point > getLaneletPolygon (std::int64_t lanelet_id) double getLaneletLength (std::int64_t lanelet_id) const const std::vector< std::int64_t > getLaneletIds () boost::optional< int > getLaneChangeableLenletId (std::int64_t lanelet_id, std::string direction) boost::optional< std::pair< simulation_api::math::HermiteCurve , double > > getLaneChangeTrajectory (geometry_msgs::msg::Pose from_pose, std::int64_t to_lanelet_id) boost::optional< simulation_api::math::HermiteCurve > getLaneChangeTrajectory (geometry_msgs::msg::Pose from_pose, std::int64_t to_lanelet_id, double to_s, double tangent_vector_size =100) double getHeight (const openscenario_msgs::msg::LaneletPose & lanelet_pose) std::vector< std::int64_t > getFollowingLanelets (std::int64_t lanelet_id, double distance =100, bool include_self =true) std::vector< std::int64_t > getFollowingLanelets (std::int64_t lanelet_id, std::vector< std::int64_t > candidate_lanelet_ids, double distance =100, bool include_self =true) const boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< geometry_msgs::msg::Point > & waypoints, const std::int64_t & traffic_light_id) const const boost::optional< double > getDistanceToTrafficLightStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) const boost::optional< double > getDistanceToStopLine (const std::vector< std::int64_t > & route_lanelets, const std::vector< geometry_msgs::msg::Point > & waypoints) std::vector< std::int64_t > getConflictingCrosswalkIds (std::vector< std::int64_t > lanelet_ids) const boost::optional< double > getCollisionPointInLaneCoordinate (std::int64_t lanelet_id, std::int64_t crossing_lanelet_id) boost::optional< std::int64_t > getClosetLanletId (geometry_msgs::msg::Pose pose, double distance_thresh =30.0) std::vector< geometry_msgs::msg::Point > getCenterPoints (std::int64_t lanelet_id) std::vector< geometry_msgs::msg::Point > getCenterPoints (std::vector< std::int64_t > lanelet_ids) const visualization_msgs::msg::MarkerArray generateMarker () const std::vector< geometry_msgs::msg::Point > clipTrajectoryFromLaneletIds (std::int64_t lanelet_id, double s, std::vector< std::int64_t > lanelet_ids, double foward_distance =20) bool canChangeLane (std::int64_t from_lanelet_id, std::int64_t to_lanelet_id) HdMapUtils (std::string lanelet_path, geographic_msgs::msg::GeoPoint origin)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-tomappose","text":"geometry_msgs :: msg :: PoseStamped toMapPose ( std :: int64_t lanelet_id , double s , double offset , geometry_msgs :: msg :: Quaternion quat )","title":"function toMapPose"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-tomappose_1","text":"geometry_msgs :: msg :: PoseStamped toMapPose ( openscenario_msgs :: msg :: LaneletPose lanlet_pose )","title":"function toMapPose"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-tomappose_2","text":"geometry_msgs :: msg :: PoseStamped toMapPose ( std :: int64_t lanelet_id , double s , double offset )","title":"function toMapPose"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-tomappoints","text":"std :: vector < geometry_msgs :: msg :: Point > toMapPoints ( std :: int64_t lanelet_id , std :: vector < double > s )","title":"function toMapPoints"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-tomapbin","text":"const autoware_auto_msgs :: msg :: HADMapBin toMapBin ()","title":"function toMapBin"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-tolaneletpose","text":"boost :: optional < openscenario_msgs :: msg :: LaneletPose > toLaneletPose ( geometry_msgs :: msg :: Pose pose )","title":"function toLaneletPose"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-isinroute","text":"bool isInRoute ( std :: int64_t lanelet_id , std :: vector < std :: int64_t > route ) const","title":"function isInRoute"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-isinlanelet","text":"bool isInLanelet ( std :: int64_t lanelet_id , double s )","title":"function isInLanelet"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-insertmarkerarray","text":"void insertMarkerArray ( visualization_msgs :: msg :: MarkerArray & a1 , const visualization_msgs :: msg :: MarkerArray & a2 ) const","title":"function insertMarkerArray"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-gettrafficlightstoplinepoints","text":"const std :: vector < geometry_msgs :: msg :: Point > getTrafficLightStopLinePoints ( std :: int64_t traffic_light_id ) const","title":"function getTrafficLightStopLinePoints"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-gettrafficlightstoplineid","text":"const boost :: optional < std :: int64_t > getTrafficLightStopLineId ( const std :: int64_t & traffic_light_id ) const","title":"function getTrafficLightStopLineId"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-gettrafficlightidsonpath","text":"const std :: vector < std :: int64_t > getTrafficLightIdsOnPath ( const std :: vector < std :: int64_t > & route_lanelets ) const","title":"function getTrafficLightIdsOnPath"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-gettrafficlightids","text":"const std :: vector < std :: int64_t > getTrafficLightIds () const","title":"function getTrafficLightIds"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-gettrafficlightbulbposition","text":"const boost :: optional < geometry_msgs :: msg :: Point > getTrafficLightBulbPosition ( std :: int64_t traffic_light_id , simulation_api :: TrafficLightColor color ) const","title":"function getTrafficLightBulbPosition"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-gettangentvector","text":"boost :: optional < geometry_msgs :: msg :: Vector3 > getTangentVector ( std :: int64_t lanelet_id , double s )","title":"function getTangentVector"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getstoplinepolygon","text":"const std :: vector < geometry_msgs :: msg :: Point > getStopLinePolygon ( std :: int64_t lanelet_id )","title":"function getStopLinePolygon"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getspeedlimit","text":"double getSpeedLimit ( std :: vector < std :: int64_t > lanelet_ids )","title":"function getSpeedLimit"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getroute","text":"std :: vector < std :: int64_t > getRoute ( std :: int64_t from_lanelet_id , std :: int64_t to_lanelet_id )","title":"function getRoute"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getrightofwaylaneletids","text":"const std :: vector < std :: int64_t > getRightOfWayLaneletIds ( std :: int64_t lanelet_id ) const","title":"function getRightOfWayLaneletIds"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getrightofwaylaneletids_1","text":"const std :: unordered_map < std :: int64_t , std :: vector < std :: int64_t > > getRightOfWayLaneletIds ( std :: vector < std :: int64_t > lanelet_ids ) const","title":"function getRightOfWayLaneletIds"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getpreviouslanelets","text":"std :: vector < std :: int64_t > getPreviousLanelets ( std :: int64_t lanelet_id , double distance = 100 )","title":"function getPreviousLanelets"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getpreviouslaneletids","text":"std :: vector < std :: int64_t > getPreviousLaneletIds ( std :: int64_t lanelet_id , std :: string turn_direction )","title":"function getPreviousLaneletIds"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getpreviouslaneletids_1","text":"std :: vector < std :: int64_t > getPreviousLaneletIds ( std :: int64_t lanelet_id ) const","title":"function getPreviousLaneletIds"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getnextlaneletids","text":"std :: vector < std :: int64_t > getNextLaneletIds ( std :: int64_t lanelet_id , std :: string turn_direction )","title":"function getNextLaneletIds"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getnextlaneletids_1","text":"std :: vector < std :: int64_t > getNextLaneletIds ( std :: int64_t lanelet_id ) const","title":"function getNextLaneletIds"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getlongitudinaldistance","text":"boost :: optional < double > getLongitudinalDistance ( openscenario_msgs :: msg :: LaneletPose from , openscenario_msgs :: msg :: LaneletPose to )","title":"function getLongitudinalDistance"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getlongitudinaldistance_1","text":"boost :: optional < double > getLongitudinalDistance ( std :: int64_t from_lanelet_id , double from_s , std :: int64_t to_lanelet_id , double to_s )","title":"function getLongitudinalDistance"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getlaneletpolygon","text":"const std :: vector < geometry_msgs :: msg :: Point > getLaneletPolygon ( std :: int64_t lanelet_id )","title":"function getLaneletPolygon"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getlaneletlength","text":"double getLaneletLength ( std :: int64_t lanelet_id ) const","title":"function getLaneletLength"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getlaneletids","text":"const std :: vector < std :: int64_t > getLaneletIds ()","title":"function getLaneletIds"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getlanechangeablelenletid","text":"boost :: optional < int > getLaneChangeableLenletId ( std :: int64_t lanelet_id , std :: string direction )","title":"function getLaneChangeableLenletId"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getlanechangetrajectory","text":"boost :: optional < std :: pair < simulation_api :: math :: HermiteCurve , double > > getLaneChangeTrajectory ( geometry_msgs :: msg :: Pose from_pose , std :: int64_t to_lanelet_id )","title":"function getLaneChangeTrajectory"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getlanechangetrajectory_1","text":"boost :: optional < simulation_api :: math :: HermiteCurve > getLaneChangeTrajectory ( geometry_msgs :: msg :: Pose from_pose , std :: int64_t to_lanelet_id , double to_s , double tangent_vector_size = 100 )","title":"function getLaneChangeTrajectory"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getheight","text":"double getHeight ( const openscenario_msgs :: msg :: LaneletPose & lanelet_pose )","title":"function getHeight"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getfollowinglanelets","text":"std :: vector < std :: int64_t > getFollowingLanelets ( std :: int64_t lanelet_id , double distance = 100 , bool include_self = true )","title":"function getFollowingLanelets"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getfollowinglanelets_1","text":"std :: vector < std :: int64_t > getFollowingLanelets ( std :: int64_t lanelet_id , std :: vector < std :: int64_t > candidate_lanelet_ids , double distance = 100 , bool include_self = true )","title":"function getFollowingLanelets"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getdistancetotrafficlightstopline","text":"const boost :: optional < double > getDistanceToTrafficLightStopLine ( const std :: vector < geometry_msgs :: msg :: Point > & waypoints , const std :: int64_t & traffic_light_id ) const","title":"function getDistanceToTrafficLightStopLine"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getdistancetotrafficlightstopline_1","text":"const boost :: optional < double > getDistanceToTrafficLightStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ) const","title":"function getDistanceToTrafficLightStopLine"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getdistancetostopline","text":"boost :: optional < double > getDistanceToStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints )","title":"function getDistanceToStopLine"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getconflictingcrosswalkids","text":"std :: vector < std :: int64_t > getConflictingCrosswalkIds ( std :: vector < std :: int64_t > lanelet_ids ) const","title":"function getConflictingCrosswalkIds"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getcollisionpointinlanecoordinate","text":"boost :: optional < double > getCollisionPointInLaneCoordinate ( std :: int64_t lanelet_id , std :: int64_t crossing_lanelet_id )","title":"function getCollisionPointInLaneCoordinate"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getclosetlanletid","text":"boost :: optional < std :: int64_t > getClosetLanletId ( geometry_msgs :: msg :: Pose pose , double distance_thresh = 30.0 )","title":"function getClosetLanletId"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getcenterpoints","text":"std :: vector < geometry_msgs :: msg :: Point > getCenterPoints ( std :: int64_t lanelet_id )","title":"function getCenterPoints"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-getcenterpoints_1","text":"std :: vector < geometry_msgs :: msg :: Point > getCenterPoints ( std :: vector < std :: int64_t > lanelet_ids )","title":"function getCenterPoints"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-generatemarker","text":"const visualization_msgs :: msg :: MarkerArray generateMarker () const","title":"function generateMarker"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-cliptrajectoryfromlaneletids","text":"std :: vector < geometry_msgs :: msg :: Point > clipTrajectoryFromLaneletIds ( std :: int64_t lanelet_id , double s , std :: vector < std :: int64_t > lanelet_ids , double foward_distance = 20 )","title":"function clipTrajectoryFromLaneletIds"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-canchangelane","text":"bool canChangeLane ( std :: int64_t from_lanelet_id , std :: int64_t to_lanelet_id )","title":"function canChangeLane"},{"location":"package/simulation_api/markdown/Classes/classhdmap__utils_1_1HdMapUtils/#function-hdmaputils","text":"explicit HdMapUtils ( std :: string lanelet_path , geographic_msgs :: msg :: GeoPoint origin ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function HdMapUtils"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/","text":"metrics::MetricBase # Inherited by metrics::MomentaryStopMetric , metrics::ReactionTimeMetric , metrics::TraveledDistanceMetric Public Functions # Name virtual ~MetricBase () virtual void update () =0 virtual nlohmann::json to_json () =0 nlohmann::json to_base_json () void throwException () void success () void setEntityManager (std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr) MetricLifecycle getLifecycle () void failure ( SpecificationViolationError error) virtual bool activateTrigger () =0 void activate () MetricBase (std::string metrics_type) Public Attributes # Name const std::string metrics_type Protected Attributes # Name std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr_ Public Functions Documentation # function ~MetricBase # virtual ~ MetricBase () function update # virtual void update () = 0 Reimplemented by : metrics::TraveledDistanceMetric::update , metrics::ReactionTimeMetric::update , metrics::MomentaryStopMetric::update function to_json # virtual nlohmann :: json to_json () = 0 Reimplemented by : metrics::TraveledDistanceMetric::to_json , metrics::ReactionTimeMetric::to_json , metrics::MomentaryStopMetric::to_json function to_base_json # nlohmann :: json to_base_json () function throwException # void throwException () function success # void success () function setEntityManager # void setEntityManager ( std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr ) function getLifecycle # inline MetricLifecycle getLifecycle () function failure # void failure ( SpecificationViolationError error ) function activateTrigger # virtual bool activateTrigger () = 0 Reimplemented by : metrics::TraveledDistanceMetric::activateTrigger , metrics::ReactionTimeMetric::activateTrigger , metrics::MomentaryStopMetric::activateTrigger function activate # void activate () function MetricBase # explicit MetricBase ( std :: string metrics_type ) Public Attributes Documentation # variable metrics_type # const std :: string metrics_type ; Protected Attributes Documentation # variable entity_manager_ptr_ # std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr_ ; Updated on 7 April 2021 at 00:31:54 UTC","title":"metrics::MetricBase"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#metricsmetricbase","text":"Inherited by metrics::MomentaryStopMetric , metrics::ReactionTimeMetric , metrics::TraveledDistanceMetric","title":"metrics::MetricBase"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#public-functions","text":"Name virtual ~MetricBase () virtual void update () =0 virtual nlohmann::json to_json () =0 nlohmann::json to_base_json () void throwException () void success () void setEntityManager (std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr) MetricLifecycle getLifecycle () void failure ( SpecificationViolationError error) virtual bool activateTrigger () =0 void activate () MetricBase (std::string metrics_type)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#public-attributes","text":"Name const std::string metrics_type","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#protected-attributes","text":"Name std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr_","title":"Protected Attributes"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#function-metricbase","text":"virtual ~ MetricBase ()","title":"function ~MetricBase"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#function-update","text":"virtual void update () = 0 Reimplemented by : metrics::TraveledDistanceMetric::update , metrics::ReactionTimeMetric::update , metrics::MomentaryStopMetric::update","title":"function update"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#function-to_json","text":"virtual nlohmann :: json to_json () = 0 Reimplemented by : metrics::TraveledDistanceMetric::to_json , metrics::ReactionTimeMetric::to_json , metrics::MomentaryStopMetric::to_json","title":"function to_json"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#function-to_base_json","text":"nlohmann :: json to_base_json ()","title":"function to_base_json"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#function-throwexception","text":"void throwException ()","title":"function throwException"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#function-success","text":"void success ()","title":"function success"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#function-setentitymanager","text":"void setEntityManager ( std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr )","title":"function setEntityManager"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#function-getlifecycle","text":"inline MetricLifecycle getLifecycle ()","title":"function getLifecycle"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#function-failure","text":"void failure ( SpecificationViolationError error )","title":"function failure"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#function-activatetrigger","text":"virtual bool activateTrigger () = 0 Reimplemented by : metrics::TraveledDistanceMetric::activateTrigger , metrics::ReactionTimeMetric::activateTrigger , metrics::MomentaryStopMetric::activateTrigger","title":"function activateTrigger"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#function-activate","text":"void activate ()","title":"function activate"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#function-metricbase_1","text":"explicit MetricBase ( std :: string metrics_type )","title":"function MetricBase"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#variable-metrics_type","text":"const std :: string metrics_type ;","title":"variable metrics_type"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricBase/#variable-entity_manager_ptr_","text":"std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr_ ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable entity_manager_ptr_"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsCalculationError/","text":"metrics::MetricsCalculationError # Inherits from runtime_error Public Functions # Name MetricsCalculationError (const char * message) MetricsCalculationError (std::string message) MetricsCalculationError (std::string message, const char * file, int line) Public Functions Documentation # function MetricsCalculationError # inline explicit MetricsCalculationError ( const char * message ) function MetricsCalculationError # inline explicit MetricsCalculationError ( std :: string message ) function MetricsCalculationError # inline explicit MetricsCalculationError ( std :: string message , const char * file , int line ) Updated on 7 April 2021 at 00:31:54 UTC","title":"metrics::MetricsCalculationError"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsCalculationError/#metricsmetricscalculationerror","text":"Inherits from runtime_error","title":"metrics::MetricsCalculationError"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsCalculationError/#public-functions","text":"Name MetricsCalculationError (const char * message) MetricsCalculationError (std::string message) MetricsCalculationError (std::string message, const char * file, int line)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsCalculationError/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsCalculationError/#function-metricscalculationerror","text":"inline explicit MetricsCalculationError ( const char * message )","title":"function MetricsCalculationError"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsCalculationError/#function-metricscalculationerror_1","text":"inline explicit MetricsCalculationError ( std :: string message )","title":"function MetricsCalculationError"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsCalculationError/#function-metricscalculationerror_2","text":"inline explicit MetricsCalculationError ( std :: string message , const char * file , int line ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function MetricsCalculationError"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsManager/","text":"metrics::MetricsManager # Public Functions # Name ~MetricsManager () void setVerbose (bool verbose) void setEntityManager (std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr) void calculate () template \\<typename T ,typename ... Ts> void addMetric (std::string name, Ts &&... xs) MetricsManager (bool verbose, const std::string & logfile_path) Public Attributes # Name const std::string logfile_path Public Functions Documentation # function ~MetricsManager # inline ~ MetricsManager () function setVerbose # void setVerbose ( bool verbose ) function setEntityManager # void setEntityManager ( std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr ) function calculate # void calculate () function addMetric # template < typename T , typename ... Ts > inline void addMetric ( std :: string name , Ts && ... xs ) function MetricsManager # explicit MetricsManager ( bool verbose , const std :: string & logfile_path ) Public Attributes Documentation # variable logfile_path # const std :: string logfile_path ; Updated on 7 April 2021 at 00:31:54 UTC","title":"metrics::MetricsManager"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsManager/#metricsmetricsmanager","text":"","title":"metrics::MetricsManager"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsManager/#public-functions","text":"Name ~MetricsManager () void setVerbose (bool verbose) void setEntityManager (std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr) void calculate () template \\<typename T ,typename ... Ts> void addMetric (std::string name, Ts &&... xs) MetricsManager (bool verbose, const std::string & logfile_path)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsManager/#public-attributes","text":"Name const std::string logfile_path","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsManager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsManager/#function-metricsmanager","text":"inline ~ MetricsManager ()","title":"function ~MetricsManager"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsManager/#function-setverbose","text":"void setVerbose ( bool verbose )","title":"function setVerbose"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsManager/#function-setentitymanager","text":"void setEntityManager ( std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr )","title":"function setEntityManager"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsManager/#function-calculate","text":"void calculate ()","title":"function calculate"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsManager/#function-addmetric","text":"template < typename T , typename ... Ts > inline void addMetric ( std :: string name , Ts && ... xs )","title":"function addMetric"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsManager/#function-metricsmanager_1","text":"explicit MetricsManager ( bool verbose , const std :: string & logfile_path )","title":"function MetricsManager"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsManager/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MetricsManager/#variable-logfile_path","text":"const std :: string logfile_path ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable logfile_path"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/","text":"metrics::MomentaryStopMetric # Inherits from metrics::MetricBase Public Types # Name enum StopTargetLaneletType { STOP_LINE, CROSSWALK } Public Functions # Name ~MomentaryStopMetric () override =default virtual void update () override virtual nlohmann::json to_json () virtual bool activateTrigger () override MomentaryStopMetric (std::string target_entity, double min_acceleration, double max_acceleration, std::int64_t stop_target_lanelet_id, StopTargetLaneletType stop_target_lanelet_type, double stop_sequence_start_distance, double stop_sequence_end_distance, double stop_duration) Public Attributes # Name const std::string target_entity const StopTargetLaneletType stop_target_lanelet_type const std::int64_t stop_target_lanelet_id const double stop_sequence_start_distance const double stop_sequence_end_distance const double stop_duration const double min_acceleration const double max_acceleration Additional inherited members # Public Functions inherited from metrics::MetricBase Name virtual ~MetricBase () nlohmann::json to_base_json () void throwException () void success () void setEntityManager (std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr) MetricLifecycle getLifecycle () void failure ( SpecificationViolationError error) void activate () MetricBase (std::string metrics_type) Public Attributes inherited from metrics::MetricBase Name const std::string metrics_type Protected Attributes inherited from metrics::MetricBase Name std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr_ Public Types Documentation # enum StopTargetLaneletType # Enumerator Value Description STOP_LINE CROSSWALK Public Functions Documentation # function ~MomentaryStopMetric # ~ MomentaryStopMetric () override = default function update # virtual void update () override Reimplements : metrics::MetricBase::update function to_json # virtual nlohmann :: json to_json () Reimplements : metrics::MetricBase::to_json function activateTrigger # virtual bool activateTrigger () override Reimplements : metrics::MetricBase::activateTrigger function MomentaryStopMetric # inline MomentaryStopMetric ( std :: string target_entity , double min_acceleration , double max_acceleration , std :: int64_t stop_target_lanelet_id , StopTargetLaneletType stop_target_lanelet_type , double stop_sequence_start_distance , double stop_sequence_end_distance , double stop_duration ) Public Attributes Documentation # variable target_entity # const std :: string target_entity ; variable stop_target_lanelet_type # const StopTargetLaneletType stop_target_lanelet_type ; variable stop_target_lanelet_id # const std :: int64_t stop_target_lanelet_id ; variable stop_sequence_start_distance # const double stop_sequence_start_distance ; variable stop_sequence_end_distance # const double stop_sequence_end_distance ; variable stop_duration # const double stop_duration ; variable min_acceleration # const double min_acceleration ; variable max_acceleration # const double max_acceleration ; Updated on 7 April 2021 at 00:31:54 UTC","title":"metrics::MomentaryStopMetric"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#metricsmomentarystopmetric","text":"Inherits from metrics::MetricBase","title":"metrics::MomentaryStopMetric"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#public-types","text":"Name enum StopTargetLaneletType { STOP_LINE, CROSSWALK }","title":"Public Types"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#public-functions","text":"Name ~MomentaryStopMetric () override =default virtual void update () override virtual nlohmann::json to_json () virtual bool activateTrigger () override MomentaryStopMetric (std::string target_entity, double min_acceleration, double max_acceleration, std::int64_t stop_target_lanelet_id, StopTargetLaneletType stop_target_lanelet_type, double stop_sequence_start_distance, double stop_sequence_end_distance, double stop_duration)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#public-attributes","text":"Name const std::string target_entity const StopTargetLaneletType stop_target_lanelet_type const std::int64_t stop_target_lanelet_id const double stop_sequence_start_distance const double stop_sequence_end_distance const double stop_duration const double min_acceleration const double max_acceleration","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#additional-inherited-members","text":"Public Functions inherited from metrics::MetricBase Name virtual ~MetricBase () nlohmann::json to_base_json () void throwException () void success () void setEntityManager (std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr) MetricLifecycle getLifecycle () void failure ( SpecificationViolationError error) void activate () MetricBase (std::string metrics_type) Public Attributes inherited from metrics::MetricBase Name const std::string metrics_type Protected Attributes inherited from metrics::MetricBase Name std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr_","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#enum-stoptargetlanelettype","text":"Enumerator Value Description STOP_LINE CROSSWALK","title":"enum StopTargetLaneletType"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#function-momentarystopmetric","text":"~ MomentaryStopMetric () override = default","title":"function ~MomentaryStopMetric"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#function-update","text":"virtual void update () override Reimplements : metrics::MetricBase::update","title":"function update"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#function-to_json","text":"virtual nlohmann :: json to_json () Reimplements : metrics::MetricBase::to_json","title":"function to_json"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#function-activatetrigger","text":"virtual bool activateTrigger () override Reimplements : metrics::MetricBase::activateTrigger","title":"function activateTrigger"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#function-momentarystopmetric_1","text":"inline MomentaryStopMetric ( std :: string target_entity , double min_acceleration , double max_acceleration , std :: int64_t stop_target_lanelet_id , StopTargetLaneletType stop_target_lanelet_type , double stop_sequence_start_distance , double stop_sequence_end_distance , double stop_duration )","title":"function MomentaryStopMetric"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#variable-target_entity","text":"const std :: string target_entity ;","title":"variable target_entity"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#variable-stop_target_lanelet_type","text":"const StopTargetLaneletType stop_target_lanelet_type ;","title":"variable stop_target_lanelet_type"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#variable-stop_target_lanelet_id","text":"const std :: int64_t stop_target_lanelet_id ;","title":"variable stop_target_lanelet_id"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#variable-stop_sequence_start_distance","text":"const double stop_sequence_start_distance ;","title":"variable stop_sequence_start_distance"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#variable-stop_sequence_end_distance","text":"const double stop_sequence_end_distance ;","title":"variable stop_sequence_end_distance"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#variable-stop_duration","text":"const double stop_duration ;","title":"variable stop_duration"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#variable-min_acceleration","text":"const double min_acceleration ;","title":"variable min_acceleration"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1MomentaryStopMetric/#variable-max_acceleration","text":"const double max_acceleration ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable max_acceleration"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/","text":"metrics::ReactionTimeMetric # Inherits from metrics::MetricBase Public Functions # Name ~ReactionTimeMetric () override =default virtual void update () override virtual nlohmann::json to_json () virtual bool activateTrigger () override ReactionTimeMetric (std::string target_entity, double maximum_reaction_time, double jerk_upper_threashold, double jerk_lower_threashold, bool check_upper_threashold =true, bool check_lower_threashold =true) Public Attributes # Name const std::string target_entity const double maximum_reaction_time const double jerk_upper_threashold const double jerk_lower_threashold const bool check_upper_threashold const bool check_lower_threashold Additional inherited members # Public Functions inherited from metrics::MetricBase Name virtual ~MetricBase () nlohmann::json to_base_json () void throwException () void success () void setEntityManager (std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr) MetricLifecycle getLifecycle () void failure ( SpecificationViolationError error) void activate () MetricBase (std::string metrics_type) Public Attributes inherited from metrics::MetricBase Name const std::string metrics_type Protected Attributes inherited from metrics::MetricBase Name std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr_ Public Functions Documentation # function ~ReactionTimeMetric # ~ ReactionTimeMetric () override = default function update # virtual void update () override Reimplements : metrics::MetricBase::update function to_json # virtual nlohmann :: json to_json () Reimplements : metrics::MetricBase::to_json function activateTrigger # virtual bool activateTrigger () override Reimplements : metrics::MetricBase::activateTrigger function ReactionTimeMetric # explicit ReactionTimeMetric ( std :: string target_entity , double maximum_reaction_time , double jerk_upper_threashold , double jerk_lower_threashold , bool check_upper_threashold = true , bool check_lower_threashold = true ) Public Attributes Documentation # variable target_entity # const std :: string target_entity ; variable maximum_reaction_time # const double maximum_reaction_time ; variable jerk_upper_threashold # const double jerk_upper_threashold ; variable jerk_lower_threashold # const double jerk_lower_threashold ; variable check_upper_threashold # const bool check_upper_threashold ; variable check_lower_threashold # const bool check_lower_threashold ; Updated on 7 April 2021 at 00:31:54 UTC","title":"metrics::ReactionTimeMetric"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#metricsreactiontimemetric","text":"Inherits from metrics::MetricBase","title":"metrics::ReactionTimeMetric"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#public-functions","text":"Name ~ReactionTimeMetric () override =default virtual void update () override virtual nlohmann::json to_json () virtual bool activateTrigger () override ReactionTimeMetric (std::string target_entity, double maximum_reaction_time, double jerk_upper_threashold, double jerk_lower_threashold, bool check_upper_threashold =true, bool check_lower_threashold =true)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#public-attributes","text":"Name const std::string target_entity const double maximum_reaction_time const double jerk_upper_threashold const double jerk_lower_threashold const bool check_upper_threashold const bool check_lower_threashold","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#additional-inherited-members","text":"Public Functions inherited from metrics::MetricBase Name virtual ~MetricBase () nlohmann::json to_base_json () void throwException () void success () void setEntityManager (std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr) MetricLifecycle getLifecycle () void failure ( SpecificationViolationError error) void activate () MetricBase (std::string metrics_type) Public Attributes inherited from metrics::MetricBase Name const std::string metrics_type Protected Attributes inherited from metrics::MetricBase Name std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr_","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#function-reactiontimemetric","text":"~ ReactionTimeMetric () override = default","title":"function ~ReactionTimeMetric"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#function-update","text":"virtual void update () override Reimplements : metrics::MetricBase::update","title":"function update"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#function-to_json","text":"virtual nlohmann :: json to_json () Reimplements : metrics::MetricBase::to_json","title":"function to_json"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#function-activatetrigger","text":"virtual bool activateTrigger () override Reimplements : metrics::MetricBase::activateTrigger","title":"function activateTrigger"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#function-reactiontimemetric_1","text":"explicit ReactionTimeMetric ( std :: string target_entity , double maximum_reaction_time , double jerk_upper_threashold , double jerk_lower_threashold , bool check_upper_threashold = true , bool check_lower_threashold = true )","title":"function ReactionTimeMetric"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#variable-target_entity","text":"const std :: string target_entity ;","title":"variable target_entity"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#variable-maximum_reaction_time","text":"const double maximum_reaction_time ;","title":"variable maximum_reaction_time"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#variable-jerk_upper_threashold","text":"const double jerk_upper_threashold ;","title":"variable jerk_upper_threashold"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#variable-jerk_lower_threashold","text":"const double jerk_lower_threashold ;","title":"variable jerk_lower_threashold"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#variable-check_upper_threashold","text":"const bool check_upper_threashold ;","title":"variable check_upper_threashold"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1ReactionTimeMetric/#variable-check_lower_threashold","text":"const bool check_lower_threashold ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable check_lower_threashold"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1SpecificationViolationError/","text":"metrics::SpecificationViolationError # Inherits from runtime_error Public Functions # Name SpecificationViolationError (const char * message) SpecificationViolationError (std::string message) SpecificationViolationError (std::string message, const char * file, int line) Public Functions Documentation # function SpecificationViolationError # inline explicit SpecificationViolationError ( const char * message ) function SpecificationViolationError # inline explicit SpecificationViolationError ( std :: string message ) function SpecificationViolationError # inline explicit SpecificationViolationError ( std :: string message , const char * file , int line ) Updated on 7 April 2021 at 00:31:54 UTC","title":"metrics::SpecificationViolationError"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1SpecificationViolationError/#metricsspecificationviolationerror","text":"Inherits from runtime_error","title":"metrics::SpecificationViolationError"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1SpecificationViolationError/#public-functions","text":"Name SpecificationViolationError (const char * message) SpecificationViolationError (std::string message) SpecificationViolationError (std::string message, const char * file, int line)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1SpecificationViolationError/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1SpecificationViolationError/#function-specificationviolationerror","text":"inline explicit SpecificationViolationError ( const char * message )","title":"function SpecificationViolationError"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1SpecificationViolationError/#function-specificationviolationerror_1","text":"inline explicit SpecificationViolationError ( std :: string message )","title":"function SpecificationViolationError"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1SpecificationViolationError/#function-specificationviolationerror_2","text":"inline explicit SpecificationViolationError ( std :: string message , const char * file , int line ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function SpecificationViolationError"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1TraveledDistanceMetric/","text":"metrics::TraveledDistanceMetric # Inherits from metrics::MetricBase Public Functions # Name ~TraveledDistanceMetric () override =default virtual void update () override virtual nlohmann::json to_json () virtual bool activateTrigger () override TraveledDistanceMetric (std::string target_entity) Public Attributes # Name const std::string target_entity Additional inherited members # Public Functions inherited from metrics::MetricBase Name virtual ~MetricBase () nlohmann::json to_base_json () void throwException () void success () void setEntityManager (std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr) MetricLifecycle getLifecycle () void failure ( SpecificationViolationError error) void activate () MetricBase (std::string metrics_type) Public Attributes inherited from metrics::MetricBase Name const std::string metrics_type Protected Attributes inherited from metrics::MetricBase Name std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr_ Public Functions Documentation # function ~TraveledDistanceMetric # ~ TraveledDistanceMetric () override = default function update # virtual void update () override Reimplements : metrics::MetricBase::update function to_json # virtual nlohmann :: json to_json () Reimplements : metrics::MetricBase::to_json function activateTrigger # virtual bool activateTrigger () override Reimplements : metrics::MetricBase::activateTrigger function TraveledDistanceMetric # explicit TraveledDistanceMetric ( std :: string target_entity ) Public Attributes Documentation # variable target_entity # const std :: string target_entity ; Updated on 7 April 2021 at 00:31:54 UTC","title":"metrics::TraveledDistanceMetric"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1TraveledDistanceMetric/#metricstraveleddistancemetric","text":"Inherits from metrics::MetricBase","title":"metrics::TraveledDistanceMetric"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1TraveledDistanceMetric/#public-functions","text":"Name ~TraveledDistanceMetric () override =default virtual void update () override virtual nlohmann::json to_json () virtual bool activateTrigger () override TraveledDistanceMetric (std::string target_entity)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1TraveledDistanceMetric/#public-attributes","text":"Name const std::string target_entity","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1TraveledDistanceMetric/#additional-inherited-members","text":"Public Functions inherited from metrics::MetricBase Name virtual ~MetricBase () nlohmann::json to_base_json () void throwException () void success () void setEntityManager (std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr) MetricLifecycle getLifecycle () void failure ( SpecificationViolationError error) void activate () MetricBase (std::string metrics_type) Public Attributes inherited from metrics::MetricBase Name const std::string metrics_type Protected Attributes inherited from metrics::MetricBase Name std::shared_ptr< simulation_api::entity::EntityManager > entity_manager_ptr_","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1TraveledDistanceMetric/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1TraveledDistanceMetric/#function-traveleddistancemetric","text":"~ TraveledDistanceMetric () override = default","title":"function ~TraveledDistanceMetric"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1TraveledDistanceMetric/#function-update","text":"virtual void update () override Reimplements : metrics::MetricBase::update","title":"function update"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1TraveledDistanceMetric/#function-to_json","text":"virtual nlohmann :: json to_json () Reimplements : metrics::MetricBase::to_json","title":"function to_json"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1TraveledDistanceMetric/#function-activatetrigger","text":"virtual bool activateTrigger () override Reimplements : metrics::MetricBase::activateTrigger","title":"function activateTrigger"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1TraveledDistanceMetric/#function-traveleddistancemetric_1","text":"explicit TraveledDistanceMetric ( std :: string target_entity )","title":"function TraveledDistanceMetric"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1TraveledDistanceMetric/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classmetrics_1_1TraveledDistanceMetric/#variable-target_entity","text":"const std :: string target_entity ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable target_entity"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/","text":"scenario_simulator::API # Public Functions # Name bool updateSensorFrame () bool updateFrame () bool spawn (const bool is_ego, const std::string & name, const std::string & catalog_xml) bool spawn (const bool is_ego, const std::string & name, const openscenario_msgs::msg::VehicleParameters & params) bool spawn (const bool is_ego, const std::string & name, const openscenario_msgs::msg::PedestrianParameters & params) template \\<typename ... Ts> decltype(auto) spawn (const bool is_ego, const std::string & name, const std::string & catalog_xml, Ts &&... xs) template \\<typename Parameters ,typename ... Ts> decltype(auto) spawn (const bool is_ego, const std::string & name, const Parameters & params, Ts &&... xs) void setVerbose (const bool verbose) bool setEntityStatus (const std::string & name, const openscenario_msgs::msg::EntityStatus & status) bool setEntityStatus (const std::string & name, const geometry_msgs::msg::Pose & map_pose, const openscenario_msgs::msg::ActionStatus & action_status =simulation_api::helper::constructActionStatus()) bool setEntityStatus (const std::string & name, const openscenario_msgs::msg::LaneletPose & lanelet_pose, const openscenario_msgs::msg::ActionStatus & action_status =simulation_api::helper::constructActionStatus()) bool setEntityStatus (const std::string & name, const std::string & reference_entity_name, const geometry_msgs::msg::Pose & relative_pose, const openscenario_msgs::msg::ActionStatus & action_status =simulation_api::helper::constructActionStatus()) bool setEntityStatus (const std::string & name, const std::string & reference_entity_name, const geometry_msgs::msg::Point & relative_position, const geometry_msgs::msg::Vector3 & relative_rpy, const openscenario_msgs::msg::ActionStatus & action_status =simulation_api::helper::constructActionStatus()) bool reachPosition (const std::string & name, const geometry_msgs::msg::Pose & target_pose, const double tolerance) bool reachPosition (const std::string & name, const openscenario_msgs::msg::LaneletPose & target_pose, const double tolerance) bool reachPosition (const std::string & name, const std::string & target_name, const double tolerance) const bool initialize (double realtime_factor, double step_time) boost::optional< double > getTimeHeadway (const std::string & from, const std::string & to) openscenario_msgs::msg::EntityStatus getEntityStatus (const std::string & name) geometry_msgs::msg::Pose getEntityPose (const std::string & name) double getCurrentTime () const bool despawn (const std::string & name) bool attachLidarSensor (simulation_api_schema::LidarConfiguration configuration) bool attachDetectionSensor (simulation_api_schema::DetectionSensorConfiguration configuration) template \\<typename T ,typename ... Ts> void addMetric (const std::string & name, Ts &&... xs) FORWARD_TO_ENTITY_MANAGER (checkCollision ) FORWARD_TO_ENTITY_MANAGER (entityExists ) FORWARD_TO_ENTITY_MANAGER (getBoundingBoxDistance ) FORWARD_TO_ENTITY_MANAGER (getEntityNames ) FORWARD_TO_ENTITY_MANAGER (getLinearJerk ) FORWARD_TO_ENTITY_MANAGER (getLongitudinalDistance ) FORWARD_TO_ENTITY_MANAGER (getRelativePose ) FORWARD_TO_ENTITY_MANAGER (getStandStillDuration ) FORWARD_TO_ENTITY_MANAGER (getTrafficLightArrow ) FORWARD_TO_ENTITY_MANAGER (getTrafficLightColor ) FORWARD_TO_ENTITY_MANAGER (isInLanelet ) FORWARD_TO_ENTITY_MANAGER (requestAcquirePosition ) FORWARD_TO_ENTITY_MANAGER (requestAssignRoute ) FORWARD_TO_ENTITY_MANAGER (requestLaneChange ) FORWARD_TO_ENTITY_MANAGER (requestWalkStraight ) FORWARD_TO_ENTITY_MANAGER (setDriverModel ) FORWARD_TO_ENTITY_MANAGER (setTargetSpeed ) FORWARD_TO_ENTITY_MANAGER (setTrafficLightArrow ) FORWARD_TO_ENTITY_MANAGER (setTrafficLightArrowPhase ) FORWARD_TO_ENTITY_MANAGER (setTrafficLightColor ) FORWARD_TO_ENTITY_MANAGER (setTrafficLightColorPhase ) FORWARD_TO_ENTITY_MANAGER (toLaneletPose ) FORWARD_TO_ENTITY_MANAGER (toMapPose ) template \\<class NodeT ,class AllocatorT =std::allocator > API (NodeT && node, const boost::filesystem::path , const std::string & lanelet2_map_osm, const bool auto_sink =true, const bool verbose =false, const bool standalone_mode =false, const std::string & metrics_logfile_path =\"/tmp/metrics.json\") Public Attributes # Name const bool standalone_mode const std::string lanelet2_map_osm Public Functions Documentation # function updateSensorFrame # bool updateSensorFrame () function updateFrame # bool updateFrame () function spawn # bool spawn ( const bool is_ego , const std :: string & name , const std :: string & catalog_xml ) function spawn # bool spawn ( const bool is_ego , const std :: string & name , const openscenario_msgs :: msg :: VehicleParameters & params ) function spawn # bool spawn ( const bool is_ego , const std :: string & name , const openscenario_msgs :: msg :: PedestrianParameters & params ) function spawn # template < typename ... Ts > inline decltype ( auto ) spawn ( const bool is_ego , const std :: string & name , const std :: string & catalog_xml , Ts && ... xs ) function spawn # template < typename Parameters , typename ... Ts > inline decltype ( auto ) spawn ( const bool is_ego , const std :: string & name , const Parameters & params , Ts && ... xs ) function setVerbose # void setVerbose ( const bool verbose ) function setEntityStatus # bool setEntityStatus ( const std :: string & name , const openscenario_msgs :: msg :: EntityStatus & status ) function setEntityStatus # bool setEntityStatus ( const std :: string & name , const geometry_msgs :: msg :: Pose & map_pose , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus () ) function setEntityStatus # bool setEntityStatus ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & lanelet_pose , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus () ) function setEntityStatus # bool setEntityStatus ( const std :: string & name , const std :: string & reference_entity_name , const geometry_msgs :: msg :: Pose & relative_pose , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus () ) function setEntityStatus # bool setEntityStatus ( const std :: string & name , const std :: string & reference_entity_name , const geometry_msgs :: msg :: Point & relative_position , const geometry_msgs :: msg :: Vector3 & relative_rpy , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus () ) function reachPosition # bool reachPosition ( const std :: string & name , const geometry_msgs :: msg :: Pose & target_pose , const double tolerance ) function reachPosition # bool reachPosition ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & target_pose , const double tolerance ) function reachPosition # bool reachPosition ( const std :: string & name , const std :: string & target_name , const double tolerance ) const function initialize # bool initialize ( double realtime_factor , double step_time ) function getTimeHeadway # boost :: optional < double > getTimeHeadway ( const std :: string & from , const std :: string & to ) function getEntityStatus # openscenario_msgs :: msg :: EntityStatus getEntityStatus ( const std :: string & name ) function getEntityPose # geometry_msgs :: msg :: Pose getEntityPose ( const std :: string & name ) function getCurrentTime # inline double getCurrentTime () const function despawn # bool despawn ( const std :: string & name ) function attachLidarSensor # bool attachLidarSensor ( simulation_api_schema :: LidarConfiguration configuration ) function attachDetectionSensor # bool attachDetectionSensor ( simulation_api_schema :: DetectionSensorConfiguration configuration ) function addMetric # template < typename T , typename ... Ts > inline void addMetric ( const std :: string & name , Ts && ... xs ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( checkCollision ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( entityExists ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( getBoundingBoxDistance ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( getEntityNames ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( getLinearJerk ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( getLongitudinalDistance ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( getRelativePose ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( getStandStillDuration ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( getTrafficLightArrow ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( getTrafficLightColor ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( isInLanelet ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( requestAcquirePosition ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( requestAssignRoute ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( requestLaneChange ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( requestWalkStraight ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( setDriverModel ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( setTargetSpeed ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( setTrafficLightArrow ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( setTrafficLightArrowPhase ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( setTrafficLightColor ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( setTrafficLightColorPhase ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( toLaneletPose ) function FORWARD_TO_ENTITY_MANAGER # FORWARD_TO_ENTITY_MANAGER ( toMapPose ) function API # template < class NodeT , class AllocatorT = std :: allocator < void >> inline explicit API ( NodeT && node , const boost :: filesystem :: path , const std :: string & lanelet2_map_osm , const bool auto_sink = true , const bool verbose = false , const bool standalone_mode = false , const std :: string & metrics_logfile_path = \"/tmp/metrics.json\" ) Public Attributes Documentation # variable standalone_mode # const bool standalone_mode ; variable lanelet2_map_osm # const std :: string lanelet2_map_osm ; Updated on 7 April 2021 at 00:31:54 UTC","title":"scenario_simulator::API"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#scenario_simulatorapi","text":"","title":"scenario_simulator::API"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#public-functions","text":"Name bool updateSensorFrame () bool updateFrame () bool spawn (const bool is_ego, const std::string & name, const std::string & catalog_xml) bool spawn (const bool is_ego, const std::string & name, const openscenario_msgs::msg::VehicleParameters & params) bool spawn (const bool is_ego, const std::string & name, const openscenario_msgs::msg::PedestrianParameters & params) template \\<typename ... Ts> decltype(auto) spawn (const bool is_ego, const std::string & name, const std::string & catalog_xml, Ts &&... xs) template \\<typename Parameters ,typename ... Ts> decltype(auto) spawn (const bool is_ego, const std::string & name, const Parameters & params, Ts &&... xs) void setVerbose (const bool verbose) bool setEntityStatus (const std::string & name, const openscenario_msgs::msg::EntityStatus & status) bool setEntityStatus (const std::string & name, const geometry_msgs::msg::Pose & map_pose, const openscenario_msgs::msg::ActionStatus & action_status =simulation_api::helper::constructActionStatus()) bool setEntityStatus (const std::string & name, const openscenario_msgs::msg::LaneletPose & lanelet_pose, const openscenario_msgs::msg::ActionStatus & action_status =simulation_api::helper::constructActionStatus()) bool setEntityStatus (const std::string & name, const std::string & reference_entity_name, const geometry_msgs::msg::Pose & relative_pose, const openscenario_msgs::msg::ActionStatus & action_status =simulation_api::helper::constructActionStatus()) bool setEntityStatus (const std::string & name, const std::string & reference_entity_name, const geometry_msgs::msg::Point & relative_position, const geometry_msgs::msg::Vector3 & relative_rpy, const openscenario_msgs::msg::ActionStatus & action_status =simulation_api::helper::constructActionStatus()) bool reachPosition (const std::string & name, const geometry_msgs::msg::Pose & target_pose, const double tolerance) bool reachPosition (const std::string & name, const openscenario_msgs::msg::LaneletPose & target_pose, const double tolerance) bool reachPosition (const std::string & name, const std::string & target_name, const double tolerance) const bool initialize (double realtime_factor, double step_time) boost::optional< double > getTimeHeadway (const std::string & from, const std::string & to) openscenario_msgs::msg::EntityStatus getEntityStatus (const std::string & name) geometry_msgs::msg::Pose getEntityPose (const std::string & name) double getCurrentTime () const bool despawn (const std::string & name) bool attachLidarSensor (simulation_api_schema::LidarConfiguration configuration) bool attachDetectionSensor (simulation_api_schema::DetectionSensorConfiguration configuration) template \\<typename T ,typename ... Ts> void addMetric (const std::string & name, Ts &&... xs) FORWARD_TO_ENTITY_MANAGER (checkCollision ) FORWARD_TO_ENTITY_MANAGER (entityExists ) FORWARD_TO_ENTITY_MANAGER (getBoundingBoxDistance ) FORWARD_TO_ENTITY_MANAGER (getEntityNames ) FORWARD_TO_ENTITY_MANAGER (getLinearJerk ) FORWARD_TO_ENTITY_MANAGER (getLongitudinalDistance ) FORWARD_TO_ENTITY_MANAGER (getRelativePose ) FORWARD_TO_ENTITY_MANAGER (getStandStillDuration ) FORWARD_TO_ENTITY_MANAGER (getTrafficLightArrow ) FORWARD_TO_ENTITY_MANAGER (getTrafficLightColor ) FORWARD_TO_ENTITY_MANAGER (isInLanelet ) FORWARD_TO_ENTITY_MANAGER (requestAcquirePosition ) FORWARD_TO_ENTITY_MANAGER (requestAssignRoute ) FORWARD_TO_ENTITY_MANAGER (requestLaneChange ) FORWARD_TO_ENTITY_MANAGER (requestWalkStraight ) FORWARD_TO_ENTITY_MANAGER (setDriverModel ) FORWARD_TO_ENTITY_MANAGER (setTargetSpeed ) FORWARD_TO_ENTITY_MANAGER (setTrafficLightArrow ) FORWARD_TO_ENTITY_MANAGER (setTrafficLightArrowPhase ) FORWARD_TO_ENTITY_MANAGER (setTrafficLightColor ) FORWARD_TO_ENTITY_MANAGER (setTrafficLightColorPhase ) FORWARD_TO_ENTITY_MANAGER (toLaneletPose ) FORWARD_TO_ENTITY_MANAGER (toMapPose ) template \\<class NodeT ,class AllocatorT =std::allocator > API (NodeT && node, const boost::filesystem::path , const std::string & lanelet2_map_osm, const bool auto_sink =true, const bool verbose =false, const bool standalone_mode =false, const std::string & metrics_logfile_path =\"/tmp/metrics.json\")","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#public-attributes","text":"Name const bool standalone_mode const std::string lanelet2_map_osm","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-updatesensorframe","text":"bool updateSensorFrame ()","title":"function updateSensorFrame"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-updateframe","text":"bool updateFrame ()","title":"function updateFrame"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-spawn","text":"bool spawn ( const bool is_ego , const std :: string & name , const std :: string & catalog_xml )","title":"function spawn"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-spawn_1","text":"bool spawn ( const bool is_ego , const std :: string & name , const openscenario_msgs :: msg :: VehicleParameters & params )","title":"function spawn"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-spawn_2","text":"bool spawn ( const bool is_ego , const std :: string & name , const openscenario_msgs :: msg :: PedestrianParameters & params )","title":"function spawn"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-spawn_3","text":"template < typename ... Ts > inline decltype ( auto ) spawn ( const bool is_ego , const std :: string & name , const std :: string & catalog_xml , Ts && ... xs )","title":"function spawn"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-spawn_4","text":"template < typename Parameters , typename ... Ts > inline decltype ( auto ) spawn ( const bool is_ego , const std :: string & name , const Parameters & params , Ts && ... xs )","title":"function spawn"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-setverbose","text":"void setVerbose ( const bool verbose )","title":"function setVerbose"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-setentitystatus","text":"bool setEntityStatus ( const std :: string & name , const openscenario_msgs :: msg :: EntityStatus & status )","title":"function setEntityStatus"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-setentitystatus_1","text":"bool setEntityStatus ( const std :: string & name , const geometry_msgs :: msg :: Pose & map_pose , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus () )","title":"function setEntityStatus"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-setentitystatus_2","text":"bool setEntityStatus ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & lanelet_pose , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus () )","title":"function setEntityStatus"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-setentitystatus_3","text":"bool setEntityStatus ( const std :: string & name , const std :: string & reference_entity_name , const geometry_msgs :: msg :: Pose & relative_pose , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus () )","title":"function setEntityStatus"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-setentitystatus_4","text":"bool setEntityStatus ( const std :: string & name , const std :: string & reference_entity_name , const geometry_msgs :: msg :: Point & relative_position , const geometry_msgs :: msg :: Vector3 & relative_rpy , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus () )","title":"function setEntityStatus"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-reachposition","text":"bool reachPosition ( const std :: string & name , const geometry_msgs :: msg :: Pose & target_pose , const double tolerance )","title":"function reachPosition"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-reachposition_1","text":"bool reachPosition ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & target_pose , const double tolerance )","title":"function reachPosition"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-reachposition_2","text":"bool reachPosition ( const std :: string & name , const std :: string & target_name , const double tolerance ) const","title":"function reachPosition"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-initialize","text":"bool initialize ( double realtime_factor , double step_time )","title":"function initialize"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-gettimeheadway","text":"boost :: optional < double > getTimeHeadway ( const std :: string & from , const std :: string & to )","title":"function getTimeHeadway"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-getentitystatus","text":"openscenario_msgs :: msg :: EntityStatus getEntityStatus ( const std :: string & name )","title":"function getEntityStatus"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-getentitypose","text":"geometry_msgs :: msg :: Pose getEntityPose ( const std :: string & name )","title":"function getEntityPose"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-getcurrenttime","text":"inline double getCurrentTime () const","title":"function getCurrentTime"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-despawn","text":"bool despawn ( const std :: string & name )","title":"function despawn"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-attachlidarsensor","text":"bool attachLidarSensor ( simulation_api_schema :: LidarConfiguration configuration )","title":"function attachLidarSensor"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-attachdetectionsensor","text":"bool attachDetectionSensor ( simulation_api_schema :: DetectionSensorConfiguration configuration )","title":"function attachDetectionSensor"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-addmetric","text":"template < typename T , typename ... Ts > inline void addMetric ( const std :: string & name , Ts && ... xs )","title":"function addMetric"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager","text":"FORWARD_TO_ENTITY_MANAGER ( checkCollision )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_1","text":"FORWARD_TO_ENTITY_MANAGER ( entityExists )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_2","text":"FORWARD_TO_ENTITY_MANAGER ( getBoundingBoxDistance )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_3","text":"FORWARD_TO_ENTITY_MANAGER ( getEntityNames )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_4","text":"FORWARD_TO_ENTITY_MANAGER ( getLinearJerk )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_5","text":"FORWARD_TO_ENTITY_MANAGER ( getLongitudinalDistance )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_6","text":"FORWARD_TO_ENTITY_MANAGER ( getRelativePose )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_7","text":"FORWARD_TO_ENTITY_MANAGER ( getStandStillDuration )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_8","text":"FORWARD_TO_ENTITY_MANAGER ( getTrafficLightArrow )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_9","text":"FORWARD_TO_ENTITY_MANAGER ( getTrafficLightColor )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_10","text":"FORWARD_TO_ENTITY_MANAGER ( isInLanelet )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_11","text":"FORWARD_TO_ENTITY_MANAGER ( requestAcquirePosition )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_12","text":"FORWARD_TO_ENTITY_MANAGER ( requestAssignRoute )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_13","text":"FORWARD_TO_ENTITY_MANAGER ( requestLaneChange )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_14","text":"FORWARD_TO_ENTITY_MANAGER ( requestWalkStraight )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_15","text":"FORWARD_TO_ENTITY_MANAGER ( setDriverModel )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_16","text":"FORWARD_TO_ENTITY_MANAGER ( setTargetSpeed )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_17","text":"FORWARD_TO_ENTITY_MANAGER ( setTrafficLightArrow )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_18","text":"FORWARD_TO_ENTITY_MANAGER ( setTrafficLightArrowPhase )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_19","text":"FORWARD_TO_ENTITY_MANAGER ( setTrafficLightColor )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_20","text":"FORWARD_TO_ENTITY_MANAGER ( setTrafficLightColorPhase )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_21","text":"FORWARD_TO_ENTITY_MANAGER ( toLaneletPose )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-forward_to_entity_manager_22","text":"FORWARD_TO_ENTITY_MANAGER ( toMapPose )","title":"function FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#function-api","text":"template < class NodeT , class AllocatorT = std :: allocator < void >> inline explicit API ( NodeT && node , const boost :: filesystem :: path , const std :: string & lanelet2_map_osm , const bool auto_sink = true , const bool verbose = false , const bool standalone_mode = false , const std :: string & metrics_logfile_path = \"/tmp/metrics.json\" )","title":"function API"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#variable-standalone_mode","text":"const bool standalone_mode ;","title":"variable standalone_mode"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1API/#variable-lanelet2_map_osm","text":"const std :: string lanelet2_map_osm ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable lanelet2_map_osm"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1ExecutionFailedError/","text":"scenario_simulator::ExecutionFailedError # Inherits from runtime_error Public Functions # Name virtual ~ExecutionFailedError () =default template \\<typename ... Ts> ExecutionFailedError (Ts &&... xs) Public Functions Documentation # function ~ExecutionFailedError # virtual ~ ExecutionFailedError () = default function ExecutionFailedError # template < typename ... Ts > inline explicit ExecutionFailedError ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:54 UTC","title":"scenario_simulator::ExecutionFailedError"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1ExecutionFailedError/#scenario_simulatorexecutionfailederror","text":"Inherits from runtime_error","title":"scenario_simulator::ExecutionFailedError"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1ExecutionFailedError/#public-functions","text":"Name virtual ~ExecutionFailedError () =default template \\<typename ... Ts> ExecutionFailedError (Ts &&... xs)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1ExecutionFailedError/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1ExecutionFailedError/#function-executionfailederror","text":"virtual ~ ExecutionFailedError () = default","title":"function ~ExecutionFailedError"},{"location":"package/simulation_api/markdown/Classes/classscenario__simulator_1_1ExecutionFailedError/#function-executionfailederror_1","text":"template < typename ... Ts > inline explicit ExecutionFailedError ( Ts && ... xs ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function ExecutionFailedError"},{"location":"package/simulation_api/markdown/Classes/classsimple__planning__simulator/","text":"simple_planning_simulator # calculate ideal twist dynamics More... Detailed Description # class simple_planning_simulator ; calculate ideal twist dynamics calculate time delay twist dynamics calculate vehicle dynamics calculate ideal steering dynamics model class twist model Updated on 7 April 2021 at 00:31:55 UTC","title":"simple_planning_simulator"},{"location":"package/simulation_api/markdown/Classes/classsimple__planning__simulator/#simple_planning_simulator","text":"calculate ideal twist dynamics More...","title":"simple_planning_simulator"},{"location":"package/simulation_api/markdown/Classes/classsimple__planning__simulator/#detailed-description","text":"class simple_planning_simulator ; calculate ideal twist dynamics calculate time delay twist dynamics calculate vehicle dynamics calculate ideal steering dynamics model class twist model Updated on 7 April 2021 at 00:31:55 UTC","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1RoutePlanner/","text":"simulation_api::RoutePlanner # Public Functions # Name std::vector< std::int64_t > getRouteLanelets (openscenario_msgs::msg::LaneletPose entity_lanelet_pose, std::vector< openscenario_msgs::msg::LaneletPose > waypoints, double horizon =100) std::vector< std::int64_t > getRouteLanelets (openscenario_msgs::msg::LaneletPose entity_lanelet_pose, openscenario_msgs::msg::LaneletPose target_lanelet_pose, double horizon =100) std::vector< std::int64_t > getRouteLanelets (openscenario_msgs::msg::LaneletPose entity_lanelet_pose, double horizon =100) void cancelGoal () RoutePlanner (std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils_ptr) Public Functions Documentation # function getRouteLanelets # std :: vector < std :: int64_t > getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , std :: vector < openscenario_msgs :: msg :: LaneletPose > waypoints , double horizon = 100 ) function getRouteLanelets # std :: vector < std :: int64_t > getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , openscenario_msgs :: msg :: LaneletPose target_lanelet_pose , double horizon = 100 ) function getRouteLanelets # std :: vector < std :: int64_t > getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , double horizon = 100 ) function cancelGoal # void cancelGoal () function RoutePlanner # explicit RoutePlanner ( std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ptr ) Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::RoutePlanner"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1RoutePlanner/#simulation_apirouteplanner","text":"","title":"simulation_api::RoutePlanner"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1RoutePlanner/#public-functions","text":"Name std::vector< std::int64_t > getRouteLanelets (openscenario_msgs::msg::LaneletPose entity_lanelet_pose, std::vector< openscenario_msgs::msg::LaneletPose > waypoints, double horizon =100) std::vector< std::int64_t > getRouteLanelets (openscenario_msgs::msg::LaneletPose entity_lanelet_pose, openscenario_msgs::msg::LaneletPose target_lanelet_pose, double horizon =100) std::vector< std::int64_t > getRouteLanelets (openscenario_msgs::msg::LaneletPose entity_lanelet_pose, double horizon =100) void cancelGoal () RoutePlanner (std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils_ptr)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1RoutePlanner/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1RoutePlanner/#function-getroutelanelets","text":"std :: vector < std :: int64_t > getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , std :: vector < openscenario_msgs :: msg :: LaneletPose > waypoints , double horizon = 100 )","title":"function getRouteLanelets"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1RoutePlanner/#function-getroutelanelets_1","text":"std :: vector < std :: int64_t > getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , openscenario_msgs :: msg :: LaneletPose target_lanelet_pose , double horizon = 100 )","title":"function getRouteLanelets"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1RoutePlanner/#function-getroutelanelets_2","text":"std :: vector < std :: int64_t > getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , double horizon = 100 )","title":"function getRouteLanelets"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1RoutePlanner/#function-cancelgoal","text":"void cancelGoal ()","title":"function cancelGoal"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1RoutePlanner/#function-routeplanner","text":"explicit RoutePlanner ( std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ptr ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function RoutePlanner"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1SimulationRuntimeError/","text":"simulation_api::SimulationRuntimeError # Inherits from runtime_error Public Functions # Name SimulationRuntimeError (const char * message) SimulationRuntimeError (std::string message) Public Functions Documentation # function SimulationRuntimeError # inline explicit SimulationRuntimeError ( const char * message ) function SimulationRuntimeError # inline explicit SimulationRuntimeError ( std :: string message ) Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::SimulationRuntimeError"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1SimulationRuntimeError/#simulation_apisimulationruntimeerror","text":"Inherits from runtime_error","title":"simulation_api::SimulationRuntimeError"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1SimulationRuntimeError/#public-functions","text":"Name SimulationRuntimeError (const char * message) SimulationRuntimeError (std::string message)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1SimulationRuntimeError/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1SimulationRuntimeError/#function-simulationruntimeerror","text":"inline explicit SimulationRuntimeError ( const char * message )","title":"function SimulationRuntimeError"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1SimulationRuntimeError/#function-simulationruntimeerror_1","text":"inline explicit SimulationRuntimeError ( std :: string message ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function SimulationRuntimeError"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1SplineInterpolationError/","text":"simulation_api::SplineInterpolationError # Inherits from runtime_error Public Functions # Name SplineInterpolationError (const char * message) Public Functions Documentation # function SplineInterpolationError # inline explicit SplineInterpolationError ( const char * message ) Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::SplineInterpolationError"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1SplineInterpolationError/#simulation_apisplineinterpolationerror","text":"Inherits from runtime_error","title":"simulation_api::SplineInterpolationError"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1SplineInterpolationError/#public-functions","text":"Name SplineInterpolationError (const char * message)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1SplineInterpolationError/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1SplineInterpolationError/#function-splineinterpolationerror","text":"inline explicit SplineInterpolationError ( const char * message ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function SplineInterpolationError"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/","text":"simulation_api::TrafficLight # Public Functions # Name void update (double step_time) void setPosition (const TrafficLightColor & color, const geometry_msgs::msg::Point & position) void setColorPhase (const std::vector< std::pair< Duration, TrafficLightColor >> & phase, double time_offset =0) void setColor (TrafficLightColor color) void setArrowPhase (const std::vector< std::pair< Duration, TrafficLightArrow >> & phase, double time_offset =0) void setArrow (TrafficLightArrow arrow) const geometry_msgs::msg::Point getPosition (const TrafficLightColor & color) const geometry_msgs::msg::Point getPosition (const TrafficLightArrow & arrow) double getColorPhaseLength () const TrafficLightColor getColor () const double getArrowPhaseLength () const TrafficLightArrow getArrow () const bool colorChanged () const bool arrowChanged () const TrafficLight (std::int64_t id, const std::unordered_map< TrafficLightColor, geometry_msgs::msg::Point > & color_positions ={}, const std::unordered_map< TrafficLightArrow, geometry_msgs::msg::Point > & arrow_positions ={}) Public Attributes # Name const std::int64_t id Public Functions Documentation # function update # void update ( double step_time ) function setPosition # void setPosition ( const TrafficLightColor & color , const geometry_msgs :: msg :: Point & position ) function setColorPhase # void setColorPhase ( const std :: vector < std :: pair < Duration , TrafficLightColor >> & phase , double time_offset = 0 ) function setColor # void setColor ( TrafficLightColor color ) function setArrowPhase # void setArrowPhase ( const std :: vector < std :: pair < Duration , TrafficLightArrow >> & phase , double time_offset = 0 ) function setArrow # void setArrow ( TrafficLightArrow arrow ) function getPosition # const geometry_msgs :: msg :: Point getPosition ( const TrafficLightColor & color ) function getPosition # const geometry_msgs :: msg :: Point getPosition ( const TrafficLightArrow & arrow ) function getColorPhaseLength # double getColorPhaseLength () const function getColor # TrafficLightColor getColor () const function getArrowPhaseLength # double getArrowPhaseLength () const function getArrow # TrafficLightArrow getArrow () const function colorChanged # bool colorChanged () const function arrowChanged # bool arrowChanged () const function TrafficLight # explicit TrafficLight ( std :: int64_t id , const std :: unordered_map < TrafficLightColor , geometry_msgs :: msg :: Point > & color_positions = {}, const std :: unordered_map < TrafficLightArrow , geometry_msgs :: msg :: Point > & arrow_positions = {} ) Public Attributes Documentation # variable id # const std :: int64_t id ; Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::TrafficLight"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#simulation_apitrafficlight","text":"","title":"simulation_api::TrafficLight"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#public-functions","text":"Name void update (double step_time) void setPosition (const TrafficLightColor & color, const geometry_msgs::msg::Point & position) void setColorPhase (const std::vector< std::pair< Duration, TrafficLightColor >> & phase, double time_offset =0) void setColor (TrafficLightColor color) void setArrowPhase (const std::vector< std::pair< Duration, TrafficLightArrow >> & phase, double time_offset =0) void setArrow (TrafficLightArrow arrow) const geometry_msgs::msg::Point getPosition (const TrafficLightColor & color) const geometry_msgs::msg::Point getPosition (const TrafficLightArrow & arrow) double getColorPhaseLength () const TrafficLightColor getColor () const double getArrowPhaseLength () const TrafficLightArrow getArrow () const bool colorChanged () const bool arrowChanged () const TrafficLight (std::int64_t id, const std::unordered_map< TrafficLightColor, geometry_msgs::msg::Point > & color_positions ={}, const std::unordered_map< TrafficLightArrow, geometry_msgs::msg::Point > & arrow_positions ={})","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#public-attributes","text":"Name const std::int64_t id","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#function-update","text":"void update ( double step_time )","title":"function update"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#function-setposition","text":"void setPosition ( const TrafficLightColor & color , const geometry_msgs :: msg :: Point & position )","title":"function setPosition"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#function-setcolorphase","text":"void setColorPhase ( const std :: vector < std :: pair < Duration , TrafficLightColor >> & phase , double time_offset = 0 )","title":"function setColorPhase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#function-setcolor","text":"void setColor ( TrafficLightColor color )","title":"function setColor"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#function-setarrowphase","text":"void setArrowPhase ( const std :: vector < std :: pair < Duration , TrafficLightArrow >> & phase , double time_offset = 0 )","title":"function setArrowPhase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#function-setarrow","text":"void setArrow ( TrafficLightArrow arrow )","title":"function setArrow"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#function-getposition","text":"const geometry_msgs :: msg :: Point getPosition ( const TrafficLightColor & color )","title":"function getPosition"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#function-getposition_1","text":"const geometry_msgs :: msg :: Point getPosition ( const TrafficLightArrow & arrow )","title":"function getPosition"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#function-getcolorphaselength","text":"double getColorPhaseLength () const","title":"function getColorPhaseLength"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#function-getcolor","text":"TrafficLightColor getColor () const","title":"function getColor"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#function-getarrowphaselength","text":"double getArrowPhaseLength () const","title":"function getArrowPhaseLength"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#function-getarrow","text":"TrafficLightArrow getArrow () const","title":"function getArrow"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#function-colorchanged","text":"bool colorChanged () const","title":"function colorChanged"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#function-arrowchanged","text":"bool arrowChanged () const","title":"function arrowChanged"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#function-trafficlight","text":"explicit TrafficLight ( std :: int64_t id , const std :: unordered_map < TrafficLightColor , geometry_msgs :: msg :: Point > & color_positions = {}, const std :: unordered_map < TrafficLightArrow , geometry_msgs :: msg :: Point > & arrow_positions = {} )","title":"function TrafficLight"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLight/#variable-id","text":"const std :: int64_t id ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable id"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightManager/","text":"simulation_api::TrafficLightManager # Public Functions # Name void update (double step_time) template \\<typename ... Ts> void setColorPhase (std::int64_t lanelet_id, Ts &&... xs) template \\<typename ... Ts> void setColor (std::int64_t lanelet_id, Ts &&... xs) template \\<typename ... Ts> void setArrowPhase (std::int64_t lanelet_id, Ts &&... xs) template \\<typename ... Ts> void setArrow (std::int64_t lanelet_id, Ts &&... xs) std::vector< std::int64_t > getIds () const TrafficLightColor getColor (std::int64_t lanelet_id) const TrafficLightArrow getArrow (std::int64_t lanelet_id) const TrafficLightManager (std::shared_ptr< hdmap_utils::HdMapUtils > & hdmap_utils_ptr, rclcpp::Publisher< visualization_msgs::msg::MarkerArray >::SharedPtr publisher, const std::shared_ptr< rclcpp::Clock > & clock_ptr, const std::string & map_frame =\"map\") Public Functions Documentation # function update # void update ( double step_time ) function setColorPhase # template < typename ... Ts > inline void setColorPhase ( std :: int64_t lanelet_id , Ts && ... xs ) function setColor # template < typename ... Ts > inline void setColor ( std :: int64_t lanelet_id , Ts && ... xs ) function setArrowPhase # template < typename ... Ts > inline void setArrowPhase ( std :: int64_t lanelet_id , Ts && ... xs ) function setArrow # template < typename ... Ts > inline void setArrow ( std :: int64_t lanelet_id , Ts && ... xs ) function getIds # std :: vector < std :: int64_t > getIds () const function getColor # TrafficLightColor getColor ( std :: int64_t lanelet_id ) const function getArrow # TrafficLightArrow getArrow ( std :: int64_t lanelet_id ) const function TrafficLightManager # explicit TrafficLightManager ( std :: shared_ptr < hdmap_utils :: HdMapUtils > & hdmap_utils_ptr , rclcpp :: Publisher < visualization_msgs :: msg :: MarkerArray >:: SharedPtr publisher , const std :: shared_ptr < rclcpp :: Clock > & clock_ptr , const std :: string & map_frame = \"map\" ) Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::TrafficLightManager"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightManager/#simulation_apitrafficlightmanager","text":"","title":"simulation_api::TrafficLightManager"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightManager/#public-functions","text":"Name void update (double step_time) template \\<typename ... Ts> void setColorPhase (std::int64_t lanelet_id, Ts &&... xs) template \\<typename ... Ts> void setColor (std::int64_t lanelet_id, Ts &&... xs) template \\<typename ... Ts> void setArrowPhase (std::int64_t lanelet_id, Ts &&... xs) template \\<typename ... Ts> void setArrow (std::int64_t lanelet_id, Ts &&... xs) std::vector< std::int64_t > getIds () const TrafficLightColor getColor (std::int64_t lanelet_id) const TrafficLightArrow getArrow (std::int64_t lanelet_id) const TrafficLightManager (std::shared_ptr< hdmap_utils::HdMapUtils > & hdmap_utils_ptr, rclcpp::Publisher< visualization_msgs::msg::MarkerArray >::SharedPtr publisher, const std::shared_ptr< rclcpp::Clock > & clock_ptr, const std::string & map_frame =\"map\")","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightManager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightManager/#function-update","text":"void update ( double step_time )","title":"function update"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightManager/#function-setcolorphase","text":"template < typename ... Ts > inline void setColorPhase ( std :: int64_t lanelet_id , Ts && ... xs )","title":"function setColorPhase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightManager/#function-setcolor","text":"template < typename ... Ts > inline void setColor ( std :: int64_t lanelet_id , Ts && ... xs )","title":"function setColor"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightManager/#function-setarrowphase","text":"template < typename ... Ts > inline void setArrowPhase ( std :: int64_t lanelet_id , Ts && ... xs )","title":"function setArrowPhase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightManager/#function-setarrow","text":"template < typename ... Ts > inline void setArrow ( std :: int64_t lanelet_id , Ts && ... xs )","title":"function setArrow"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightManager/#function-getids","text":"std :: vector < std :: int64_t > getIds () const","title":"function getIds"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightManager/#function-getcolor","text":"TrafficLightColor getColor ( std :: int64_t lanelet_id ) const","title":"function getColor"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightManager/#function-getarrow","text":"TrafficLightArrow getArrow ( std :: int64_t lanelet_id ) const","title":"function getArrow"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightManager/#function-trafficlightmanager","text":"explicit TrafficLightManager ( std :: shared_ptr < hdmap_utils :: HdMapUtils > & hdmap_utils_ptr , rclcpp :: Publisher < visualization_msgs :: msg :: MarkerArray >:: SharedPtr publisher , const std :: shared_ptr < rclcpp :: Clock > & clock_ptr , const std :: string & map_frame = \"map\" ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function TrafficLightManager"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightPhase/","text":"simulation_api::TrafficLightPhase # More... Public Functions # Name void update (double step_time) void setState (const T & state) void setPhase (const std::vector< std::pair< double, T >> & phase, double time_offset =0) const T getState () const double getPhaseLength () const const std::vector< std::pair< double, T > > getPhase () const TrafficLightPhase () TrafficLightPhase (const std::vector< std::pair< double, T >> & phase) Detailed Description # template < typename T > class simulation_api :: TrafficLightPhase ; Public Functions Documentation # function update # inline void update ( double step_time ) function setState # inline void setState ( const T & state ) function setPhase # inline void setPhase ( const std :: vector < std :: pair < double , T >> & phase , double time_offset = 0 ) function getState # inline const T getState () const function getPhaseLength # inline double getPhaseLength () const function getPhase # inline const std :: vector < std :: pair < double , T > > getPhase () const function TrafficLightPhase # inline TrafficLightPhase () function TrafficLightPhase # inline explicit TrafficLightPhase ( const std :: vector < std :: pair < double , T >> & phase ) Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::TrafficLightPhase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightPhase/#simulation_apitrafficlightphase","text":"More...","title":"simulation_api::TrafficLightPhase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightPhase/#public-functions","text":"Name void update (double step_time) void setState (const T & state) void setPhase (const std::vector< std::pair< double, T >> & phase, double time_offset =0) const T getState () const double getPhaseLength () const const std::vector< std::pair< double, T > > getPhase () const TrafficLightPhase () TrafficLightPhase (const std::vector< std::pair< double, T >> & phase)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightPhase/#detailed-description","text":"template < typename T > class simulation_api :: TrafficLightPhase ;","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightPhase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightPhase/#function-update","text":"inline void update ( double step_time )","title":"function update"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightPhase/#function-setstate","text":"inline void setState ( const T & state )","title":"function setState"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightPhase/#function-setphase","text":"inline void setPhase ( const std :: vector < std :: pair < double , T >> & phase , double time_offset = 0 )","title":"function setPhase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightPhase/#function-getstate","text":"inline const T getState () const","title":"function getState"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightPhase/#function-getphaselength","text":"inline double getPhaseLength () const","title":"function getPhaseLength"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightPhase/#function-getphase","text":"inline const std :: vector < std :: pair < double , T > > getPhase () const","title":"function getPhase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightPhase/#function-trafficlightphase","text":"inline TrafficLightPhase ()","title":"function TrafficLightPhase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1TrafficLightPhase/#function-trafficlightphase_1","text":"inline explicit TrafficLightPhase ( const std :: vector < std :: pair < double , T >> & phase ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function TrafficLightPhase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/","text":"simulation_api::entity::EgoEntity # Inherits from simulation_api::entity::VehicleEntity , simulation_api::entity::EntityBase Public Functions # Name ~EgoEntity () override decltype(auto) setTargetSpeed (const double value, const bool ) bool setStatus (const openscenario_msgs::msg::EntityStatus & status) virtual void requestAssignRoute (const std::vector< openscenario_msgs::msg::LaneletPose > & waypoints) override void requestAcquirePosition (const geometry_msgs::msg::PoseStamped & goal_pose, const std::vector< geometry_msgs::msg::PoseStamped > & constraints ={}) virtual void onUpdate (double current_time, double step_time) auto initializeAutoware () openscenario_msgs::msg::WaypointsArray getWaypoints () const virtual const std::string getCurrentAction () const EgoEntity () EgoEntity (const std::string & name, const boost::filesystem::path & lanelet2_map_osm, const double step_time, const openscenario_msgs::msg::VehicleParameters & parameters) Public Attributes # Name bool autoware_initialized Additional inherited members # Public Functions inherited from simulation_api::entity::VehicleEntity Name void setTrafficLightManager (std::shared_ptr< simulation_api::TrafficLightManager > ptr) void setHdMapUtils (std::shared_ptr< hdmap_utils::HdMapUtils > ptr) void setDriverModel (const openscenario_msgs::msg::DriverModel & model) void requestLaneChange (std::int64_t to_lanelet_id) std::vector< std::int64_t > getRouteLanelets (double horizon =100) boost::optional< openscenario_msgs::msg::Obstacle > getObstacle () virtual const openscenario_msgs::msg::BoundingBox getBoundingBox () const override void cancelRequest () VehicleEntity (std::string name, const openscenario_msgs::msg::EntityStatus & initial_state, openscenario_msgs::msg::VehicleParameters parameters) VehicleEntity (std::string name, openscenario_msgs::msg::VehicleParameters parameters) Public Attributes inherited from simulation_api::entity::VehicleEntity Name const openscenario_msgs::msg::VehicleParameters parameters Public Functions inherited from simulation_api::entity::EntityBase Name virtual ~EntityBase () =default void updateStandStillDuration (double step_time) void stopAtEndOfRoad () bool statusSetted () const bool setVisibility (bool visibility) void setVerbose (bool verbose) void setTrafficLightManager (std::shared_ptr< simulation_api::TrafficLightManager > ptr) void setOtherStatus (const std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > & status) void setHdMapUtils (std::shared_ptr< hdmap_utils::HdMapUtils > ptr) void setEntityTypeList (const std::unordered_map< std::string, openscenario_msgs::msg::EntityType > & entity_type_list) bool getVisibility () const openscenario_msgs::msg::EntityStatus getStatus () const boost::optional< double > getStandStillDuration () const boost::optional< double > getLinearJerk () const virtual const openscenario_msgs::msg::BoundingBox getBoundingBox () const =0 EntityBase (std::string type, std::string name, const openscenario_msgs::msg::EntityStatus & initial_state) EntityBase (std::string type, std::string name) Public Attributes inherited from simulation_api::entity::EntityBase Name const std::string type const std::string name Protected Attributes inherited from simulation_api::entity::EntityBase Name std::queue< openscenario_msgs::msg::LaneletPose > waypoints_ bool visibility_ bool verbose_ std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager_ boost::optional< openscenario_msgs::msg::EntityStatus > status_ boost::optional< double > stand_still_duration_ std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_status_ boost::optional< openscenario_msgs::msg::LaneletPose > next_waypoint_ boost::optional< double > linear_jerk_ std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils_ptr_ std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list_ visualization_msgs::msg::MarkerArray current_marker_ Public Functions Documentation # function ~EgoEntity # inline ~ EgoEntity () override function setTargetSpeed # inline decltype ( auto ) setTargetSpeed ( const double value , const bool ) function setStatus # bool setStatus ( const openscenario_msgs :: msg :: EntityStatus & status ) function requestAssignRoute # virtual void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) override Reimplements : simulation_api::entity::EntityBase::requestAssignRoute function requestAcquirePosition # inline void requestAcquirePosition ( const geometry_msgs :: msg :: PoseStamped & goal_pose , const std :: vector < geometry_msgs :: msg :: PoseStamped > & constraints = {} ) function onUpdate # virtual void onUpdate ( double current_time , double step_time ) Reimplements : simulation_api::entity::EntityBase::onUpdate function initializeAutoware # inline auto initializeAutoware () function getWaypoints # openscenario_msgs :: msg :: WaypointsArray getWaypoints () const function getCurrentAction # inline virtual const std :: string getCurrentAction () const Reimplements : simulation_api::entity::EntityBase::getCurrentAction function EgoEntity # EgoEntity () function EgoEntity # inline explicit EgoEntity ( const std :: string & name , const boost :: filesystem :: path & lanelet2_map_osm , const double step_time , const openscenario_msgs :: msg :: VehicleParameters & parameters ) Public Attributes Documentation # variable autoware_initialized # bool autoware_initialized = false ; Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity::EgoEntity"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#simulation_apientityegoentity","text":"Inherits from simulation_api::entity::VehicleEntity , simulation_api::entity::EntityBase","title":"simulation_api::entity::EgoEntity"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#public-functions","text":"Name ~EgoEntity () override decltype(auto) setTargetSpeed (const double value, const bool ) bool setStatus (const openscenario_msgs::msg::EntityStatus & status) virtual void requestAssignRoute (const std::vector< openscenario_msgs::msg::LaneletPose > & waypoints) override void requestAcquirePosition (const geometry_msgs::msg::PoseStamped & goal_pose, const std::vector< geometry_msgs::msg::PoseStamped > & constraints ={}) virtual void onUpdate (double current_time, double step_time) auto initializeAutoware () openscenario_msgs::msg::WaypointsArray getWaypoints () const virtual const std::string getCurrentAction () const EgoEntity () EgoEntity (const std::string & name, const boost::filesystem::path & lanelet2_map_osm, const double step_time, const openscenario_msgs::msg::VehicleParameters & parameters)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#public-attributes","text":"Name bool autoware_initialized","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#additional-inherited-members","text":"Public Functions inherited from simulation_api::entity::VehicleEntity Name void setTrafficLightManager (std::shared_ptr< simulation_api::TrafficLightManager > ptr) void setHdMapUtils (std::shared_ptr< hdmap_utils::HdMapUtils > ptr) void setDriverModel (const openscenario_msgs::msg::DriverModel & model) void requestLaneChange (std::int64_t to_lanelet_id) std::vector< std::int64_t > getRouteLanelets (double horizon =100) boost::optional< openscenario_msgs::msg::Obstacle > getObstacle () virtual const openscenario_msgs::msg::BoundingBox getBoundingBox () const override void cancelRequest () VehicleEntity (std::string name, const openscenario_msgs::msg::EntityStatus & initial_state, openscenario_msgs::msg::VehicleParameters parameters) VehicleEntity (std::string name, openscenario_msgs::msg::VehicleParameters parameters) Public Attributes inherited from simulation_api::entity::VehicleEntity Name const openscenario_msgs::msg::VehicleParameters parameters Public Functions inherited from simulation_api::entity::EntityBase Name virtual ~EntityBase () =default void updateStandStillDuration (double step_time) void stopAtEndOfRoad () bool statusSetted () const bool setVisibility (bool visibility) void setVerbose (bool verbose) void setTrafficLightManager (std::shared_ptr< simulation_api::TrafficLightManager > ptr) void setOtherStatus (const std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > & status) void setHdMapUtils (std::shared_ptr< hdmap_utils::HdMapUtils > ptr) void setEntityTypeList (const std::unordered_map< std::string, openscenario_msgs::msg::EntityType > & entity_type_list) bool getVisibility () const openscenario_msgs::msg::EntityStatus getStatus () const boost::optional< double > getStandStillDuration () const boost::optional< double > getLinearJerk () const virtual const openscenario_msgs::msg::BoundingBox getBoundingBox () const =0 EntityBase (std::string type, std::string name, const openscenario_msgs::msg::EntityStatus & initial_state) EntityBase (std::string type, std::string name) Public Attributes inherited from simulation_api::entity::EntityBase Name const std::string type const std::string name Protected Attributes inherited from simulation_api::entity::EntityBase Name std::queue< openscenario_msgs::msg::LaneletPose > waypoints_ bool visibility_ bool verbose_ std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager_ boost::optional< openscenario_msgs::msg::EntityStatus > status_ boost::optional< double > stand_still_duration_ std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_status_ boost::optional< openscenario_msgs::msg::LaneletPose > next_waypoint_ boost::optional< double > linear_jerk_ std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils_ptr_ std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list_ visualization_msgs::msg::MarkerArray current_marker_","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#function-egoentity","text":"inline ~ EgoEntity () override","title":"function ~EgoEntity"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#function-settargetspeed","text":"inline decltype ( auto ) setTargetSpeed ( const double value , const bool )","title":"function setTargetSpeed"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#function-setstatus","text":"bool setStatus ( const openscenario_msgs :: msg :: EntityStatus & status )","title":"function setStatus"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#function-requestassignroute","text":"virtual void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) override Reimplements : simulation_api::entity::EntityBase::requestAssignRoute","title":"function requestAssignRoute"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#function-requestacquireposition","text":"inline void requestAcquirePosition ( const geometry_msgs :: msg :: PoseStamped & goal_pose , const std :: vector < geometry_msgs :: msg :: PoseStamped > & constraints = {} )","title":"function requestAcquirePosition"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#function-onupdate","text":"virtual void onUpdate ( double current_time , double step_time ) Reimplements : simulation_api::entity::EntityBase::onUpdate","title":"function onUpdate"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#function-initializeautoware","text":"inline auto initializeAutoware ()","title":"function initializeAutoware"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#function-getwaypoints","text":"openscenario_msgs :: msg :: WaypointsArray getWaypoints () const","title":"function getWaypoints"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#function-getcurrentaction","text":"inline virtual const std :: string getCurrentAction () const Reimplements : simulation_api::entity::EntityBase::getCurrentAction","title":"function getCurrentAction"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#function-egoentity_1","text":"EgoEntity ()","title":"function EgoEntity"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#function-egoentity_2","text":"inline explicit EgoEntity ( const std :: string & name , const boost :: filesystem :: path & lanelet2_map_osm , const double step_time , const openscenario_msgs :: msg :: VehicleParameters & parameters )","title":"function EgoEntity"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EgoEntity/#variable-autoware_initialized","text":"bool autoware_initialized = false ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable autoware_initialized"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/","text":"simulation_api::entity::EntityBase # Inherited by simulation_api::entity::PedestrianEntity , simulation_api::entity::VehicleEntity Public Functions # Name virtual ~EntityBase () =default void updateStandStillDuration (double step_time) void stopAtEndOfRoad () bool statusSetted () const bool setVisibility (bool visibility) void setVerbose (bool verbose) void setTrafficLightManager (std::shared_ptr< simulation_api::TrafficLightManager > ptr) bool setStatus (const openscenario_msgs::msg::EntityStatus & status) void setOtherStatus (const std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > & status) void setHdMapUtils (std::shared_ptr< hdmap_utils::HdMapUtils > ptr) void setEntityTypeList (const std::unordered_map< std::string, openscenario_msgs::msg::EntityType > & entity_type_list) virtual void requestAssignRoute (const std::vector< openscenario_msgs::msg::LaneletPose > & waypoints) =0 virtual void onUpdate (double current_time, double step_time) =0 bool getVisibility () const openscenario_msgs::msg::EntityStatus getStatus () const boost::optional< double > getStandStillDuration () const boost::optional< double > getLinearJerk () const virtual const std::string getCurrentAction () const =0 virtual const openscenario_msgs::msg::BoundingBox getBoundingBox () const =0 EntityBase (std::string type, std::string name, const openscenario_msgs::msg::EntityStatus & initial_state) EntityBase (std::string type, std::string name) Public Attributes # Name const std::string type const std::string name Protected Attributes # Name std::queue< openscenario_msgs::msg::LaneletPose > waypoints_ bool visibility_ bool verbose_ std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager_ boost::optional< openscenario_msgs::msg::EntityStatus > status_ boost::optional< double > stand_still_duration_ std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_status_ boost::optional< openscenario_msgs::msg::LaneletPose > next_waypoint_ boost::optional< double > linear_jerk_ std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils_ptr_ std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list_ visualization_msgs::msg::MarkerArray current_marker_ Public Functions Documentation # function ~EntityBase # virtual ~ EntityBase () = default function updateStandStillDuration # void updateStandStillDuration ( double step_time ) function stopAtEndOfRoad # void stopAtEndOfRoad () function statusSetted # inline bool statusSetted () const function setVisibility # bool setVisibility ( bool visibility ) function setVerbose # inline void setVerbose ( bool verbose ) function setTrafficLightManager # inline void setTrafficLightManager ( std :: shared_ptr < simulation_api :: TrafficLightManager > ptr ) function setStatus # bool setStatus ( const openscenario_msgs :: msg :: EntityStatus & status ) function setOtherStatus # void setOtherStatus ( const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > & status ) function setHdMapUtils # inline void setHdMapUtils ( std :: shared_ptr < hdmap_utils :: HdMapUtils > ptr ) function setEntityTypeList # inline void setEntityTypeList ( const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > & entity_type_list ) function requestAssignRoute # virtual void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) = 0 Reimplemented by : simulation_api::entity::PedestrianEntity::requestAssignRoute , simulation_api::entity::VehicleEntity::requestAssignRoute , simulation_api::entity::EgoEntity::requestAssignRoute function onUpdate # virtual void onUpdate ( double current_time , double step_time ) = 0 Reimplemented by : simulation_api::entity::PedestrianEntity::onUpdate , simulation_api::entity::VehicleEntity::onUpdate , simulation_api::entity::EgoEntity::onUpdate function getVisibility # bool getVisibility () function getStatus # const openscenario_msgs :: msg :: EntityStatus getStatus () const function getStandStillDuration # boost :: optional < double > getStandStillDuration () const function getLinearJerk # inline boost :: optional < double > getLinearJerk () const function getCurrentAction # virtual const std :: string getCurrentAction () const = 0 Reimplemented by : simulation_api::entity::PedestrianEntity::getCurrentAction , simulation_api::entity::VehicleEntity::getCurrentAction , simulation_api::entity::EgoEntity::getCurrentAction function getBoundingBox # virtual const openscenario_msgs :: msg :: BoundingBox getBoundingBox () const = 0 Reimplemented by : simulation_api::entity::PedestrianEntity::getBoundingBox , simulation_api::entity::VehicleEntity::getBoundingBox function EntityBase # EntityBase ( std :: string type , std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state ) function EntityBase # EntityBase ( std :: string type , std :: string name ) Public Attributes Documentation # variable type # const std :: string type ; variable name # const std :: string name ; Protected Attributes Documentation # variable waypoints_ # std :: queue < openscenario_msgs :: msg :: LaneletPose > waypoints_ ; variable visibility_ # bool visibility_ ; variable verbose_ # bool verbose_ ; variable traffic_light_manager_ # std :: shared_ptr < simulation_api :: TrafficLightManager > traffic_light_manager_ ; variable status_ # boost :: optional < openscenario_msgs :: msg :: EntityStatus > status_ ; variable stand_still_duration_ # boost :: optional < double > stand_still_duration_ ; variable other_status_ # std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > other_status_ ; variable next_waypoint_ # boost :: optional < openscenario_msgs :: msg :: LaneletPose > next_waypoint_ ; variable linear_jerk_ # boost :: optional < double > linear_jerk_ ; variable hdmap_utils_ptr_ # std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ptr_ ; variable entity_type_list_ # std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > entity_type_list_ ; variable current_marker_ # visualization_msgs :: msg :: MarkerArray current_marker_ ; Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity::EntityBase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#simulation_apientityentitybase","text":"Inherited by simulation_api::entity::PedestrianEntity , simulation_api::entity::VehicleEntity","title":"simulation_api::entity::EntityBase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#public-functions","text":"Name virtual ~EntityBase () =default void updateStandStillDuration (double step_time) void stopAtEndOfRoad () bool statusSetted () const bool setVisibility (bool visibility) void setVerbose (bool verbose) void setTrafficLightManager (std::shared_ptr< simulation_api::TrafficLightManager > ptr) bool setStatus (const openscenario_msgs::msg::EntityStatus & status) void setOtherStatus (const std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > & status) void setHdMapUtils (std::shared_ptr< hdmap_utils::HdMapUtils > ptr) void setEntityTypeList (const std::unordered_map< std::string, openscenario_msgs::msg::EntityType > & entity_type_list) virtual void requestAssignRoute (const std::vector< openscenario_msgs::msg::LaneletPose > & waypoints) =0 virtual void onUpdate (double current_time, double step_time) =0 bool getVisibility () const openscenario_msgs::msg::EntityStatus getStatus () const boost::optional< double > getStandStillDuration () const boost::optional< double > getLinearJerk () const virtual const std::string getCurrentAction () const =0 virtual const openscenario_msgs::msg::BoundingBox getBoundingBox () const =0 EntityBase (std::string type, std::string name, const openscenario_msgs::msg::EntityStatus & initial_state) EntityBase (std::string type, std::string name)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#public-attributes","text":"Name const std::string type const std::string name","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#protected-attributes","text":"Name std::queue< openscenario_msgs::msg::LaneletPose > waypoints_ bool visibility_ bool verbose_ std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager_ boost::optional< openscenario_msgs::msg::EntityStatus > status_ boost::optional< double > stand_still_duration_ std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_status_ boost::optional< openscenario_msgs::msg::LaneletPose > next_waypoint_ boost::optional< double > linear_jerk_ std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils_ptr_ std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list_ visualization_msgs::msg::MarkerArray current_marker_","title":"Protected Attributes"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-entitybase","text":"virtual ~ EntityBase () = default","title":"function ~EntityBase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-updatestandstillduration","text":"void updateStandStillDuration ( double step_time )","title":"function updateStandStillDuration"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-stopatendofroad","text":"void stopAtEndOfRoad ()","title":"function stopAtEndOfRoad"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-statussetted","text":"inline bool statusSetted () const","title":"function statusSetted"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-setvisibility","text":"bool setVisibility ( bool visibility )","title":"function setVisibility"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-setverbose","text":"inline void setVerbose ( bool verbose )","title":"function setVerbose"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-settrafficlightmanager","text":"inline void setTrafficLightManager ( std :: shared_ptr < simulation_api :: TrafficLightManager > ptr )","title":"function setTrafficLightManager"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-setstatus","text":"bool setStatus ( const openscenario_msgs :: msg :: EntityStatus & status )","title":"function setStatus"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-setotherstatus","text":"void setOtherStatus ( const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > & status )","title":"function setOtherStatus"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-sethdmaputils","text":"inline void setHdMapUtils ( std :: shared_ptr < hdmap_utils :: HdMapUtils > ptr )","title":"function setHdMapUtils"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-setentitytypelist","text":"inline void setEntityTypeList ( const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > & entity_type_list )","title":"function setEntityTypeList"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-requestassignroute","text":"virtual void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) = 0 Reimplemented by : simulation_api::entity::PedestrianEntity::requestAssignRoute , simulation_api::entity::VehicleEntity::requestAssignRoute , simulation_api::entity::EgoEntity::requestAssignRoute","title":"function requestAssignRoute"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-onupdate","text":"virtual void onUpdate ( double current_time , double step_time ) = 0 Reimplemented by : simulation_api::entity::PedestrianEntity::onUpdate , simulation_api::entity::VehicleEntity::onUpdate , simulation_api::entity::EgoEntity::onUpdate","title":"function onUpdate"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-getvisibility","text":"bool getVisibility ()","title":"function getVisibility"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-getstatus","text":"const openscenario_msgs :: msg :: EntityStatus getStatus () const","title":"function getStatus"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-getstandstillduration","text":"boost :: optional < double > getStandStillDuration () const","title":"function getStandStillDuration"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-getlinearjerk","text":"inline boost :: optional < double > getLinearJerk () const","title":"function getLinearJerk"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-getcurrentaction","text":"virtual const std :: string getCurrentAction () const = 0 Reimplemented by : simulation_api::entity::PedestrianEntity::getCurrentAction , simulation_api::entity::VehicleEntity::getCurrentAction , simulation_api::entity::EgoEntity::getCurrentAction","title":"function getCurrentAction"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-getboundingbox","text":"virtual const openscenario_msgs :: msg :: BoundingBox getBoundingBox () const = 0 Reimplemented by : simulation_api::entity::PedestrianEntity::getBoundingBox , simulation_api::entity::VehicleEntity::getBoundingBox","title":"function getBoundingBox"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-entitybase_1","text":"EntityBase ( std :: string type , std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state )","title":"function EntityBase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#function-entitybase_2","text":"EntityBase ( std :: string type , std :: string name )","title":"function EntityBase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#variable-type","text":"const std :: string type ;","title":"variable type"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#variable-name","text":"const std :: string name ;","title":"variable name"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#variable-waypoints_","text":"std :: queue < openscenario_msgs :: msg :: LaneletPose > waypoints_ ;","title":"variable waypoints_"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#variable-visibility_","text":"bool visibility_ ;","title":"variable visibility_"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#variable-verbose_","text":"bool verbose_ ;","title":"variable verbose_"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#variable-traffic_light_manager_","text":"std :: shared_ptr < simulation_api :: TrafficLightManager > traffic_light_manager_ ;","title":"variable traffic_light_manager_"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#variable-status_","text":"boost :: optional < openscenario_msgs :: msg :: EntityStatus > status_ ;","title":"variable status_"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#variable-stand_still_duration_","text":"boost :: optional < double > stand_still_duration_ ;","title":"variable stand_still_duration_"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#variable-other_status_","text":"std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > other_status_ ;","title":"variable other_status_"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#variable-next_waypoint_","text":"boost :: optional < openscenario_msgs :: msg :: LaneletPose > next_waypoint_ ;","title":"variable next_waypoint_"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#variable-linear_jerk_","text":"boost :: optional < double > linear_jerk_ ;","title":"variable linear_jerk_"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#variable-hdmap_utils_ptr_","text":"std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ptr_ ;","title":"variable hdmap_utils_ptr_"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#variable-entity_type_list_","text":"std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > entity_type_list_ ;","title":"variable entity_type_list_"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityBase/#variable-current_marker_","text":"visualization_msgs :: msg :: MarkerArray current_marker_ ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable current_marker_"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/","text":"simulation_api::entity::EntityManager # Public Functions # Name ~EntityManager () =default void updateHdmapMarker () void update (const double current_time, const double step_time) const geometry_msgs::msg::Pose toMapPose (const openscenario_msgs::msg::LaneletPose & lanelet_pose) const template \\<typename Entity ,typename =typename std::enable_if< std::is_base_of ::type>::value >::type> bool spawnEntity (Entity && entity) void setVerbose (bool verbose) void setTargetSpeed (const std::string & name, const double target_speed, const bool continuous) bool setEntityStatus (const std::string & name, openscenario_msgs::msg::EntityStatus status) void setDriverModel (const std::string & name, const openscenario_msgs::msg::DriverModel & model) void requestWalkStraight (const std::string & name) void requestLaneChange (const std::string & name, std::int64_t to_lanelet_id) void requestLaneChange (const std::string & name, const Direction & direction) void requestAssignRoute (const std::string & name, const std::vector< openscenario_msgs::msg::LaneletPose > & waypoints) void requestAcquirePosition (const std::string & name, const openscenario_msgs::msg::LaneletPose & lanelet_pose) decltype(auto) reference (const std::string & name) bool reachPosition (const std::string & name, const geometry_msgs::msg::Pose & target_pose, const double tolerance) const bool reachPosition (const std::string & name, const std::int64_t lanelet_id, const double s, const double offset, const double tolerance) const bool reachPosition (const std::string & name, const std::string & target_name, const double tolerance) const bool isStopping (const std::string & name) const bool isInLanelet (const std::string & name, const std::int64_t lanelet_id, const double tolerance) bool isEgo (const std::string & name) const openscenario_msgs::msg::WaypointsArray getWaypoints (const std::string & name) const boost::optional< openscenario_msgs::msg::VehicleParameters > getVehicleParameters (const std::string & name) const double getStepTime () const const boost::optional< double > getStandStillDuration (const std::string & name) const boost::optional< double > getSValueInRoute (const std::string & name, const std::vector< std::int64_t > & route) std::vector< std::int64_t > getRouteLanelets (const std::string & name, const double horizon) geometry_msgs::msg::Pose getRelativePose (const std::string & from, const std::string & to) geometry_msgs::msg::Pose getRelativePose (const std::string & from, const geometry_msgs::msg::Pose & to) geometry_msgs::msg::Pose getRelativePose (const geometry_msgs::msg::Pose & from, const std::string & to) geometry_msgs::msg::Pose getRelativePose (const geometry_msgs::msg::Pose & from, const geometry_msgs::msg::Pose & to) const boost::optional< openscenario_msgs::msg::Obstacle > getObstacle (const std::string & name) geometry_msgs::msg::Pose getMapPose (const std::string & entity_name) geometry_msgs::msg::Pose getMapPose (const std::string & reference_entity_name, const geometry_msgs::msg::Pose & relative_pose) boost::optional< double > getLongitudinalDistance (const std::string & from, const std::string & to, const double max_distance =100) boost::optional< double > getLinearJerk (const std::string & name) const boost::optional< openscenario_msgs::msg::LaneletPose > getLaneletPose (const std::string & name) const std::shared_ptr< hdmap_utils::HdMapUtils > getHdmapUtils () const std::unordered_map< std::string, openscenario_msgs::msg::EntityType > getEntityTypeList () const openscenario_msgs::msg::EntityType getEntityType (const std::string & name) const const boost::optional< openscenario_msgs::msg::EntityStatus > getEntityStatus (const std::string & name) const const std::vector< std::string > getEntityNames () const boost::optional< double > getDistanceToStopLine (const std::string & name, const std::int64_t target_stop_line_id) boost::optional< double > getDistanceToCrosswalk (const std::string & name, const std::int64_t target_crosswalk_id) double getCurrentTime () const const std::string getCurrentAction (const std::string & name) const std::vector< std::int64_t > getConflictingEntityOnRouteLanelets (const std::string & name, const double horizon) boost::optional< double > getBoundingBoxDistance (const std::string & from, const std::string & to) const openscenario_msgs::msg::BoundingBox getBoundingBox (const std::string & name) const bool entityStatusSetted (const std::string & name) const bool entityExists (const std::string & name) bool despawnEntity (const std::string & name) bool checkCollision (const std::string & name0, const std::string & name1) void broadcastTransform (const geometry_msgs::msg::PoseStamped & pose, const bool static_transform =true) void broadcastEntityTransform () void broadcastBaseLinkTransform () FORWARD_TO_HDMAP_UTILS (toLaneletPose ) template \\<class NodeT ,class AllocatorT =std::allocator > EntityManager (NodeT && node, const std::string & map_path) DEFINE_SET_TRAFFIC_LIGHT (Arrow ) DEFINE_SET_TRAFFIC_LIGHT (ArrowPhase ) DEFINE_SET_TRAFFIC_LIGHT (Color ) DEFINE_SET_TRAFFIC_LIGHT (ColorPhase ) DEFINE_GET_TRAFFIC_LIGHT (Color ) DEFINE_GET_TRAFFIC_LIGHT (Arrow ) Public Functions Documentation # function ~EntityManager # ~ EntityManager () = default function updateHdmapMarker # inline void updateHdmapMarker () function update # void update ( const double current_time , const double step_time ) function toMapPose # const geometry_msgs :: msg :: Pose toMapPose ( const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ) const function spawnEntity # template < typename Entity , typename = typename std :: enable_if < std :: is_base_of < EntityBase , typename std :: decay < Entity >:: type >:: value >:: type > inline bool spawnEntity ( Entity && entity ) function setVerbose # void setVerbose ( bool verbose ) function setTargetSpeed # void setTargetSpeed ( const std :: string & name , const double target_speed , const bool continuous ) function setEntityStatus # bool setEntityStatus ( const std :: string & name , openscenario_msgs :: msg :: EntityStatus status ) function setDriverModel # void setDriverModel ( const std :: string & name , const openscenario_msgs :: msg :: DriverModel & model ) function requestWalkStraight # void requestWalkStraight ( const std :: string & name ) function requestLaneChange # void requestLaneChange ( const std :: string & name , std :: int64_t to_lanelet_id ) function requestLaneChange # void requestLaneChange ( const std :: string & name , const Direction & direction ) function requestAssignRoute # void requestAssignRoute ( const std :: string & name , const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) function requestAcquirePosition # void requestAcquirePosition ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ) function reference # inline decltype ( auto ) reference ( const std :: string & name ) function reachPosition # bool reachPosition ( const std :: string & name , const geometry_msgs :: msg :: Pose & target_pose , const double tolerance ) const function reachPosition # bool reachPosition ( const std :: string & name , const std :: int64_t lanelet_id , const double s , const double offset , const double tolerance ) const function reachPosition # bool reachPosition ( const std :: string & name , const std :: string & target_name , const double tolerance ) const function isStopping # bool isStopping ( const std :: string & name ) const function isInLanelet # bool isInLanelet ( const std :: string & name , const std :: int64_t lanelet_id , const double tolerance ) function isEgo # bool isEgo ( const std :: string & name ) const function getWaypoints # openscenario_msgs :: msg :: WaypointsArray getWaypoints ( const std :: string & name ) function getVehicleParameters # const boost :: optional < openscenario_msgs :: msg :: VehicleParameters > getVehicleParameters ( const std :: string & name ) const function getStepTime # double getStepTime () const function getStandStillDuration # const boost :: optional < double > getStandStillDuration ( const std :: string & name ) const function getSValueInRoute # boost :: optional < double > getSValueInRoute ( const std :: string & name , const std :: vector < std :: int64_t > & route ) function getRouteLanelets # std :: vector < std :: int64_t > getRouteLanelets ( const std :: string & name , const double horizon ) function getRelativePose # geometry_msgs :: msg :: Pose getRelativePose ( const std :: string & from , const std :: string & to ) function getRelativePose # geometry_msgs :: msg :: Pose getRelativePose ( const std :: string & from , const geometry_msgs :: msg :: Pose & to ) function getRelativePose # geometry_msgs :: msg :: Pose getRelativePose ( const geometry_msgs :: msg :: Pose & from , const std :: string & to ) function getRelativePose # geometry_msgs :: msg :: Pose getRelativePose ( const geometry_msgs :: msg :: Pose & from , const geometry_msgs :: msg :: Pose & to ) const function getObstacle # boost :: optional < openscenario_msgs :: msg :: Obstacle > getObstacle ( const std :: string & name ) function getMapPose # geometry_msgs :: msg :: Pose getMapPose ( const std :: string & entity_name ) function getMapPose # geometry_msgs :: msg :: Pose getMapPose ( const std :: string & reference_entity_name , const geometry_msgs :: msg :: Pose & relative_pose ) function getLongitudinalDistance # boost :: optional < double > getLongitudinalDistance ( const std :: string & from , const std :: string & to , const double max_distance = 100 ) function getLinearJerk # boost :: optional < double > getLinearJerk ( const std :: string & name ) const function getLaneletPose # boost :: optional < openscenario_msgs :: msg :: LaneletPose > getLaneletPose ( const std :: string & name ) function getHdmapUtils # const std :: shared_ptr < hdmap_utils :: HdMapUtils > getHdmapUtils () function getEntityTypeList # const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > getEntityTypeList () const function getEntityType # openscenario_msgs :: msg :: EntityType getEntityType ( const std :: string & name ) const function getEntityStatus # const boost :: optional < openscenario_msgs :: msg :: EntityStatus > getEntityStatus ( const std :: string & name ) const function getEntityNames # const std :: vector < std :: string > getEntityNames () const function getDistanceToStopLine # boost :: optional < double > getDistanceToStopLine ( const std :: string & name , const std :: int64_t target_stop_line_id ) function getDistanceToCrosswalk # boost :: optional < double > getDistanceToCrosswalk ( const std :: string & name , const std :: int64_t target_crosswalk_id ) function getCurrentTime # double getCurrentTime () const function getCurrentAction # const std :: string getCurrentAction ( const std :: string & name ) const function getConflictingEntityOnRouteLanelets # std :: vector < std :: int64_t > getConflictingEntityOnRouteLanelets ( const std :: string & name , const double horizon ) function getBoundingBoxDistance # boost :: optional < double > getBoundingBoxDistance ( const std :: string & from , const std :: string & to ) Parameters : from from entity name to to entity name Returns : boost::none bounding box is intersects 0 <= distance between two bounding box function getBoundingBox # const openscenario_msgs :: msg :: BoundingBox getBoundingBox ( const std :: string & name ) const function entityStatusSetted # bool entityStatusSetted ( const std :: string & name ) const function entityExists # inline bool entityExists ( const std :: string & name ) function despawnEntity # inline bool despawnEntity ( const std :: string & name ) function checkCollision # bool checkCollision ( const std :: string & name0 , const std :: string & name1 ) function broadcastTransform # void broadcastTransform ( const geometry_msgs :: msg :: PoseStamped & pose , const bool static_transform = true ) function broadcastEntityTransform # void broadcastEntityTransform () function broadcastBaseLinkTransform # void broadcastBaseLinkTransform () function FORWARD_TO_HDMAP_UTILS # FORWARD_TO_HDMAP_UTILS ( toLaneletPose ) function EntityManager # template < class NodeT , class AllocatorT = std :: allocator < void >> inline explicit EntityManager ( NodeT && node , const std :: string & map_path ) function DEFINE_SET_TRAFFIC_LIGHT # DEFINE_SET_TRAFFIC_LIGHT ( Arrow ) function DEFINE_SET_TRAFFIC_LIGHT # DEFINE_SET_TRAFFIC_LIGHT ( ArrowPhase ) function DEFINE_SET_TRAFFIC_LIGHT # DEFINE_SET_TRAFFIC_LIGHT ( Color ) function DEFINE_SET_TRAFFIC_LIGHT # DEFINE_SET_TRAFFIC_LIGHT ( ColorPhase ) function DEFINE_GET_TRAFFIC_LIGHT # DEFINE_GET_TRAFFIC_LIGHT ( Color ) function DEFINE_GET_TRAFFIC_LIGHT # DEFINE_GET_TRAFFIC_LIGHT ( Arrow ) Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity::EntityManager"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#simulation_apientityentitymanager","text":"","title":"simulation_api::entity::EntityManager"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#public-functions","text":"Name ~EntityManager () =default void updateHdmapMarker () void update (const double current_time, const double step_time) const geometry_msgs::msg::Pose toMapPose (const openscenario_msgs::msg::LaneletPose & lanelet_pose) const template \\<typename Entity ,typename =typename std::enable_if< std::is_base_of ::type>::value >::type> bool spawnEntity (Entity && entity) void setVerbose (bool verbose) void setTargetSpeed (const std::string & name, const double target_speed, const bool continuous) bool setEntityStatus (const std::string & name, openscenario_msgs::msg::EntityStatus status) void setDriverModel (const std::string & name, const openscenario_msgs::msg::DriverModel & model) void requestWalkStraight (const std::string & name) void requestLaneChange (const std::string & name, std::int64_t to_lanelet_id) void requestLaneChange (const std::string & name, const Direction & direction) void requestAssignRoute (const std::string & name, const std::vector< openscenario_msgs::msg::LaneletPose > & waypoints) void requestAcquirePosition (const std::string & name, const openscenario_msgs::msg::LaneletPose & lanelet_pose) decltype(auto) reference (const std::string & name) bool reachPosition (const std::string & name, const geometry_msgs::msg::Pose & target_pose, const double tolerance) const bool reachPosition (const std::string & name, const std::int64_t lanelet_id, const double s, const double offset, const double tolerance) const bool reachPosition (const std::string & name, const std::string & target_name, const double tolerance) const bool isStopping (const std::string & name) const bool isInLanelet (const std::string & name, const std::int64_t lanelet_id, const double tolerance) bool isEgo (const std::string & name) const openscenario_msgs::msg::WaypointsArray getWaypoints (const std::string & name) const boost::optional< openscenario_msgs::msg::VehicleParameters > getVehicleParameters (const std::string & name) const double getStepTime () const const boost::optional< double > getStandStillDuration (const std::string & name) const boost::optional< double > getSValueInRoute (const std::string & name, const std::vector< std::int64_t > & route) std::vector< std::int64_t > getRouteLanelets (const std::string & name, const double horizon) geometry_msgs::msg::Pose getRelativePose (const std::string & from, const std::string & to) geometry_msgs::msg::Pose getRelativePose (const std::string & from, const geometry_msgs::msg::Pose & to) geometry_msgs::msg::Pose getRelativePose (const geometry_msgs::msg::Pose & from, const std::string & to) geometry_msgs::msg::Pose getRelativePose (const geometry_msgs::msg::Pose & from, const geometry_msgs::msg::Pose & to) const boost::optional< openscenario_msgs::msg::Obstacle > getObstacle (const std::string & name) geometry_msgs::msg::Pose getMapPose (const std::string & entity_name) geometry_msgs::msg::Pose getMapPose (const std::string & reference_entity_name, const geometry_msgs::msg::Pose & relative_pose) boost::optional< double > getLongitudinalDistance (const std::string & from, const std::string & to, const double max_distance =100) boost::optional< double > getLinearJerk (const std::string & name) const boost::optional< openscenario_msgs::msg::LaneletPose > getLaneletPose (const std::string & name) const std::shared_ptr< hdmap_utils::HdMapUtils > getHdmapUtils () const std::unordered_map< std::string, openscenario_msgs::msg::EntityType > getEntityTypeList () const openscenario_msgs::msg::EntityType getEntityType (const std::string & name) const const boost::optional< openscenario_msgs::msg::EntityStatus > getEntityStatus (const std::string & name) const const std::vector< std::string > getEntityNames () const boost::optional< double > getDistanceToStopLine (const std::string & name, const std::int64_t target_stop_line_id) boost::optional< double > getDistanceToCrosswalk (const std::string & name, const std::int64_t target_crosswalk_id) double getCurrentTime () const const std::string getCurrentAction (const std::string & name) const std::vector< std::int64_t > getConflictingEntityOnRouteLanelets (const std::string & name, const double horizon) boost::optional< double > getBoundingBoxDistance (const std::string & from, const std::string & to) const openscenario_msgs::msg::BoundingBox getBoundingBox (const std::string & name) const bool entityStatusSetted (const std::string & name) const bool entityExists (const std::string & name) bool despawnEntity (const std::string & name) bool checkCollision (const std::string & name0, const std::string & name1) void broadcastTransform (const geometry_msgs::msg::PoseStamped & pose, const bool static_transform =true) void broadcastEntityTransform () void broadcastBaseLinkTransform () FORWARD_TO_HDMAP_UTILS (toLaneletPose ) template \\<class NodeT ,class AllocatorT =std::allocator > EntityManager (NodeT && node, const std::string & map_path) DEFINE_SET_TRAFFIC_LIGHT (Arrow ) DEFINE_SET_TRAFFIC_LIGHT (ArrowPhase ) DEFINE_SET_TRAFFIC_LIGHT (Color ) DEFINE_SET_TRAFFIC_LIGHT (ColorPhase ) DEFINE_GET_TRAFFIC_LIGHT (Color ) DEFINE_GET_TRAFFIC_LIGHT (Arrow )","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-entitymanager","text":"~ EntityManager () = default","title":"function ~EntityManager"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-updatehdmapmarker","text":"inline void updateHdmapMarker ()","title":"function updateHdmapMarker"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-update","text":"void update ( const double current_time , const double step_time )","title":"function update"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-tomappose","text":"const geometry_msgs :: msg :: Pose toMapPose ( const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ) const","title":"function toMapPose"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-spawnentity","text":"template < typename Entity , typename = typename std :: enable_if < std :: is_base_of < EntityBase , typename std :: decay < Entity >:: type >:: value >:: type > inline bool spawnEntity ( Entity && entity )","title":"function spawnEntity"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-setverbose","text":"void setVerbose ( bool verbose )","title":"function setVerbose"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-settargetspeed","text":"void setTargetSpeed ( const std :: string & name , const double target_speed , const bool continuous )","title":"function setTargetSpeed"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-setentitystatus","text":"bool setEntityStatus ( const std :: string & name , openscenario_msgs :: msg :: EntityStatus status )","title":"function setEntityStatus"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-setdrivermodel","text":"void setDriverModel ( const std :: string & name , const openscenario_msgs :: msg :: DriverModel & model )","title":"function setDriverModel"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-requestwalkstraight","text":"void requestWalkStraight ( const std :: string & name )","title":"function requestWalkStraight"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-requestlanechange","text":"void requestLaneChange ( const std :: string & name , std :: int64_t to_lanelet_id )","title":"function requestLaneChange"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-requestlanechange_1","text":"void requestLaneChange ( const std :: string & name , const Direction & direction )","title":"function requestLaneChange"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-requestassignroute","text":"void requestAssignRoute ( const std :: string & name , const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints )","title":"function requestAssignRoute"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-requestacquireposition","text":"void requestAcquirePosition ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & lanelet_pose )","title":"function requestAcquirePosition"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-reference","text":"inline decltype ( auto ) reference ( const std :: string & name )","title":"function reference"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-reachposition","text":"bool reachPosition ( const std :: string & name , const geometry_msgs :: msg :: Pose & target_pose , const double tolerance ) const","title":"function reachPosition"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-reachposition_1","text":"bool reachPosition ( const std :: string & name , const std :: int64_t lanelet_id , const double s , const double offset , const double tolerance ) const","title":"function reachPosition"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-reachposition_2","text":"bool reachPosition ( const std :: string & name , const std :: string & target_name , const double tolerance ) const","title":"function reachPosition"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-isstopping","text":"bool isStopping ( const std :: string & name ) const","title":"function isStopping"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-isinlanelet","text":"bool isInLanelet ( const std :: string & name , const std :: int64_t lanelet_id , const double tolerance )","title":"function isInLanelet"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-isego","text":"bool isEgo ( const std :: string & name ) const","title":"function isEgo"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getwaypoints","text":"openscenario_msgs :: msg :: WaypointsArray getWaypoints ( const std :: string & name )","title":"function getWaypoints"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getvehicleparameters","text":"const boost :: optional < openscenario_msgs :: msg :: VehicleParameters > getVehicleParameters ( const std :: string & name ) const","title":"function getVehicleParameters"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getsteptime","text":"double getStepTime () const","title":"function getStepTime"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getstandstillduration","text":"const boost :: optional < double > getStandStillDuration ( const std :: string & name ) const","title":"function getStandStillDuration"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getsvalueinroute","text":"boost :: optional < double > getSValueInRoute ( const std :: string & name , const std :: vector < std :: int64_t > & route )","title":"function getSValueInRoute"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getroutelanelets","text":"std :: vector < std :: int64_t > getRouteLanelets ( const std :: string & name , const double horizon )","title":"function getRouteLanelets"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getrelativepose","text":"geometry_msgs :: msg :: Pose getRelativePose ( const std :: string & from , const std :: string & to )","title":"function getRelativePose"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getrelativepose_1","text":"geometry_msgs :: msg :: Pose getRelativePose ( const std :: string & from , const geometry_msgs :: msg :: Pose & to )","title":"function getRelativePose"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getrelativepose_2","text":"geometry_msgs :: msg :: Pose getRelativePose ( const geometry_msgs :: msg :: Pose & from , const std :: string & to )","title":"function getRelativePose"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getrelativepose_3","text":"geometry_msgs :: msg :: Pose getRelativePose ( const geometry_msgs :: msg :: Pose & from , const geometry_msgs :: msg :: Pose & to ) const","title":"function getRelativePose"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getobstacle","text":"boost :: optional < openscenario_msgs :: msg :: Obstacle > getObstacle ( const std :: string & name )","title":"function getObstacle"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getmappose","text":"geometry_msgs :: msg :: Pose getMapPose ( const std :: string & entity_name )","title":"function getMapPose"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getmappose_1","text":"geometry_msgs :: msg :: Pose getMapPose ( const std :: string & reference_entity_name , const geometry_msgs :: msg :: Pose & relative_pose )","title":"function getMapPose"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getlongitudinaldistance","text":"boost :: optional < double > getLongitudinalDistance ( const std :: string & from , const std :: string & to , const double max_distance = 100 )","title":"function getLongitudinalDistance"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getlinearjerk","text":"boost :: optional < double > getLinearJerk ( const std :: string & name ) const","title":"function getLinearJerk"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getlaneletpose","text":"boost :: optional < openscenario_msgs :: msg :: LaneletPose > getLaneletPose ( const std :: string & name )","title":"function getLaneletPose"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-gethdmaputils","text":"const std :: shared_ptr < hdmap_utils :: HdMapUtils > getHdmapUtils ()","title":"function getHdmapUtils"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getentitytypelist","text":"const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > getEntityTypeList () const","title":"function getEntityTypeList"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getentitytype","text":"openscenario_msgs :: msg :: EntityType getEntityType ( const std :: string & name ) const","title":"function getEntityType"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getentitystatus","text":"const boost :: optional < openscenario_msgs :: msg :: EntityStatus > getEntityStatus ( const std :: string & name ) const","title":"function getEntityStatus"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getentitynames","text":"const std :: vector < std :: string > getEntityNames () const","title":"function getEntityNames"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getdistancetostopline","text":"boost :: optional < double > getDistanceToStopLine ( const std :: string & name , const std :: int64_t target_stop_line_id )","title":"function getDistanceToStopLine"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getdistancetocrosswalk","text":"boost :: optional < double > getDistanceToCrosswalk ( const std :: string & name , const std :: int64_t target_crosswalk_id )","title":"function getDistanceToCrosswalk"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getcurrenttime","text":"double getCurrentTime () const","title":"function getCurrentTime"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getcurrentaction","text":"const std :: string getCurrentAction ( const std :: string & name ) const","title":"function getCurrentAction"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getconflictingentityonroutelanelets","text":"std :: vector < std :: int64_t > getConflictingEntityOnRouteLanelets ( const std :: string & name , const double horizon )","title":"function getConflictingEntityOnRouteLanelets"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getboundingboxdistance","text":"boost :: optional < double > getBoundingBoxDistance ( const std :: string & from , const std :: string & to ) Parameters : from from entity name to to entity name Returns : boost::none bounding box is intersects 0 <= distance between two bounding box","title":"function getBoundingBoxDistance"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-getboundingbox","text":"const openscenario_msgs :: msg :: BoundingBox getBoundingBox ( const std :: string & name ) const","title":"function getBoundingBox"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-entitystatussetted","text":"bool entityStatusSetted ( const std :: string & name ) const","title":"function entityStatusSetted"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-entityexists","text":"inline bool entityExists ( const std :: string & name )","title":"function entityExists"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-despawnentity","text":"inline bool despawnEntity ( const std :: string & name )","title":"function despawnEntity"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-checkcollision","text":"bool checkCollision ( const std :: string & name0 , const std :: string & name1 )","title":"function checkCollision"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-broadcasttransform","text":"void broadcastTransform ( const geometry_msgs :: msg :: PoseStamped & pose , const bool static_transform = true )","title":"function broadcastTransform"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-broadcastentitytransform","text":"void broadcastEntityTransform ()","title":"function broadcastEntityTransform"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-broadcastbaselinktransform","text":"void broadcastBaseLinkTransform ()","title":"function broadcastBaseLinkTransform"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-forward_to_hdmap_utils","text":"FORWARD_TO_HDMAP_UTILS ( toLaneletPose )","title":"function FORWARD_TO_HDMAP_UTILS"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-entitymanager_1","text":"template < class NodeT , class AllocatorT = std :: allocator < void >> inline explicit EntityManager ( NodeT && node , const std :: string & map_path )","title":"function EntityManager"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-define_set_traffic_light","text":"DEFINE_SET_TRAFFIC_LIGHT ( Arrow )","title":"function DEFINE_SET_TRAFFIC_LIGHT"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-define_set_traffic_light_1","text":"DEFINE_SET_TRAFFIC_LIGHT ( ArrowPhase )","title":"function DEFINE_SET_TRAFFIC_LIGHT"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-define_set_traffic_light_2","text":"DEFINE_SET_TRAFFIC_LIGHT ( Color )","title":"function DEFINE_SET_TRAFFIC_LIGHT"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-define_set_traffic_light_3","text":"DEFINE_SET_TRAFFIC_LIGHT ( ColorPhase )","title":"function DEFINE_SET_TRAFFIC_LIGHT"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-define_get_traffic_light","text":"DEFINE_GET_TRAFFIC_LIGHT ( Color )","title":"function DEFINE_GET_TRAFFIC_LIGHT"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityManager/#function-define_get_traffic_light_1","text":"DEFINE_GET_TRAFFIC_LIGHT ( Arrow ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function DEFINE_GET_TRAFFIC_LIGHT"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityMarkerQoS/","text":"simulation_api::entity::EntityMarkerQoS # Inherits from QoS Public Functions # Name EntityMarkerQoS (std::size_t depth =100) Public Functions Documentation # function EntityMarkerQoS # inline explicit EntityMarkerQoS ( std :: size_t depth = 100 ) Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity::EntityMarkerQoS"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityMarkerQoS/#simulation_apientityentitymarkerqos","text":"Inherits from QoS","title":"simulation_api::entity::EntityMarkerQoS"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityMarkerQoS/#public-functions","text":"Name EntityMarkerQoS (std::size_t depth =100)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityMarkerQoS/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1EntityMarkerQoS/#function-entitymarkerqos","text":"inline explicit EntityMarkerQoS ( std :: size_t depth = 100 ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function EntityMarkerQoS"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1LaneletMarkerQoS/","text":"simulation_api::entity::LaneletMarkerQoS # Inherits from QoS Public Functions # Name LaneletMarkerQoS (std::size_t depth =1) Public Functions Documentation # function LaneletMarkerQoS # inline explicit LaneletMarkerQoS ( std :: size_t depth = 1 ) Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity::LaneletMarkerQoS"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1LaneletMarkerQoS/#simulation_apientitylaneletmarkerqos","text":"Inherits from QoS","title":"simulation_api::entity::LaneletMarkerQoS"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1LaneletMarkerQoS/#public-functions","text":"Name LaneletMarkerQoS (std::size_t depth =1)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1LaneletMarkerQoS/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1LaneletMarkerQoS/#function-laneletmarkerqos","text":"inline explicit LaneletMarkerQoS ( std :: size_t depth = 1 ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function LaneletMarkerQoS"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/","text":"simulation_api::entity::PedestrianEntity # Inherits from simulation_api::entity::EntityBase Public Functions # Name void setTrafficLightManager (std::shared_ptr< simulation_api::TrafficLightManager > ptr) void setTargetSpeed (double target_speed, bool continuous) void setHdMapUtils (std::shared_ptr< hdmap_utils::HdMapUtils > ptr) void requestWalkStraight () virtual void requestAssignRoute (const std::vector< openscenario_msgs::msg::LaneletPose > & waypoints) override void requestAcquirePosition (openscenario_msgs::msg::LaneletPose lanelet_pose) virtual void onUpdate (double current_time, double step_time) override std::vector< std::int64_t > getRouteLanelets (double horizon =100) virtual const std::string getCurrentAction () const virtual const openscenario_msgs::msg::BoundingBox getBoundingBox () const override void cancelRequest () PedestrianEntity (std::string name, const openscenario_msgs::msg::EntityStatus & initial_state, openscenario_msgs::msg::PedestrianParameters parameters) PedestrianEntity (std::string name, openscenario_msgs::msg::PedestrianParameters parameters) Public Attributes # Name const openscenario_msgs::msg::PedestrianParameters parameters Additional inherited members # Public Functions inherited from simulation_api::entity::EntityBase Name virtual ~EntityBase () =default void updateStandStillDuration (double step_time) void stopAtEndOfRoad () bool statusSetted () const bool setVisibility (bool visibility) void setVerbose (bool verbose) bool setStatus (const openscenario_msgs::msg::EntityStatus & status) void setOtherStatus (const std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > & status) void setEntityTypeList (const std::unordered_map< std::string, openscenario_msgs::msg::EntityType > & entity_type_list) bool getVisibility () const openscenario_msgs::msg::EntityStatus getStatus () const boost::optional< double > getStandStillDuration () const boost::optional< double > getLinearJerk () const EntityBase (std::string type, std::string name, const openscenario_msgs::msg::EntityStatus & initial_state) EntityBase (std::string type, std::string name) Public Attributes inherited from simulation_api::entity::EntityBase Name const std::string type const std::string name Protected Attributes inherited from simulation_api::entity::EntityBase Name std::queue< openscenario_msgs::msg::LaneletPose > waypoints_ bool visibility_ bool verbose_ std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager_ boost::optional< openscenario_msgs::msg::EntityStatus > status_ boost::optional< double > stand_still_duration_ std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_status_ boost::optional< openscenario_msgs::msg::LaneletPose > next_waypoint_ boost::optional< double > linear_jerk_ std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils_ptr_ std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list_ visualization_msgs::msg::MarkerArray current_marker_ Public Functions Documentation # function setTrafficLightManager # inline void setTrafficLightManager ( std :: shared_ptr < simulation_api :: TrafficLightManager > ptr ) function setTargetSpeed # void setTargetSpeed ( double target_speed , bool continuous ) function setHdMapUtils # inline void setHdMapUtils ( std :: shared_ptr < hdmap_utils :: HdMapUtils > ptr ) function requestWalkStraight # void requestWalkStraight () function requestAssignRoute # virtual void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) override Reimplements : simulation_api::entity::EntityBase::requestAssignRoute function requestAcquirePosition # void requestAcquirePosition ( openscenario_msgs :: msg :: LaneletPose lanelet_pose ) function onUpdate # virtual void onUpdate ( double current_time , double step_time ) override Reimplements : simulation_api::entity::EntityBase::onUpdate function getRouteLanelets # inline std :: vector < std :: int64_t > getRouteLanelets ( double horizon = 100 ) function getCurrentAction # inline virtual const std :: string getCurrentAction () const Reimplements : simulation_api::entity::EntityBase::getCurrentAction function getBoundingBox # inline virtual const openscenario_msgs :: msg :: BoundingBox getBoundingBox () const override Reimplements : simulation_api::entity::EntityBase::getBoundingBox function cancelRequest # void cancelRequest () function PedestrianEntity # PedestrianEntity ( std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state , openscenario_msgs :: msg :: PedestrianParameters parameters ) function PedestrianEntity # PedestrianEntity ( std :: string name , openscenario_msgs :: msg :: PedestrianParameters parameters ) Public Attributes Documentation # variable parameters # const openscenario_msgs :: msg :: PedestrianParameters parameters ; Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity::PedestrianEntity"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#simulation_apientitypedestrianentity","text":"Inherits from simulation_api::entity::EntityBase","title":"simulation_api::entity::PedestrianEntity"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#public-functions","text":"Name void setTrafficLightManager (std::shared_ptr< simulation_api::TrafficLightManager > ptr) void setTargetSpeed (double target_speed, bool continuous) void setHdMapUtils (std::shared_ptr< hdmap_utils::HdMapUtils > ptr) void requestWalkStraight () virtual void requestAssignRoute (const std::vector< openscenario_msgs::msg::LaneletPose > & waypoints) override void requestAcquirePosition (openscenario_msgs::msg::LaneletPose lanelet_pose) virtual void onUpdate (double current_time, double step_time) override std::vector< std::int64_t > getRouteLanelets (double horizon =100) virtual const std::string getCurrentAction () const virtual const openscenario_msgs::msg::BoundingBox getBoundingBox () const override void cancelRequest () PedestrianEntity (std::string name, const openscenario_msgs::msg::EntityStatus & initial_state, openscenario_msgs::msg::PedestrianParameters parameters) PedestrianEntity (std::string name, openscenario_msgs::msg::PedestrianParameters parameters)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#public-attributes","text":"Name const openscenario_msgs::msg::PedestrianParameters parameters","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#additional-inherited-members","text":"Public Functions inherited from simulation_api::entity::EntityBase Name virtual ~EntityBase () =default void updateStandStillDuration (double step_time) void stopAtEndOfRoad () bool statusSetted () const bool setVisibility (bool visibility) void setVerbose (bool verbose) bool setStatus (const openscenario_msgs::msg::EntityStatus & status) void setOtherStatus (const std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > & status) void setEntityTypeList (const std::unordered_map< std::string, openscenario_msgs::msg::EntityType > & entity_type_list) bool getVisibility () const openscenario_msgs::msg::EntityStatus getStatus () const boost::optional< double > getStandStillDuration () const boost::optional< double > getLinearJerk () const EntityBase (std::string type, std::string name, const openscenario_msgs::msg::EntityStatus & initial_state) EntityBase (std::string type, std::string name) Public Attributes inherited from simulation_api::entity::EntityBase Name const std::string type const std::string name Protected Attributes inherited from simulation_api::entity::EntityBase Name std::queue< openscenario_msgs::msg::LaneletPose > waypoints_ bool visibility_ bool verbose_ std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager_ boost::optional< openscenario_msgs::msg::EntityStatus > status_ boost::optional< double > stand_still_duration_ std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_status_ boost::optional< openscenario_msgs::msg::LaneletPose > next_waypoint_ boost::optional< double > linear_jerk_ std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils_ptr_ std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list_ visualization_msgs::msg::MarkerArray current_marker_","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#function-settrafficlightmanager","text":"inline void setTrafficLightManager ( std :: shared_ptr < simulation_api :: TrafficLightManager > ptr )","title":"function setTrafficLightManager"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#function-settargetspeed","text":"void setTargetSpeed ( double target_speed , bool continuous )","title":"function setTargetSpeed"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#function-sethdmaputils","text":"inline void setHdMapUtils ( std :: shared_ptr < hdmap_utils :: HdMapUtils > ptr )","title":"function setHdMapUtils"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#function-requestwalkstraight","text":"void requestWalkStraight ()","title":"function requestWalkStraight"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#function-requestassignroute","text":"virtual void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) override Reimplements : simulation_api::entity::EntityBase::requestAssignRoute","title":"function requestAssignRoute"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#function-requestacquireposition","text":"void requestAcquirePosition ( openscenario_msgs :: msg :: LaneletPose lanelet_pose )","title":"function requestAcquirePosition"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#function-onupdate","text":"virtual void onUpdate ( double current_time , double step_time ) override Reimplements : simulation_api::entity::EntityBase::onUpdate","title":"function onUpdate"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#function-getroutelanelets","text":"inline std :: vector < std :: int64_t > getRouteLanelets ( double horizon = 100 )","title":"function getRouteLanelets"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#function-getcurrentaction","text":"inline virtual const std :: string getCurrentAction () const Reimplements : simulation_api::entity::EntityBase::getCurrentAction","title":"function getCurrentAction"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#function-getboundingbox","text":"inline virtual const openscenario_msgs :: msg :: BoundingBox getBoundingBox () const override Reimplements : simulation_api::entity::EntityBase::getBoundingBox","title":"function getBoundingBox"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#function-cancelrequest","text":"void cancelRequest ()","title":"function cancelRequest"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#function-pedestrianentity","text":"PedestrianEntity ( std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state , openscenario_msgs :: msg :: PedestrianParameters parameters )","title":"function PedestrianEntity"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#function-pedestrianentity_1","text":"PedestrianEntity ( std :: string name , openscenario_msgs :: msg :: PedestrianParameters parameters )","title":"function PedestrianEntity"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1PedestrianEntity/#variable-parameters","text":"const openscenario_msgs :: msg :: PedestrianParameters parameters ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable parameters"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/","text":"simulation_api::entity::VehicleEntity # Inherits from simulation_api::entity::EntityBase Inherited by simulation_api::entity::EgoEntity Public Functions # Name void setTrafficLightManager (std::shared_ptr< simulation_api::TrafficLightManager > ptr) void setTargetSpeed (double target_speed, bool continuous) void setHdMapUtils (std::shared_ptr< hdmap_utils::HdMapUtils > ptr) void setDriverModel (const openscenario_msgs::msg::DriverModel & model) void requestLaneChange (std::int64_t to_lanelet_id) virtual void requestAssignRoute (const std::vector< openscenario_msgs::msg::LaneletPose > & waypoints) override void requestAcquirePosition (openscenario_msgs::msg::LaneletPose lanelet_pose) virtual void onUpdate (double current_time, double step_time) override openscenario_msgs::msg::WaypointsArray getWaypoints () std::vector< std::int64_t > getRouteLanelets (double horizon =100) boost::optional< openscenario_msgs::msg::Obstacle > getObstacle () virtual const std::string getCurrentAction () const virtual const openscenario_msgs::msg::BoundingBox getBoundingBox () const override void cancelRequest () VehicleEntity (std::string name, const openscenario_msgs::msg::EntityStatus & initial_state, openscenario_msgs::msg::VehicleParameters parameters) VehicleEntity (std::string name, openscenario_msgs::msg::VehicleParameters parameters) Public Attributes # Name const openscenario_msgs::msg::VehicleParameters parameters Additional inherited members # Public Functions inherited from simulation_api::entity::EntityBase Name virtual ~EntityBase () =default void updateStandStillDuration (double step_time) void stopAtEndOfRoad () bool statusSetted () const bool setVisibility (bool visibility) void setVerbose (bool verbose) bool setStatus (const openscenario_msgs::msg::EntityStatus & status) void setOtherStatus (const std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > & status) void setEntityTypeList (const std::unordered_map< std::string, openscenario_msgs::msg::EntityType > & entity_type_list) bool getVisibility () const openscenario_msgs::msg::EntityStatus getStatus () const boost::optional< double > getStandStillDuration () const boost::optional< double > getLinearJerk () const EntityBase (std::string type, std::string name, const openscenario_msgs::msg::EntityStatus & initial_state) EntityBase (std::string type, std::string name) Public Attributes inherited from simulation_api::entity::EntityBase Name const std::string type const std::string name Protected Attributes inherited from simulation_api::entity::EntityBase Name std::queue< openscenario_msgs::msg::LaneletPose > waypoints_ bool visibility_ bool verbose_ std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager_ boost::optional< openscenario_msgs::msg::EntityStatus > status_ boost::optional< double > stand_still_duration_ std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_status_ boost::optional< openscenario_msgs::msg::LaneletPose > next_waypoint_ boost::optional< double > linear_jerk_ std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils_ptr_ std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list_ visualization_msgs::msg::MarkerArray current_marker_ Public Functions Documentation # function setTrafficLightManager # inline void setTrafficLightManager ( std :: shared_ptr < simulation_api :: TrafficLightManager > ptr ) function setTargetSpeed # void setTargetSpeed ( double target_speed , bool continuous ) function setHdMapUtils # inline void setHdMapUtils ( std :: shared_ptr < hdmap_utils :: HdMapUtils > ptr ) function setDriverModel # inline void setDriverModel ( const openscenario_msgs :: msg :: DriverModel & model ) function requestLaneChange # void requestLaneChange ( std :: int64_t to_lanelet_id ) function requestAssignRoute # virtual void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) override Reimplements : simulation_api::entity::EntityBase::requestAssignRoute function requestAcquirePosition # void requestAcquirePosition ( openscenario_msgs :: msg :: LaneletPose lanelet_pose ) function onUpdate # virtual void onUpdate ( double current_time , double step_time ) override Reimplements : simulation_api::entity::EntityBase::onUpdate function getWaypoints # inline openscenario_msgs :: msg :: WaypointsArray getWaypoints () function getRouteLanelets # inline std :: vector < std :: int64_t > getRouteLanelets ( double horizon = 100 ) function getObstacle # inline boost :: optional < openscenario_msgs :: msg :: Obstacle > getObstacle () function getCurrentAction # inline virtual const std :: string getCurrentAction () const Reimplements : simulation_api::entity::EntityBase::getCurrentAction function getBoundingBox # inline virtual const openscenario_msgs :: msg :: BoundingBox getBoundingBox () const override Reimplements : simulation_api::entity::EntityBase::getBoundingBox function cancelRequest # void cancelRequest () function VehicleEntity # VehicleEntity ( std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state , openscenario_msgs :: msg :: VehicleParameters parameters ) function VehicleEntity # VehicleEntity ( std :: string name , openscenario_msgs :: msg :: VehicleParameters parameters ) Public Attributes Documentation # variable parameters # const openscenario_msgs :: msg :: VehicleParameters parameters ; Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity::VehicleEntity"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#simulation_apientityvehicleentity","text":"Inherits from simulation_api::entity::EntityBase Inherited by simulation_api::entity::EgoEntity","title":"simulation_api::entity::VehicleEntity"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#public-functions","text":"Name void setTrafficLightManager (std::shared_ptr< simulation_api::TrafficLightManager > ptr) void setTargetSpeed (double target_speed, bool continuous) void setHdMapUtils (std::shared_ptr< hdmap_utils::HdMapUtils > ptr) void setDriverModel (const openscenario_msgs::msg::DriverModel & model) void requestLaneChange (std::int64_t to_lanelet_id) virtual void requestAssignRoute (const std::vector< openscenario_msgs::msg::LaneletPose > & waypoints) override void requestAcquirePosition (openscenario_msgs::msg::LaneletPose lanelet_pose) virtual void onUpdate (double current_time, double step_time) override openscenario_msgs::msg::WaypointsArray getWaypoints () std::vector< std::int64_t > getRouteLanelets (double horizon =100) boost::optional< openscenario_msgs::msg::Obstacle > getObstacle () virtual const std::string getCurrentAction () const virtual const openscenario_msgs::msg::BoundingBox getBoundingBox () const override void cancelRequest () VehicleEntity (std::string name, const openscenario_msgs::msg::EntityStatus & initial_state, openscenario_msgs::msg::VehicleParameters parameters) VehicleEntity (std::string name, openscenario_msgs::msg::VehicleParameters parameters)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#public-attributes","text":"Name const openscenario_msgs::msg::VehicleParameters parameters","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#additional-inherited-members","text":"Public Functions inherited from simulation_api::entity::EntityBase Name virtual ~EntityBase () =default void updateStandStillDuration (double step_time) void stopAtEndOfRoad () bool statusSetted () const bool setVisibility (bool visibility) void setVerbose (bool verbose) bool setStatus (const openscenario_msgs::msg::EntityStatus & status) void setOtherStatus (const std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > & status) void setEntityTypeList (const std::unordered_map< std::string, openscenario_msgs::msg::EntityType > & entity_type_list) bool getVisibility () const openscenario_msgs::msg::EntityStatus getStatus () const boost::optional< double > getStandStillDuration () const boost::optional< double > getLinearJerk () const EntityBase (std::string type, std::string name, const openscenario_msgs::msg::EntityStatus & initial_state) EntityBase (std::string type, std::string name) Public Attributes inherited from simulation_api::entity::EntityBase Name const std::string type const std::string name Protected Attributes inherited from simulation_api::entity::EntityBase Name std::queue< openscenario_msgs::msg::LaneletPose > waypoints_ bool visibility_ bool verbose_ std::shared_ptr< simulation_api::TrafficLightManager > traffic_light_manager_ boost::optional< openscenario_msgs::msg::EntityStatus > status_ boost::optional< double > stand_still_duration_ std::unordered_map< std::string, openscenario_msgs::msg::EntityStatus > other_status_ boost::optional< openscenario_msgs::msg::LaneletPose > next_waypoint_ boost::optional< double > linear_jerk_ std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils_ptr_ std::unordered_map< std::string, openscenario_msgs::msg::EntityType > entity_type_list_ visualization_msgs::msg::MarkerArray current_marker_","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-settrafficlightmanager","text":"inline void setTrafficLightManager ( std :: shared_ptr < simulation_api :: TrafficLightManager > ptr )","title":"function setTrafficLightManager"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-settargetspeed","text":"void setTargetSpeed ( double target_speed , bool continuous )","title":"function setTargetSpeed"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-sethdmaputils","text":"inline void setHdMapUtils ( std :: shared_ptr < hdmap_utils :: HdMapUtils > ptr )","title":"function setHdMapUtils"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-setdrivermodel","text":"inline void setDriverModel ( const openscenario_msgs :: msg :: DriverModel & model )","title":"function setDriverModel"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-requestlanechange","text":"void requestLaneChange ( std :: int64_t to_lanelet_id )","title":"function requestLaneChange"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-requestassignroute","text":"virtual void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) override Reimplements : simulation_api::entity::EntityBase::requestAssignRoute","title":"function requestAssignRoute"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-requestacquireposition","text":"void requestAcquirePosition ( openscenario_msgs :: msg :: LaneletPose lanelet_pose )","title":"function requestAcquirePosition"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-onupdate","text":"virtual void onUpdate ( double current_time , double step_time ) override Reimplements : simulation_api::entity::EntityBase::onUpdate","title":"function onUpdate"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-getwaypoints","text":"inline openscenario_msgs :: msg :: WaypointsArray getWaypoints ()","title":"function getWaypoints"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-getroutelanelets","text":"inline std :: vector < std :: int64_t > getRouteLanelets ( double horizon = 100 )","title":"function getRouteLanelets"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-getobstacle","text":"inline boost :: optional < openscenario_msgs :: msg :: Obstacle > getObstacle ()","title":"function getObstacle"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-getcurrentaction","text":"inline virtual const std :: string getCurrentAction () const Reimplements : simulation_api::entity::EntityBase::getCurrentAction","title":"function getCurrentAction"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-getboundingbox","text":"inline virtual const openscenario_msgs :: msg :: BoundingBox getBoundingBox () const override Reimplements : simulation_api::entity::EntityBase::getBoundingBox","title":"function getBoundingBox"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-cancelrequest","text":"void cancelRequest ()","title":"function cancelRequest"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-vehicleentity","text":"VehicleEntity ( std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state , openscenario_msgs :: msg :: VehicleParameters parameters )","title":"function VehicleEntity"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#function-vehicleentity_1","text":"VehicleEntity ( std :: string name , openscenario_msgs :: msg :: VehicleParameters parameters )","title":"function VehicleEntity"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1entity_1_1VehicleEntity/#variable-parameters","text":"const openscenario_msgs :: msg :: VehicleParameters parameters ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable parameters"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1helper_1_1StopWatch/","text":"simulation_api::helper::StopWatch # More... Public Functions # Name void stop () void start () void print () StopWatch (const std::string & name) Detailed Description # template < typename T > class simulation_api :: helper :: StopWatch ; Public Functions Documentation # function stop # inline void stop () function start # inline void start () function print # inline void print () function StopWatch # inline explicit StopWatch ( const std :: string & name ) Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::helper::StopWatch"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1helper_1_1StopWatch/#simulation_apihelperstopwatch","text":"More...","title":"simulation_api::helper::StopWatch"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1helper_1_1StopWatch/#public-functions","text":"Name void stop () void start () void print () StopWatch (const std::string & name)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1helper_1_1StopWatch/#detailed-description","text":"template < typename T > class simulation_api :: helper :: StopWatch ;","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1helper_1_1StopWatch/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1helper_1_1StopWatch/#function-stop","text":"inline void stop ()","title":"function stop"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1helper_1_1StopWatch/#function-start","text":"inline void start ()","title":"function start"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1helper_1_1StopWatch/#function-print","text":"inline void print ()","title":"function print"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1helper_1_1StopWatch/#function-stopwatch","text":"inline explicit StopWatch ( const std :: string & name ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function StopWatch"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/","text":"simulation_api::math::CatmullRomSpline # Public Functions # Name const openscenario_msgs::msg::CatmullRomSpline toRosMsg () const const std::vector< geometry_msgs::msg::Point > getTrajectory (int num_points) const const std::vector< geometry_msgs::msg::Point > getTrajectory (double start_s, double end_s, double resolution) const const geometry_msgs::msg::Vector3 getTangentVector (double s) const double getSquaredDistanceIn2D (geometry_msgs::msg::Point point, double s) const boost::optional< double > getSValue (geometry_msgs::msg::Point position, double threadhold_distance =3.0, unsigned int initial_resolution =30, unsigned int max_iteration =30, double tolerance =0.001) const geometry_msgs::msg::Point getRightBoundsPoint (double width, double s, double z_offset =0) const const geometry_msgs::msg::Pose getPose (double s) const const std::vector< geometry_msgs::msg::Point > getPolygon (double width, size_t num_points =30, double z_offset =0) const geometry_msgs::msg::Point getPoint (double s) const const geometry_msgs::msg::Vector3 getNormalVector (double s) const double getMaximum2DCurventure () const double getLength () const const geometry_msgs::msg::Point getLeftBoundsPoint (double width, double s, double z_offset =0) const boost::optional< double > getCollisionPointIn2D (geometry_msgs::msg::Point point0, geometry_msgs::msg::Point point1, bool search_backward =false) const boost::optional< double > getCollisionPointIn2D (std::vector< geometry_msgs::msg::Point > polygon, bool search_backward =false) const CatmullRomSpline () CatmullRomSpline (const openscenario_msgs::msg::CatmullRomSpline & spline) CatmullRomSpline (const std::vector< openscenario_msgs::msg::HermiteCurve > & hermite_curves) CatmullRomSpline (const std::vector< geometry_msgs::msg::Point > & control_points) Public Functions Documentation # function toRosMsg # const openscenario_msgs :: msg :: CatmullRomSpline toRosMsg () const function getTrajectory # const std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( int num_points ) const function getTrajectory # const std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( double start_s , double end_s , double resolution ) const function getTangentVector # const geometry_msgs :: msg :: Vector3 getTangentVector ( double s ) const function getSquaredDistanceIn2D # double getSquaredDistanceIn2D ( geometry_msgs :: msg :: Point point , double s ) const function getSValue # boost :: optional < double > getSValue ( geometry_msgs :: msg :: Point position , double threadhold_distance = 3.0 , unsigned int initial_resolution = 30 , unsigned int max_iteration = 30 , double tolerance = 0.001 ) function getRightBoundsPoint # const geometry_msgs :: msg :: Point getRightBoundsPoint ( double width , double s , double z_offset = 0 ) const function getPose # const geometry_msgs :: msg :: Pose getPose ( double s ) const function getPolygon # const std :: vector < geometry_msgs :: msg :: Point > getPolygon ( double width , size_t num_points = 30 , double z_offset = 0 ) function getPoint # const geometry_msgs :: msg :: Point getPoint ( double s ) const function getNormalVector # const geometry_msgs :: msg :: Vector3 getNormalVector ( double s ) const function getMaximum2DCurventure # double getMaximum2DCurventure () const function getLength # inline double getLength () const function getLeftBoundsPoint # const geometry_msgs :: msg :: Point getLeftBoundsPoint ( double width , double s , double z_offset = 0 ) const function getCollisionPointIn2D # boost :: optional < double > getCollisionPointIn2D ( geometry_msgs :: msg :: Point point0 , geometry_msgs :: msg :: Point point1 , bool search_backward = false ) const function getCollisionPointIn2D # boost :: optional < double > getCollisionPointIn2D ( std :: vector < geometry_msgs :: msg :: Point > polygon , bool search_backward = false ) const function CatmullRomSpline # CatmullRomSpline () function CatmullRomSpline # explicit CatmullRomSpline ( const openscenario_msgs :: msg :: CatmullRomSpline & spline ) function CatmullRomSpline # explicit CatmullRomSpline ( const std :: vector < openscenario_msgs :: msg :: HermiteCurve > & hermite_curves ) function CatmullRomSpline # explicit CatmullRomSpline ( const std :: vector < geometry_msgs :: msg :: Point > & control_points ) Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::math::CatmullRomSpline"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#simulation_apimathcatmullromspline","text":"","title":"simulation_api::math::CatmullRomSpline"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#public-functions","text":"Name const openscenario_msgs::msg::CatmullRomSpline toRosMsg () const const std::vector< geometry_msgs::msg::Point > getTrajectory (int num_points) const const std::vector< geometry_msgs::msg::Point > getTrajectory (double start_s, double end_s, double resolution) const const geometry_msgs::msg::Vector3 getTangentVector (double s) const double getSquaredDistanceIn2D (geometry_msgs::msg::Point point, double s) const boost::optional< double > getSValue (geometry_msgs::msg::Point position, double threadhold_distance =3.0, unsigned int initial_resolution =30, unsigned int max_iteration =30, double tolerance =0.001) const geometry_msgs::msg::Point getRightBoundsPoint (double width, double s, double z_offset =0) const const geometry_msgs::msg::Pose getPose (double s) const const std::vector< geometry_msgs::msg::Point > getPolygon (double width, size_t num_points =30, double z_offset =0) const geometry_msgs::msg::Point getPoint (double s) const const geometry_msgs::msg::Vector3 getNormalVector (double s) const double getMaximum2DCurventure () const double getLength () const const geometry_msgs::msg::Point getLeftBoundsPoint (double width, double s, double z_offset =0) const boost::optional< double > getCollisionPointIn2D (geometry_msgs::msg::Point point0, geometry_msgs::msg::Point point1, bool search_backward =false) const boost::optional< double > getCollisionPointIn2D (std::vector< geometry_msgs::msg::Point > polygon, bool search_backward =false) const CatmullRomSpline () CatmullRomSpline (const openscenario_msgs::msg::CatmullRomSpline & spline) CatmullRomSpline (const std::vector< openscenario_msgs::msg::HermiteCurve > & hermite_curves) CatmullRomSpline (const std::vector< geometry_msgs::msg::Point > & control_points)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-torosmsg","text":"const openscenario_msgs :: msg :: CatmullRomSpline toRosMsg () const","title":"function toRosMsg"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-gettrajectory","text":"const std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( int num_points ) const","title":"function getTrajectory"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-gettrajectory_1","text":"const std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( double start_s , double end_s , double resolution ) const","title":"function getTrajectory"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-gettangentvector","text":"const geometry_msgs :: msg :: Vector3 getTangentVector ( double s ) const","title":"function getTangentVector"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-getsquareddistancein2d","text":"double getSquaredDistanceIn2D ( geometry_msgs :: msg :: Point point , double s ) const","title":"function getSquaredDistanceIn2D"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-getsvalue","text":"boost :: optional < double > getSValue ( geometry_msgs :: msg :: Point position , double threadhold_distance = 3.0 , unsigned int initial_resolution = 30 , unsigned int max_iteration = 30 , double tolerance = 0.001 )","title":"function getSValue"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-getrightboundspoint","text":"const geometry_msgs :: msg :: Point getRightBoundsPoint ( double width , double s , double z_offset = 0 ) const","title":"function getRightBoundsPoint"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-getpose","text":"const geometry_msgs :: msg :: Pose getPose ( double s ) const","title":"function getPose"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-getpolygon","text":"const std :: vector < geometry_msgs :: msg :: Point > getPolygon ( double width , size_t num_points = 30 , double z_offset = 0 )","title":"function getPolygon"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-getpoint","text":"const geometry_msgs :: msg :: Point getPoint ( double s ) const","title":"function getPoint"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-getnormalvector","text":"const geometry_msgs :: msg :: Vector3 getNormalVector ( double s ) const","title":"function getNormalVector"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-getmaximum2dcurventure","text":"double getMaximum2DCurventure () const","title":"function getMaximum2DCurventure"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-getlength","text":"inline double getLength () const","title":"function getLength"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-getleftboundspoint","text":"const geometry_msgs :: msg :: Point getLeftBoundsPoint ( double width , double s , double z_offset = 0 ) const","title":"function getLeftBoundsPoint"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-getcollisionpointin2d","text":"boost :: optional < double > getCollisionPointIn2D ( geometry_msgs :: msg :: Point point0 , geometry_msgs :: msg :: Point point1 , bool search_backward = false ) const","title":"function getCollisionPointIn2D"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-getcollisionpointin2d_1","text":"boost :: optional < double > getCollisionPointIn2D ( std :: vector < geometry_msgs :: msg :: Point > polygon , bool search_backward = false ) const","title":"function getCollisionPointIn2D"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-catmullromspline","text":"CatmullRomSpline ()","title":"function CatmullRomSpline"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-catmullromspline_1","text":"explicit CatmullRomSpline ( const openscenario_msgs :: msg :: CatmullRomSpline & spline )","title":"function CatmullRomSpline"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-catmullromspline_2","text":"explicit CatmullRomSpline ( const std :: vector < openscenario_msgs :: msg :: HermiteCurve > & hermite_curves )","title":"function CatmullRomSpline"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1CatmullRomSpline/#function-catmullromspline_3","text":"explicit CatmullRomSpline ( const std :: vector < geometry_msgs :: msg :: Point > & control_points ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function CatmullRomSpline"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/","text":"simulation_api::math::HermiteCurve # Public Functions # Name const openscenario_msgs::msg::HermiteCurve toRosMsg () const std::vector< geometry_msgs::msg::Point > getTrajectory (size_t num_points =30) const const std::vector< geometry_msgs::msg::Point > getTrajectory (double start_s, double end_s, double resolution, bool autoscale =false) const const geometry_msgs::msg::Vector3 getTangentVector (double s, bool autoscale =false) const double getSquaredDistanceIn2D (geometry_msgs::msg::Point point, double s, bool autoscale =false) const boost::optional< double > getSValue (geometry_msgs::msg::Point position, double threadhold_distance =1.0, unsigned int initial_resolution =30, unsigned int max_iteration =30, double tolerance =0.001, bool autoscale =false) const const geometry_msgs::msg::Pose getPose (double s, bool autoscale =false) const const geometry_msgs::msg::Point getPoint (double s, bool autoscale =false) const const geometry_msgs::msg::Vector3 getNormalVector (double s, bool autoscale =false) const double getMaximu2DCurvature () const double getLength (size_t num_points =100) const boost::optional< double > getCollisionPointIn2D (geometry_msgs::msg::Point point0, geometry_msgs::msg::Point point1, bool search_backward =false) const boost::optional< double > getCollisionPointIn2D (std::vector< geometry_msgs::msg::Point > polygon, bool search_backward =false) const double get2DCurvature (double s, bool autoscale =false) const HermiteCurve (const openscenario_msgs::msg::HermiteCurve & curve) HermiteCurve (geometry_msgs::msg::Pose start_pose, geometry_msgs::msg::Pose goal_pose, geometry_msgs::msg::Vector3 start_vec, geometry_msgs::msg::Vector3 goal_vec) HermiteCurve (double ax, double bx, double cx, double dx, double ay, double by, double cy, double dy, double az, double bz, double cz, double dz) Public Functions Documentation # function toRosMsg # const openscenario_msgs :: msg :: HermiteCurve toRosMsg () const function getTrajectory # std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( size_t num_points = 30 ) const function getTrajectory # const std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( double start_s , double end_s , double resolution , bool autoscale = false ) const function getTangentVector # const geometry_msgs :: msg :: Vector3 getTangentVector ( double s , bool autoscale = false ) const function getSquaredDistanceIn2D # double getSquaredDistanceIn2D ( geometry_msgs :: msg :: Point point , double s , bool autoscale = false ) const function getSValue # boost :: optional < double > getSValue ( geometry_msgs :: msg :: Point position , double threadhold_distance = 1.0 , unsigned int initial_resolution = 30 , unsigned int max_iteration = 30 , double tolerance = 0.001 , bool autoscale = false ) const function getPose # const geometry_msgs :: msg :: Pose getPose ( double s , bool autoscale = false ) const function getPoint # const geometry_msgs :: msg :: Point getPoint ( double s , bool autoscale = false ) const function getNormalVector # const geometry_msgs :: msg :: Vector3 getNormalVector ( double s , bool autoscale = false ) const function getMaximu2DCurvature # double getMaximu2DCurvature () const function getLength # double getLength ( size_t num_points = 100 ) const function getCollisionPointIn2D # boost :: optional < double > getCollisionPointIn2D ( geometry_msgs :: msg :: Point point0 , geometry_msgs :: msg :: Point point1 , bool search_backward = false ) const function getCollisionPointIn2D # boost :: optional < double > getCollisionPointIn2D ( std :: vector < geometry_msgs :: msg :: Point > polygon , bool search_backward = false ) const function get2DCurvature # double get2DCurvature ( double s , bool autoscale = false ) const function HermiteCurve # explicit HermiteCurve ( const openscenario_msgs :: msg :: HermiteCurve & curve ) function HermiteCurve # HermiteCurve ( geometry_msgs :: msg :: Pose start_pose , geometry_msgs :: msg :: Pose goal_pose , geometry_msgs :: msg :: Vector3 start_vec , geometry_msgs :: msg :: Vector3 goal_vec ) function HermiteCurve # HermiteCurve ( double ax , double bx , double cx , double dx , double ay , double by , double cy , double dy , double az , double bz , double cz , double dz ) Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::math::HermiteCurve"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#simulation_apimathhermitecurve","text":"","title":"simulation_api::math::HermiteCurve"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#public-functions","text":"Name const openscenario_msgs::msg::HermiteCurve toRosMsg () const std::vector< geometry_msgs::msg::Point > getTrajectory (size_t num_points =30) const const std::vector< geometry_msgs::msg::Point > getTrajectory (double start_s, double end_s, double resolution, bool autoscale =false) const const geometry_msgs::msg::Vector3 getTangentVector (double s, bool autoscale =false) const double getSquaredDistanceIn2D (geometry_msgs::msg::Point point, double s, bool autoscale =false) const boost::optional< double > getSValue (geometry_msgs::msg::Point position, double threadhold_distance =1.0, unsigned int initial_resolution =30, unsigned int max_iteration =30, double tolerance =0.001, bool autoscale =false) const const geometry_msgs::msg::Pose getPose (double s, bool autoscale =false) const const geometry_msgs::msg::Point getPoint (double s, bool autoscale =false) const const geometry_msgs::msg::Vector3 getNormalVector (double s, bool autoscale =false) const double getMaximu2DCurvature () const double getLength (size_t num_points =100) const boost::optional< double > getCollisionPointIn2D (geometry_msgs::msg::Point point0, geometry_msgs::msg::Point point1, bool search_backward =false) const boost::optional< double > getCollisionPointIn2D (std::vector< geometry_msgs::msg::Point > polygon, bool search_backward =false) const double get2DCurvature (double s, bool autoscale =false) const HermiteCurve (const openscenario_msgs::msg::HermiteCurve & curve) HermiteCurve (geometry_msgs::msg::Pose start_pose, geometry_msgs::msg::Pose goal_pose, geometry_msgs::msg::Vector3 start_vec, geometry_msgs::msg::Vector3 goal_vec) HermiteCurve (double ax, double bx, double cx, double dx, double ay, double by, double cy, double dy, double az, double bz, double cz, double dz)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-torosmsg","text":"const openscenario_msgs :: msg :: HermiteCurve toRosMsg () const","title":"function toRosMsg"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-gettrajectory","text":"std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( size_t num_points = 30 ) const","title":"function getTrajectory"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-gettrajectory_1","text":"const std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( double start_s , double end_s , double resolution , bool autoscale = false ) const","title":"function getTrajectory"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-gettangentvector","text":"const geometry_msgs :: msg :: Vector3 getTangentVector ( double s , bool autoscale = false ) const","title":"function getTangentVector"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-getsquareddistancein2d","text":"double getSquaredDistanceIn2D ( geometry_msgs :: msg :: Point point , double s , bool autoscale = false ) const","title":"function getSquaredDistanceIn2D"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-getsvalue","text":"boost :: optional < double > getSValue ( geometry_msgs :: msg :: Point position , double threadhold_distance = 1.0 , unsigned int initial_resolution = 30 , unsigned int max_iteration = 30 , double tolerance = 0.001 , bool autoscale = false ) const","title":"function getSValue"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-getpose","text":"const geometry_msgs :: msg :: Pose getPose ( double s , bool autoscale = false ) const","title":"function getPose"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-getpoint","text":"const geometry_msgs :: msg :: Point getPoint ( double s , bool autoscale = false ) const","title":"function getPoint"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-getnormalvector","text":"const geometry_msgs :: msg :: Vector3 getNormalVector ( double s , bool autoscale = false ) const","title":"function getNormalVector"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-getmaximu2dcurvature","text":"double getMaximu2DCurvature () const","title":"function getMaximu2DCurvature"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-getlength","text":"double getLength ( size_t num_points = 100 ) const","title":"function getLength"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-getcollisionpointin2d","text":"boost :: optional < double > getCollisionPointIn2D ( geometry_msgs :: msg :: Point point0 , geometry_msgs :: msg :: Point point1 , bool search_backward = false ) const","title":"function getCollisionPointIn2D"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-getcollisionpointin2d_1","text":"boost :: optional < double > getCollisionPointIn2D ( std :: vector < geometry_msgs :: msg :: Point > polygon , bool search_backward = false ) const","title":"function getCollisionPointIn2D"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-get2dcurvature","text":"double get2DCurvature ( double s , bool autoscale = false ) const","title":"function get2DCurvature"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-hermitecurve","text":"explicit HermiteCurve ( const openscenario_msgs :: msg :: HermiteCurve & curve )","title":"function HermiteCurve"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-hermitecurve_1","text":"HermiteCurve ( geometry_msgs :: msg :: Pose start_pose , geometry_msgs :: msg :: Pose goal_pose , geometry_msgs :: msg :: Vector3 start_vec , geometry_msgs :: msg :: Vector3 goal_vec )","title":"function HermiteCurve"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1HermiteCurve/#function-hermitecurve_2","text":"HermiteCurve ( double ax , double bx , double cx , double dx , double ay , double by , double cy , double dy , double az , double bz , double cz , double dz ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function HermiteCurve"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1PolynomialSolver/","text":"simulation_api::math::PolynomialSolver # Public Functions # Name std::vector< double > solveQuadraticEquation (double a, double b, double c, double min_value =0, double max_value =1) const solve quadratic equation a x^2 + b x + c = 0 std::vector< double > solveLinearEquation (double a, double b, double min_value =0, double max_value =1) const solve linear equation a*x + b = 0 std::vector< double > solveCubicEquation (double a, double b, double c, double d, double min_value =0, double max_value =1) const solve cubic function a t^3 + b t^2 + c*t + d = 0 double quadraticFunction (double a, double b, double c, double t) const calculate result of quadratic function a t^2 + b t + c double cubicFunction (double a, double b, double c, double d, double t) const calculate result of cubic function a t^3 + b t^2 + c*t + d Public Functions Documentation # function solveQuadraticEquation # std :: vector < double > solveQuadraticEquation ( double a , double b , double c , double min_value = 0 , double max_value = 1 ) const solve quadratic equation a x^2 + b x + c = 0 Parameters : a b Return : std::vector real root of the quadratic functions (from 0 to 1) function solveLinearEquation # std :: vector < double > solveLinearEquation ( double a , double b , double min_value = 0 , double max_value = 1 ) const solve linear equation a*x + b = 0 Parameters : a b Return : std::vector real root of the quadratic functions (from 0 to 1) function solveCubicEquation # std :: vector < double > solveCubicEquation ( double a , double b , double c , double d , double min_value = 0 , double max_value = 1 ) const solve cubic function a t^3 + b t^2 + c*t + d = 0 Parameters : a b c d Return : std::vector real root of the cubic functions (from 0 to 1) function quadraticFunction # double quadraticFunction ( double a , double b , double c , double t ) const calculate result of quadratic function a t^2 + b t + c Parameters : a b c t Return : double result of quadratic function function cubicFunction # double cubicFunction ( double a , double b , double c , double d , double t ) const calculate result of cubic function a t^3 + b t^2 + c*t + d Parameters : a b c d t Return : double result of cubic function Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::math::PolynomialSolver"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1PolynomialSolver/#simulation_apimathpolynomialsolver","text":"","title":"simulation_api::math::PolynomialSolver"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1PolynomialSolver/#public-functions","text":"Name std::vector< double > solveQuadraticEquation (double a, double b, double c, double min_value =0, double max_value =1) const solve quadratic equation a x^2 + b x + c = 0 std::vector< double > solveLinearEquation (double a, double b, double min_value =0, double max_value =1) const solve linear equation a*x + b = 0 std::vector< double > solveCubicEquation (double a, double b, double c, double d, double min_value =0, double max_value =1) const solve cubic function a t^3 + b t^2 + c*t + d = 0 double quadraticFunction (double a, double b, double c, double t) const calculate result of quadratic function a t^2 + b t + c double cubicFunction (double a, double b, double c, double d, double t) const calculate result of cubic function a t^3 + b t^2 + c*t + d","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1PolynomialSolver/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1PolynomialSolver/#function-solvequadraticequation","text":"std :: vector < double > solveQuadraticEquation ( double a , double b , double c , double min_value = 0 , double max_value = 1 ) const solve quadratic equation a x^2 + b x + c = 0 Parameters : a b Return : std::vector real root of the quadratic functions (from 0 to 1)","title":"function solveQuadraticEquation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1PolynomialSolver/#function-solvelinearequation","text":"std :: vector < double > solveLinearEquation ( double a , double b , double min_value = 0 , double max_value = 1 ) const solve linear equation a*x + b = 0 Parameters : a b Return : std::vector real root of the quadratic functions (from 0 to 1)","title":"function solveLinearEquation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1PolynomialSolver/#function-solvecubicequation","text":"std :: vector < double > solveCubicEquation ( double a , double b , double c , double d , double min_value = 0 , double max_value = 1 ) const solve cubic function a t^3 + b t^2 + c*t + d = 0 Parameters : a b c d Return : std::vector real root of the cubic functions (from 0 to 1)","title":"function solveCubicEquation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1PolynomialSolver/#function-quadraticfunction","text":"double quadraticFunction ( double a , double b , double c , double t ) const calculate result of quadratic function a t^2 + b t + c Parameters : a b c t Return : double result of quadratic function","title":"function quadraticFunction"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1PolynomialSolver/#function-cubicfunction","text":"double cubicFunction ( double a , double b , double c , double d , double t ) const calculate result of cubic function a t^3 + b t^2 + c*t + d Parameters : a b c d t Return : double result of cubic function Updated on 7 April 2021 at 00:31:54 UTC","title":"function cubicFunction"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1SplineInterpolationError/","text":"simulation_api::math::SplineInterpolationError # Inherits from runtime_error Public Functions # Name SplineInterpolationError (const char * message) SplineInterpolationError (std::string message) Public Functions Documentation # function SplineInterpolationError # inline explicit SplineInterpolationError ( const char * message ) function SplineInterpolationError # inline explicit SplineInterpolationError ( std :: string message ) Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::math::SplineInterpolationError"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1SplineInterpolationError/#simulation_apimathsplineinterpolationerror","text":"Inherits from runtime_error","title":"simulation_api::math::SplineInterpolationError"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1SplineInterpolationError/#public-functions","text":"Name SplineInterpolationError (const char * message) SplineInterpolationError (std::string message)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1SplineInterpolationError/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1SplineInterpolationError/#function-splineinterpolationerror","text":"inline explicit SplineInterpolationError ( const char * message )","title":"function SplineInterpolationError"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1math_1_1SplineInterpolationError/#function-splineinterpolationerror_1","text":"inline explicit SplineInterpolationError ( std :: string message ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function SplineInterpolationError"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TraffiModuleBase/","text":"simulation_api::traffic::TraffiModuleBase # Inherited by simulation_api::traffic::TrafficSink Public Functions # Name virtual void execute () =0 TraffiModuleBase () Public Functions Documentation # function execute # virtual void execute () = 0 Reimplemented by : simulation_api::traffic::TrafficSink::execute function TraffiModuleBase # inline TraffiModuleBase () Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::traffic::TraffiModuleBase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TraffiModuleBase/#simulation_apitraffictraffimodulebase","text":"Inherited by simulation_api::traffic::TrafficSink","title":"simulation_api::traffic::TraffiModuleBase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TraffiModuleBase/#public-functions","text":"Name virtual void execute () =0 TraffiModuleBase ()","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TraffiModuleBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TraffiModuleBase/#function-execute","text":"virtual void execute () = 0 Reimplemented by : simulation_api::traffic::TrafficSink::execute","title":"function execute"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TraffiModuleBase/#function-traffimodulebase","text":"inline TraffiModuleBase () Updated on 7 April 2021 at 00:31:54 UTC","title":"function TraffiModuleBase"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficController/","text":"simulation_api::traffic::TrafficController # Public Functions # Name void execute () template \\<typename T ,typename ... Ts> void addModule (Ts &&... xs) TrafficController (std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils, const std::function< std::vector< std::string >(void)> & get_entity_names_function, const std::function< geometry_msgs::msg::Pose(const std::string &)> & get_entity_pose_function, const std::function< void(std::string)> & despawn_function, bool auto_sink =false) Public Attributes # Name const bool auto_sink Public Functions Documentation # function execute # void execute () function addModule # template < typename T , typename ... Ts > inline void addModule ( Ts && ... xs ) function TrafficController # explicit TrafficController ( std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils , const std :: function < std :: vector < std :: string > ( void ) > & get_entity_names_function , const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > & get_entity_pose_function , const std :: function < void ( std :: string ) > & despawn_function , bool auto_sink = false ) Public Attributes Documentation # variable auto_sink # const bool auto_sink ; Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::traffic::TrafficController"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficController/#simulation_apitraffictrafficcontroller","text":"","title":"simulation_api::traffic::TrafficController"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficController/#public-functions","text":"Name void execute () template \\<typename T ,typename ... Ts> void addModule (Ts &&... xs) TrafficController (std::shared_ptr< hdmap_utils::HdMapUtils > hdmap_utils, const std::function< std::vector< std::string >(void)> & get_entity_names_function, const std::function< geometry_msgs::msg::Pose(const std::string &)> & get_entity_pose_function, const std::function< void(std::string)> & despawn_function, bool auto_sink =false)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficController/#public-attributes","text":"Name const bool auto_sink","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficController/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficController/#function-execute","text":"void execute ()","title":"function execute"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficController/#function-addmodule","text":"template < typename T , typename ... Ts > inline void addModule ( Ts && ... xs )","title":"function addModule"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficController/#function-trafficcontroller","text":"explicit TrafficController ( std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils , const std :: function < std :: vector < std :: string > ( void ) > & get_entity_names_function , const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > & get_entity_pose_function , const std :: function < void ( std :: string ) > & despawn_function , bool auto_sink = false )","title":"function TrafficController"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficController/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficController/#variable-auto_sink","text":"const bool auto_sink ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable auto_sink"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficSink/","text":"simulation_api::traffic::TrafficSink # Inherits from simulation_api::traffic::TraffiModuleBase Public Functions # Name virtual void execute () override TrafficSink (double radius, const geometry_msgs::msg::Point & position, const std::function< std::vector< std::string >(void)> & get_entity_names_function, const std::function< geometry_msgs::msg::Pose(const std::string &)> & get_entity_pose_function, const std::function< void(std::string)> & despawn_function) Public Attributes # Name const double radius const geometry_msgs::msg::Point position Additional inherited members # Public Functions inherited from simulation_api::traffic::TraffiModuleBase Name TraffiModuleBase () Public Functions Documentation # function execute # virtual void execute () override Reimplements : simulation_api::traffic::TraffiModuleBase::execute function TrafficSink # explicit TrafficSink ( double radius , const geometry_msgs :: msg :: Point & position , const std :: function < std :: vector < std :: string > ( void ) > & get_entity_names_function , const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > & get_entity_pose_function , const std :: function < void ( std :: string ) > & despawn_function ) Public Attributes Documentation # variable radius # const double radius ; variable position # const geometry_msgs :: msg :: Point position ; Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::traffic::TrafficSink"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficSink/#simulation_apitraffictrafficsink","text":"Inherits from simulation_api::traffic::TraffiModuleBase","title":"simulation_api::traffic::TrafficSink"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficSink/#public-functions","text":"Name virtual void execute () override TrafficSink (double radius, const geometry_msgs::msg::Point & position, const std::function< std::vector< std::string >(void)> & get_entity_names_function, const std::function< geometry_msgs::msg::Pose(const std::string &)> & get_entity_pose_function, const std::function< void(std::string)> & despawn_function)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficSink/#public-attributes","text":"Name const double radius const geometry_msgs::msg::Point position","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficSink/#additional-inherited-members","text":"Public Functions inherited from simulation_api::traffic::TraffiModuleBase Name TraffiModuleBase ()","title":"Additional inherited members"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficSink/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficSink/#function-execute","text":"virtual void execute () override Reimplements : simulation_api::traffic::TraffiModuleBase::execute","title":"function execute"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficSink/#function-trafficsink","text":"explicit TrafficSink ( double radius , const geometry_msgs :: msg :: Point & position , const std :: function < std :: vector < std :: string > ( void ) > & get_entity_names_function , const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > & get_entity_pose_function , const std :: function < void ( std :: string ) > & despawn_function )","title":"function TrafficSink"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficSink/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficSink/#variable-radius","text":"const double radius ;","title":"variable radius"},{"location":"package/simulation_api/markdown/Classes/classsimulation__api_1_1traffic_1_1TrafficSink/#variable-position","text":"const geometry_msgs :: msg :: Point position ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable position"},{"location":"package/simulation_api/markdown/Classes/classwf__simulator/","text":"wf_simulator # calculate ideal steering dynamics More... Detailed Description # class wf_simulator ; calculate ideal steering dynamics and steering model Updated on 7 April 2021 at 00:31:55 UTC","title":"wf_simulator"},{"location":"package/simulation_api/markdown/Classes/classwf__simulator/#wf_simulator","text":"calculate ideal steering dynamics More...","title":"wf_simulator"},{"location":"package/simulation_api/markdown/Classes/classwf__simulator/#detailed-description","text":"class wf_simulator ; calculate ideal steering dynamics and steering model Updated on 7 April 2021 at 00:31:55 UTC","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axle/","text":"simulation_api::entity::Axle # Public Functions # Name const openscenario_msgs::msg::Axle toRosMsg () const Axle (const pugi::xml_node & xml) Axle (double max_steering, double wheel_diameter, double track_width, double position_x, double position_z) Public Attributes # Name const double wheel_diameter const double track_width const double position_z const double position_x const double max_steering Public Functions Documentation # function toRosMsg # inline const openscenario_msgs :: msg :: Axle toRosMsg () const function Axle # inline explicit Axle ( const pugi :: xml_node & xml ) function Axle # inline Axle ( double max_steering , double wheel_diameter , double track_width , double position_x , double position_z ) Public Attributes Documentation # variable wheel_diameter # const double wheel_diameter ; variable track_width # const double track_width ; variable position_z # const double position_z ; variable position_x # const double position_x ; variable max_steering # const double max_steering ; Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity::Axle"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axle/#simulation_apientityaxle","text":"","title":"simulation_api::entity::Axle"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axle/#public-functions","text":"Name const openscenario_msgs::msg::Axle toRosMsg () const Axle (const pugi::xml_node & xml) Axle (double max_steering, double wheel_diameter, double track_width, double position_x, double position_z)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axle/#public-attributes","text":"Name const double wheel_diameter const double track_width const double position_z const double position_x const double max_steering","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axle/#function-torosmsg","text":"inline const openscenario_msgs :: msg :: Axle toRosMsg () const","title":"function toRosMsg"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axle/#function-axle","text":"inline explicit Axle ( const pugi :: xml_node & xml )","title":"function Axle"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axle/#function-axle_1","text":"inline Axle ( double max_steering , double wheel_diameter , double track_width , double position_x , double position_z )","title":"function Axle"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axle/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axle/#variable-wheel_diameter","text":"const double wheel_diameter ;","title":"variable wheel_diameter"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axle/#variable-track_width","text":"const double track_width ;","title":"variable track_width"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axle/#variable-position_z","text":"const double position_z ;","title":"variable position_z"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axle/#variable-position_x","text":"const double position_x ;","title":"variable position_x"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axle/#variable-max_steering","text":"const double max_steering ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable max_steering"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axles/","text":"simulation_api::entity::Axles # Public Functions # Name const openscenario_msgs::msg::Axles toRosMsg () const Axles (const pugi::xml_node & xml) Axles ( Axle front_axle, Axle rear_axle) Public Attributes # Name const Axle rear_axle const Axle front_axle Public Functions Documentation # function toRosMsg # inline const openscenario_msgs :: msg :: Axles toRosMsg () const function Axles # inline explicit Axles ( const pugi :: xml_node & xml ) function Axles # inline Axles ( Axle front_axle , Axle rear_axle ) Public Attributes Documentation # variable rear_axle # const Axle rear_axle ; variable front_axle # const Axle front_axle ; Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity::Axles"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axles/#simulation_apientityaxles","text":"","title":"simulation_api::entity::Axles"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axles/#public-functions","text":"Name const openscenario_msgs::msg::Axles toRosMsg () const Axles (const pugi::xml_node & xml) Axles ( Axle front_axle, Axle rear_axle)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axles/#public-attributes","text":"Name const Axle rear_axle const Axle front_axle","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axles/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axles/#function-torosmsg","text":"inline const openscenario_msgs :: msg :: Axles toRosMsg () const","title":"function toRosMsg"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axles/#function-axles","text":"inline explicit Axles ( const pugi :: xml_node & xml )","title":"function Axles"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axles/#function-axles_1","text":"inline Axles ( Axle front_axle , Axle rear_axle )","title":"function Axles"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axles/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axles/#variable-rear_axle","text":"const Axle rear_axle ;","title":"variable rear_axle"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Axles/#variable-front_axle","text":"const Axle front_axle ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable front_axle"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1BoundingBox/","text":"simulation_api::entity::BoundingBox # Public Functions # Name const openscenario_msgs::msg::BoundingBox toRosMsg () const BoundingBox (const pugi::xml_node & xml) BoundingBox ( Center center, Dimensions dimensions) Public Attributes # Name const Dimensions dimensions const Center center Public Functions Documentation # function toRosMsg # inline const openscenario_msgs :: msg :: BoundingBox toRosMsg () const function BoundingBox # inline explicit BoundingBox ( const pugi :: xml_node & xml ) function BoundingBox # inline BoundingBox ( Center center , Dimensions dimensions ) Public Attributes Documentation # variable dimensions # const Dimensions dimensions ; variable center # const Center center ; Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity::BoundingBox"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1BoundingBox/#simulation_apientityboundingbox","text":"","title":"simulation_api::entity::BoundingBox"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1BoundingBox/#public-functions","text":"Name const openscenario_msgs::msg::BoundingBox toRosMsg () const BoundingBox (const pugi::xml_node & xml) BoundingBox ( Center center, Dimensions dimensions)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1BoundingBox/#public-attributes","text":"Name const Dimensions dimensions const Center center","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1BoundingBox/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1BoundingBox/#function-torosmsg","text":"inline const openscenario_msgs :: msg :: BoundingBox toRosMsg () const","title":"function toRosMsg"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1BoundingBox/#function-boundingbox","text":"inline explicit BoundingBox ( const pugi :: xml_node & xml )","title":"function BoundingBox"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1BoundingBox/#function-boundingbox_1","text":"inline BoundingBox ( Center center , Dimensions dimensions )","title":"function BoundingBox"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1BoundingBox/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1BoundingBox/#variable-dimensions","text":"const Dimensions dimensions ;","title":"variable dimensions"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1BoundingBox/#variable-center","text":"const Center center ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable center"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Center/","text":"simulation_api::entity::Center # Public Functions # Name Center (const pugi::xml_node & xml) Center (double x, double y, double z) Public Attributes # Name const double z const double y const double x Public Functions Documentation # function Center # inline explicit Center ( const pugi :: xml_node & xml ) function Center # inline Center ( double x , double y , double z ) Public Attributes Documentation # variable z # const double z ; variable y # const double y ; variable x # const double x ; Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity::Center"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Center/#simulation_apientitycenter","text":"","title":"simulation_api::entity::Center"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Center/#public-functions","text":"Name Center (const pugi::xml_node & xml) Center (double x, double y, double z)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Center/#public-attributes","text":"Name const double z const double y const double x","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Center/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Center/#function-center","text":"inline explicit Center ( const pugi :: xml_node & xml )","title":"function Center"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Center/#function-center_1","text":"inline Center ( double x , double y , double z )","title":"function Center"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Center/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Center/#variable-z","text":"const double z ;","title":"variable z"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Center/#variable-y","text":"const double y ;","title":"variable y"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Center/#variable-x","text":"const double x ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable x"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Dimensions/","text":"simulation_api::entity::Dimensions # Public Functions # Name Dimensions (const pugi::xml_node & xml) Dimensions (double width, double length, double height) Public Attributes # Name const double width const double length const double height Public Functions Documentation # function Dimensions # inline explicit Dimensions ( const pugi :: xml_node & xml ) function Dimensions # inline Dimensions ( double width , double length , double height ) Public Attributes Documentation # variable width # const double width ; variable length # const double length ; variable height # const double height ; Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity::Dimensions"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Dimensions/#simulation_apientitydimensions","text":"","title":"simulation_api::entity::Dimensions"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Dimensions/#public-functions","text":"Name Dimensions (const pugi::xml_node & xml) Dimensions (double width, double length, double height)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Dimensions/#public-attributes","text":"Name const double width const double length const double height","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Dimensions/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Dimensions/#function-dimensions","text":"inline explicit Dimensions ( const pugi :: xml_node & xml )","title":"function Dimensions"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Dimensions/#function-dimensions_1","text":"inline Dimensions ( double width , double length , double height )","title":"function Dimensions"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Dimensions/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Dimensions/#variable-width","text":"const double width ;","title":"variable width"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Dimensions/#variable-length","text":"const double length ;","title":"variable length"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Dimensions/#variable-height","text":"const double height ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable height"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1PedestrianParameters/","text":"simulation_api::entity::PedestrianParameters # Public Functions # Name std::string toXml () const const openscenario_msgs::msg::PedestrianParameters toRosMsg () const PedestrianParameters (const pugi::xml_node & xml) PedestrianParameters (std::string name, std::string pedestrian_category, BoundingBox bounding_box) Public Attributes # Name const std::string pedestrian_category const std::string name const BoundingBox bounding_box Public Functions Documentation # function toXml # inline std :: string toXml () const function toRosMsg # inline const openscenario_msgs :: msg :: PedestrianParameters toRosMsg () const function PedestrianParameters # inline explicit PedestrianParameters ( const pugi :: xml_node & xml ) function PedestrianParameters # inline PedestrianParameters ( std :: string name , std :: string pedestrian_category , BoundingBox bounding_box ) Public Attributes Documentation # variable pedestrian_category # const std :: string pedestrian_category ; variable name # const std :: string name ; variable bounding_box # const BoundingBox bounding_box ; Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity::PedestrianParameters"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1PedestrianParameters/#simulation_apientitypedestrianparameters","text":"","title":"simulation_api::entity::PedestrianParameters"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1PedestrianParameters/#public-functions","text":"Name std::string toXml () const const openscenario_msgs::msg::PedestrianParameters toRosMsg () const PedestrianParameters (const pugi::xml_node & xml) PedestrianParameters (std::string name, std::string pedestrian_category, BoundingBox bounding_box)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1PedestrianParameters/#public-attributes","text":"Name const std::string pedestrian_category const std::string name const BoundingBox bounding_box","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1PedestrianParameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1PedestrianParameters/#function-toxml","text":"inline std :: string toXml () const","title":"function toXml"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1PedestrianParameters/#function-torosmsg","text":"inline const openscenario_msgs :: msg :: PedestrianParameters toRosMsg () const","title":"function toRosMsg"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1PedestrianParameters/#function-pedestrianparameters","text":"inline explicit PedestrianParameters ( const pugi :: xml_node & xml )","title":"function PedestrianParameters"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1PedestrianParameters/#function-pedestrianparameters_1","text":"inline PedestrianParameters ( std :: string name , std :: string pedestrian_category , BoundingBox bounding_box )","title":"function PedestrianParameters"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1PedestrianParameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1PedestrianParameters/#variable-pedestrian_category","text":"const std :: string pedestrian_category ;","title":"variable pedestrian_category"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1PedestrianParameters/#variable-name","text":"const std :: string name ;","title":"variable name"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1PedestrianParameters/#variable-bounding_box","text":"const BoundingBox bounding_box ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable bounding_box"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Performance/","text":"simulation_api::entity::Performance # Public Functions # Name const openscenario_msgs::msg::Performance toRosMsg () const Performance (const pugi::xml_node & xml) Performance (double max_speed, double max_acceleration, double max_deceleration) Public Attributes # Name const double max_speed const double max_deceleration const double max_acceleration Public Functions Documentation # function toRosMsg # inline const openscenario_msgs :: msg :: Performance toRosMsg () const function Performance # inline explicit Performance ( const pugi :: xml_node & xml ) function Performance # inline Performance ( double max_speed , double max_acceleration , double max_deceleration ) Public Attributes Documentation # variable max_speed # const double max_speed ; variable max_deceleration # const double max_deceleration ; variable max_acceleration # const double max_acceleration ; Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity::Performance"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Performance/#simulation_apientityperformance","text":"","title":"simulation_api::entity::Performance"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Performance/#public-functions","text":"Name const openscenario_msgs::msg::Performance toRosMsg () const Performance (const pugi::xml_node & xml) Performance (double max_speed, double max_acceleration, double max_deceleration)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Performance/#public-attributes","text":"Name const double max_speed const double max_deceleration const double max_acceleration","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Performance/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Performance/#function-torosmsg","text":"inline const openscenario_msgs :: msg :: Performance toRosMsg () const","title":"function toRosMsg"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Performance/#function-performance","text":"inline explicit Performance ( const pugi :: xml_node & xml )","title":"function Performance"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Performance/#function-performance_1","text":"inline Performance ( double max_speed , double max_acceleration , double max_deceleration )","title":"function Performance"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Performance/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Performance/#variable-max_speed","text":"const double max_speed ;","title":"variable max_speed"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Performance/#variable-max_deceleration","text":"const double max_deceleration ;","title":"variable max_deceleration"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1Performance/#variable-max_acceleration","text":"const double max_acceleration ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable max_acceleration"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1VehicleParameters/","text":"simulation_api::entity::VehicleParameters # Public Functions # Name std::string toXml () const const openscenario_msgs::msg::VehicleParameters toRosMsg () VehicleParameters (const pugi::xml_node & xml) VehicleParameters (std::string name, std::string vehicle_categoly, Performance performance, BoundingBox bounding_box, Axles axles) Public Attributes # Name const std::string vehicle_categoly const Performance performance const std::string name const BoundingBox bounding_box const Axles axles Public Functions Documentation # function toXml # inline std :: string toXml () const function toRosMsg # inline const openscenario_msgs :: msg :: VehicleParameters toRosMsg () function VehicleParameters # inline explicit VehicleParameters ( const pugi :: xml_node & xml ) function VehicleParameters # inline VehicleParameters ( std :: string name , std :: string vehicle_categoly , Performance performance , BoundingBox bounding_box , Axles axles ) Public Attributes Documentation # variable vehicle_categoly # const std :: string vehicle_categoly ; variable performance # const Performance performance ; variable name # const std :: string name ; variable bounding_box # const BoundingBox bounding_box ; variable axles # const Axles axles ; Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity::VehicleParameters"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1VehicleParameters/#simulation_apientityvehicleparameters","text":"","title":"simulation_api::entity::VehicleParameters"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1VehicleParameters/#public-functions","text":"Name std::string toXml () const const openscenario_msgs::msg::VehicleParameters toRosMsg () VehicleParameters (const pugi::xml_node & xml) VehicleParameters (std::string name, std::string vehicle_categoly, Performance performance, BoundingBox bounding_box, Axles axles)","title":"Public Functions"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1VehicleParameters/#public-attributes","text":"Name const std::string vehicle_categoly const Performance performance const std::string name const BoundingBox bounding_box const Axles axles","title":"Public Attributes"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1VehicleParameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1VehicleParameters/#function-toxml","text":"inline std :: string toXml () const","title":"function toXml"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1VehicleParameters/#function-torosmsg","text":"inline const openscenario_msgs :: msg :: VehicleParameters toRosMsg ()","title":"function toRosMsg"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1VehicleParameters/#function-vehicleparameters","text":"inline explicit VehicleParameters ( const pugi :: xml_node & xml )","title":"function VehicleParameters"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1VehicleParameters/#function-vehicleparameters_1","text":"inline VehicleParameters ( std :: string name , std :: string vehicle_categoly , Performance performance , BoundingBox bounding_box , Axles axles )","title":"function VehicleParameters"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1VehicleParameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1VehicleParameters/#variable-vehicle_categoly","text":"const std :: string vehicle_categoly ;","title":"variable vehicle_categoly"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1VehicleParameters/#variable-performance","text":"const Performance performance ;","title":"variable performance"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1VehicleParameters/#variable-name","text":"const std :: string name ;","title":"variable name"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1VehicleParameters/#variable-bounding_box","text":"const BoundingBox bounding_box ;","title":"variable bounding_box"},{"location":"package/simulation_api/markdown/Classes/structsimulation__api_1_1entity_1_1VehicleParameters/#variable-axles","text":"const Axles axles ; Updated on 7 April 2021 at 00:31:54 UTC","title":"variable axles"},{"location":"package/simulation_api/markdown/Examples/","text":"Examples # Updated on 7 April 2021 at 00:31:55 UTC","title":"Examples"},{"location":"package/simulation_api/markdown/Examples/#examples","text":"Updated on 7 April 2021 at 00:31:55 UTC","title":"Examples"},{"location":"package/simulation_api/markdown/Files/","text":"Files # dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/api file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/api/api.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/behavior_tree.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/follow_lane_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/pedestrian_action_node.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/walk_straight_action.hpp class definition for the walk straight action dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/follow_lane_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/yield_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/behavior_tree.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/lane_change_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/vehicle_action_node.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/action_node.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/route_planner.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/color_utils file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/color_utils/color_utils.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/ego_entity.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/entity_base.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/entity_manager.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/exception.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/pedestrian_entity.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/pedestrian_parameter.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/vehicle_entity.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/vehicle_parameter.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/hdmap_utils file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/hdmap_utils/hdmap_utils.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper/helper.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper/stop_watch.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/bounding_box.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/catmull_rom_spline.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/collision.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/distance.hpp functions for calculating distance file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/hermite_curve.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/polynomial_solver.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/uuid.hpp header files for generating UUID dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metric_base.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metrics.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metrics_manager.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/momentary_stop_metric.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/reaction_time_metric.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/traveled_distance_metric.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_controller.hpp class definition for the traffic controller file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_module_base.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_sink.hpp class definition of the traffic sink dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_manager.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_phase.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_state.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_ideal.hpp simple planning simulator ideal velocity model (no dynamics for desired velocity & angular-velocity or steering) file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_interface.hpp simple planning simulator model interface class file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_time_delay.hpp simple planning simulator model with time delay and 1-dimensional dynamics for velocity & steering file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_util.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/api file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/api/api.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/behavior_tree.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/follow_lane_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/pedestrian_action_node.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/walk_straight_action.cpp class implimentation of the walk straight action dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/follow_lane_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/yield_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/behavior_tree.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/lane_change_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/vehicle_action_node.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/action_node.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/route_planner.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/color_utils file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/color_utils/color_utils.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/ego_entity.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/entity_base.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/entity_manager.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/pedestrian_entity.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/vehicle_entity.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/hdmap_utils file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/hdmap_utils/hdmap_utils.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/helper file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/helper/helper.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/bounding_box.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/catmull_rom_spline.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/collision.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/distance.cpp functions for calculating distance file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/hermite_curve.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/polynomial_solver.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/uuid.cpp source files for generating UUID dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/metric_base.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/metrics_manager.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/momentary_stop_metric.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/reaction_time_metric.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/traveled_distance_metric.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc/catmull_rom_visualization.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc/scenario_runner_moc_node.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic/traffic_controller.cpp class implementation for the traffic controller file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic/traffic_sink.cpp implementation of the TrafficSink class dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights/traffic_light.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights/traffic_light_manager.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_ideal.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_interface.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_time_delay.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_util.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src/test_hdmap_utils.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src/test_math.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/#files","text":"dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/api file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/api/api.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/behavior_tree.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/follow_lane_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/pedestrian_action_node.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/walk_straight_action.hpp class definition for the walk straight action dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/follow_lane_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/yield_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/behavior_tree.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/lane_change_action.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/vehicle_action_node.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/action_node.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/route_planner.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/color_utils file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/color_utils/color_utils.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/ego_entity.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/entity_base.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/entity_manager.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/exception.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/pedestrian_entity.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/pedestrian_parameter.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/vehicle_entity.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/vehicle_parameter.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/hdmap_utils file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/hdmap_utils/hdmap_utils.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper/helper.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper/stop_watch.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/bounding_box.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/catmull_rom_spline.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/collision.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/distance.hpp functions for calculating distance file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/hermite_curve.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/polynomial_solver.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/uuid.hpp header files for generating UUID dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metric_base.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metrics.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metrics_manager.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/momentary_stop_metric.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/reaction_time_metric.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/traveled_distance_metric.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_controller.hpp class definition for the traffic controller file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_module_base.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_sink.hpp class definition of the traffic sink dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_manager.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_phase.hpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_state.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_ideal.hpp simple planning simulator ideal velocity model (no dynamics for desired velocity & angular-velocity or steering) file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_interface.hpp simple planning simulator model interface class file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_time_delay.hpp simple planning simulator model with time delay and 1-dimensional dynamics for velocity & steering file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_util.hpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/api file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/api/api.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/behavior_tree.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/follow_lane_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/pedestrian_action_node.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/walk_straight_action.cpp class implimentation of the walk straight action dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/follow_lane_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/yield_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/behavior_tree.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/lane_change_action.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/vehicle_action_node.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/action_node.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/route_planner.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/color_utils file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/color_utils/color_utils.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/ego_entity.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/entity_base.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/entity_manager.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/pedestrian_entity.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/vehicle_entity.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/hdmap_utils file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/hdmap_utils/hdmap_utils.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/helper file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/helper/helper.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/bounding_box.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/catmull_rom_spline.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/collision.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/distance.cpp functions for calculating distance file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/hermite_curve.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/polynomial_solver.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/uuid.cpp source files for generating UUID dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/metric_base.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/metrics_manager.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/momentary_stop_metric.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/reaction_time_metric.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/traveled_distance_metric.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc/catmull_rom_visualization.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc/scenario_runner_moc_node.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic/traffic_controller.cpp class implementation for the traffic controller file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic/traffic_sink.cpp implementation of the TrafficSink class dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights/traffic_light.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights/traffic_light_manager.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_ideal.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_interface.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_time_delay.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_util.cpp dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test dir /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src/test_hdmap_utils.cpp file /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src/test_math.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/action__node_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/action_node.cpp # Namespaces # Name entity_behavior Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/action_node.hpp> #include <string> #include <memory> #include <unordered_map> #include <vector> #include <utility> #include <algorithm> #include <set> namespace entity_behavior { ActionNode :: ActionNode ( const std :: string & name , const BT :: NodeConfiguration & config ) : BT :: ActionNodeBase ( name , config ) {} BT :: NodeStatus ActionNode :: executeTick () { return BT :: ActionNodeBase :: executeTick (); } void ActionNode :: getBlackBoardValues () { if ( ! getInput ( \"request\" , request )) { throw BehaviorTreeRuntimeError ( \"failed to get input request in ActionNode\" ); } if ( ! getInput < double > ( \"step_time\" , step_time )) { throw BehaviorTreeRuntimeError ( \"failed to get input step_time in ActionNode\" ); } if ( ! getInput < double > ( \"current_time\" , current_time )) { throw BehaviorTreeRuntimeError ( \"failed to get input current_time in ActionNode\" ); } if ( ! getInput < std :: shared_ptr < hdmap_utils :: HdMapUtils >> ( \"hdmap_utils\" , hdmap_utils )) { throw BehaviorTreeRuntimeError ( \"failed to get input hdmap_utils in ActionNode\" ); } if ( ! getInput < std :: shared_ptr < simulation_api :: TrafficLightManager >> ( \"traffic_light_manager\" , traffic_light_manager )) { throw BehaviorTreeRuntimeError ( \"failed to get input traffic_light_manager in ActionNode\" ); } if ( ! getInput < openscenario_msgs :: msg :: EntityStatus > ( \"entity_status\" , entity_status )) { throw BehaviorTreeRuntimeError ( \"failed to get input entity_status in ActionNode\" ); } if ( ! getInput < boost :: optional < double >> ( \"target_speed\" , target_speed )) { target_speed = boost :: none ; } if ( ! getInput < std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus >> ( \"other_entity_status\" , other_entity_status )) { throw BehaviorTreeRuntimeError ( \"failed to get input other_entity_status in ActionNode\" ); } if ( ! getInput < std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType >> ( \"entity_type_list\" , entity_type_list )) { throw BehaviorTreeRuntimeError ( \"failed to get input entity_type_list in ActionNode\" ); } if ( ! getInput < std :: vector < std :: int64_t >> ( \"route_lanelets\" , route_lanelets )) { throw BehaviorTreeRuntimeError ( \"failed to get input route_lanelets in ActionNode\" ); } } double ActionNode :: getHorizon () const { return boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x * 5 , 20 , 50 ); } openscenario_msgs :: msg :: EntityStatus ActionNode :: stopAtEndOfRoad () { openscenario_msgs :: msg :: EntityStatus entity_status_updated = entity_status ; entity_status_updated . time = current_time + step_time ; entity_status_updated . action_status . twist = geometry_msgs :: msg :: Twist (); entity_status_updated . action_status . accel = geometry_msgs :: msg :: Accel (); return entity_status_updated ; } std :: vector < openscenario_msgs :: msg :: EntityStatus > ActionNode :: getOtherEntityStatus ( std :: int64_t lanelet_id ) { std :: vector < openscenario_msgs :: msg :: EntityStatus > ret ; for ( const auto & status : other_entity_status ) { if ( status . second . lanelet_pose_valid ) { if ( status . second . lanelet_pose . lanelet_id == lanelet_id ) { ret . emplace_back ( status . second ); } } } return ret ; } boost :: optional < double > ActionNode :: getYieldStopDistance ( const std :: vector < std :: int64_t > & following_lanelets ) { std :: set < double > dists ; for ( const auto & lanelet : following_lanelets ) { const auto right_of_way_ids = hdmap_utils -> getRightOfWayLaneletIds ( lanelet ); for ( const auto right_of_way_id : right_of_way_ids ) { const auto other_status = getOtherEntityStatus ( right_of_way_id ); if ( other_status . size () != 0 ) { auto distance = hdmap_utils -> getLongitudinalDistance ( entity_status . lanelet_pose . lanelet_id , entity_status . lanelet_pose . s , lanelet , 0 ); if ( distance ) { dists . insert ( distance . get ()); } } } if ( dists . size () != 0 ) { return * dists . begin (); } } return boost :: none ; } std :: vector < openscenario_msgs :: msg :: EntityStatus > ActionNode :: getRightOfWayEntities ( const std :: vector < std :: int64_t > & following_lanelets ) { std :: vector < openscenario_msgs :: msg :: EntityStatus > ret ; const auto lanelet_ids_list = hdmap_utils -> getRightOfWayLaneletIds ( following_lanelets ); for ( const auto & status : other_entity_status ) { for ( const auto & following_lanelet : following_lanelets ) { for ( const std :: int64_t & lanelet_id : lanelet_ids_list . at ( following_lanelet )) { if ( lanelet_id == status . second . lanelet_pose . lanelet_id ) { ret . emplace_back ( status . second ); } } } } return ret ; } std :: vector < openscenario_msgs :: msg :: EntityStatus > ActionNode :: getRightOfWayEntities () { std :: vector < openscenario_msgs :: msg :: EntityStatus > ret ; const auto lanelet_ids = hdmap_utils -> getRightOfWayLaneletIds ( entity_status . lanelet_pose . lanelet_id ); if ( lanelet_ids . empty ()) { return ret ; } for ( const auto & status : other_entity_status ) { for ( const std :: int64_t & lanelet_id : lanelet_ids ) { if ( lanelet_id == status . second . lanelet_pose . lanelet_id ) { ret . emplace_back ( status . second ); } } } return ret ; } boost :: optional < double > ActionNode :: getDistanceToTrafficLightStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ) { const auto traffic_light_ids = hdmap_utils -> getTrafficLightIdsOnPath ( route_lanelets ); if ( traffic_light_ids . empty ()) { return boost :: none ; } std :: set < double > collision_points = {}; for ( const auto id : traffic_light_ids ) { const auto color = traffic_light_manager -> getColor ( id ); if ( color == simulation_api :: TrafficLightColor :: RED || color == simulation_api :: TrafficLightColor :: YELLOW ) { const auto collision_point = hdmap_utils -> getDistanceToTrafficLightStopLine ( waypoints , id ); if ( collision_point ) { collision_points . insert ( collision_point . get ()); } } } if ( collision_points . empty ()) { return boost :: none ; } return * collision_points . begin (); } boost :: optional < double > ActionNode :: getDistanceToStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ) { return hdmap_utils -> getDistanceToStopLine ( route_lanelets , waypoints ); } boost :: optional < double > ActionNode :: getDistanceToFrontEntity () { auto status = getFrontEntityStatus (); if ( ! status ) { return boost :: none ; } return hdmap_utils -> getLongitudinalDistance ( entity_status . lanelet_pose , status -> lanelet_pose ); } boost :: optional < openscenario_msgs :: msg :: EntityStatus > ActionNode :: getFrontEntityStatus () { boost :: optional < double > front_entity_distance , front_entity_speed ; std :: string front_entity_name = \"\" ; for ( const auto & each : other_entity_status ) { if ( ! entity_status . lanelet_pose_valid || ! each . second . lanelet_pose_valid ) { continue ; } boost :: optional < double > distance = hdmap_utils -> getLongitudinalDistance ( entity_status . lanelet_pose , each . second . lanelet_pose ); if ( distance ) { if ( distance . get () < 40 ) { if ( ! front_entity_distance && ! front_entity_speed ) { front_entity_speed = each . second . action_status . twist . linear . x ; front_entity_distance = distance . get (); front_entity_name = each . first ; } else { if ( front_entity_distance . get () > distance . get ()) { front_entity_speed = each . second . action_status . twist . linear . x ; front_entity_distance = distance . get (); front_entity_name = each . first ; } } } } } if ( ! front_entity_distance && ! front_entity_speed ) { return boost :: none ; } return other_entity_status [ front_entity_name ]; } boost :: optional < double > ActionNode :: getDistanceToConflictingEntity ( const std :: vector < std :: int64_t > & route_lanelets , const simulation_api :: math :: CatmullRomSpline & spline ) { auto conflicting_entity_status = getConflictingEntityStatusOnRoute ( route_lanelets ); if ( conflicting_entity_status . empty ()) { return boost :: none ; } std :: set < double > distances ; for ( const auto status : conflicting_entity_status ) { if ( status . lanelet_pose_valid ) { auto polygon = hdmap_utils -> getLaneletPolygon ( status . lanelet_pose . lanelet_id ); auto s = spline . getCollisionPointIn2D ( polygon ); if ( s ) { distances . insert ( s . get ()); } } } if ( distances . empty ()) { return boost :: none ; } return * distances . begin (); } boost :: optional < double > ActionNode :: getDistanceToConflictingEntity ( const std :: vector < std :: int64_t > & following_lanelets ) const { auto conflicting_entity_status = getConflictingEntityStatus ( following_lanelets ); if ( ! conflicting_entity_status ) { return boost :: none ; } std :: vector < double > dists ; std :: vector < std :: pair < int , double >> collision_points ; for ( const auto & lanelet_id : following_lanelets ) { auto stop_position_s = hdmap_utils -> getCollisionPointInLaneCoordinate ( lanelet_id , conflicting_entity_status -> lanelet_pose . lanelet_id ); if ( stop_position_s ) { auto dist = hdmap_utils -> getLongitudinalDistance ( entity_status . lanelet_pose . lanelet_id , entity_status . lanelet_pose . s , lanelet_id , stop_position_s . get ()); if ( dist ) { dists . push_back ( dist . get ()); collision_points . push_back ( std :: make_pair ( lanelet_id , stop_position_s . get ())); } } } if ( dists . size () != 0 ) { auto iter = std :: min_element ( dists . begin (), dists . end ()); size_t index = std :: distance ( dists . begin (), iter ); double stop_s = collision_points [ index ]. second ; std :: int64_t stop_lanelet_id = collision_points [ index ]. first ; geometry_msgs :: msg :: Vector3 rpy ; geometry_msgs :: msg :: Twist twist ; geometry_msgs :: msg :: Accel accel ; openscenario_msgs :: msg :: EntityStatus stop_target_status ; stop_target_status . lanelet_pose . lanelet_id = stop_lanelet_id ; stop_target_status . lanelet_pose . s = stop_s ; stop_target_status . lanelet_pose . rpy = rpy ; stop_target_status . action_status . twist = twist ; stop_target_status . action_status . accel = accel ; auto dist_to_stop_target = hdmap_utils -> getLongitudinalDistance ( entity_status . lanelet_pose . lanelet_id , entity_status . lanelet_pose . s , stop_target_status . lanelet_pose . lanelet_id , stop_target_status . lanelet_pose . s ); return dist_to_stop_target ; } return boost :: none ; } std :: vector < openscenario_msgs :: msg :: EntityStatus > ActionNode :: getConflictingEntityStatusOnRoute ( const std :: vector < std :: int64_t > & route_lanelets ) const { auto conflicting_crosswalks = hdmap_utils -> getConflictingCrosswalkIds ( route_lanelets ); std :: vector < openscenario_msgs :: msg :: EntityStatus > conflicting_entity_status ; for ( const auto & status : other_entity_status ) { if ( std :: count ( conflicting_crosswalks . begin (), conflicting_crosswalks . end (), status . second . lanelet_pose . lanelet_id ) >= 1 ) { conflicting_entity_status . push_back ( status . second ); } } return conflicting_entity_status ; } boost :: optional < openscenario_msgs :: msg :: EntityStatus > ActionNode :: getConflictingEntityStatus ( const std :: vector < std :: int64_t > & following_lanelets ) const { auto conflicting_crosswalks = hdmap_utils -> getConflictingCrosswalkIds ( following_lanelets ); std :: vector < openscenario_msgs :: msg :: EntityStatus > conflicting_entity_status ; for ( const auto & status : other_entity_status ) { if ( std :: count ( conflicting_crosswalks . begin (), conflicting_crosswalks . end (), status . second . lanelet_pose . lanelet_id ) >= 1 ) { conflicting_entity_status . push_back ( status . second ); } } std :: vector < double > dists ; std :: vector < std :: pair < int , double >> collision_points ; for ( const auto & status : conflicting_entity_status ) { for ( const auto & lanelet_id : following_lanelets ) { auto stop_position_s = hdmap_utils -> getCollisionPointInLaneCoordinate ( lanelet_id , status . lanelet_pose . lanelet_id ); if ( stop_position_s ) { auto dist = hdmap_utils -> getLongitudinalDistance ( entity_status . lanelet_pose . lanelet_id , entity_status . lanelet_pose . s , lanelet_id , stop_position_s . get ()); if ( dist ) { dists . push_back ( dist . get ()); collision_points . push_back ( std :: make_pair ( lanelet_id , stop_position_s . get ())); } } } } if ( dists . size () != 0 ) { auto iter = std :: max_element ( dists . begin (), dists . end ()); size_t index = std :: distance ( dists . begin (), iter ); double stop_s = collision_points [ index ]. second ; std :: int64_t stop_lanelet_id = collision_points [ index ]. first ; geometry_msgs :: msg :: Vector3 rpy ; geometry_msgs :: msg :: Twist twist ; geometry_msgs :: msg :: Accel accel ; openscenario_msgs :: msg :: EntityStatus conflicting_entity_status ; conflicting_entity_status . lanelet_pose . lanelet_id = stop_lanelet_id ; conflicting_entity_status . lanelet_pose . s = stop_s ; conflicting_entity_status . lanelet_pose . offset = 0 ; conflicting_entity_status . lanelet_pose . rpy = rpy ; conflicting_entity_status . action_status . twist = twist ; conflicting_entity_status . action_status . accel = accel ; conflicting_entity_status . pose = hdmap_utils -> toMapPose ( conflicting_entity_status . lanelet_pose ). pose ; return conflicting_entity_status ; } return boost :: none ; } bool ActionNode :: foundConflictingEntity ( const std :: vector < std :: int64_t > & following_lanelets ) const { auto conflicting_crosswalks = hdmap_utils -> getConflictingCrosswalkIds ( following_lanelets ); for ( const auto & status : other_entity_status ) { if ( std :: count ( conflicting_crosswalks . begin (), conflicting_crosswalks . end (), status . second . lanelet_pose . lanelet_id ) >= 1 ) { return true ; } } return false ; } double ActionNode :: calculateStopDistance () const { return std :: pow ( entity_status . action_status . twist . linear . x , 2 ) / ( 2 * 5 ); } } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/action_node.cpp"},{"location":"package/simulation_api/markdown/Files/action__node_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehavioraction_nodecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/action_node.cpp"},{"location":"package/simulation_api/markdown/Files/action__node_8cpp/#namespaces","text":"Name entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/action__node_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/action_node.hpp> #include <string> #include <memory> #include <unordered_map> #include <vector> #include <utility> #include <algorithm> #include <set> namespace entity_behavior { ActionNode :: ActionNode ( const std :: string & name , const BT :: NodeConfiguration & config ) : BT :: ActionNodeBase ( name , config ) {} BT :: NodeStatus ActionNode :: executeTick () { return BT :: ActionNodeBase :: executeTick (); } void ActionNode :: getBlackBoardValues () { if ( ! getInput ( \"request\" , request )) { throw BehaviorTreeRuntimeError ( \"failed to get input request in ActionNode\" ); } if ( ! getInput < double > ( \"step_time\" , step_time )) { throw BehaviorTreeRuntimeError ( \"failed to get input step_time in ActionNode\" ); } if ( ! getInput < double > ( \"current_time\" , current_time )) { throw BehaviorTreeRuntimeError ( \"failed to get input current_time in ActionNode\" ); } if ( ! getInput < std :: shared_ptr < hdmap_utils :: HdMapUtils >> ( \"hdmap_utils\" , hdmap_utils )) { throw BehaviorTreeRuntimeError ( \"failed to get input hdmap_utils in ActionNode\" ); } if ( ! getInput < std :: shared_ptr < simulation_api :: TrafficLightManager >> ( \"traffic_light_manager\" , traffic_light_manager )) { throw BehaviorTreeRuntimeError ( \"failed to get input traffic_light_manager in ActionNode\" ); } if ( ! getInput < openscenario_msgs :: msg :: EntityStatus > ( \"entity_status\" , entity_status )) { throw BehaviorTreeRuntimeError ( \"failed to get input entity_status in ActionNode\" ); } if ( ! getInput < boost :: optional < double >> ( \"target_speed\" , target_speed )) { target_speed = boost :: none ; } if ( ! getInput < std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus >> ( \"other_entity_status\" , other_entity_status )) { throw BehaviorTreeRuntimeError ( \"failed to get input other_entity_status in ActionNode\" ); } if ( ! getInput < std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType >> ( \"entity_type_list\" , entity_type_list )) { throw BehaviorTreeRuntimeError ( \"failed to get input entity_type_list in ActionNode\" ); } if ( ! getInput < std :: vector < std :: int64_t >> ( \"route_lanelets\" , route_lanelets )) { throw BehaviorTreeRuntimeError ( \"failed to get input route_lanelets in ActionNode\" ); } } double ActionNode :: getHorizon () const { return boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x * 5 , 20 , 50 ); } openscenario_msgs :: msg :: EntityStatus ActionNode :: stopAtEndOfRoad () { openscenario_msgs :: msg :: EntityStatus entity_status_updated = entity_status ; entity_status_updated . time = current_time + step_time ; entity_status_updated . action_status . twist = geometry_msgs :: msg :: Twist (); entity_status_updated . action_status . accel = geometry_msgs :: msg :: Accel (); return entity_status_updated ; } std :: vector < openscenario_msgs :: msg :: EntityStatus > ActionNode :: getOtherEntityStatus ( std :: int64_t lanelet_id ) { std :: vector < openscenario_msgs :: msg :: EntityStatus > ret ; for ( const auto & status : other_entity_status ) { if ( status . second . lanelet_pose_valid ) { if ( status . second . lanelet_pose . lanelet_id == lanelet_id ) { ret . emplace_back ( status . second ); } } } return ret ; } boost :: optional < double > ActionNode :: getYieldStopDistance ( const std :: vector < std :: int64_t > & following_lanelets ) { std :: set < double > dists ; for ( const auto & lanelet : following_lanelets ) { const auto right_of_way_ids = hdmap_utils -> getRightOfWayLaneletIds ( lanelet ); for ( const auto right_of_way_id : right_of_way_ids ) { const auto other_status = getOtherEntityStatus ( right_of_way_id ); if ( other_status . size () != 0 ) { auto distance = hdmap_utils -> getLongitudinalDistance ( entity_status . lanelet_pose . lanelet_id , entity_status . lanelet_pose . s , lanelet , 0 ); if ( distance ) { dists . insert ( distance . get ()); } } } if ( dists . size () != 0 ) { return * dists . begin (); } } return boost :: none ; } std :: vector < openscenario_msgs :: msg :: EntityStatus > ActionNode :: getRightOfWayEntities ( const std :: vector < std :: int64_t > & following_lanelets ) { std :: vector < openscenario_msgs :: msg :: EntityStatus > ret ; const auto lanelet_ids_list = hdmap_utils -> getRightOfWayLaneletIds ( following_lanelets ); for ( const auto & status : other_entity_status ) { for ( const auto & following_lanelet : following_lanelets ) { for ( const std :: int64_t & lanelet_id : lanelet_ids_list . at ( following_lanelet )) { if ( lanelet_id == status . second . lanelet_pose . lanelet_id ) { ret . emplace_back ( status . second ); } } } } return ret ; } std :: vector < openscenario_msgs :: msg :: EntityStatus > ActionNode :: getRightOfWayEntities () { std :: vector < openscenario_msgs :: msg :: EntityStatus > ret ; const auto lanelet_ids = hdmap_utils -> getRightOfWayLaneletIds ( entity_status . lanelet_pose . lanelet_id ); if ( lanelet_ids . empty ()) { return ret ; } for ( const auto & status : other_entity_status ) { for ( const std :: int64_t & lanelet_id : lanelet_ids ) { if ( lanelet_id == status . second . lanelet_pose . lanelet_id ) { ret . emplace_back ( status . second ); } } } return ret ; } boost :: optional < double > ActionNode :: getDistanceToTrafficLightStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ) { const auto traffic_light_ids = hdmap_utils -> getTrafficLightIdsOnPath ( route_lanelets ); if ( traffic_light_ids . empty ()) { return boost :: none ; } std :: set < double > collision_points = {}; for ( const auto id : traffic_light_ids ) { const auto color = traffic_light_manager -> getColor ( id ); if ( color == simulation_api :: TrafficLightColor :: RED || color == simulation_api :: TrafficLightColor :: YELLOW ) { const auto collision_point = hdmap_utils -> getDistanceToTrafficLightStopLine ( waypoints , id ); if ( collision_point ) { collision_points . insert ( collision_point . get ()); } } } if ( collision_points . empty ()) { return boost :: none ; } return * collision_points . begin (); } boost :: optional < double > ActionNode :: getDistanceToStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ) { return hdmap_utils -> getDistanceToStopLine ( route_lanelets , waypoints ); } boost :: optional < double > ActionNode :: getDistanceToFrontEntity () { auto status = getFrontEntityStatus (); if ( ! status ) { return boost :: none ; } return hdmap_utils -> getLongitudinalDistance ( entity_status . lanelet_pose , status -> lanelet_pose ); } boost :: optional < openscenario_msgs :: msg :: EntityStatus > ActionNode :: getFrontEntityStatus () { boost :: optional < double > front_entity_distance , front_entity_speed ; std :: string front_entity_name = \"\" ; for ( const auto & each : other_entity_status ) { if ( ! entity_status . lanelet_pose_valid || ! each . second . lanelet_pose_valid ) { continue ; } boost :: optional < double > distance = hdmap_utils -> getLongitudinalDistance ( entity_status . lanelet_pose , each . second . lanelet_pose ); if ( distance ) { if ( distance . get () < 40 ) { if ( ! front_entity_distance && ! front_entity_speed ) { front_entity_speed = each . second . action_status . twist . linear . x ; front_entity_distance = distance . get (); front_entity_name = each . first ; } else { if ( front_entity_distance . get () > distance . get ()) { front_entity_speed = each . second . action_status . twist . linear . x ; front_entity_distance = distance . get (); front_entity_name = each . first ; } } } } } if ( ! front_entity_distance && ! front_entity_speed ) { return boost :: none ; } return other_entity_status [ front_entity_name ]; } boost :: optional < double > ActionNode :: getDistanceToConflictingEntity ( const std :: vector < std :: int64_t > & route_lanelets , const simulation_api :: math :: CatmullRomSpline & spline ) { auto conflicting_entity_status = getConflictingEntityStatusOnRoute ( route_lanelets ); if ( conflicting_entity_status . empty ()) { return boost :: none ; } std :: set < double > distances ; for ( const auto status : conflicting_entity_status ) { if ( status . lanelet_pose_valid ) { auto polygon = hdmap_utils -> getLaneletPolygon ( status . lanelet_pose . lanelet_id ); auto s = spline . getCollisionPointIn2D ( polygon ); if ( s ) { distances . insert ( s . get ()); } } } if ( distances . empty ()) { return boost :: none ; } return * distances . begin (); } boost :: optional < double > ActionNode :: getDistanceToConflictingEntity ( const std :: vector < std :: int64_t > & following_lanelets ) const { auto conflicting_entity_status = getConflictingEntityStatus ( following_lanelets ); if ( ! conflicting_entity_status ) { return boost :: none ; } std :: vector < double > dists ; std :: vector < std :: pair < int , double >> collision_points ; for ( const auto & lanelet_id : following_lanelets ) { auto stop_position_s = hdmap_utils -> getCollisionPointInLaneCoordinate ( lanelet_id , conflicting_entity_status -> lanelet_pose . lanelet_id ); if ( stop_position_s ) { auto dist = hdmap_utils -> getLongitudinalDistance ( entity_status . lanelet_pose . lanelet_id , entity_status . lanelet_pose . s , lanelet_id , stop_position_s . get ()); if ( dist ) { dists . push_back ( dist . get ()); collision_points . push_back ( std :: make_pair ( lanelet_id , stop_position_s . get ())); } } } if ( dists . size () != 0 ) { auto iter = std :: min_element ( dists . begin (), dists . end ()); size_t index = std :: distance ( dists . begin (), iter ); double stop_s = collision_points [ index ]. second ; std :: int64_t stop_lanelet_id = collision_points [ index ]. first ; geometry_msgs :: msg :: Vector3 rpy ; geometry_msgs :: msg :: Twist twist ; geometry_msgs :: msg :: Accel accel ; openscenario_msgs :: msg :: EntityStatus stop_target_status ; stop_target_status . lanelet_pose . lanelet_id = stop_lanelet_id ; stop_target_status . lanelet_pose . s = stop_s ; stop_target_status . lanelet_pose . rpy = rpy ; stop_target_status . action_status . twist = twist ; stop_target_status . action_status . accel = accel ; auto dist_to_stop_target = hdmap_utils -> getLongitudinalDistance ( entity_status . lanelet_pose . lanelet_id , entity_status . lanelet_pose . s , stop_target_status . lanelet_pose . lanelet_id , stop_target_status . lanelet_pose . s ); return dist_to_stop_target ; } return boost :: none ; } std :: vector < openscenario_msgs :: msg :: EntityStatus > ActionNode :: getConflictingEntityStatusOnRoute ( const std :: vector < std :: int64_t > & route_lanelets ) const { auto conflicting_crosswalks = hdmap_utils -> getConflictingCrosswalkIds ( route_lanelets ); std :: vector < openscenario_msgs :: msg :: EntityStatus > conflicting_entity_status ; for ( const auto & status : other_entity_status ) { if ( std :: count ( conflicting_crosswalks . begin (), conflicting_crosswalks . end (), status . second . lanelet_pose . lanelet_id ) >= 1 ) { conflicting_entity_status . push_back ( status . second ); } } return conflicting_entity_status ; } boost :: optional < openscenario_msgs :: msg :: EntityStatus > ActionNode :: getConflictingEntityStatus ( const std :: vector < std :: int64_t > & following_lanelets ) const { auto conflicting_crosswalks = hdmap_utils -> getConflictingCrosswalkIds ( following_lanelets ); std :: vector < openscenario_msgs :: msg :: EntityStatus > conflicting_entity_status ; for ( const auto & status : other_entity_status ) { if ( std :: count ( conflicting_crosswalks . begin (), conflicting_crosswalks . end (), status . second . lanelet_pose . lanelet_id ) >= 1 ) { conflicting_entity_status . push_back ( status . second ); } } std :: vector < double > dists ; std :: vector < std :: pair < int , double >> collision_points ; for ( const auto & status : conflicting_entity_status ) { for ( const auto & lanelet_id : following_lanelets ) { auto stop_position_s = hdmap_utils -> getCollisionPointInLaneCoordinate ( lanelet_id , status . lanelet_pose . lanelet_id ); if ( stop_position_s ) { auto dist = hdmap_utils -> getLongitudinalDistance ( entity_status . lanelet_pose . lanelet_id , entity_status . lanelet_pose . s , lanelet_id , stop_position_s . get ()); if ( dist ) { dists . push_back ( dist . get ()); collision_points . push_back ( std :: make_pair ( lanelet_id , stop_position_s . get ())); } } } } if ( dists . size () != 0 ) { auto iter = std :: max_element ( dists . begin (), dists . end ()); size_t index = std :: distance ( dists . begin (), iter ); double stop_s = collision_points [ index ]. second ; std :: int64_t stop_lanelet_id = collision_points [ index ]. first ; geometry_msgs :: msg :: Vector3 rpy ; geometry_msgs :: msg :: Twist twist ; geometry_msgs :: msg :: Accel accel ; openscenario_msgs :: msg :: EntityStatus conflicting_entity_status ; conflicting_entity_status . lanelet_pose . lanelet_id = stop_lanelet_id ; conflicting_entity_status . lanelet_pose . s = stop_s ; conflicting_entity_status . lanelet_pose . offset = 0 ; conflicting_entity_status . lanelet_pose . rpy = rpy ; conflicting_entity_status . action_status . twist = twist ; conflicting_entity_status . action_status . accel = accel ; conflicting_entity_status . pose = hdmap_utils -> toMapPose ( conflicting_entity_status . lanelet_pose ). pose ; return conflicting_entity_status ; } return boost :: none ; } bool ActionNode :: foundConflictingEntity ( const std :: vector < std :: int64_t > & following_lanelets ) const { auto conflicting_crosswalks = hdmap_utils -> getConflictingCrosswalkIds ( following_lanelets ); for ( const auto & status : other_entity_status ) { if ( std :: count ( conflicting_crosswalks . begin (), conflicting_crosswalks . end (), status . second . lanelet_pose . lanelet_id ) >= 1 ) { return true ; } } return false ; } double ActionNode :: calculateStopDistance () const { return std :: pow ( entity_status . action_status . twist . linear . x , 2 ) / ( 2 * 5 ); } } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/action__node_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/action_node.hpp # Namespaces # Name entity_behavior Classes # Name class entity_behavior::BehaviorTreeRuntimeError class entity_behavior::ActionNode Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__ACTION_NODE_HPP_ #define SIMULATION_API__BEHAVIOR__ACTION_NODE_HPP_ #include <behaviortree_cpp_v3/action_node.h> #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/traffic_lights/traffic_light_manager.hpp> #include <openscenario_msgs/msg/waypoints_array.hpp> #include <openscenario_msgs/msg/obstacle.hpp> #include <boost/algorithm/clamp.hpp> #include <string> #include <memory> #include <vector> #include <unordered_map> namespace entity_behavior { class BehaviorTreeRuntimeError : public std :: runtime_error { public : explicit BehaviorTreeRuntimeError ( const char * message ) : runtime_error ( message ) {} }; class ActionNode : public BT :: ActionNodeBase { public : ActionNode ( const std :: string & name , const BT :: NodeConfiguration & config ); ~ ActionNode () override = default ; bool foundConflictingEntity ( const std :: vector < std :: int64_t > & following_lanelets ) const ; std :: vector < openscenario_msgs :: msg :: EntityStatus > getConflictingEntityStatusOnRoute ( const std :: vector < std :: int64_t > & route_lanelets ) const ; boost :: optional < openscenario_msgs :: msg :: EntityStatus > getConflictingEntityStatus ( const std :: vector < std :: int64_t > & following_lanelets ) const ; boost :: optional < double > getDistanceToConflictingEntity ( const std :: vector < std :: int64_t > & following_lanelets ) const ; boost :: optional < double > getDistanceToConflictingEntity ( const std :: vector < std :: int64_t > & route_lanelets , const simulation_api :: math :: CatmullRomSpline & spline ); boost :: optional < openscenario_msgs :: msg :: EntityStatus > getFrontEntityStatus (); double calculateStopDistance () const ; boost :: optional < double > getDistanceToFrontEntity (); boost :: optional < double > getDistanceToStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ); boost :: optional < double > getDistanceToTrafficLightStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ); std :: vector < openscenario_msgs :: msg :: EntityStatus > getRightOfWayEntities (); std :: vector < openscenario_msgs :: msg :: EntityStatus > getRightOfWayEntities ( const std :: vector < std :: int64_t > & following_lanelets ); boost :: optional < double > getYieldStopDistance ( const std :: vector < std :: int64_t > & following_lanelets ); std :: vector < openscenario_msgs :: msg :: EntityStatus > getOtherEntityStatus ( std :: int64_t lanelet_id ); openscenario_msgs :: msg :: EntityStatus stopAtEndOfRoad (); double getHorizon () const ; BT :: NodeStatus executeTick () override ; void halt () override { setStatus ( BT :: NodeStatus :: IDLE ); } static BT :: PortsList providedPorts () { return { BT :: InputPort < std :: string > ( \"request\" ), BT :: InputPort < std :: shared_ptr < hdmap_utils :: HdMapUtils >> ( \"hdmap_utils\" ), BT :: InputPort < openscenario_msgs :: msg :: EntityStatus > ( \"entity_status\" ), BT :: InputPort < double > ( \"current_time\" ), BT :: InputPort < double > ( \"step_time\" ), BT :: InputPort < boost :: optional < double >> ( \"target_speed\" ), BT :: OutputPort < openscenario_msgs :: msg :: EntityStatus > ( \"updated_status\" ), BT :: OutputPort < std :: string > ( \"request\" ), BT :: InputPort < std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus >> ( \"other_entity_status\" ), BT :: InputPort < std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType >> ( \"entity_type_list\" ), BT :: InputPort < std :: vector < std :: int64_t >> ( \"route_lanelets\" ), BT :: InputPort < std :: shared_ptr < simulation_api :: TrafficLightManager >> ( \"traffic_light_manager\" ), BT :: OutputPort < boost :: optional < openscenario_msgs :: msg :: Obstacle >> ( \"obstacle\" ), BT :: OutputPort < openscenario_msgs :: msg :: WaypointsArray > ( \"waypoints\" ) }; } void getBlackBoardValues (); std :: string request ; std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils ; std :: shared_ptr < simulation_api :: TrafficLightManager > traffic_light_manager ; openscenario_msgs :: msg :: EntityStatus entity_status ; double current_time ; double step_time ; boost :: optional < double > target_speed ; openscenario_msgs :: msg :: EntityStatus updated_status ; std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > other_entity_status ; std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > entity_type_list ; std :: vector < std :: int64_t > route_lanelets ; }; } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__ACTION_NODE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/action_node.hpp"},{"location":"package/simulation_api/markdown/Files/action__node_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehavioraction_nodehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/action_node.hpp"},{"location":"package/simulation_api/markdown/Files/action__node_8hpp/#namespaces","text":"Name entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/action__node_8hpp/#classes","text":"Name class entity_behavior::BehaviorTreeRuntimeError class entity_behavior::ActionNode","title":"Classes"},{"location":"package/simulation_api/markdown/Files/action__node_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__ACTION_NODE_HPP_ #define SIMULATION_API__BEHAVIOR__ACTION_NODE_HPP_ #include <behaviortree_cpp_v3/action_node.h> #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/traffic_lights/traffic_light_manager.hpp> #include <openscenario_msgs/msg/waypoints_array.hpp> #include <openscenario_msgs/msg/obstacle.hpp> #include <boost/algorithm/clamp.hpp> #include <string> #include <memory> #include <vector> #include <unordered_map> namespace entity_behavior { class BehaviorTreeRuntimeError : public std :: runtime_error { public : explicit BehaviorTreeRuntimeError ( const char * message ) : runtime_error ( message ) {} }; class ActionNode : public BT :: ActionNodeBase { public : ActionNode ( const std :: string & name , const BT :: NodeConfiguration & config ); ~ ActionNode () override = default ; bool foundConflictingEntity ( const std :: vector < std :: int64_t > & following_lanelets ) const ; std :: vector < openscenario_msgs :: msg :: EntityStatus > getConflictingEntityStatusOnRoute ( const std :: vector < std :: int64_t > & route_lanelets ) const ; boost :: optional < openscenario_msgs :: msg :: EntityStatus > getConflictingEntityStatus ( const std :: vector < std :: int64_t > & following_lanelets ) const ; boost :: optional < double > getDistanceToConflictingEntity ( const std :: vector < std :: int64_t > & following_lanelets ) const ; boost :: optional < double > getDistanceToConflictingEntity ( const std :: vector < std :: int64_t > & route_lanelets , const simulation_api :: math :: CatmullRomSpline & spline ); boost :: optional < openscenario_msgs :: msg :: EntityStatus > getFrontEntityStatus (); double calculateStopDistance () const ; boost :: optional < double > getDistanceToFrontEntity (); boost :: optional < double > getDistanceToStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ); boost :: optional < double > getDistanceToTrafficLightStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ); std :: vector < openscenario_msgs :: msg :: EntityStatus > getRightOfWayEntities (); std :: vector < openscenario_msgs :: msg :: EntityStatus > getRightOfWayEntities ( const std :: vector < std :: int64_t > & following_lanelets ); boost :: optional < double > getYieldStopDistance ( const std :: vector < std :: int64_t > & following_lanelets ); std :: vector < openscenario_msgs :: msg :: EntityStatus > getOtherEntityStatus ( std :: int64_t lanelet_id ); openscenario_msgs :: msg :: EntityStatus stopAtEndOfRoad (); double getHorizon () const ; BT :: NodeStatus executeTick () override ; void halt () override { setStatus ( BT :: NodeStatus :: IDLE ); } static BT :: PortsList providedPorts () { return { BT :: InputPort < std :: string > ( \"request\" ), BT :: InputPort < std :: shared_ptr < hdmap_utils :: HdMapUtils >> ( \"hdmap_utils\" ), BT :: InputPort < openscenario_msgs :: msg :: EntityStatus > ( \"entity_status\" ), BT :: InputPort < double > ( \"current_time\" ), BT :: InputPort < double > ( \"step_time\" ), BT :: InputPort < boost :: optional < double >> ( \"target_speed\" ), BT :: OutputPort < openscenario_msgs :: msg :: EntityStatus > ( \"updated_status\" ), BT :: OutputPort < std :: string > ( \"request\" ), BT :: InputPort < std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus >> ( \"other_entity_status\" ), BT :: InputPort < std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType >> ( \"entity_type_list\" ), BT :: InputPort < std :: vector < std :: int64_t >> ( \"route_lanelets\" ), BT :: InputPort < std :: shared_ptr < simulation_api :: TrafficLightManager >> ( \"traffic_light_manager\" ), BT :: OutputPort < boost :: optional < openscenario_msgs :: msg :: Obstacle >> ( \"obstacle\" ), BT :: OutputPort < openscenario_msgs :: msg :: WaypointsArray > ( \"waypoints\" ) }; } void getBlackBoardValues (); std :: string request ; std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils ; std :: shared_ptr < simulation_api :: TrafficLightManager > traffic_light_manager ; openscenario_msgs :: msg :: EntityStatus entity_status ; double current_time ; double step_time ; boost :: optional < double > target_speed ; openscenario_msgs :: msg :: EntityStatus updated_status ; std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > other_entity_status ; std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > entity_type_list ; std :: vector < std :: int64_t > route_lanelets ; }; } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__ACTION_NODE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/api_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/api/api.cpp # Namespaces # Name scenario_simulator Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/api/api.hpp> #include <simulation_interface/conversions.hpp> #include <tf2/LinearMath/Quaternion.h> #include <stdexcept> #include <string> #include <limits> #include <memory> namespace scenario_simulator { void API :: setVerbose ( bool verbose ) { metrics_manager_ . setVerbose ( verbose ); entity_manager_ptr_ -> setVerbose ( verbose ); } bool API :: despawn ( const std :: string & name ) { const auto result = entity_manager_ptr_ -> despawnEntity ( name ); if ( ! result ) { return false ; } if ( ! standalone_mode ) { simulation_api_schema :: DespawnEntityRequest req ; simulation_api_schema :: DespawnEntityResponse res ; req . set_name ( name ); despawn_entity_client_ . call ( req , res ); return res . result (). success (); } return true ; } bool API :: spawn ( const bool is_ego , const std :: string & catalog_xml , const openscenario_msgs :: msg :: EntityStatus & status ) { pugi :: xml_document catalog_xml_doc ; catalog_xml_doc . load_string ( catalog_xml . c_str ()); pugi :: xml_node vehicle_node = catalog_xml_doc . child ( \"Vehicle\" ); if ( vehicle_node != nullptr ) { const auto params = simulation_api :: entity :: VehicleParameters ( catalog_xml_doc ). toRosMsg (); return spawn ( is_ego , status . name , params ); } pugi :: xml_node pedestrian_node = catalog_xml_doc . child ( \"Pedestrian\" ); if ( pedestrian_node != nullptr ) { const auto params = simulation_api :: entity :: PedestrianParameters ( catalog_xml_doc ). toRosMsg (); return spawn ( is_ego , status . name , params ); } return false ; } bool API :: spawn ( const bool is_ego , const std :: string & name , const openscenario_msgs :: msg :: VehicleParameters & params ) { if ( is_ego ) { if ( ! entity_manager_ptr_ -> entityExists ( name ) && ! entity_manager_ptr_ -> spawnEntity ( simulation_api :: entity :: EgoEntity ( name , lanelet2_map_osm , step_time_ , params ))) { return false ; } if ( standalone_mode ) { return true ; } simulation_api_schema :: SpawnVehicleEntityRequest req ; simulation_api_schema :: SpawnVehicleEntityResponse res ; req . set_is_ego ( true ); simulation_interface :: toProto ( params , * req . mutable_parameters ()); spawn_vehicle_entity_client_ . call ( req , res ); return res . result (). success (); } else { simulation_api :: entity :: VehicleEntity npc ( name , params ); if ( ! entity_manager_ptr_ -> spawnEntity ( npc )) { return false ; } if ( standalone_mode ) { return true ; } simulation_api_schema :: SpawnVehicleEntityRequest req ; simulation_api_schema :: SpawnVehicleEntityResponse res ; req . set_is_ego ( false ); simulation_interface :: toProto ( params , * req . mutable_parameters ()); spawn_vehicle_entity_client_ . call ( req , res ); return res . result (). success (); } return false ; } bool API :: spawn ( const bool is_ego , const std :: string & name , const openscenario_msgs :: msg :: PedestrianParameters & params ) { if ( is_ego ) { throw simulation_api :: SimulationRuntimeError ( \"pedestrian should not be ego\" ); } simulation_api :: entity :: PedestrianEntity pedestrian ( name , params ); if ( ! entity_manager_ptr_ -> spawnEntity ( pedestrian )) { return false ; } if ( standalone_mode ) { return true ; } simulation_api_schema :: SpawnPedestrianEntityRequest req ; simulation_api_schema :: SpawnPedestrianEntityResponse res ; simulation_interface :: toProto ( params , * req . mutable_parameters ()); spawn_pedestrian_entity_client_ . call ( req , res ); return res . result (). success (); } bool API :: spawn ( const bool is_ego , const std :: string & name , const std :: string & catalog_xml ) { pugi :: xml_document catalog_xml_doc ; catalog_xml_doc . load_string ( catalog_xml . c_str ()); pugi :: xml_node vehicle_node = catalog_xml_doc . child ( \"Vehicle\" ); if ( vehicle_node != NULL ) { const auto params = simulation_api :: entity :: VehicleParameters ( catalog_xml_doc ). toRosMsg (); spawn ( is_ego , name , params ); } pugi :: xml_node pedestrian_node = catalog_xml_doc . child ( \"Pedestrian\" ); if ( pedestrian_node != NULL ) { const auto params = simulation_api :: entity :: PedestrianParameters ( catalog_xml_doc ). toRosMsg (); spawn ( false , name , params ); } return true ; } geometry_msgs :: msg :: Pose API :: getEntityPose ( const std :: string & name ) { auto status = getEntityStatus ( name ); return status . pose ; } openscenario_msgs :: msg :: EntityStatus API :: getEntityStatus ( const std :: string & name ) { auto status = entity_manager_ptr_ -> getEntityStatus ( name ); if ( ! status ) { throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting entity stauts, target entity : \" + name ); } return status . get (); } bool API :: setEntityStatus ( const std :: string & name , const openscenario_msgs :: msg :: EntityStatus & status ) { return entity_manager_ptr_ -> setEntityStatus ( name , status ); } bool API :: setEntityStatus ( const std :: string & name , const std :: string & reference_entity_name , const geometry_msgs :: msg :: Point & relative_position , const geometry_msgs :: msg :: Vector3 & relative_rpy , const openscenario_msgs :: msg :: ActionStatus & action_status ) { geometry_msgs :: msg :: Pose relative_pose ; relative_pose . position = relative_position ; relative_pose . orientation = quaternion_operation :: convertEulerAngleToQuaternion ( relative_rpy ); return setEntityStatus ( name , reference_entity_name , relative_pose , action_status ); } bool API :: setEntityStatus ( const std :: string & name , const std :: string & reference_entity_name , const geometry_msgs :: msg :: Pose & relative_pose , const openscenario_msgs :: msg :: ActionStatus & action_status ) { const auto pose = entity_manager_ptr_ -> getMapPose ( reference_entity_name , relative_pose ); openscenario_msgs :: msg :: EntityStatus status ; status . time = current_time_ ; status . pose = pose ; const auto lanelet_pose = entity_manager_ptr_ -> toLaneletPose ( pose ); status . action_status = action_status ; if ( lanelet_pose ) { status . lanelet_pose_valid = true ; status . lanelet_pose = lanelet_pose . get (); } else { status . lanelet_pose_valid = false ; } return entity_manager_ptr_ -> setEntityStatus ( name , status ); } boost :: optional < double > API :: getTimeHeadway ( const std :: string & from , const std :: string & to ) { if ( ! entity_manager_ptr_ -> entityStatusSetted ( from ) || ! entity_manager_ptr_ -> entityStatusSetted ( to )) { return boost :: none ; } geometry_msgs :: msg :: Pose pose = getRelativePose ( from , to ); if ( pose . position . x > 0 ) { return boost :: none ; } openscenario_msgs :: msg :: EntityStatus to_status = getEntityStatus ( to ); double ret = ( pose . position . x * -1 ) / ( to_status . action_status . twist . linear . x ); if ( std :: isnan ( ret )) { return std :: numeric_limits < double >:: infinity (); } return ret ; } bool API :: reachPosition ( const std :: string & name , const geometry_msgs :: msg :: Pose & target_pose , const double tolerance ) { return entity_manager_ptr_ -> entityStatusSetted ( name ) && entity_manager_ptr_ -> reachPosition ( name , target_pose , tolerance ); } bool API :: reachPosition ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & target_pose , const double tolerance ) { return entity_manager_ptr_ -> entityStatusSetted ( name ) && entity_manager_ptr_ -> reachPosition ( name , target_pose . lanelet_id , target_pose . s , target_pose . offset , tolerance ); // NOTE: ^ ament_uncrustify says above indentation is so beautiful. } bool API :: reachPosition ( const std :: string & name , const std :: string & target_name , const double tolerance ) const { return entity_manager_ptr_ -> entityStatusSetted ( name ) && entity_manager_ptr_ -> entityStatusSetted ( target_name ) && entity_manager_ptr_ -> reachPosition ( name , target_name , tolerance ); } bool API :: setEntityStatus ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & lanelet_pose , const openscenario_msgs :: msg :: ActionStatus & action_status ) { openscenario_msgs :: msg :: EntityStatus status ; status . lanelet_pose = lanelet_pose ; status . lanelet_pose_valid = true ; status . bounding_box = entity_manager_ptr_ -> getBoundingBox ( name ); status . pose = entity_manager_ptr_ -> toMapPose ( lanelet_pose ); status . name = name ; status . time = getCurrentTime (); status . action_status = action_status ; return setEntityStatus ( name , status ); } bool API :: setEntityStatus ( const std :: string & name , const geometry_msgs :: msg :: Pose & map_pose , const openscenario_msgs :: msg :: ActionStatus & action_status ) { const auto lanelet_pose = entity_manager_ptr_ -> toLaneletPose ( map_pose ); openscenario_msgs :: msg :: EntityStatus status ; if ( lanelet_pose ) { status . lanelet_pose = lanelet_pose . get (); } else { status . lanelet_pose_valid = false ; } status . pose = map_pose ; status . name = name ; status . action_status = action_status ; status . time = getCurrentTime (); status . bounding_box = entity_manager_ptr_ -> getBoundingBox ( name ); return setEntityStatus ( name , status ); } bool API :: initialize ( double realtime_factor , double step_time ) { step_time_ = step_time ; current_time_ = 0.0 ; if ( standalone_mode ) { return true ; } simulation_api_schema :: InitializeRequest req ; req . set_step_time ( step_time ); req . set_realtime_factor ( realtime_factor ); simulation_api_schema :: InitializeResponse res ; initialize_client_ . call ( req , res ); return res . result (). success (); } bool API :: attachDetectionSensor ( simulation_api_schema :: DetectionSensorConfiguration configuration ) { if ( standalone_mode ) { return true ; } else { simulation_api_schema :: AttachDetectionSensorRequest req ; simulation_api_schema :: AttachDetectionSensorResponse res ; * req . mutable_configuration () = configuration ; attach_detection_sensor_client_ . call ( req , res ); return res . result (). success (); } } bool API :: attachLidarSensor ( simulation_api_schema :: LidarConfiguration configuration ) { if ( standalone_mode ) { return true ; } else { simulation_api_schema :: AttachLidarSensorRequest req ; simulation_api_schema :: AttachLidarSensorResponse res ; * req . mutable_configuration () = configuration ; attach_lidar_sensor_client_ . call ( req , res ); return res . result (). success (); } } bool API :: updateSensorFrame () { if ( standalone_mode ) { return true ; } simulation_api_schema :: UpdateSensorFrameRequest req ; req . set_current_time ( current_time_ ); simulation_api_schema :: UpdateSensorFrameResponse res ; update_sensor_frame_client_ . call ( req , res ); return res . result (). success (); } bool API :: updateEntityStatusInSim () { simulation_api_schema :: UpdateEntityStatusRequest req ; const auto names = entity_manager_ptr_ -> getEntityNames (); for ( const auto name : names ) { auto status = entity_manager_ptr_ -> getEntityStatus ( name ); if ( status ) { openscenario_msgs :: EntityStatus proto ; status . get (). name = name ; simulation_interface :: toProto ( status . get (), proto ); * req . add_status () = proto ; } } simulation_api_schema :: UpdateEntityStatusResponse res ; update_entity_status_client_ . call ( req , res ); for ( const auto status : res . status ()) { auto entity_status = entity_manager_ptr_ -> getEntityStatus ( status . name ()); if ( ! entity_status ) { continue ; } openscenario_msgs :: msg :: EntityStatus status_msg ; status_msg = entity_status . get (); geometry_msgs :: msg :: Pose pose ; simulation_interface :: toMsg ( status . pose (), pose ); status_msg . pose = pose ; const auto lanelet_pose = entity_manager_ptr_ -> toLaneletPose ( pose ); if ( lanelet_pose ) { status_msg . lanelet_pose_valid = true ; status_msg . lanelet_pose = lanelet_pose . get (); } else { status_msg . lanelet_pose_valid = false ; status_msg . lanelet_pose = openscenario_msgs :: msg :: LaneletPose (); } simulation_interface :: toMsg ( status . action_status (). twist (), status_msg . action_status . twist ); simulation_interface :: toMsg ( status . action_status (). accel (), status_msg . action_status . accel ); entity_manager_ptr_ -> setEntityStatus ( status . name (), status_msg ); } return res . result (). success (); } bool API :: updateFrame () { entity_manager_ptr_ -> update ( current_time_ , step_time_ ); traffic_controller_ptr_ -> execute (); if ( ! standalone_mode ) { simulation_api_schema :: UpdateFrameRequest req ; req . set_current_time ( current_time_ ); simulation_api_schema :: UpdateFrameResponse res ; update_frame_client_ . call ( req , res ); if ( ! res . result (). success ()) { return false ; } entity_manager_ptr_ -> broadcastEntityTransform (); current_time_ = current_time_ + step_time_ ; metrics_manager_ . calculate (); if ( ! updateEntityStatusInSim ()) { return false ; } return updateSensorFrame (); } entity_manager_ptr_ -> broadcastEntityTransform (); current_time_ = current_time_ + step_time_ ; metrics_manager_ . calculate (); return true ; } } // namespace scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/api/api.cpp"},{"location":"package/simulation_api/markdown/Files/api_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcapiapicpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/api/api.cpp"},{"location":"package/simulation_api/markdown/Files/api_8cpp/#namespaces","text":"Name scenario_simulator","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/api_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/api/api.hpp> #include <simulation_interface/conversions.hpp> #include <tf2/LinearMath/Quaternion.h> #include <stdexcept> #include <string> #include <limits> #include <memory> namespace scenario_simulator { void API :: setVerbose ( bool verbose ) { metrics_manager_ . setVerbose ( verbose ); entity_manager_ptr_ -> setVerbose ( verbose ); } bool API :: despawn ( const std :: string & name ) { const auto result = entity_manager_ptr_ -> despawnEntity ( name ); if ( ! result ) { return false ; } if ( ! standalone_mode ) { simulation_api_schema :: DespawnEntityRequest req ; simulation_api_schema :: DespawnEntityResponse res ; req . set_name ( name ); despawn_entity_client_ . call ( req , res ); return res . result (). success (); } return true ; } bool API :: spawn ( const bool is_ego , const std :: string & catalog_xml , const openscenario_msgs :: msg :: EntityStatus & status ) { pugi :: xml_document catalog_xml_doc ; catalog_xml_doc . load_string ( catalog_xml . c_str ()); pugi :: xml_node vehicle_node = catalog_xml_doc . child ( \"Vehicle\" ); if ( vehicle_node != nullptr ) { const auto params = simulation_api :: entity :: VehicleParameters ( catalog_xml_doc ). toRosMsg (); return spawn ( is_ego , status . name , params ); } pugi :: xml_node pedestrian_node = catalog_xml_doc . child ( \"Pedestrian\" ); if ( pedestrian_node != nullptr ) { const auto params = simulation_api :: entity :: PedestrianParameters ( catalog_xml_doc ). toRosMsg (); return spawn ( is_ego , status . name , params ); } return false ; } bool API :: spawn ( const bool is_ego , const std :: string & name , const openscenario_msgs :: msg :: VehicleParameters & params ) { if ( is_ego ) { if ( ! entity_manager_ptr_ -> entityExists ( name ) && ! entity_manager_ptr_ -> spawnEntity ( simulation_api :: entity :: EgoEntity ( name , lanelet2_map_osm , step_time_ , params ))) { return false ; } if ( standalone_mode ) { return true ; } simulation_api_schema :: SpawnVehicleEntityRequest req ; simulation_api_schema :: SpawnVehicleEntityResponse res ; req . set_is_ego ( true ); simulation_interface :: toProto ( params , * req . mutable_parameters ()); spawn_vehicle_entity_client_ . call ( req , res ); return res . result (). success (); } else { simulation_api :: entity :: VehicleEntity npc ( name , params ); if ( ! entity_manager_ptr_ -> spawnEntity ( npc )) { return false ; } if ( standalone_mode ) { return true ; } simulation_api_schema :: SpawnVehicleEntityRequest req ; simulation_api_schema :: SpawnVehicleEntityResponse res ; req . set_is_ego ( false ); simulation_interface :: toProto ( params , * req . mutable_parameters ()); spawn_vehicle_entity_client_ . call ( req , res ); return res . result (). success (); } return false ; } bool API :: spawn ( const bool is_ego , const std :: string & name , const openscenario_msgs :: msg :: PedestrianParameters & params ) { if ( is_ego ) { throw simulation_api :: SimulationRuntimeError ( \"pedestrian should not be ego\" ); } simulation_api :: entity :: PedestrianEntity pedestrian ( name , params ); if ( ! entity_manager_ptr_ -> spawnEntity ( pedestrian )) { return false ; } if ( standalone_mode ) { return true ; } simulation_api_schema :: SpawnPedestrianEntityRequest req ; simulation_api_schema :: SpawnPedestrianEntityResponse res ; simulation_interface :: toProto ( params , * req . mutable_parameters ()); spawn_pedestrian_entity_client_ . call ( req , res ); return res . result (). success (); } bool API :: spawn ( const bool is_ego , const std :: string & name , const std :: string & catalog_xml ) { pugi :: xml_document catalog_xml_doc ; catalog_xml_doc . load_string ( catalog_xml . c_str ()); pugi :: xml_node vehicle_node = catalog_xml_doc . child ( \"Vehicle\" ); if ( vehicle_node != NULL ) { const auto params = simulation_api :: entity :: VehicleParameters ( catalog_xml_doc ). toRosMsg (); spawn ( is_ego , name , params ); } pugi :: xml_node pedestrian_node = catalog_xml_doc . child ( \"Pedestrian\" ); if ( pedestrian_node != NULL ) { const auto params = simulation_api :: entity :: PedestrianParameters ( catalog_xml_doc ). toRosMsg (); spawn ( false , name , params ); } return true ; } geometry_msgs :: msg :: Pose API :: getEntityPose ( const std :: string & name ) { auto status = getEntityStatus ( name ); return status . pose ; } openscenario_msgs :: msg :: EntityStatus API :: getEntityStatus ( const std :: string & name ) { auto status = entity_manager_ptr_ -> getEntityStatus ( name ); if ( ! status ) { throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting entity stauts, target entity : \" + name ); } return status . get (); } bool API :: setEntityStatus ( const std :: string & name , const openscenario_msgs :: msg :: EntityStatus & status ) { return entity_manager_ptr_ -> setEntityStatus ( name , status ); } bool API :: setEntityStatus ( const std :: string & name , const std :: string & reference_entity_name , const geometry_msgs :: msg :: Point & relative_position , const geometry_msgs :: msg :: Vector3 & relative_rpy , const openscenario_msgs :: msg :: ActionStatus & action_status ) { geometry_msgs :: msg :: Pose relative_pose ; relative_pose . position = relative_position ; relative_pose . orientation = quaternion_operation :: convertEulerAngleToQuaternion ( relative_rpy ); return setEntityStatus ( name , reference_entity_name , relative_pose , action_status ); } bool API :: setEntityStatus ( const std :: string & name , const std :: string & reference_entity_name , const geometry_msgs :: msg :: Pose & relative_pose , const openscenario_msgs :: msg :: ActionStatus & action_status ) { const auto pose = entity_manager_ptr_ -> getMapPose ( reference_entity_name , relative_pose ); openscenario_msgs :: msg :: EntityStatus status ; status . time = current_time_ ; status . pose = pose ; const auto lanelet_pose = entity_manager_ptr_ -> toLaneletPose ( pose ); status . action_status = action_status ; if ( lanelet_pose ) { status . lanelet_pose_valid = true ; status . lanelet_pose = lanelet_pose . get (); } else { status . lanelet_pose_valid = false ; } return entity_manager_ptr_ -> setEntityStatus ( name , status ); } boost :: optional < double > API :: getTimeHeadway ( const std :: string & from , const std :: string & to ) { if ( ! entity_manager_ptr_ -> entityStatusSetted ( from ) || ! entity_manager_ptr_ -> entityStatusSetted ( to )) { return boost :: none ; } geometry_msgs :: msg :: Pose pose = getRelativePose ( from , to ); if ( pose . position . x > 0 ) { return boost :: none ; } openscenario_msgs :: msg :: EntityStatus to_status = getEntityStatus ( to ); double ret = ( pose . position . x * -1 ) / ( to_status . action_status . twist . linear . x ); if ( std :: isnan ( ret )) { return std :: numeric_limits < double >:: infinity (); } return ret ; } bool API :: reachPosition ( const std :: string & name , const geometry_msgs :: msg :: Pose & target_pose , const double tolerance ) { return entity_manager_ptr_ -> entityStatusSetted ( name ) && entity_manager_ptr_ -> reachPosition ( name , target_pose , tolerance ); } bool API :: reachPosition ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & target_pose , const double tolerance ) { return entity_manager_ptr_ -> entityStatusSetted ( name ) && entity_manager_ptr_ -> reachPosition ( name , target_pose . lanelet_id , target_pose . s , target_pose . offset , tolerance ); // NOTE: ^ ament_uncrustify says above indentation is so beautiful. } bool API :: reachPosition ( const std :: string & name , const std :: string & target_name , const double tolerance ) const { return entity_manager_ptr_ -> entityStatusSetted ( name ) && entity_manager_ptr_ -> entityStatusSetted ( target_name ) && entity_manager_ptr_ -> reachPosition ( name , target_name , tolerance ); } bool API :: setEntityStatus ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & lanelet_pose , const openscenario_msgs :: msg :: ActionStatus & action_status ) { openscenario_msgs :: msg :: EntityStatus status ; status . lanelet_pose = lanelet_pose ; status . lanelet_pose_valid = true ; status . bounding_box = entity_manager_ptr_ -> getBoundingBox ( name ); status . pose = entity_manager_ptr_ -> toMapPose ( lanelet_pose ); status . name = name ; status . time = getCurrentTime (); status . action_status = action_status ; return setEntityStatus ( name , status ); } bool API :: setEntityStatus ( const std :: string & name , const geometry_msgs :: msg :: Pose & map_pose , const openscenario_msgs :: msg :: ActionStatus & action_status ) { const auto lanelet_pose = entity_manager_ptr_ -> toLaneletPose ( map_pose ); openscenario_msgs :: msg :: EntityStatus status ; if ( lanelet_pose ) { status . lanelet_pose = lanelet_pose . get (); } else { status . lanelet_pose_valid = false ; } status . pose = map_pose ; status . name = name ; status . action_status = action_status ; status . time = getCurrentTime (); status . bounding_box = entity_manager_ptr_ -> getBoundingBox ( name ); return setEntityStatus ( name , status ); } bool API :: initialize ( double realtime_factor , double step_time ) { step_time_ = step_time ; current_time_ = 0.0 ; if ( standalone_mode ) { return true ; } simulation_api_schema :: InitializeRequest req ; req . set_step_time ( step_time ); req . set_realtime_factor ( realtime_factor ); simulation_api_schema :: InitializeResponse res ; initialize_client_ . call ( req , res ); return res . result (). success (); } bool API :: attachDetectionSensor ( simulation_api_schema :: DetectionSensorConfiguration configuration ) { if ( standalone_mode ) { return true ; } else { simulation_api_schema :: AttachDetectionSensorRequest req ; simulation_api_schema :: AttachDetectionSensorResponse res ; * req . mutable_configuration () = configuration ; attach_detection_sensor_client_ . call ( req , res ); return res . result (). success (); } } bool API :: attachLidarSensor ( simulation_api_schema :: LidarConfiguration configuration ) { if ( standalone_mode ) { return true ; } else { simulation_api_schema :: AttachLidarSensorRequest req ; simulation_api_schema :: AttachLidarSensorResponse res ; * req . mutable_configuration () = configuration ; attach_lidar_sensor_client_ . call ( req , res ); return res . result (). success (); } } bool API :: updateSensorFrame () { if ( standalone_mode ) { return true ; } simulation_api_schema :: UpdateSensorFrameRequest req ; req . set_current_time ( current_time_ ); simulation_api_schema :: UpdateSensorFrameResponse res ; update_sensor_frame_client_ . call ( req , res ); return res . result (). success (); } bool API :: updateEntityStatusInSim () { simulation_api_schema :: UpdateEntityStatusRequest req ; const auto names = entity_manager_ptr_ -> getEntityNames (); for ( const auto name : names ) { auto status = entity_manager_ptr_ -> getEntityStatus ( name ); if ( status ) { openscenario_msgs :: EntityStatus proto ; status . get (). name = name ; simulation_interface :: toProto ( status . get (), proto ); * req . add_status () = proto ; } } simulation_api_schema :: UpdateEntityStatusResponse res ; update_entity_status_client_ . call ( req , res ); for ( const auto status : res . status ()) { auto entity_status = entity_manager_ptr_ -> getEntityStatus ( status . name ()); if ( ! entity_status ) { continue ; } openscenario_msgs :: msg :: EntityStatus status_msg ; status_msg = entity_status . get (); geometry_msgs :: msg :: Pose pose ; simulation_interface :: toMsg ( status . pose (), pose ); status_msg . pose = pose ; const auto lanelet_pose = entity_manager_ptr_ -> toLaneletPose ( pose ); if ( lanelet_pose ) { status_msg . lanelet_pose_valid = true ; status_msg . lanelet_pose = lanelet_pose . get (); } else { status_msg . lanelet_pose_valid = false ; status_msg . lanelet_pose = openscenario_msgs :: msg :: LaneletPose (); } simulation_interface :: toMsg ( status . action_status (). twist (), status_msg . action_status . twist ); simulation_interface :: toMsg ( status . action_status (). accel (), status_msg . action_status . accel ); entity_manager_ptr_ -> setEntityStatus ( status . name (), status_msg ); } return res . result (). success (); } bool API :: updateFrame () { entity_manager_ptr_ -> update ( current_time_ , step_time_ ); traffic_controller_ptr_ -> execute (); if ( ! standalone_mode ) { simulation_api_schema :: UpdateFrameRequest req ; req . set_current_time ( current_time_ ); simulation_api_schema :: UpdateFrameResponse res ; update_frame_client_ . call ( req , res ); if ( ! res . result (). success ()) { return false ; } entity_manager_ptr_ -> broadcastEntityTransform (); current_time_ = current_time_ + step_time_ ; metrics_manager_ . calculate (); if ( ! updateEntityStatusInSim ()) { return false ; } return updateSensorFrame (); } entity_manager_ptr_ -> broadcastEntityTransform (); current_time_ = current_time_ + step_time_ ; metrics_manager_ . calculate (); return true ; } } // namespace scenario_simulator Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/api_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/api/api.hpp # Namespaces # Name scenario_simulator Classes # Name class scenario_simulator::ExecutionFailedError class scenario_simulator::API Defines # Name FORWARD_TO_ENTITY_MANAGER (NAME) Macro Documentation # define FORWARD_TO_ENTITY_MANAGER # #define FORWARD_TO_ENTITY_MANAGER( NAME ) template < typename ... Ts > \\ decltype ( auto ) NAME ( Ts && ... xs ) \\ { \\ assert ( entity_manager_ptr_ ); \\ return ( * entity_manager_ptr_ ). NAME ( std :: forward < decltype ( xs ) > ( xs )...); \\ } static_assert ( true , \"\" ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__API__API_HPP_ #define SIMULATION_API__API__API_HPP_ #include <simulation_api/entity/entity_manager.hpp> #include <simulation_api/helper/helper.hpp> #include <simulation_api/metrics/metrics_manager.hpp> #include <simulation_api/traffic/traffic_controller.hpp> #include <simulation_api/traffic_lights/traffic_light.hpp> #include <autoware_auto_msgs/msg/vehicle_control_command.hpp> #include <autoware_auto_msgs/msg/vehicle_state_command.hpp> #include <awapi_accessor/accessor.hpp> #include <boost/filesystem.hpp> #include <openscenario_msgs/msg/driver_model.hpp> #include <rclcpp/rclcpp.hpp> #include <simulation_api_schema.pb.h> #include <simulation_interface/zmq_client.hpp> #include <cassert> #include <memory> #include <string> #include <utility> namespace scenario_simulator { class ExecutionFailedError : public std :: runtime_error { public : template < typename ... Ts > explicit ExecutionFailedError ( Ts && ... xs ) : runtime_error ( std :: forward < decltype ( xs ) > ( xs )...) {} virtual ~ ExecutionFailedError () = default ; }; class API { using EntityManager = simulation_api :: entity :: EntityManager ; public : const std :: string lanelet2_map_osm ; template < class NodeT , class AllocatorT = std :: allocator < void >> explicit API ( NodeT && node , const boost :: filesystem :: path , const std :: string & lanelet2_map_osm , const bool auto_sink = true , const bool verbose = false , const bool standalone_mode = false , const std :: string & metrics_logfile_path = \"/tmp/metrics.json\" ) : lanelet2_map_osm ( lanelet2_map_osm ), standalone_mode ( standalone_mode ), entity_manager_ptr_ ( std :: make_shared < EntityManager > ( node , lanelet2_map_osm )), metrics_manager_ ( verbose , metrics_logfile_path ), initialize_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: initialize ), update_frame_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: update_frame ), update_sensor_frame_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: update_sensor_frame ), spawn_vehicle_entity_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: spawn_vehicle_entity ), spawn_pedestrian_entity_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: spawn_pedestrian_entity ), despawn_entity_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: despawn_entity ), update_entity_status_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: update_entity_status ), attach_lidar_sensor_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: attach_lidar_sensor ), attach_detection_sensor_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: attach_detection_sensor ) { static const std :: string address = \"127.0.0.1\" ; traffic_controller_ptr_ = std :: make_shared < simulation_api :: traffic :: TrafficController > ( entity_manager_ptr_ -> getHdmapUtils (), [ this ]() { return API :: getEntityNames (); }, [ this ]( const auto & name ) { return API :: getEntityPose ( name ); }, [ this ]( const auto & name ) { return API :: despawn ( name ); }, auto_sink ); metrics_manager_ . setEntityManager ( entity_manager_ptr_ ); setVerbose ( verbose ); } template < typename T , typename ... Ts > void addMetric ( const std :: string & name , Ts && ... xs ) { metrics_manager_ . addMetric < T > ( name , std :: forward < Ts > ( xs )...); } void setVerbose ( const bool verbose ); [[ deprecated ( \"catalog_xml will be removed in the near future\" )]] bool spawn ( const bool is_ego , const std :: string & name , const std :: string & catalog_xml ); bool spawn ( const bool is_ego , const std :: string & name , const openscenario_msgs :: msg :: VehicleParameters & params ); bool spawn ( const bool is_ego , const std :: string & name , const openscenario_msgs :: msg :: PedestrianParameters & params ); template < typename ... Ts > decltype ( auto ) spawn ( const bool is_ego , const std :: string & name , const std :: string & catalog_xml , Ts && ... xs ) { return spawn ( is_ego , name , catalog_xml ) && setEntityStatus ( name , std :: forward < decltype ( xs ) > ( xs )...); } template < typename Parameters , // Maybe, VehicleParameters or PedestrianParameters typename ... Ts // Arguments for setEntityStatus > decltype ( auto ) spawn ( const bool is_ego , const std :: string & name , const Parameters & params , Ts && ... xs ) { return spawn ( is_ego , name , params ) && setEntityStatus ( name , std :: forward < decltype ( xs ) > ( xs )...); } bool despawn ( const std :: string & name ); openscenario_msgs :: msg :: EntityStatus getEntityStatus ( const std :: string & name ); geometry_msgs :: msg :: Pose getEntityPose ( const std :: string & name ); bool setEntityStatus ( const std :: string & name , const openscenario_msgs :: msg :: EntityStatus & status ); bool setEntityStatus ( const std :: string & name , const geometry_msgs :: msg :: Pose & map_pose , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus ()); bool setEntityStatus ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & lanelet_pose , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus ()); bool setEntityStatus ( const std :: string & name , const std :: string & reference_entity_name , const geometry_msgs :: msg :: Pose & relative_pose , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus ()); bool setEntityStatus ( const std :: string & name , const std :: string & reference_entity_name , const geometry_msgs :: msg :: Point & relative_position , const geometry_msgs :: msg :: Vector3 & relative_rpy , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus ()); boost :: optional < double > getTimeHeadway ( const std :: string & from , const std :: string & to ); bool reachPosition ( const std :: string & name , const geometry_msgs :: msg :: Pose & target_pose , const double tolerance ); bool reachPosition ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & target_pose , const double tolerance ); bool reachPosition ( const std :: string & name , const std :: string & target_name , const double tolerance ) const ; bool attachLidarSensor ( simulation_api_schema :: LidarConfiguration configuration ); bool attachDetectionSensor ( simulation_api_schema :: DetectionSensorConfiguration configuration ); bool initialize ( double realtime_factor , double step_time ); bool updateFrame (); bool updateSensorFrame (); double getCurrentTime () const noexcept { return current_time_ ; } const bool standalone_mode ; #define FORWARD_TO_ENTITY_MANAGER(NAME) \\ template<typename ... Ts> \\ decltype(auto) NAME(Ts && ... xs) \\ { \\ assert(entity_manager_ptr_); \\ return (*entity_manager_ptr_).NAME(std::forward<decltype(xs)>(xs)...); \\ } static_assert(true, \"\") FORWARD_TO_ENTITY_MANAGER ( checkCollision ); FORWARD_TO_ENTITY_MANAGER ( entityExists ); FORWARD_TO_ENTITY_MANAGER ( getBoundingBoxDistance ); FORWARD_TO_ENTITY_MANAGER ( getEntityNames ); FORWARD_TO_ENTITY_MANAGER ( getLinearJerk ); FORWARD_TO_ENTITY_MANAGER ( getLongitudinalDistance ); FORWARD_TO_ENTITY_MANAGER ( getRelativePose ); FORWARD_TO_ENTITY_MANAGER ( getStandStillDuration ); FORWARD_TO_ENTITY_MANAGER ( getTrafficLightArrow ); FORWARD_TO_ENTITY_MANAGER ( getTrafficLightColor ); FORWARD_TO_ENTITY_MANAGER ( isInLanelet ); FORWARD_TO_ENTITY_MANAGER ( requestAcquirePosition ); FORWARD_TO_ENTITY_MANAGER ( requestAssignRoute ); FORWARD_TO_ENTITY_MANAGER ( requestLaneChange ); FORWARD_TO_ENTITY_MANAGER ( requestWalkStraight ); FORWARD_TO_ENTITY_MANAGER ( setDriverModel ); FORWARD_TO_ENTITY_MANAGER ( setTargetSpeed ); FORWARD_TO_ENTITY_MANAGER ( setTrafficLightArrow ); FORWARD_TO_ENTITY_MANAGER ( setTrafficLightArrowPhase ); FORWARD_TO_ENTITY_MANAGER ( setTrafficLightColor ); FORWARD_TO_ENTITY_MANAGER ( setTrafficLightColorPhase ); FORWARD_TO_ENTITY_MANAGER ( toLaneletPose ); FORWARD_TO_ENTITY_MANAGER ( toMapPose ); #undef FORWARD_TO_ENTITY_MANAGER private : bool updateEntityStatusInSim (); bool spawn ( const bool is_ego , const std :: string & catalog_xml , const openscenario_msgs :: msg :: EntityStatus & status ); template < typename Parameters // Maybe, VehicleParameters or PedestrianParameters > bool spawn ( const bool is_ego , const Parameters & parameters , const openscenario_msgs :: msg :: EntityStatus & status ) { return spawn ( is_ego , parameters . toXml (), status ); } // openscenario_msgs::msg::EntityStatus toStatus(XmlRpc::XmlRpcValue param); // XmlRpc::XmlRpcValue toValue(openscenario_msgs::msg::EntityStatus status); // std::shared_ptr<XmlRpc::XmlRpcClient> client_ptr_; std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr_ ; std :: shared_ptr < simulation_api :: traffic :: TrafficController > traffic_controller_ptr_ ; double step_time_ ; double current_time_ ; metrics :: MetricsManager metrics_manager_ ; zeromq :: Client < simulation_api_schema :: InitializeRequest , simulation_api_schema :: InitializeResponse > initialize_client_ ; zeromq :: Client < simulation_api_schema :: UpdateFrameRequest , simulation_api_schema :: UpdateFrameResponse > update_frame_client_ ; zeromq :: Client < simulation_api_schema :: UpdateSensorFrameRequest , simulation_api_schema :: UpdateSensorFrameResponse > update_sensor_frame_client_ ; zeromq :: Client < simulation_api_schema :: SpawnVehicleEntityRequest , simulation_api_schema :: SpawnVehicleEntityResponse > spawn_vehicle_entity_client_ ; zeromq :: Client < simulation_api_schema :: SpawnPedestrianEntityRequest , simulation_api_schema :: SpawnPedestrianEntityResponse > spawn_pedestrian_entity_client_ ; zeromq :: Client < simulation_api_schema :: DespawnEntityRequest , simulation_api_schema :: DespawnEntityResponse > despawn_entity_client_ ; zeromq :: Client < simulation_api_schema :: UpdateEntityStatusRequest , simulation_api_schema :: UpdateEntityStatusResponse > update_entity_status_client_ ; zeromq :: Client < simulation_api_schema :: AttachLidarSensorRequest , simulation_api_schema :: AttachLidarSensorResponse > attach_lidar_sensor_client_ ; zeromq :: Client < simulation_api_schema :: AttachDetectionSensorRequest , simulation_api_schema :: AttachDetectionSensorResponse > attach_detection_sensor_client_ ; }; } // namespace scenario_simulator #endif // SIMULATION_API__API__API_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/api/api.hpp"},{"location":"package/simulation_api/markdown/Files/api_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apiapiapihpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/api/api.hpp"},{"location":"package/simulation_api/markdown/Files/api_8hpp/#namespaces","text":"Name scenario_simulator","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/api_8hpp/#classes","text":"Name class scenario_simulator::ExecutionFailedError class scenario_simulator::API","title":"Classes"},{"location":"package/simulation_api/markdown/Files/api_8hpp/#defines","text":"Name FORWARD_TO_ENTITY_MANAGER (NAME)","title":"Defines"},{"location":"package/simulation_api/markdown/Files/api_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/simulation_api/markdown/Files/api_8hpp/#define-forward_to_entity_manager","text":"#define FORWARD_TO_ENTITY_MANAGER( NAME ) template < typename ... Ts > \\ decltype ( auto ) NAME ( Ts && ... xs ) \\ { \\ assert ( entity_manager_ptr_ ); \\ return ( * entity_manager_ptr_ ). NAME ( std :: forward < decltype ( xs ) > ( xs )...); \\ } static_assert ( true , \"\" )","title":"define FORWARD_TO_ENTITY_MANAGER"},{"location":"package/simulation_api/markdown/Files/api_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__API__API_HPP_ #define SIMULATION_API__API__API_HPP_ #include <simulation_api/entity/entity_manager.hpp> #include <simulation_api/helper/helper.hpp> #include <simulation_api/metrics/metrics_manager.hpp> #include <simulation_api/traffic/traffic_controller.hpp> #include <simulation_api/traffic_lights/traffic_light.hpp> #include <autoware_auto_msgs/msg/vehicle_control_command.hpp> #include <autoware_auto_msgs/msg/vehicle_state_command.hpp> #include <awapi_accessor/accessor.hpp> #include <boost/filesystem.hpp> #include <openscenario_msgs/msg/driver_model.hpp> #include <rclcpp/rclcpp.hpp> #include <simulation_api_schema.pb.h> #include <simulation_interface/zmq_client.hpp> #include <cassert> #include <memory> #include <string> #include <utility> namespace scenario_simulator { class ExecutionFailedError : public std :: runtime_error { public : template < typename ... Ts > explicit ExecutionFailedError ( Ts && ... xs ) : runtime_error ( std :: forward < decltype ( xs ) > ( xs )...) {} virtual ~ ExecutionFailedError () = default ; }; class API { using EntityManager = simulation_api :: entity :: EntityManager ; public : const std :: string lanelet2_map_osm ; template < class NodeT , class AllocatorT = std :: allocator < void >> explicit API ( NodeT && node , const boost :: filesystem :: path , const std :: string & lanelet2_map_osm , const bool auto_sink = true , const bool verbose = false , const bool standalone_mode = false , const std :: string & metrics_logfile_path = \"/tmp/metrics.json\" ) : lanelet2_map_osm ( lanelet2_map_osm ), standalone_mode ( standalone_mode ), entity_manager_ptr_ ( std :: make_shared < EntityManager > ( node , lanelet2_map_osm )), metrics_manager_ ( verbose , metrics_logfile_path ), initialize_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: initialize ), update_frame_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: update_frame ), update_sensor_frame_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: update_sensor_frame ), spawn_vehicle_entity_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: spawn_vehicle_entity ), spawn_pedestrian_entity_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: spawn_pedestrian_entity ), despawn_entity_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: despawn_entity ), update_entity_status_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: update_entity_status ), attach_lidar_sensor_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: attach_lidar_sensor ), attach_detection_sensor_client_ ( simulation_interface :: protocol , simulation_interface :: HostName :: LOCLHOST , simulation_interface :: ports :: attach_detection_sensor ) { static const std :: string address = \"127.0.0.1\" ; traffic_controller_ptr_ = std :: make_shared < simulation_api :: traffic :: TrafficController > ( entity_manager_ptr_ -> getHdmapUtils (), [ this ]() { return API :: getEntityNames (); }, [ this ]( const auto & name ) { return API :: getEntityPose ( name ); }, [ this ]( const auto & name ) { return API :: despawn ( name ); }, auto_sink ); metrics_manager_ . setEntityManager ( entity_manager_ptr_ ); setVerbose ( verbose ); } template < typename T , typename ... Ts > void addMetric ( const std :: string & name , Ts && ... xs ) { metrics_manager_ . addMetric < T > ( name , std :: forward < Ts > ( xs )...); } void setVerbose ( const bool verbose ); [[ deprecated ( \"catalog_xml will be removed in the near future\" )]] bool spawn ( const bool is_ego , const std :: string & name , const std :: string & catalog_xml ); bool spawn ( const bool is_ego , const std :: string & name , const openscenario_msgs :: msg :: VehicleParameters & params ); bool spawn ( const bool is_ego , const std :: string & name , const openscenario_msgs :: msg :: PedestrianParameters & params ); template < typename ... Ts > decltype ( auto ) spawn ( const bool is_ego , const std :: string & name , const std :: string & catalog_xml , Ts && ... xs ) { return spawn ( is_ego , name , catalog_xml ) && setEntityStatus ( name , std :: forward < decltype ( xs ) > ( xs )...); } template < typename Parameters , // Maybe, VehicleParameters or PedestrianParameters typename ... Ts // Arguments for setEntityStatus > decltype ( auto ) spawn ( const bool is_ego , const std :: string & name , const Parameters & params , Ts && ... xs ) { return spawn ( is_ego , name , params ) && setEntityStatus ( name , std :: forward < decltype ( xs ) > ( xs )...); } bool despawn ( const std :: string & name ); openscenario_msgs :: msg :: EntityStatus getEntityStatus ( const std :: string & name ); geometry_msgs :: msg :: Pose getEntityPose ( const std :: string & name ); bool setEntityStatus ( const std :: string & name , const openscenario_msgs :: msg :: EntityStatus & status ); bool setEntityStatus ( const std :: string & name , const geometry_msgs :: msg :: Pose & map_pose , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus ()); bool setEntityStatus ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & lanelet_pose , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus ()); bool setEntityStatus ( const std :: string & name , const std :: string & reference_entity_name , const geometry_msgs :: msg :: Pose & relative_pose , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus ()); bool setEntityStatus ( const std :: string & name , const std :: string & reference_entity_name , const geometry_msgs :: msg :: Point & relative_position , const geometry_msgs :: msg :: Vector3 & relative_rpy , const openscenario_msgs :: msg :: ActionStatus & action_status = simulation_api :: helper :: constructActionStatus ()); boost :: optional < double > getTimeHeadway ( const std :: string & from , const std :: string & to ); bool reachPosition ( const std :: string & name , const geometry_msgs :: msg :: Pose & target_pose , const double tolerance ); bool reachPosition ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & target_pose , const double tolerance ); bool reachPosition ( const std :: string & name , const std :: string & target_name , const double tolerance ) const ; bool attachLidarSensor ( simulation_api_schema :: LidarConfiguration configuration ); bool attachDetectionSensor ( simulation_api_schema :: DetectionSensorConfiguration configuration ); bool initialize ( double realtime_factor , double step_time ); bool updateFrame (); bool updateSensorFrame (); double getCurrentTime () const noexcept { return current_time_ ; } const bool standalone_mode ; #define FORWARD_TO_ENTITY_MANAGER(NAME) \\ template<typename ... Ts> \\ decltype(auto) NAME(Ts && ... xs) \\ { \\ assert(entity_manager_ptr_); \\ return (*entity_manager_ptr_).NAME(std::forward<decltype(xs)>(xs)...); \\ } static_assert(true, \"\") FORWARD_TO_ENTITY_MANAGER ( checkCollision ); FORWARD_TO_ENTITY_MANAGER ( entityExists ); FORWARD_TO_ENTITY_MANAGER ( getBoundingBoxDistance ); FORWARD_TO_ENTITY_MANAGER ( getEntityNames ); FORWARD_TO_ENTITY_MANAGER ( getLinearJerk ); FORWARD_TO_ENTITY_MANAGER ( getLongitudinalDistance ); FORWARD_TO_ENTITY_MANAGER ( getRelativePose ); FORWARD_TO_ENTITY_MANAGER ( getStandStillDuration ); FORWARD_TO_ENTITY_MANAGER ( getTrafficLightArrow ); FORWARD_TO_ENTITY_MANAGER ( getTrafficLightColor ); FORWARD_TO_ENTITY_MANAGER ( isInLanelet ); FORWARD_TO_ENTITY_MANAGER ( requestAcquirePosition ); FORWARD_TO_ENTITY_MANAGER ( requestAssignRoute ); FORWARD_TO_ENTITY_MANAGER ( requestLaneChange ); FORWARD_TO_ENTITY_MANAGER ( requestWalkStraight ); FORWARD_TO_ENTITY_MANAGER ( setDriverModel ); FORWARD_TO_ENTITY_MANAGER ( setTargetSpeed ); FORWARD_TO_ENTITY_MANAGER ( setTrafficLightArrow ); FORWARD_TO_ENTITY_MANAGER ( setTrafficLightArrowPhase ); FORWARD_TO_ENTITY_MANAGER ( setTrafficLightColor ); FORWARD_TO_ENTITY_MANAGER ( setTrafficLightColorPhase ); FORWARD_TO_ENTITY_MANAGER ( toLaneletPose ); FORWARD_TO_ENTITY_MANAGER ( toMapPose ); #undef FORWARD_TO_ENTITY_MANAGER private : bool updateEntityStatusInSim (); bool spawn ( const bool is_ego , const std :: string & catalog_xml , const openscenario_msgs :: msg :: EntityStatus & status ); template < typename Parameters // Maybe, VehicleParameters or PedestrianParameters > bool spawn ( const bool is_ego , const Parameters & parameters , const openscenario_msgs :: msg :: EntityStatus & status ) { return spawn ( is_ego , parameters . toXml (), status ); } // openscenario_msgs::msg::EntityStatus toStatus(XmlRpc::XmlRpcValue param); // XmlRpc::XmlRpcValue toValue(openscenario_msgs::msg::EntityStatus status); // std::shared_ptr<XmlRpc::XmlRpcClient> client_ptr_; std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr_ ; std :: shared_ptr < simulation_api :: traffic :: TrafficController > traffic_controller_ptr_ ; double step_time_ ; double current_time_ ; metrics :: MetricsManager metrics_manager_ ; zeromq :: Client < simulation_api_schema :: InitializeRequest , simulation_api_schema :: InitializeResponse > initialize_client_ ; zeromq :: Client < simulation_api_schema :: UpdateFrameRequest , simulation_api_schema :: UpdateFrameResponse > update_frame_client_ ; zeromq :: Client < simulation_api_schema :: UpdateSensorFrameRequest , simulation_api_schema :: UpdateSensorFrameResponse > update_sensor_frame_client_ ; zeromq :: Client < simulation_api_schema :: SpawnVehicleEntityRequest , simulation_api_schema :: SpawnVehicleEntityResponse > spawn_vehicle_entity_client_ ; zeromq :: Client < simulation_api_schema :: SpawnPedestrianEntityRequest , simulation_api_schema :: SpawnPedestrianEntityResponse > spawn_pedestrian_entity_client_ ; zeromq :: Client < simulation_api_schema :: DespawnEntityRequest , simulation_api_schema :: DespawnEntityResponse > despawn_entity_client_ ; zeromq :: Client < simulation_api_schema :: UpdateEntityStatusRequest , simulation_api_schema :: UpdateEntityStatusResponse > update_entity_status_client_ ; zeromq :: Client < simulation_api_schema :: AttachLidarSensorRequest , simulation_api_schema :: AttachLidarSensorResponse > attach_lidar_sensor_client_ ; zeromq :: Client < simulation_api_schema :: AttachDetectionSensorRequest , simulation_api_schema :: AttachDetectionSensorResponse > attach_detection_sensor_client_ ; }; } // namespace scenario_simulator #endif // SIMULATION_API__API__API_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/bounding__box_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/bounding_box.cpp # Namespaces # Name simulation_api::math simulation_api Defines # Name EIGEN_MPL2_ONLY Macro Documentation # define EIGEN_MPL2_ONLY # #define EIGEN_MPL2_ONLY Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/math/bounding_box.hpp> #include <quaternion_operation/quaternion_operation.h> // headers in Eigen #define EIGEN_MPL2_ONLY #include <Eigen/Core> #include <vector> namespace simulation_api { namespace math { boost :: optional < double > getPolygonDistance ( const geometry_msgs :: msg :: Pose & pose0 , const openscenario_msgs :: msg :: BoundingBox & bbox0 , const geometry_msgs :: msg :: Pose & pose1 , const openscenario_msgs :: msg :: BoundingBox & bbox1 ) { const auto poly0 = get2DPolygon ( pose0 , bbox0 ); const auto poly1 = get2DPolygon ( pose1 , bbox1 ); namespace bg = boost :: geometry ; if ( bg :: intersects ( poly0 , poly1 )) { return boost :: none ; } if ( bg :: intersects ( poly1 , poly0 )) { return boost :: none ; } if ( bg :: disjoint ( poly0 , poly1 )) { return bg :: distance ( poly0 , poly1 ); } return boost :: none ; } const boost :: geometry :: model :: polygon < boost :: geometry :: model :: d2 :: point_xy < double >> get2DPolygon ( const geometry_msgs :: msg :: Pose & pose , const openscenario_msgs :: msg :: BoundingBox & bbox ) { auto points = transformPoints ( pose , getPointsFromBbox ( bbox )); namespace bg = boost :: geometry ; typedef bg :: model :: d2 :: point_xy < double > bg_point ; bg :: model :: polygon < bg_point > poly ; poly . outer (). push_back ( bg_point ( points [ 0 ]. x , points [ 0 ]. y )); poly . outer (). push_back ( bg_point ( points [ 1 ]. x , points [ 1 ]. y )); poly . outer (). push_back ( bg_point ( points [ 2 ]. x , points [ 2 ]. y )); poly . outer (). push_back ( bg_point ( points [ 3 ]. x , points [ 3 ]. y )); poly . outer (). push_back ( bg_point ( points [ 0 ]. x , points [ 0 ]. y )); return poly ; } std :: vector < geometry_msgs :: msg :: Point > getPointsFromBbox ( openscenario_msgs :: msg :: BoundingBox bbox ) { std :: vector < geometry_msgs :: msg :: Point > points ; geometry_msgs :: msg :: Point p0 ; p0 . x = bbox . center . x + bbox . dimensions . x * 0.5 ; p0 . y = bbox . center . y + bbox . dimensions . y * 0.5 ; p0 . z = bbox . center . z + bbox . dimensions . z * 0.5 ; points . emplace_back ( p0 ); geometry_msgs :: msg :: Point p1 ; p1 . x = bbox . center . x - bbox . dimensions . x * 0.5 ; p1 . y = bbox . center . y + bbox . dimensions . y * 0.5 ; p1 . z = bbox . center . z + bbox . dimensions . z * 0.5 ; points . emplace_back ( p1 ); geometry_msgs :: msg :: Point p2 ; p2 . x = bbox . center . x - bbox . dimensions . x * 0.5 ; p2 . y = bbox . center . y - bbox . dimensions . y * 0.5 ; p2 . z = bbox . center . z + bbox . dimensions . z * 0.5 ; points . emplace_back ( p2 ); geometry_msgs :: msg :: Point p3 ; p3 . x = bbox . center . x + bbox . dimensions . x * 0.5 ; p3 . y = bbox . center . y - bbox . dimensions . y * 0.5 ; p3 . z = bbox . center . z + bbox . dimensions . z * 0.5 ; points . emplace_back ( p3 ); return points ; } std :: vector < geometry_msgs :: msg :: Point > transformPoints ( geometry_msgs :: msg :: Pose pose , std :: vector < geometry_msgs :: msg :: Point > points ) { auto mat = quaternion_operation :: getRotationMatrix ( pose . orientation ); std :: vector < geometry_msgs :: msg :: Point > ret ; for ( const auto & point : points ) { Eigen :: VectorXd v ( 3 ); v ( 0 ) = point . x ; v ( 1 ) = point . y ; v ( 2 ) = point . z ; v = mat * v ; v ( 0 ) = v ( 0 ) + pose . position . x ; v ( 1 ) = v ( 1 ) + pose . position . y ; v ( 2 ) = v ( 2 ) + pose . position . z ; geometry_msgs :: msg :: Point transformed ; transformed . x = v ( 0 ); transformed . y = v ( 1 ); transformed . z = v ( 2 ); ret . emplace_back ( transformed ); } return ret ; } } // namespace math } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/bounding_box.cpp"},{"location":"package/simulation_api/markdown/Files/bounding__box_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmathbounding_boxcpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/bounding_box.cpp"},{"location":"package/simulation_api/markdown/Files/bounding__box_8cpp/#namespaces","text":"Name simulation_api::math simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/bounding__box_8cpp/#defines","text":"Name EIGEN_MPL2_ONLY","title":"Defines"},{"location":"package/simulation_api/markdown/Files/bounding__box_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/simulation_api/markdown/Files/bounding__box_8cpp/#define-eigen_mpl2_only","text":"#define EIGEN_MPL2_ONLY","title":"define EIGEN_MPL2_ONLY"},{"location":"package/simulation_api/markdown/Files/bounding__box_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/math/bounding_box.hpp> #include <quaternion_operation/quaternion_operation.h> // headers in Eigen #define EIGEN_MPL2_ONLY #include <Eigen/Core> #include <vector> namespace simulation_api { namespace math { boost :: optional < double > getPolygonDistance ( const geometry_msgs :: msg :: Pose & pose0 , const openscenario_msgs :: msg :: BoundingBox & bbox0 , const geometry_msgs :: msg :: Pose & pose1 , const openscenario_msgs :: msg :: BoundingBox & bbox1 ) { const auto poly0 = get2DPolygon ( pose0 , bbox0 ); const auto poly1 = get2DPolygon ( pose1 , bbox1 ); namespace bg = boost :: geometry ; if ( bg :: intersects ( poly0 , poly1 )) { return boost :: none ; } if ( bg :: intersects ( poly1 , poly0 )) { return boost :: none ; } if ( bg :: disjoint ( poly0 , poly1 )) { return bg :: distance ( poly0 , poly1 ); } return boost :: none ; } const boost :: geometry :: model :: polygon < boost :: geometry :: model :: d2 :: point_xy < double >> get2DPolygon ( const geometry_msgs :: msg :: Pose & pose , const openscenario_msgs :: msg :: BoundingBox & bbox ) { auto points = transformPoints ( pose , getPointsFromBbox ( bbox )); namespace bg = boost :: geometry ; typedef bg :: model :: d2 :: point_xy < double > bg_point ; bg :: model :: polygon < bg_point > poly ; poly . outer (). push_back ( bg_point ( points [ 0 ]. x , points [ 0 ]. y )); poly . outer (). push_back ( bg_point ( points [ 1 ]. x , points [ 1 ]. y )); poly . outer (). push_back ( bg_point ( points [ 2 ]. x , points [ 2 ]. y )); poly . outer (). push_back ( bg_point ( points [ 3 ]. x , points [ 3 ]. y )); poly . outer (). push_back ( bg_point ( points [ 0 ]. x , points [ 0 ]. y )); return poly ; } std :: vector < geometry_msgs :: msg :: Point > getPointsFromBbox ( openscenario_msgs :: msg :: BoundingBox bbox ) { std :: vector < geometry_msgs :: msg :: Point > points ; geometry_msgs :: msg :: Point p0 ; p0 . x = bbox . center . x + bbox . dimensions . x * 0.5 ; p0 . y = bbox . center . y + bbox . dimensions . y * 0.5 ; p0 . z = bbox . center . z + bbox . dimensions . z * 0.5 ; points . emplace_back ( p0 ); geometry_msgs :: msg :: Point p1 ; p1 . x = bbox . center . x - bbox . dimensions . x * 0.5 ; p1 . y = bbox . center . y + bbox . dimensions . y * 0.5 ; p1 . z = bbox . center . z + bbox . dimensions . z * 0.5 ; points . emplace_back ( p1 ); geometry_msgs :: msg :: Point p2 ; p2 . x = bbox . center . x - bbox . dimensions . x * 0.5 ; p2 . y = bbox . center . y - bbox . dimensions . y * 0.5 ; p2 . z = bbox . center . z + bbox . dimensions . z * 0.5 ; points . emplace_back ( p2 ); geometry_msgs :: msg :: Point p3 ; p3 . x = bbox . center . x + bbox . dimensions . x * 0.5 ; p3 . y = bbox . center . y - bbox . dimensions . y * 0.5 ; p3 . z = bbox . center . z + bbox . dimensions . z * 0.5 ; points . emplace_back ( p3 ); return points ; } std :: vector < geometry_msgs :: msg :: Point > transformPoints ( geometry_msgs :: msg :: Pose pose , std :: vector < geometry_msgs :: msg :: Point > points ) { auto mat = quaternion_operation :: getRotationMatrix ( pose . orientation ); std :: vector < geometry_msgs :: msg :: Point > ret ; for ( const auto & point : points ) { Eigen :: VectorXd v ( 3 ); v ( 0 ) = point . x ; v ( 1 ) = point . y ; v ( 2 ) = point . z ; v = mat * v ; v ( 0 ) = v ( 0 ) + pose . position . x ; v ( 1 ) = v ( 1 ) + pose . position . y ; v ( 2 ) = v ( 2 ) + pose . position . z ; geometry_msgs :: msg :: Point transformed ; transformed . x = v ( 0 ); transformed . y = v ( 1 ); transformed . z = v ( 2 ); ret . emplace_back ( transformed ); } return ret ; } } // namespace math } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/bounding__box_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/bounding_box.hpp # Namespaces # Name simulation_api::math simulation_api Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__MATH__BOUNDING_BOX_HPP_ #define SIMULATION_API__MATH__BOUNDING_BOX_HPP_ #include <openscenario_msgs/msg/bounding_box.hpp> #include <geometry_msgs/msg/pose.hpp> #include <boost/assert.hpp> #include <boost/geometry.hpp> #include <boost/geometry/geometries/linestring.hpp> #include <boost/geometry/geometries/point_xy.hpp> #include <boost/assign/list_of.hpp> #include <boost/geometry/algorithms/disjoint.hpp> #include <boost/optional.hpp> #include <vector> namespace simulation_api { namespace math { boost :: optional < double > getPolygonDistance ( const geometry_msgs :: msg :: Pose & pose0 , const openscenario_msgs :: msg :: BoundingBox & bbox0 , const geometry_msgs :: msg :: Pose & pose1 , const openscenario_msgs :: msg :: BoundingBox & bbox1 ); const boost :: geometry :: model :: polygon < boost :: geometry :: model :: d2 :: point_xy < double >> get2DPolygon ( const geometry_msgs :: msg :: Pose & pose , const openscenario_msgs :: msg :: BoundingBox & bbox ); std :: vector < geometry_msgs :: msg :: Point > transformPoints ( geometry_msgs :: msg :: Pose pose , std :: vector < geometry_msgs :: msg :: Point > points ); std :: vector < geometry_msgs :: msg :: Point > getPointsFromBbox ( openscenario_msgs :: msg :: BoundingBox bbox ); } // namespace math } // namespace simulation_api #endif // SIMULATION_API__MATH__BOUNDING_BOX_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/bounding_box.hpp"},{"location":"package/simulation_api/markdown/Files/bounding__box_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apimathbounding_boxhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/bounding_box.hpp"},{"location":"package/simulation_api/markdown/Files/bounding__box_8hpp/#namespaces","text":"Name simulation_api::math simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/bounding__box_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__MATH__BOUNDING_BOX_HPP_ #define SIMULATION_API__MATH__BOUNDING_BOX_HPP_ #include <openscenario_msgs/msg/bounding_box.hpp> #include <geometry_msgs/msg/pose.hpp> #include <boost/assert.hpp> #include <boost/geometry.hpp> #include <boost/geometry/geometries/linestring.hpp> #include <boost/geometry/geometries/point_xy.hpp> #include <boost/assign/list_of.hpp> #include <boost/geometry/algorithms/disjoint.hpp> #include <boost/optional.hpp> #include <vector> namespace simulation_api { namespace math { boost :: optional < double > getPolygonDistance ( const geometry_msgs :: msg :: Pose & pose0 , const openscenario_msgs :: msg :: BoundingBox & bbox0 , const geometry_msgs :: msg :: Pose & pose1 , const openscenario_msgs :: msg :: BoundingBox & bbox1 ); const boost :: geometry :: model :: polygon < boost :: geometry :: model :: d2 :: point_xy < double >> get2DPolygon ( const geometry_msgs :: msg :: Pose & pose , const openscenario_msgs :: msg :: BoundingBox & bbox ); std :: vector < geometry_msgs :: msg :: Point > transformPoints ( geometry_msgs :: msg :: Pose pose , std :: vector < geometry_msgs :: msg :: Point > points ); std :: vector < geometry_msgs :: msg :: Point > getPointsFromBbox ( openscenario_msgs :: msg :: BoundingBox bbox ); } // namespace math } // namespace simulation_api #endif // SIMULATION_API__MATH__BOUNDING_BOX_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/catmull__rom__spline_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/catmull_rom_spline.cpp # Namespaces # Name simulation_api::math simulation_api Source code # // Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/math/catmull_rom_spline.hpp> #include <vector> #include <string> #include <limits> #include <utility> #include <iostream> namespace simulation_api { namespace math { CatmullRomSpline :: CatmullRomSpline ( const std :: vector < openscenario_msgs :: msg :: HermiteCurve > & hermite_curves ) { for ( const auto & curve : hermite_curves ) { curves_ . emplace_back ( HermiteCurve ( curve )); } } const std :: vector < geometry_msgs :: msg :: Point > CatmullRomSpline :: getPolygon ( double width , size_t num_points , double z_offset ) { std :: vector < geometry_msgs :: msg :: Point > points ; std :: vector < geometry_msgs :: msg :: Point > left_bounds = getLeftBounds ( width , num_points , z_offset ); std :: vector < geometry_msgs :: msg :: Point > right_bounds = getRightBounds ( width , num_points , z_offset ); size_t num_sections = static_cast < size_t > ( left_bounds . size () - 1 ); for ( size_t i = 0 ; i < num_sections ; i ++ ) { geometry_msgs :: msg :: Point pr_0 = right_bounds [ i ]; geometry_msgs :: msg :: Point pl_0 = left_bounds [ i ]; geometry_msgs :: msg :: Point pr_1 = right_bounds [ i + 1 ]; geometry_msgs :: msg :: Point pl_1 = left_bounds [ i + 1 ]; points . emplace_back ( pr_0 ); points . emplace_back ( pl_0 ); points . emplace_back ( pr_1 ); points . emplace_back ( pl_0 ); points . emplace_back ( pl_1 ); points . emplace_back ( pr_1 ); } return points ; } const geometry_msgs :: msg :: Point CatmullRomSpline :: getRightBoundsPoint ( double width , double s , double z_offset ) const { geometry_msgs :: msg :: Vector3 vec = getNormalVector ( s ); double theta = std :: atan2 ( vec . y , vec . x ); geometry_msgs :: msg :: Point p = getPoint ( s ); geometry_msgs :: msg :: Point point ; point . x = p . x + 0.5 * width * std :: cos ( theta ); point . y = p . y + 0.5 * width * std :: sin ( theta ); point . z = p . z + z_offset ; return point ; } const geometry_msgs :: msg :: Point CatmullRomSpline :: getLeftBoundsPoint ( double width , double s , double z_offset ) const { geometry_msgs :: msg :: Vector3 vec = getNormalVector ( s ); double theta = std :: atan2 ( vec . y , vec . x ); geometry_msgs :: msg :: Point p = getPoint ( s ); geometry_msgs :: msg :: Point point ; point . x = p . x - 0.5 * width * std :: cos ( theta ); point . y = p . y - 0.5 * width * std :: sin ( theta ); point . z = p . z + z_offset ; return point ; } const std :: vector < geometry_msgs :: msg :: Point > CatmullRomSpline :: getRightBounds ( double width , size_t num_points , double z_offset ) const { std :: vector < geometry_msgs :: msg :: Point > points ; double step_size = getLength () / static_cast < double > ( num_points ); for ( size_t i = 0 ; i < static_cast < size_t > ( num_points + 1 ); i ++ ) { double s = step_size * static_cast < double > ( i ); points . emplace_back ( getRightBoundsPoint ( width , s , z_offset )); } return points ; } const std :: vector < geometry_msgs :: msg :: Point > CatmullRomSpline :: getLeftBounds ( double width , size_t num_points , double z_offset ) const { std :: vector < geometry_msgs :: msg :: Point > points ; double step_size = getLength () / static_cast < double > ( num_points ); for ( size_t i = 0 ; i < static_cast < size_t > ( num_points + 1 ); i ++ ) { double s = step_size * static_cast < double > ( i ); points . emplace_back ( getLeftBoundsPoint ( width , s , z_offset )); } return points ; } const std :: vector < geometry_msgs :: msg :: Point > CatmullRomSpline :: getTrajectory ( double start_s , double end_s , double num_points ) const { std :: vector < geometry_msgs :: msg :: Point > traj ; num_points = std :: fabs ( num_points ); double s = start_s ; if ( start_s < end_s ) { while ( s < end_s ) { auto p = getPoint ( s ); traj . emplace_back ( p ); s = s + num_points ; } } else { while ( s < end_s ) { auto p = getPoint ( s ); traj . emplace_back ( p ); s = s - num_points ; } } return traj ; } CatmullRomSpline :: CatmullRomSpline ( const openscenario_msgs :: msg :: CatmullRomSpline & spline ) { for ( const auto & curve : spline . curves ) { curves_ . emplace_back ( HermiteCurve ( curve )); } } CatmullRomSpline :: CatmullRomSpline ( const std :: vector < geometry_msgs :: msg :: Point > & control_points ) : control_points ( control_points ) { size_t n = control_points . size () - 1 ; if ( control_points . size () <= 2 ) { throw SplineInterpolationError ( \"numbers of control points are not enough.\" ); } for ( size_t i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { double ax = 0 ; double bx = control_points [ 0 ]. x - 2 * control_points [ 1 ]. x + control_points [ 2 ]. x ; double cx = -3 * control_points [ 0 ]. x + 4 * control_points [ 1 ]. x - control_points [ 2 ]. x ; double dx = 2 * control_points [ 0 ]. x ; double ay = 0 ; double by = control_points [ 0 ]. y - 2 * control_points [ 1 ]. y + control_points [ 2 ]. y ; double cy = -3 * control_points [ 0 ]. y + 4 * control_points [ 1 ]. y - control_points [ 2 ]. y ; double dy = 2 * control_points [ 0 ]. y ; double az = 0 ; double bz = control_points [ 0 ]. z - 2 * control_points [ 1 ]. z + control_points [ 2 ]. z ; double cz = -3 * control_points [ 0 ]. z + 4 * control_points [ 1 ]. z - control_points [ 2 ]. z ; double dz = 2 * control_points [ 0 ]. z ; ax = ax * 0.5 ; bx = bx * 0.5 ; cx = cx * 0.5 ; dx = dx * 0.5 ; ay = ay * 0.5 ; by = by * 0.5 ; cy = cy * 0.5 ; dy = dy * 0.5 ; az = az * 0.5 ; bz = bz * 0.5 ; cz = cz * 0.5 ; dz = dz * 0.5 ; curves_ . emplace_back ( HermiteCurve ( ax , bx , cx , dx , ay , by , cy , dy , az , bz , cz , dz )); } else if ( i == ( n - 1 )) { double ax = 0 ; double bx = control_points [ i - 1 ]. x - 2 * control_points [ i ]. x + control_points [ i + 1 ]. x ; double cx = -1 * control_points [ i - 1 ]. x + control_points [ i + 1 ]. x ; double dx = 2 * control_points [ i ]. x ; double ay = 0 ; double by = control_points [ i - 1 ]. y - 2 * control_points [ i ]. y + control_points [ i + 1 ]. y ; double cy = -1 * control_points [ i - 1 ]. y + control_points [ i + 1 ]. y ; double dy = 2 * control_points [ i ]. y ; double az = 0 ; double bz = control_points [ i - 1 ]. z - 2 * control_points [ i ]. z + control_points [ i + 1 ]. z ; double cz = -1 * control_points [ i - 1 ]. z + control_points [ i + 1 ]. z ; double dz = 2 * control_points [ i ]. z ; ax = ax * 0.5 ; bx = bx * 0.5 ; cx = cx * 0.5 ; dx = dx * 0.5 ; ay = ay * 0.5 ; by = by * 0.5 ; cy = cy * 0.5 ; dy = dy * 0.5 ; az = az * 0.5 ; bz = bz * 0.5 ; cz = cz * 0.5 ; dz = dz * 0.5 ; curves_ . emplace_back ( HermiteCurve ( ax , bx , cx , dx , ay , by , cy , dy , az , bz , cz , dz )); } else { double ax = -1 * control_points [ i - 1 ]. x + 3 * control_points [ i ]. x - 3 * control_points [ i + 1 ]. x + control_points [ i + 2 ]. x ; double bx = 2 * control_points [ i - 1 ]. x - 5 * control_points [ i ]. x + 4 * control_points [ i + 1 ]. x - control_points [ i + 2 ]. x ; double cx = - control_points [ i - 1 ]. x + control_points [ i + 1 ]. x ; double dx = 2 * control_points [ i ]. x ; double ay = -1 * control_points [ i - 1 ]. y + 3 * control_points [ i ]. y - 3 * control_points [ i + 1 ]. y + control_points [ i + 2 ]. y ; double by = 2 * control_points [ i - 1 ]. y - 5 * control_points [ i ]. y + 4 * control_points [ i + 1 ]. y - control_points [ i + 2 ]. y ; double cy = - control_points [ i - 1 ]. y + control_points [ i + 1 ]. y ; double dy = 2 * control_points [ i ]. y ; double az = -1 * control_points [ i - 1 ]. z + 3 * control_points [ i ]. z - 3 * control_points [ i + 1 ]. z + control_points [ i + 2 ]. z ; double bz = 2 * control_points [ i - 1 ]. z - 5 * control_points [ i ]. z + 4 * control_points [ i + 1 ]. z - control_points [ i + 2 ]. z ; double cz = - control_points [ i - 1 ]. z + control_points [ i + 1 ]. z ; double dz = 2 * control_points [ i ]. z ; ax = ax * 0.5 ; bx = bx * 0.5 ; cx = cx * 0.5 ; dx = dx * 0.5 ; ay = ay * 0.5 ; by = by * 0.5 ; cy = cy * 0.5 ; dy = dy * 0.5 ; az = az * 0.5 ; bz = bz * 0.5 ; cz = cz * 0.5 ; dz = dz * 0.5 ; curves_ . emplace_back ( HermiteCurve ( ax , bx , cx , dx , ay , by , cy , dy , az , bz , cz , dz )); } } for ( const auto & curve : curves_ ) { length_list_ . emplace_back ( curve . getLength ()); maximum_2d_curvatures_ . emplace_back ( curve . getMaximu2DCurvature ()); } total_length_ = 0 ; for ( const auto & length : length_list_ ) { total_length_ = total_length_ + length ; } checkConnection (); } const openscenario_msgs :: msg :: CatmullRomSpline CatmullRomSpline :: toRosMsg () const { openscenario_msgs :: msg :: CatmullRomSpline spline ; for ( const auto & curve : curves_ ) { spline . curves . emplace_back ( curve . toRosMsg ()); } return spline ; } std :: pair < size_t , double > CatmullRomSpline :: getCurveIndexAndS ( double s ) const { if ( s < 0 ) { return std :: make_pair ( 0 , s ); } if ( s >= total_length_ ) { return std :: make_pair ( curves_ . size () - 1 , s - ( total_length_ - curves_ [ curves_ . size () - 1 ]. getLength ())); } double current_s = 0 ; for ( size_t i = 0 ; i < curves_ . size (); i ++ ) { double prev_s = current_s ; current_s = current_s + length_list_ [ i ]; if ( prev_s <= s && s < current_s ) { return std :: make_pair ( i , s - prev_s ); } } throw SplineInterpolationError ( \"failed to calculate curve index\" ); } double CatmullRomSpline :: getSInSplineCurve ( size_t curve_index , double s ) const { size_t n = curves_ . size (); double ret = 0 ; for ( size_t i = 0 ; i < n ; i ++ ) { if ( i == curve_index ) { return ret + s ; } else { ret = ret + curves_ [ i ]. getLength (); } } throw SplineInterpolationError ( \"curve index does not match.\" ); } boost :: optional < double > CatmullRomSpline :: getCollisionPointIn2D ( std :: vector < geometry_msgs :: msg :: Point > polygon , bool search_backward ) const { size_t n = curves_ . size (); if ( search_backward ) { for ( size_t i = 0 ; i < n ; i ++ ) { auto s = curves_ [ n - 1 - i ]. getCollisionPointIn2D ( polygon , search_backward ); if ( s ) { return getSInSplineCurve ( n - 1 - i , s . get ()); } } return boost :: none ; } else { for ( size_t i = 0 ; i < n ; i ++ ) { auto s = curves_ [ i ]. getCollisionPointIn2D ( polygon , search_backward ); if ( s ) { return getSInSplineCurve ( i , s . get ()); } } return boost :: none ; } return boost :: none ; } boost :: optional < double > CatmullRomSpline :: getCollisionPointIn2D ( geometry_msgs :: msg :: Point point0 , geometry_msgs :: msg :: Point point1 , bool search_backward ) const { size_t n = curves_ . size (); if ( search_backward ) { for ( size_t i = 0 ; i < n ; i ++ ) { auto s = curves_ [ n - 1 - i ]. getCollisionPointIn2D ( point0 , point1 , search_backward ); if ( s ) { return getSInSplineCurve ( n - 1 - i , s . get ()); } } return boost :: none ; } else { for ( size_t i = 0 ; i < n ; i ++ ) { auto s = curves_ [ i ]. getCollisionPointIn2D ( point0 , point1 , search_backward ); if ( s ) { return getSInSplineCurve ( i , s . get ()); } } return boost :: none ; } return boost :: none ; } const std :: vector < geometry_msgs :: msg :: Point > CatmullRomSpline :: getTrajectory ( int num_points ) const { std :: vector < geometry_msgs :: msg :: Point > ret ; if ( num_points <= 1 ) { throw SplineInterpolationError ( \"trajectory points should be more than 2.\" ); } double seg_size = total_length_ / ( num_points - 1 ); for ( int i = 0 ; i < num_points ; i ++ ) { double s = seg_size * static_cast < double > ( i ); ret . emplace_back ( getPoint ( s )); } return ret ; } boost :: optional < double > CatmullRomSpline :: getSValue ( geometry_msgs :: msg :: Point position , double threadhold_distance , unsigned int initial_num_points , unsigned int max_iteration , double tolerance ) { std :: vector < double > s_values ; std :: vector < double > error_values ; std :: vector < size_t > curve_index ; for ( size_t i = 0 ; i < curves_ . size (); i ++ ) { auto s_value = curves_ [ i ]. getSValue ( position , threadhold_distance , initial_num_points , max_iteration , tolerance , true ); if ( s_value ) { if ( s_value . get () > 0 && s_value . get () < curves_ [ i ]. getLength ()) { s_values . emplace_back ( s_value . get ()); error_values . emplace_back ( curves_ [ i ]. getSquaredDistanceIn2D ( position , s_value . get (), true )); curve_index . emplace_back ( i ); } } } if ( s_values . size () != error_values . size ()) { throw SplineInterpolationError ( \"s values and error values size are does not match.\" ); } if ( s_values . size () != curve_index . size ()) { throw SplineInterpolationError ( \"s values and error values size are does not match.\" ); } if ( s_values . empty ()) { return boost :: none ; } double s = 0 ; auto iter = std :: max_element ( error_values . begin (), error_values . end ()); size_t min_error_index = std :: distance ( error_values . begin (), iter ); for ( size_t i = 0 ; i <= curve_index [ min_error_index ]; i ++ ) { if ( i == curve_index [ min_error_index ]) { s = s + s_values [ min_error_index ]; break ; } else { s = s + curves_ [ i ]. getLength (); } } return s ; } double CatmullRomSpline :: getSquaredDistanceIn2D ( geometry_msgs :: msg :: Point point , double s ) const { const auto index_and_s = getCurveIndexAndS ( s ); return curves_ [ index_and_s . first ]. getSquaredDistanceIn2D ( point , index_and_s . second , true ); } const geometry_msgs :: msg :: Point CatmullRomSpline :: getPoint ( double s ) const { const auto index_and_s = getCurveIndexAndS ( s ); return curves_ [ index_and_s . first ]. getPoint ( index_and_s . second , true ); } double CatmullRomSpline :: getMaximum2DCurventure () const { if ( maximum_2d_curvatures_ . empty ()) { throw SplineInterpolationError ( \"maximum 2D curventure vector size is 0.\" ); } return * std :: max_element ( maximum_2d_curvatures_ . begin (), maximum_2d_curvatures_ . end ()); } const geometry_msgs :: msg :: Vector3 CatmullRomSpline :: getNormalVector ( double s ) const { const auto index_and_s = getCurveIndexAndS ( s ); return curves_ [ index_and_s . first ]. getNormalVector ( index_and_s . second , true ); } const geometry_msgs :: msg :: Vector3 CatmullRomSpline :: getTangentVector ( double s ) const { const auto index_and_s = getCurveIndexAndS ( s ); return curves_ [ index_and_s . first ]. getTangentVector ( index_and_s . second , true ); } const geometry_msgs :: msg :: Pose CatmullRomSpline :: getPose ( double s ) const { const auto index_and_s = getCurveIndexAndS ( s ); return curves_ [ index_and_s . first ]. getPose ( index_and_s . second , true ); } bool CatmullRomSpline :: checkConnection () const { if ( control_points . size () != ( curves_ . size () + 1 )) { throw SplineInterpolationError ( \"number of control points and curves does not match.\" ); } for ( size_t i = 0 ; i < curves_ . size (); i ++ ) { const auto control_point0 = control_points [ i ]; const auto control_point1 = control_points [ i + 1 ]; const auto p0 = curves_ [ i ]. getPoint ( 0 , false ); const auto p1 = curves_ [ i ]. getPoint ( 1 , false ); if ( equals ( control_point0 , p0 ) && equals ( control_point1 , p1 )) { continue ; } else if ( ! equals ( control_point0 , p0 )) { throw SplineInterpolationError ( \"start point of the curve number \" + std :: to_string ( i ) + \" does not match.\" ); } else if ( ! equals ( control_point1 , p1 )) { throw SplineInterpolationError ( \"end point of the curve number \" + std :: to_string ( i ) + \" does not match.\" ); } } if ( curves_ . empty ()) { throw SplineInterpolationError ( \"curve size should not be zero.\" ); } return true ; } bool CatmullRomSpline :: equals ( geometry_msgs :: msg :: Point p0 , geometry_msgs :: msg :: Point p1 ) const { constexpr double e = std :: numeric_limits < float >:: epsilon (); if ( std :: abs ( p0 . x - p1 . x ) > e ) { return false ; } if ( std :: abs ( p0 . y - p1 . y ) > e ) { return false ; } if ( std :: abs ( p0 . z - p1 . z ) > e ) { return false ; } return true ; } } // namespace math } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/catmull_rom_spline.cpp"},{"location":"package/simulation_api/markdown/Files/catmull__rom__spline_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmathcatmull_rom_splinecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/catmull_rom_spline.cpp"},{"location":"package/simulation_api/markdown/Files/catmull__rom__spline_8cpp/#namespaces","text":"Name simulation_api::math simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/catmull__rom__spline_8cpp/#source-code","text":"// Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/math/catmull_rom_spline.hpp> #include <vector> #include <string> #include <limits> #include <utility> #include <iostream> namespace simulation_api { namespace math { CatmullRomSpline :: CatmullRomSpline ( const std :: vector < openscenario_msgs :: msg :: HermiteCurve > & hermite_curves ) { for ( const auto & curve : hermite_curves ) { curves_ . emplace_back ( HermiteCurve ( curve )); } } const std :: vector < geometry_msgs :: msg :: Point > CatmullRomSpline :: getPolygon ( double width , size_t num_points , double z_offset ) { std :: vector < geometry_msgs :: msg :: Point > points ; std :: vector < geometry_msgs :: msg :: Point > left_bounds = getLeftBounds ( width , num_points , z_offset ); std :: vector < geometry_msgs :: msg :: Point > right_bounds = getRightBounds ( width , num_points , z_offset ); size_t num_sections = static_cast < size_t > ( left_bounds . size () - 1 ); for ( size_t i = 0 ; i < num_sections ; i ++ ) { geometry_msgs :: msg :: Point pr_0 = right_bounds [ i ]; geometry_msgs :: msg :: Point pl_0 = left_bounds [ i ]; geometry_msgs :: msg :: Point pr_1 = right_bounds [ i + 1 ]; geometry_msgs :: msg :: Point pl_1 = left_bounds [ i + 1 ]; points . emplace_back ( pr_0 ); points . emplace_back ( pl_0 ); points . emplace_back ( pr_1 ); points . emplace_back ( pl_0 ); points . emplace_back ( pl_1 ); points . emplace_back ( pr_1 ); } return points ; } const geometry_msgs :: msg :: Point CatmullRomSpline :: getRightBoundsPoint ( double width , double s , double z_offset ) const { geometry_msgs :: msg :: Vector3 vec = getNormalVector ( s ); double theta = std :: atan2 ( vec . y , vec . x ); geometry_msgs :: msg :: Point p = getPoint ( s ); geometry_msgs :: msg :: Point point ; point . x = p . x + 0.5 * width * std :: cos ( theta ); point . y = p . y + 0.5 * width * std :: sin ( theta ); point . z = p . z + z_offset ; return point ; } const geometry_msgs :: msg :: Point CatmullRomSpline :: getLeftBoundsPoint ( double width , double s , double z_offset ) const { geometry_msgs :: msg :: Vector3 vec = getNormalVector ( s ); double theta = std :: atan2 ( vec . y , vec . x ); geometry_msgs :: msg :: Point p = getPoint ( s ); geometry_msgs :: msg :: Point point ; point . x = p . x - 0.5 * width * std :: cos ( theta ); point . y = p . y - 0.5 * width * std :: sin ( theta ); point . z = p . z + z_offset ; return point ; } const std :: vector < geometry_msgs :: msg :: Point > CatmullRomSpline :: getRightBounds ( double width , size_t num_points , double z_offset ) const { std :: vector < geometry_msgs :: msg :: Point > points ; double step_size = getLength () / static_cast < double > ( num_points ); for ( size_t i = 0 ; i < static_cast < size_t > ( num_points + 1 ); i ++ ) { double s = step_size * static_cast < double > ( i ); points . emplace_back ( getRightBoundsPoint ( width , s , z_offset )); } return points ; } const std :: vector < geometry_msgs :: msg :: Point > CatmullRomSpline :: getLeftBounds ( double width , size_t num_points , double z_offset ) const { std :: vector < geometry_msgs :: msg :: Point > points ; double step_size = getLength () / static_cast < double > ( num_points ); for ( size_t i = 0 ; i < static_cast < size_t > ( num_points + 1 ); i ++ ) { double s = step_size * static_cast < double > ( i ); points . emplace_back ( getLeftBoundsPoint ( width , s , z_offset )); } return points ; } const std :: vector < geometry_msgs :: msg :: Point > CatmullRomSpline :: getTrajectory ( double start_s , double end_s , double num_points ) const { std :: vector < geometry_msgs :: msg :: Point > traj ; num_points = std :: fabs ( num_points ); double s = start_s ; if ( start_s < end_s ) { while ( s < end_s ) { auto p = getPoint ( s ); traj . emplace_back ( p ); s = s + num_points ; } } else { while ( s < end_s ) { auto p = getPoint ( s ); traj . emplace_back ( p ); s = s - num_points ; } } return traj ; } CatmullRomSpline :: CatmullRomSpline ( const openscenario_msgs :: msg :: CatmullRomSpline & spline ) { for ( const auto & curve : spline . curves ) { curves_ . emplace_back ( HermiteCurve ( curve )); } } CatmullRomSpline :: CatmullRomSpline ( const std :: vector < geometry_msgs :: msg :: Point > & control_points ) : control_points ( control_points ) { size_t n = control_points . size () - 1 ; if ( control_points . size () <= 2 ) { throw SplineInterpolationError ( \"numbers of control points are not enough.\" ); } for ( size_t i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { double ax = 0 ; double bx = control_points [ 0 ]. x - 2 * control_points [ 1 ]. x + control_points [ 2 ]. x ; double cx = -3 * control_points [ 0 ]. x + 4 * control_points [ 1 ]. x - control_points [ 2 ]. x ; double dx = 2 * control_points [ 0 ]. x ; double ay = 0 ; double by = control_points [ 0 ]. y - 2 * control_points [ 1 ]. y + control_points [ 2 ]. y ; double cy = -3 * control_points [ 0 ]. y + 4 * control_points [ 1 ]. y - control_points [ 2 ]. y ; double dy = 2 * control_points [ 0 ]. y ; double az = 0 ; double bz = control_points [ 0 ]. z - 2 * control_points [ 1 ]. z + control_points [ 2 ]. z ; double cz = -3 * control_points [ 0 ]. z + 4 * control_points [ 1 ]. z - control_points [ 2 ]. z ; double dz = 2 * control_points [ 0 ]. z ; ax = ax * 0.5 ; bx = bx * 0.5 ; cx = cx * 0.5 ; dx = dx * 0.5 ; ay = ay * 0.5 ; by = by * 0.5 ; cy = cy * 0.5 ; dy = dy * 0.5 ; az = az * 0.5 ; bz = bz * 0.5 ; cz = cz * 0.5 ; dz = dz * 0.5 ; curves_ . emplace_back ( HermiteCurve ( ax , bx , cx , dx , ay , by , cy , dy , az , bz , cz , dz )); } else if ( i == ( n - 1 )) { double ax = 0 ; double bx = control_points [ i - 1 ]. x - 2 * control_points [ i ]. x + control_points [ i + 1 ]. x ; double cx = -1 * control_points [ i - 1 ]. x + control_points [ i + 1 ]. x ; double dx = 2 * control_points [ i ]. x ; double ay = 0 ; double by = control_points [ i - 1 ]. y - 2 * control_points [ i ]. y + control_points [ i + 1 ]. y ; double cy = -1 * control_points [ i - 1 ]. y + control_points [ i + 1 ]. y ; double dy = 2 * control_points [ i ]. y ; double az = 0 ; double bz = control_points [ i - 1 ]. z - 2 * control_points [ i ]. z + control_points [ i + 1 ]. z ; double cz = -1 * control_points [ i - 1 ]. z + control_points [ i + 1 ]. z ; double dz = 2 * control_points [ i ]. z ; ax = ax * 0.5 ; bx = bx * 0.5 ; cx = cx * 0.5 ; dx = dx * 0.5 ; ay = ay * 0.5 ; by = by * 0.5 ; cy = cy * 0.5 ; dy = dy * 0.5 ; az = az * 0.5 ; bz = bz * 0.5 ; cz = cz * 0.5 ; dz = dz * 0.5 ; curves_ . emplace_back ( HermiteCurve ( ax , bx , cx , dx , ay , by , cy , dy , az , bz , cz , dz )); } else { double ax = -1 * control_points [ i - 1 ]. x + 3 * control_points [ i ]. x - 3 * control_points [ i + 1 ]. x + control_points [ i + 2 ]. x ; double bx = 2 * control_points [ i - 1 ]. x - 5 * control_points [ i ]. x + 4 * control_points [ i + 1 ]. x - control_points [ i + 2 ]. x ; double cx = - control_points [ i - 1 ]. x + control_points [ i + 1 ]. x ; double dx = 2 * control_points [ i ]. x ; double ay = -1 * control_points [ i - 1 ]. y + 3 * control_points [ i ]. y - 3 * control_points [ i + 1 ]. y + control_points [ i + 2 ]. y ; double by = 2 * control_points [ i - 1 ]. y - 5 * control_points [ i ]. y + 4 * control_points [ i + 1 ]. y - control_points [ i + 2 ]. y ; double cy = - control_points [ i - 1 ]. y + control_points [ i + 1 ]. y ; double dy = 2 * control_points [ i ]. y ; double az = -1 * control_points [ i - 1 ]. z + 3 * control_points [ i ]. z - 3 * control_points [ i + 1 ]. z + control_points [ i + 2 ]. z ; double bz = 2 * control_points [ i - 1 ]. z - 5 * control_points [ i ]. z + 4 * control_points [ i + 1 ]. z - control_points [ i + 2 ]. z ; double cz = - control_points [ i - 1 ]. z + control_points [ i + 1 ]. z ; double dz = 2 * control_points [ i ]. z ; ax = ax * 0.5 ; bx = bx * 0.5 ; cx = cx * 0.5 ; dx = dx * 0.5 ; ay = ay * 0.5 ; by = by * 0.5 ; cy = cy * 0.5 ; dy = dy * 0.5 ; az = az * 0.5 ; bz = bz * 0.5 ; cz = cz * 0.5 ; dz = dz * 0.5 ; curves_ . emplace_back ( HermiteCurve ( ax , bx , cx , dx , ay , by , cy , dy , az , bz , cz , dz )); } } for ( const auto & curve : curves_ ) { length_list_ . emplace_back ( curve . getLength ()); maximum_2d_curvatures_ . emplace_back ( curve . getMaximu2DCurvature ()); } total_length_ = 0 ; for ( const auto & length : length_list_ ) { total_length_ = total_length_ + length ; } checkConnection (); } const openscenario_msgs :: msg :: CatmullRomSpline CatmullRomSpline :: toRosMsg () const { openscenario_msgs :: msg :: CatmullRomSpline spline ; for ( const auto & curve : curves_ ) { spline . curves . emplace_back ( curve . toRosMsg ()); } return spline ; } std :: pair < size_t , double > CatmullRomSpline :: getCurveIndexAndS ( double s ) const { if ( s < 0 ) { return std :: make_pair ( 0 , s ); } if ( s >= total_length_ ) { return std :: make_pair ( curves_ . size () - 1 , s - ( total_length_ - curves_ [ curves_ . size () - 1 ]. getLength ())); } double current_s = 0 ; for ( size_t i = 0 ; i < curves_ . size (); i ++ ) { double prev_s = current_s ; current_s = current_s + length_list_ [ i ]; if ( prev_s <= s && s < current_s ) { return std :: make_pair ( i , s - prev_s ); } } throw SplineInterpolationError ( \"failed to calculate curve index\" ); } double CatmullRomSpline :: getSInSplineCurve ( size_t curve_index , double s ) const { size_t n = curves_ . size (); double ret = 0 ; for ( size_t i = 0 ; i < n ; i ++ ) { if ( i == curve_index ) { return ret + s ; } else { ret = ret + curves_ [ i ]. getLength (); } } throw SplineInterpolationError ( \"curve index does not match.\" ); } boost :: optional < double > CatmullRomSpline :: getCollisionPointIn2D ( std :: vector < geometry_msgs :: msg :: Point > polygon , bool search_backward ) const { size_t n = curves_ . size (); if ( search_backward ) { for ( size_t i = 0 ; i < n ; i ++ ) { auto s = curves_ [ n - 1 - i ]. getCollisionPointIn2D ( polygon , search_backward ); if ( s ) { return getSInSplineCurve ( n - 1 - i , s . get ()); } } return boost :: none ; } else { for ( size_t i = 0 ; i < n ; i ++ ) { auto s = curves_ [ i ]. getCollisionPointIn2D ( polygon , search_backward ); if ( s ) { return getSInSplineCurve ( i , s . get ()); } } return boost :: none ; } return boost :: none ; } boost :: optional < double > CatmullRomSpline :: getCollisionPointIn2D ( geometry_msgs :: msg :: Point point0 , geometry_msgs :: msg :: Point point1 , bool search_backward ) const { size_t n = curves_ . size (); if ( search_backward ) { for ( size_t i = 0 ; i < n ; i ++ ) { auto s = curves_ [ n - 1 - i ]. getCollisionPointIn2D ( point0 , point1 , search_backward ); if ( s ) { return getSInSplineCurve ( n - 1 - i , s . get ()); } } return boost :: none ; } else { for ( size_t i = 0 ; i < n ; i ++ ) { auto s = curves_ [ i ]. getCollisionPointIn2D ( point0 , point1 , search_backward ); if ( s ) { return getSInSplineCurve ( i , s . get ()); } } return boost :: none ; } return boost :: none ; } const std :: vector < geometry_msgs :: msg :: Point > CatmullRomSpline :: getTrajectory ( int num_points ) const { std :: vector < geometry_msgs :: msg :: Point > ret ; if ( num_points <= 1 ) { throw SplineInterpolationError ( \"trajectory points should be more than 2.\" ); } double seg_size = total_length_ / ( num_points - 1 ); for ( int i = 0 ; i < num_points ; i ++ ) { double s = seg_size * static_cast < double > ( i ); ret . emplace_back ( getPoint ( s )); } return ret ; } boost :: optional < double > CatmullRomSpline :: getSValue ( geometry_msgs :: msg :: Point position , double threadhold_distance , unsigned int initial_num_points , unsigned int max_iteration , double tolerance ) { std :: vector < double > s_values ; std :: vector < double > error_values ; std :: vector < size_t > curve_index ; for ( size_t i = 0 ; i < curves_ . size (); i ++ ) { auto s_value = curves_ [ i ]. getSValue ( position , threadhold_distance , initial_num_points , max_iteration , tolerance , true ); if ( s_value ) { if ( s_value . get () > 0 && s_value . get () < curves_ [ i ]. getLength ()) { s_values . emplace_back ( s_value . get ()); error_values . emplace_back ( curves_ [ i ]. getSquaredDistanceIn2D ( position , s_value . get (), true )); curve_index . emplace_back ( i ); } } } if ( s_values . size () != error_values . size ()) { throw SplineInterpolationError ( \"s values and error values size are does not match.\" ); } if ( s_values . size () != curve_index . size ()) { throw SplineInterpolationError ( \"s values and error values size are does not match.\" ); } if ( s_values . empty ()) { return boost :: none ; } double s = 0 ; auto iter = std :: max_element ( error_values . begin (), error_values . end ()); size_t min_error_index = std :: distance ( error_values . begin (), iter ); for ( size_t i = 0 ; i <= curve_index [ min_error_index ]; i ++ ) { if ( i == curve_index [ min_error_index ]) { s = s + s_values [ min_error_index ]; break ; } else { s = s + curves_ [ i ]. getLength (); } } return s ; } double CatmullRomSpline :: getSquaredDistanceIn2D ( geometry_msgs :: msg :: Point point , double s ) const { const auto index_and_s = getCurveIndexAndS ( s ); return curves_ [ index_and_s . first ]. getSquaredDistanceIn2D ( point , index_and_s . second , true ); } const geometry_msgs :: msg :: Point CatmullRomSpline :: getPoint ( double s ) const { const auto index_and_s = getCurveIndexAndS ( s ); return curves_ [ index_and_s . first ]. getPoint ( index_and_s . second , true ); } double CatmullRomSpline :: getMaximum2DCurventure () const { if ( maximum_2d_curvatures_ . empty ()) { throw SplineInterpolationError ( \"maximum 2D curventure vector size is 0.\" ); } return * std :: max_element ( maximum_2d_curvatures_ . begin (), maximum_2d_curvatures_ . end ()); } const geometry_msgs :: msg :: Vector3 CatmullRomSpline :: getNormalVector ( double s ) const { const auto index_and_s = getCurveIndexAndS ( s ); return curves_ [ index_and_s . first ]. getNormalVector ( index_and_s . second , true ); } const geometry_msgs :: msg :: Vector3 CatmullRomSpline :: getTangentVector ( double s ) const { const auto index_and_s = getCurveIndexAndS ( s ); return curves_ [ index_and_s . first ]. getTangentVector ( index_and_s . second , true ); } const geometry_msgs :: msg :: Pose CatmullRomSpline :: getPose ( double s ) const { const auto index_and_s = getCurveIndexAndS ( s ); return curves_ [ index_and_s . first ]. getPose ( index_and_s . second , true ); } bool CatmullRomSpline :: checkConnection () const { if ( control_points . size () != ( curves_ . size () + 1 )) { throw SplineInterpolationError ( \"number of control points and curves does not match.\" ); } for ( size_t i = 0 ; i < curves_ . size (); i ++ ) { const auto control_point0 = control_points [ i ]; const auto control_point1 = control_points [ i + 1 ]; const auto p0 = curves_ [ i ]. getPoint ( 0 , false ); const auto p1 = curves_ [ i ]. getPoint ( 1 , false ); if ( equals ( control_point0 , p0 ) && equals ( control_point1 , p1 )) { continue ; } else if ( ! equals ( control_point0 , p0 )) { throw SplineInterpolationError ( \"start point of the curve number \" + std :: to_string ( i ) + \" does not match.\" ); } else if ( ! equals ( control_point1 , p1 )) { throw SplineInterpolationError ( \"end point of the curve number \" + std :: to_string ( i ) + \" does not match.\" ); } } if ( curves_ . empty ()) { throw SplineInterpolationError ( \"curve size should not be zero.\" ); } return true ; } bool CatmullRomSpline :: equals ( geometry_msgs :: msg :: Point p0 , geometry_msgs :: msg :: Point p1 ) const { constexpr double e = std :: numeric_limits < float >:: epsilon (); if ( std :: abs ( p0 . x - p1 . x ) > e ) { return false ; } if ( std :: abs ( p0 . y - p1 . y ) > e ) { return false ; } if ( std :: abs ( p0 . z - p1 . z ) > e ) { return false ; } return true ; } } // namespace math } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/catmull__rom__spline_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/catmull_rom_spline.hpp # Namespaces # Name simulation_api::math simulation_api Classes # Name class simulation_api::math::SplineInterpolationError class simulation_api::math::CatmullRomSpline Source code # // Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__MATH__CATMULL_ROM_SPLINE_HPP_ #define SIMULATION_API__MATH__CATMULL_ROM_SPLINE_HPP_ #include <simulation_api/math/hermite_curve.hpp> #include <openscenario_msgs/msg/catmull_rom_spline.hpp> #include <geometry_msgs/msg/point.hpp> #include <vector> #include <exception> #include <string> #include <utility> namespace simulation_api { namespace math { class SplineInterpolationError : public std :: runtime_error { public : explicit SplineInterpolationError ( const char * message ) : runtime_error ( message ) {} explicit SplineInterpolationError ( std :: string message ) : runtime_error ( message . c_str ()) {} }; class CatmullRomSpline { public : CatmullRomSpline () = delete ; explicit CatmullRomSpline ( const openscenario_msgs :: msg :: CatmullRomSpline & spline ); explicit CatmullRomSpline ( const std :: vector < openscenario_msgs :: msg :: HermiteCurve > & hermite_curves ); explicit CatmullRomSpline ( const std :: vector < geometry_msgs :: msg :: Point > & control_points ); double getLength () const { return total_length_ ;} double getMaximum2DCurventure () const ; const geometry_msgs :: msg :: Point getPoint ( double s ) const ; const geometry_msgs :: msg :: Vector3 getTangentVector ( double s ) const ; const geometry_msgs :: msg :: Vector3 getNormalVector ( double s ) const ; const geometry_msgs :: msg :: Pose getPose ( double s ) const ; const std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( int num_points ) const ; const std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( double start_s , double end_s , double resolution ) const ; boost :: optional < double > getSValue ( geometry_msgs :: msg :: Point position , double threadhold_distance = 3.0 , unsigned int initial_resolution = 30 , unsigned int max_iteration = 30 , double tolerance = 0.001 ); double getSquaredDistanceIn2D ( geometry_msgs :: msg :: Point point , double s ) const ; boost :: optional < double > getCollisionPointIn2D ( geometry_msgs :: msg :: Point point0 , geometry_msgs :: msg :: Point point1 , bool search_backward = false ) const ; boost :: optional < double > getCollisionPointIn2D ( std :: vector < geometry_msgs :: msg :: Point > polygon , bool search_backward = false ) const ; const openscenario_msgs :: msg :: CatmullRomSpline toRosMsg () const ; const geometry_msgs :: msg :: Point getRightBoundsPoint ( double width , double s , double z_offset = 0 ) const ; const geometry_msgs :: msg :: Point getLeftBoundsPoint ( double width , double s , double z_offset = 0 ) const ; const std :: vector < geometry_msgs :: msg :: Point > getPolygon ( double width , size_t num_points = 30 , double z_offset = 0 ); private : const std :: vector < geometry_msgs :: msg :: Point > getRightBounds ( double width , size_t num_points = 30 , double z_offset = 0 ) const ; const std :: vector < geometry_msgs :: msg :: Point > getLeftBounds ( double width , size_t num_points = 30 , double z_offset = 0 ) const ; double getSInSplineCurve ( size_t curve_index , double s ) const ; std :: pair < size_t , double > getCurveIndexAndS ( double s ) const ; bool checkConnection () const ; bool equals ( geometry_msgs :: msg :: Point p0 , geometry_msgs :: msg :: Point p1 ) const ; std :: vector < HermiteCurve > curves_ ; std :: vector < double > length_list_ ; std :: vector < double > maximum_2d_curvatures_ ; double total_length_ ; const std :: vector < geometry_msgs :: msg :: Point > control_points ; }; } // namespace math } // namespace simulation_api #endif // SIMULATION_API__MATH__CATMULL_ROM_SPLINE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/catmull_rom_spline.hpp"},{"location":"package/simulation_api/markdown/Files/catmull__rom__spline_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apimathcatmull_rom_splinehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/catmull_rom_spline.hpp"},{"location":"package/simulation_api/markdown/Files/catmull__rom__spline_8hpp/#namespaces","text":"Name simulation_api::math simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/catmull__rom__spline_8hpp/#classes","text":"Name class simulation_api::math::SplineInterpolationError class simulation_api::math::CatmullRomSpline","title":"Classes"},{"location":"package/simulation_api/markdown/Files/catmull__rom__spline_8hpp/#source-code","text":"// Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__MATH__CATMULL_ROM_SPLINE_HPP_ #define SIMULATION_API__MATH__CATMULL_ROM_SPLINE_HPP_ #include <simulation_api/math/hermite_curve.hpp> #include <openscenario_msgs/msg/catmull_rom_spline.hpp> #include <geometry_msgs/msg/point.hpp> #include <vector> #include <exception> #include <string> #include <utility> namespace simulation_api { namespace math { class SplineInterpolationError : public std :: runtime_error { public : explicit SplineInterpolationError ( const char * message ) : runtime_error ( message ) {} explicit SplineInterpolationError ( std :: string message ) : runtime_error ( message . c_str ()) {} }; class CatmullRomSpline { public : CatmullRomSpline () = delete ; explicit CatmullRomSpline ( const openscenario_msgs :: msg :: CatmullRomSpline & spline ); explicit CatmullRomSpline ( const std :: vector < openscenario_msgs :: msg :: HermiteCurve > & hermite_curves ); explicit CatmullRomSpline ( const std :: vector < geometry_msgs :: msg :: Point > & control_points ); double getLength () const { return total_length_ ;} double getMaximum2DCurventure () const ; const geometry_msgs :: msg :: Point getPoint ( double s ) const ; const geometry_msgs :: msg :: Vector3 getTangentVector ( double s ) const ; const geometry_msgs :: msg :: Vector3 getNormalVector ( double s ) const ; const geometry_msgs :: msg :: Pose getPose ( double s ) const ; const std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( int num_points ) const ; const std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( double start_s , double end_s , double resolution ) const ; boost :: optional < double > getSValue ( geometry_msgs :: msg :: Point position , double threadhold_distance = 3.0 , unsigned int initial_resolution = 30 , unsigned int max_iteration = 30 , double tolerance = 0.001 ); double getSquaredDistanceIn2D ( geometry_msgs :: msg :: Point point , double s ) const ; boost :: optional < double > getCollisionPointIn2D ( geometry_msgs :: msg :: Point point0 , geometry_msgs :: msg :: Point point1 , bool search_backward = false ) const ; boost :: optional < double > getCollisionPointIn2D ( std :: vector < geometry_msgs :: msg :: Point > polygon , bool search_backward = false ) const ; const openscenario_msgs :: msg :: CatmullRomSpline toRosMsg () const ; const geometry_msgs :: msg :: Point getRightBoundsPoint ( double width , double s , double z_offset = 0 ) const ; const geometry_msgs :: msg :: Point getLeftBoundsPoint ( double width , double s , double z_offset = 0 ) const ; const std :: vector < geometry_msgs :: msg :: Point > getPolygon ( double width , size_t num_points = 30 , double z_offset = 0 ); private : const std :: vector < geometry_msgs :: msg :: Point > getRightBounds ( double width , size_t num_points = 30 , double z_offset = 0 ) const ; const std :: vector < geometry_msgs :: msg :: Point > getLeftBounds ( double width , size_t num_points = 30 , double z_offset = 0 ) const ; double getSInSplineCurve ( size_t curve_index , double s ) const ; std :: pair < size_t , double > getCurveIndexAndS ( double s ) const ; bool checkConnection () const ; bool equals ( geometry_msgs :: msg :: Point p0 , geometry_msgs :: msg :: Point p1 ) const ; std :: vector < HermiteCurve > curves_ ; std :: vector < double > length_list_ ; std :: vector < double > maximum_2d_curvatures_ ; double total_length_ ; const std :: vector < geometry_msgs :: msg :: Point > control_points ; }; } // namespace math } // namespace simulation_api #endif // SIMULATION_API__MATH__CATMULL_ROM_SPLINE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/catmull__rom__visualization_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc/catmull_rom_visualization.cpp # Classes # Name class CatmullRomSplineVisualization Functions # Name int main (int argc, char * argv[]) Functions Documentation # function main # int main ( int argc , char * argv [] ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <rclcpp/rclcpp.hpp> #include <simulation_api/color_utils/color_utils.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <geometry_msgs/msg/pose_stamped.hpp> #include <geometry_msgs/msg/point_stamped.hpp> #include <visualization_msgs/msg/marker_array.hpp> #include <string> #include <vector> #include <memory> class CatmullRomSplineVisualization : public rclcpp :: Node { public : explicit CatmullRomSplineVisualization ( const rclcpp :: NodeOptions & option ) : Node ( \"catumull_rom_spline_viz\" , option ) { marker_pub_ptr_ = create_publisher < visualization_msgs :: msg :: MarkerArray > ( \"/spline/marker\" , 1 ); clicked_points_sub_ptr_ = create_subscription < geometry_msgs :: msg :: PoseStamped > ( \"/move_base_simple/goal\" , 1 , std :: bind ( & CatmullRomSplineVisualization :: goalPoseCallback , this , std :: placeholders :: _1 )); } private : std :: string frame_ ; std :: vector < geometry_msgs :: msg :: Point > points_ ; void goalPoseCallback ( const geometry_msgs :: msg :: PoseStamped :: SharedPtr msg ) { if ( frame_ == \"\" ) { frame_ = msg -> header . frame_id ; points_ . emplace_back ( msg -> pose . position ); } else { if ( frame_ != msg -> header . frame_id ) { RCLCPP_ERROR ( get_logger (), \"frame does not match.\" ); } else { points_ . emplace_back ( msg -> pose . position ); } } if ( points_ . size () >= 3 ) { marker_pub_ptr_ -> publish ( generateDeleteMarker ()); marker_pub_ptr_ -> publish ( generateSplineMarker ()); } } const visualization_msgs :: msg :: MarkerArray generateDeleteMarker () const { visualization_msgs :: msg :: MarkerArray ret ; visualization_msgs :: msg :: Marker marker ; marker . action = marker . DELETEALL ; ret . markers . push_back ( marker ); return ret ; } const visualization_msgs :: msg :: MarkerArray generateSplineMarker () const { visualization_msgs :: msg :: MarkerArray ret ; visualization_msgs :: msg :: Marker marker ; marker . action = marker . ADD ; marker . header . frame_id = frame_ ; auto spline = simulation_api :: math :: CatmullRomSpline ( points_ ); marker . points = spline . getTrajectory ( 100 ); marker . type = marker . LINE_STRIP ; marker . color = color_utils :: makeColorMsg ( \"red\" , 0.99 ); marker . ns = \"spiline\" ; marker . id = 0 ; marker . scale . x = 0.01 ; marker . scale . y = 0.01 ; marker . scale . z = 0.01 ; ret . markers . push_back ( marker ); return ret ; } rclcpp :: Publisher < visualization_msgs :: msg :: MarkerArray >:: SharedPtr marker_pub_ptr_ ; rclcpp :: Subscription < geometry_msgs :: msg :: PoseStamped >:: SharedPtr clicked_points_sub_ptr_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: NodeOptions options ; auto component = std :: make_shared < CatmullRomSplineVisualization > ( options ); rclcpp :: spin ( component ); rclcpp :: shutdown (); return 0 ; } Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc/catmull_rom_visualization.cpp"},{"location":"package/simulation_api/markdown/Files/catmull__rom__visualization_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmoccatmull_rom_visualizationcpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc/catmull_rom_visualization.cpp"},{"location":"package/simulation_api/markdown/Files/catmull__rom__visualization_8cpp/#classes","text":"Name class CatmullRomSplineVisualization","title":"Classes"},{"location":"package/simulation_api/markdown/Files/catmull__rom__visualization_8cpp/#functions","text":"Name int main (int argc, char * argv[])","title":"Functions"},{"location":"package/simulation_api/markdown/Files/catmull__rom__visualization_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/simulation_api/markdown/Files/catmull__rom__visualization_8cpp/#function-main","text":"int main ( int argc , char * argv [] )","title":"function main"},{"location":"package/simulation_api/markdown/Files/catmull__rom__visualization_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <rclcpp/rclcpp.hpp> #include <simulation_api/color_utils/color_utils.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <geometry_msgs/msg/pose_stamped.hpp> #include <geometry_msgs/msg/point_stamped.hpp> #include <visualization_msgs/msg/marker_array.hpp> #include <string> #include <vector> #include <memory> class CatmullRomSplineVisualization : public rclcpp :: Node { public : explicit CatmullRomSplineVisualization ( const rclcpp :: NodeOptions & option ) : Node ( \"catumull_rom_spline_viz\" , option ) { marker_pub_ptr_ = create_publisher < visualization_msgs :: msg :: MarkerArray > ( \"/spline/marker\" , 1 ); clicked_points_sub_ptr_ = create_subscription < geometry_msgs :: msg :: PoseStamped > ( \"/move_base_simple/goal\" , 1 , std :: bind ( & CatmullRomSplineVisualization :: goalPoseCallback , this , std :: placeholders :: _1 )); } private : std :: string frame_ ; std :: vector < geometry_msgs :: msg :: Point > points_ ; void goalPoseCallback ( const geometry_msgs :: msg :: PoseStamped :: SharedPtr msg ) { if ( frame_ == \"\" ) { frame_ = msg -> header . frame_id ; points_ . emplace_back ( msg -> pose . position ); } else { if ( frame_ != msg -> header . frame_id ) { RCLCPP_ERROR ( get_logger (), \"frame does not match.\" ); } else { points_ . emplace_back ( msg -> pose . position ); } } if ( points_ . size () >= 3 ) { marker_pub_ptr_ -> publish ( generateDeleteMarker ()); marker_pub_ptr_ -> publish ( generateSplineMarker ()); } } const visualization_msgs :: msg :: MarkerArray generateDeleteMarker () const { visualization_msgs :: msg :: MarkerArray ret ; visualization_msgs :: msg :: Marker marker ; marker . action = marker . DELETEALL ; ret . markers . push_back ( marker ); return ret ; } const visualization_msgs :: msg :: MarkerArray generateSplineMarker () const { visualization_msgs :: msg :: MarkerArray ret ; visualization_msgs :: msg :: Marker marker ; marker . action = marker . ADD ; marker . header . frame_id = frame_ ; auto spline = simulation_api :: math :: CatmullRomSpline ( points_ ); marker . points = spline . getTrajectory ( 100 ); marker . type = marker . LINE_STRIP ; marker . color = color_utils :: makeColorMsg ( \"red\" , 0.99 ); marker . ns = \"spiline\" ; marker . id = 0 ; marker . scale . x = 0.01 ; marker . scale . y = 0.01 ; marker . scale . z = 0.01 ; ret . markers . push_back ( marker ); return ret ; } rclcpp :: Publisher < visualization_msgs :: msg :: MarkerArray >:: SharedPtr marker_pub_ptr_ ; rclcpp :: Subscription < geometry_msgs :: msg :: PoseStamped >:: SharedPtr clicked_points_sub_ptr_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: NodeOptions options ; auto component = std :: make_shared < CatmullRomSplineVisualization > ( options ); rclcpp :: spin ( component ); rclcpp :: shutdown (); return 0 ; } Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/collision_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/collision.cpp # Namespaces # Name simulation_api::math simulation_api Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/math/collision.hpp> #include <quaternion_operation/quaternion_operation.h> #include <boost/assert.hpp> #include <boost/geometry.hpp> #include <boost/geometry/geometries/linestring.hpp> #include <boost/geometry/geometries/point_xy.hpp> #include <boost/assign/list_of.hpp> #include <boost/geometry/algorithms/disjoint.hpp> #include <vector> #include <iostream> namespace simulation_api { namespace math { bool checkCollision2D ( geometry_msgs :: msg :: Pose pose0 , openscenario_msgs :: msg :: BoundingBox bbox0 , geometry_msgs :: msg :: Pose pose1 , openscenario_msgs :: msg :: BoundingBox bbox1 ) { double z_diff_pose = std :: fabs ( ( pose0 . position . z + bbox0 . center . z ) - ( pose1 . position . z + bbox1 . center . z )); if ( z_diff_pose > ( std :: fabs ( bbox0 . dimensions . z + bbox1 . dimensions . z ) * 0.5 ) ) { return false ; } namespace bg = boost :: geometry ; typedef bg :: model :: d2 :: point_xy < double > bg_point ; const bg :: model :: polygon < bg_point > poly0 = get2DPolygon ( pose0 , bbox0 ); const bg :: model :: polygon < bg_point > poly1 = get2DPolygon ( pose1 , bbox1 ); if ( bg :: intersects ( poly0 , poly1 )) { return true ; } if ( bg :: intersects ( poly1 , poly0 )) { return true ; } if ( bg :: disjoint ( poly0 , poly1 )) { return false ; } return true ; } } // namespace math } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/collision.cpp"},{"location":"package/simulation_api/markdown/Files/collision_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmathcollisioncpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/collision.cpp"},{"location":"package/simulation_api/markdown/Files/collision_8cpp/#namespaces","text":"Name simulation_api::math simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/collision_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/math/collision.hpp> #include <quaternion_operation/quaternion_operation.h> #include <boost/assert.hpp> #include <boost/geometry.hpp> #include <boost/geometry/geometries/linestring.hpp> #include <boost/geometry/geometries/point_xy.hpp> #include <boost/assign/list_of.hpp> #include <boost/geometry/algorithms/disjoint.hpp> #include <vector> #include <iostream> namespace simulation_api { namespace math { bool checkCollision2D ( geometry_msgs :: msg :: Pose pose0 , openscenario_msgs :: msg :: BoundingBox bbox0 , geometry_msgs :: msg :: Pose pose1 , openscenario_msgs :: msg :: BoundingBox bbox1 ) { double z_diff_pose = std :: fabs ( ( pose0 . position . z + bbox0 . center . z ) - ( pose1 . position . z + bbox1 . center . z )); if ( z_diff_pose > ( std :: fabs ( bbox0 . dimensions . z + bbox1 . dimensions . z ) * 0.5 ) ) { return false ; } namespace bg = boost :: geometry ; typedef bg :: model :: d2 :: point_xy < double > bg_point ; const bg :: model :: polygon < bg_point > poly0 = get2DPolygon ( pose0 , bbox0 ); const bg :: model :: polygon < bg_point > poly1 = get2DPolygon ( pose1 , bbox1 ); if ( bg :: intersects ( poly0 , poly1 )) { return true ; } if ( bg :: intersects ( poly1 , poly0 )) { return true ; } if ( bg :: disjoint ( poly0 , poly1 )) { return false ; } return true ; } } // namespace math } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/collision_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/collision.hpp # Namespaces # Name simulation_api::math simulation_api Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__MATH__COLLISION_HPP_ #define SIMULATION_API__MATH__COLLISION_HPP_ #include <simulation_api/math/bounding_box.hpp> #include <openscenario_msgs/msg/bounding_box.hpp> #include <geometry_msgs/msg/pose.hpp> #include <vector> namespace simulation_api { namespace math { bool checkCollision2D ( geometry_msgs :: msg :: Pose pose0 , openscenario_msgs :: msg :: BoundingBox bbox0 , geometry_msgs :: msg :: Pose pose1 , openscenario_msgs :: msg :: BoundingBox bbox1 ); } // namespace math } // namespace simulation_api #endif // SIMULATION_API__MATH__COLLISION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/collision.hpp"},{"location":"package/simulation_api/markdown/Files/collision_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apimathcollisionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/collision.hpp"},{"location":"package/simulation_api/markdown/Files/collision_8hpp/#namespaces","text":"Name simulation_api::math simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/collision_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__MATH__COLLISION_HPP_ #define SIMULATION_API__MATH__COLLISION_HPP_ #include <simulation_api/math/bounding_box.hpp> #include <openscenario_msgs/msg/bounding_box.hpp> #include <geometry_msgs/msg/pose.hpp> #include <vector> namespace simulation_api { namespace math { bool checkCollision2D ( geometry_msgs :: msg :: Pose pose0 , openscenario_msgs :: msg :: BoundingBox bbox0 , geometry_msgs :: msg :: Pose pose1 , openscenario_msgs :: msg :: BoundingBox bbox1 ); } // namespace math } // namespace simulation_api #endif // SIMULATION_API__MATH__COLLISION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/color__utils_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/color_utils/color_utils.cpp # Namespaces # Name color_utils Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/color_utils/color_utils.hpp> #include <iostream> #include <string> namespace color_utils { void printRed ( const std :: string & text ) { std :: string raw_text = \" \\x1b [31m\" + text + \" \\x1b [0m \\n \" ; printf ( \"%s\" , raw_text . c_str ()); } void printGreen ( const std :: string & text ) { std :: string raw_text = \" \\x1b [32m\" + text + \" \\x1b [0m \\n \" ; printf ( \"%s\" , raw_text . c_str ()); } void printYellow ( const std :: string & text ) { std :: string raw_text = \" \\x1b [33m\" + text + \" \\x1b [0m \\n \" ; printf ( \"%s\" , raw_text . c_str ()); } void printBlue ( const std :: string & text ) { std :: string raw_text = \" \\x1b [34m\" + text + \" \\x1b [0m \\n \" ; printf ( \"%s\" , raw_text . c_str ()); } void printMagenta ( const std :: string & text ) { std :: string raw_text = \" \\x1b [35m\" + text + \" \\x1b [0m \\n \" ; printf ( \"%s\" , raw_text . c_str ()); } void printCyan ( const std :: string & text ) { std :: string raw_text = \" \\x1b [36m\" + text + \" \\x1b [0m \\n \" ; printf ( \"%s\" , raw_text . c_str ()); } void printWhite ( const std :: string & text ) { std :: string raw_text = \" \\x1b [37m\" + text + \" \\x1b [0m \\n \" ; printf ( \"%s\" , raw_text . c_str ()); } const std_msgs :: msg :: ColorRGBA fromRgba ( double r , double g , double b , double alpha ) { std_msgs :: msg :: ColorRGBA color ; color . r = r ; color . g = g ; color . b = b ; color . a = alpha ; return color ; } const std_msgs :: msg :: ColorRGBA fromHsv ( double h , double s , double v , double alpha ) { std_msgs :: msg :: ColorRGBA color ; color . a = alpha ; float r = v ; float g = v ; float b = v ; if ( s > 0.0f ) { h *= 6.0f ; int i = static_cast < int > ( h ); float f = h - static_cast < float > ( i ); switch ( i ) { default : case 0 : g *= 1 - s * ( 1 - f ); b *= 1 - s ; break ; case 1 : r *= 1 - s * f ; b *= 1 - s ; break ; case 2 : r *= 1 - s ; b *= 1 - s * ( 1 - f ); break ; case 3 : r *= 1 - s ; g *= 1 - s * f ; break ; case 4 : r *= 1 - s * ( 1 - f ); g *= 1 - s ; break ; case 5 : g *= 1 - s ; b *= 1 - s * f ; break ; } } color . r = r ; color . g = g ; color . b = b ; return color ; } const std_msgs :: msg :: ColorRGBA makeColorMsg ( std :: string preset_name , double alpha ) { std_msgs :: msg :: ColorRGBA c_msg ; c_msg . a = alpha ; if ( c_msg . a < 0. ) { c_msg . a = 0. ;} if ( c_msg . a > 1. ) { c_msg . a = 1. ;} auto found_itr = COLOR_NAME_DICT . find ( preset_name ); if ( found_itr != COLOR_NAME_DICT . end ()) { c_msg . r = found_itr -> second [ 0 ]; c_msg . g = found_itr -> second [ 1 ]; c_msg . b = found_itr -> second [ 2 ]; } else { c_msg . r = 0 ; c_msg . g = 0 ; c_msg . b = 0 ; } return c_msg ; } } // namespace color_utils Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/color_utils/color_utils.cpp"},{"location":"package/simulation_api/markdown/Files/color__utils_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrccolor_utilscolor_utilscpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/color_utils/color_utils.cpp"},{"location":"package/simulation_api/markdown/Files/color__utils_8cpp/#namespaces","text":"Name color_utils","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/color__utils_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/color_utils/color_utils.hpp> #include <iostream> #include <string> namespace color_utils { void printRed ( const std :: string & text ) { std :: string raw_text = \" \\x1b [31m\" + text + \" \\x1b [0m \\n \" ; printf ( \"%s\" , raw_text . c_str ()); } void printGreen ( const std :: string & text ) { std :: string raw_text = \" \\x1b [32m\" + text + \" \\x1b [0m \\n \" ; printf ( \"%s\" , raw_text . c_str ()); } void printYellow ( const std :: string & text ) { std :: string raw_text = \" \\x1b [33m\" + text + \" \\x1b [0m \\n \" ; printf ( \"%s\" , raw_text . c_str ()); } void printBlue ( const std :: string & text ) { std :: string raw_text = \" \\x1b [34m\" + text + \" \\x1b [0m \\n \" ; printf ( \"%s\" , raw_text . c_str ()); } void printMagenta ( const std :: string & text ) { std :: string raw_text = \" \\x1b [35m\" + text + \" \\x1b [0m \\n \" ; printf ( \"%s\" , raw_text . c_str ()); } void printCyan ( const std :: string & text ) { std :: string raw_text = \" \\x1b [36m\" + text + \" \\x1b [0m \\n \" ; printf ( \"%s\" , raw_text . c_str ()); } void printWhite ( const std :: string & text ) { std :: string raw_text = \" \\x1b [37m\" + text + \" \\x1b [0m \\n \" ; printf ( \"%s\" , raw_text . c_str ()); } const std_msgs :: msg :: ColorRGBA fromRgba ( double r , double g , double b , double alpha ) { std_msgs :: msg :: ColorRGBA color ; color . r = r ; color . g = g ; color . b = b ; color . a = alpha ; return color ; } const std_msgs :: msg :: ColorRGBA fromHsv ( double h , double s , double v , double alpha ) { std_msgs :: msg :: ColorRGBA color ; color . a = alpha ; float r = v ; float g = v ; float b = v ; if ( s > 0.0f ) { h *= 6.0f ; int i = static_cast < int > ( h ); float f = h - static_cast < float > ( i ); switch ( i ) { default : case 0 : g *= 1 - s * ( 1 - f ); b *= 1 - s ; break ; case 1 : r *= 1 - s * f ; b *= 1 - s ; break ; case 2 : r *= 1 - s ; b *= 1 - s * ( 1 - f ); break ; case 3 : r *= 1 - s ; g *= 1 - s * f ; break ; case 4 : r *= 1 - s * ( 1 - f ); g *= 1 - s ; break ; case 5 : g *= 1 - s ; b *= 1 - s * f ; break ; } } color . r = r ; color . g = g ; color . b = b ; return color ; } const std_msgs :: msg :: ColorRGBA makeColorMsg ( std :: string preset_name , double alpha ) { std_msgs :: msg :: ColorRGBA c_msg ; c_msg . a = alpha ; if ( c_msg . a < 0. ) { c_msg . a = 0. ;} if ( c_msg . a > 1. ) { c_msg . a = 1. ;} auto found_itr = COLOR_NAME_DICT . find ( preset_name ); if ( found_itr != COLOR_NAME_DICT . end ()) { c_msg . r = found_itr -> second [ 0 ]; c_msg . g = found_itr -> second [ 1 ]; c_msg . b = found_itr -> second [ 2 ]; } else { c_msg . r = 0 ; c_msg . g = 0 ; c_msg . b = 0 ; } return c_msg ; } } // namespace color_utils Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/color__utils_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/color_utils/color_utils.hpp # Namespaces # Name color_utils Source code # // Copyright (c) 2019 shuhei yoshida // Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the \"Software\"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions: // The above copyright notice and this permission notice shall be included in // all copies or substantial portions of the Software. // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL // THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. #ifndef SIMULATION_API__COLOR_UTILS__COLOR_UTILS_HPP_ #define SIMULATION_API__COLOR_UTILS__COLOR_UTILS_HPP_ #include <std_msgs/msg/color_rgba.hpp> #include <stdio.h> #include <cassert> #include <map> #include <string> namespace color_utils { void printRed ( const std :: string & text ); void printGreen ( const std :: string & text ); void printYellow ( const std :: string & text ); void printBlue ( const std :: string & text ); void printMagenta ( const std :: string & text ); void printCyan ( const std :: string & text ); void printWhite ( const std :: string & text ); const std_msgs :: msg :: ColorRGBA makeColorMsg ( std :: string preset_name , double alpha = 1.0 ); const std_msgs :: msg :: ColorRGBA fromHsv ( double h , double s , double v , double alpha = 1.0 ); const std_msgs :: msg :: ColorRGBA fromRgba ( double r , double g , double b , double alpha = 1.0 ); const std :: map < std :: string , std :: array < float , 3 >> COLOR_NAME_DICT { // {\"COLOR_NAME\", {R, G, B}} // template { \"aliceblue\" , { 0.941176 , 0.972549 , 1 }}, { \"antiquewhite\" , { 0.980392 , 0.921569 , 0.843137 }}, { \"aqua\" , { 0 , 1 , 1 }}, { \"aquamarine\" , { 0.498039 , 1 , 0.831373 }}, { \"azure\" , { 0.941176 , 1 , 1 }}, { \"beige\" , { 0.960784 , 0.960784 , 0.862745 }}, { \"bisque\" , { 1 , 0.894118 , 0.768627 }}, { \"black\" , { 0 , 0 , 0 }}, { \"blanchedalmond\" , { 1 , 0.921569 , 0.803922 }}, { \"blue\" , { 0 , 0 , 1 }}, { \"blueviolet\" , { 0.541176 , 0.168627 , 0.886275 }}, { \"brown\" , { 0.647059 , 0.164706 , 0.164706 }}, { \"burlywood\" , { 0.870588 , 0.721569 , 0.529412 }}, { \"cadetblue\" , { 0.372549 , 0.619608 , 0.627451 }}, { \"chartreuse\" , { 0.498039 , 1 , 0 }}, { \"chocolate\" , { 0.823529 , 0.411765 , 0.117647 }}, { \"coral\" , { 1 , 0.498039 , 0.313725 }}, { \"cornflowerblue\" , { 0.392157 , 0.584314 , 0.929412 }}, { \"cornsilk\" , { 1 , 0.972549 , 0.862745 }}, { \"crimson\" , { 0.862745 , 0.0784314 , 0.235294 }}, { \"cyan\" , { 0 , 1 , 1 }}, { \"darkblue\" , { 0 , 0 , 0.545098 }}, { \"darkcyan\" , { 0 , 0.545098 , 0.545098 }}, { \"darkgoldenrod\" , { 0.721569 , 0.52549 , 0.0431373 }}, { \"darkgray\" , { 0.662745 , 0.662745 , 0.662745 }}, { \"darkgreen\" , { 0 , 0.392157 , 0 }}, { \"darkkhaki\" , { 0.741176 , 0.717647 , 0.419608 }}, { \"darkmagenta\" , { 0.545098 , 0 , 0.545098 }}, { \"darkolivegreen\" , { 0.333333 , 0.419608 , 0.184314 }}, { \"darkorange\" , { 1 , 0.54902 , 0 }}, { \"darkorchid\" , { 0.6 , 0.196078 , 0.8 }}, { \"darkred\" , { 0.545098 , 0 , 0 }}, { \"darksalmon\" , { 0.913725 , 0.588235 , 0.478431 }}, { \"darkseagreen\" , { 0.560784 , 0.737255 , 0.560784 }}, { \"darkslateblue\" , { 0.282353 , 0.239216 , 0.545098 }}, { \"darkslategray\" , { 0.184314 , 0.309804 , 0.309804 }}, { \"darkturquoise\" , { 0 , 0.807843 , 0.819608 }}, { \"darkviolet\" , { 0.580392 , 0 , 0.827451 }}, { \"deeppink\" , { 1 , 0.0784314 , 0.576471 }}, { \"deepskyblue\" , { 0 , 0.74902 , 1 }}, { \"dimgray\" , { 0.411765 , 0.411765 , 0.411765 }}, { \"dodgerblue\" , { 0.117647 , 0.564706 , 1 }}, { \"firebrick\" , { 0.698039 , 0.133333 , 0.133333 }}, { \"floralwhite\" , { 1 , 0.980392 , 0.941176 }}, { \"forestgreen\" , { 0.133333 , 0.545098 , 0.133333 }}, { \"fuchsia\" , { 1 , 0 , 1 }}, { \"gainsboro\" , { 0.862745 , 0.862745 , 0.862745 }}, { \"ghostwhite\" , { 0.972549 , 0.972549 , 1 }}, { \"gold\" , { 1 , 0.843137 , 0 }}, { \"goldenrod\" , { 0.854902 , 0.647059 , 0.12549 }}, { \"gray\" , { 0.501961 , 0.501961 , 0.501961 }}, { \"green\" , { 0 , 0.501961 , 0 }}, { \"greenyellow\" , { 0.678431 , 1 , 0.184314 }}, { \"honeydew\" , { 0.941176 , 1 , 0.941176 }}, { \"hotpink\" , { 1 , 0.411765 , 0.705882 }}, { \"indianred\" , { 0.803922 , 0.360784 , 0.360784 }}, { \"indigo\" , { 0.294118 , 0 , 0.509804 }}, { \"ivory\" , { 1 , 1 , 0.941176 }}, { \"khaki\" , { 0.941176 , 0.901961 , 0.54902 }}, { \"lavender\" , { 0.901961 , 0.901961 , 0.980392 }}, { \"lavenderblush\" , { 1 , 0.941176 , 0.960784 }}, { \"lawngreen\" , { 0.486275 , 0.988235 , 0 }}, { \"lemonchiffon\" , { 1 , 0.980392 , 0.803922 }}, { \"lightblue\" , { 0.678431 , 0.847059 , 0.901961 }}, { \"lightcoral\" , { 0.941176 , 0.501961 , 0.501961 }}, { \"lightcyan\" , { 0.878431 , 1 , 1 }}, { \"lightgoldenrodyellow\" , { 0.980392 , 0.980392 , 0.823529 }}, { \"lightgray\" , { 0.827451 , 0.827451 , 0.827451 }}, { \"lightgreen\" , { 0.564706 , 0.933333 , 0.564706 }}, { \"lightpink\" , { 1 , 0.713725 , 0.756863 }}, { \"lightsalmon\" , { 1 , 0.627451 , 0.478431 }}, { \"lightseagreen\" , { 0.12549 , 0.698039 , 0.666667 }}, { \"lightskyblue\" , { 0.529412 , 0.807843 , 0.980392 }}, { \"lightslategray\" , { 0.466667 , 0.533333 , 0.6 }}, { \"lightsteelblue\" , { 0.690196 , 0.768627 , 0.870588 }}, { \"lightyellow\" , { 1 , 1 , 0.878431 }}, { \"lime\" , { 0 , 1 , 0 }}, { \"limegreen\" , { 0.196078 , 0.803922 , 0.196078 }}, { \"linen\" , { 0.980392 , 0.941176 , 0.901961 }}, { \"magenta\" , { 1 , 0 , 1 }}, { \"maroon\" , { 0.501961 , 0 , 0 }}, { \"mediumaquamarine\" , { 0.4 , 0.803922 , 0.666667 }}, { \"mediumblue\" , { 0 , 0 , 0.803922 }}, { \"mediumorchid\" , { 0.729412 , 0.333333 , 0.827451 }}, { \"mediumpurple\" , { 0.576471 , 0.439216 , 0.858824 }}, { \"mediumseagreen\" , { 0.235294 , 0.701961 , 0.443137 }}, { \"mediumslateblue\" , { 0.482353 , 0.407843 , 0.933333 }}, { \"mediumspringgreen\" , { 0 , 0.980392 , 0.603922 }}, { \"mediumturquoise\" , { 0.282353 , 0.819608 , 0.8 }}, { \"mediumvioletred\" , { 0.780392 , 0.0823529 , 0.521569 }}, { \"midnightblue\" , { 0.0980392 , 0.0980392 , 0.439216 }}, { \"mintcream\" , { 0.960784 , 1 , 0.980392 }}, { \"mistyrose\" , { 1 , 0.894118 , 0.882353 }}, { \"moccasin\" , { 1 , 0.894118 , 0.709804 }}, { \"navajowhite\" , { 1 , 0.870588 , 0.678431 }}, { \"navy\" , { 0 , 0 , 0.501961 }}, { \"oldlace\" , { 0.992157 , 0.960784 , 0.901961 }}, { \"olive\" , { 0.501961 , 0.501961 , 0 }}, { \"olivedrab\" , { 0.419608 , 0.556863 , 0.137255 }}, { \"orange\" , { 1 , 0.647059 , 0 }}, { \"orangered\" , { 1 , 0.270588 , 0 }}, { \"orchid\" , { 0.854902 , 0.439216 , 0.839216 }}, { \"palegoldenrod\" , { 0.933333 , 0.909804 , 0.666667 }}, { \"palegreen\" , { 0.596078 , 0.984314 , 0.596078 }}, { \"paleturquoise\" , { 0.686275 , 0.933333 , 0.933333 }}, { \"palevioletred\" , { 0.858824 , 0.439216 , 0.576471 }}, { \"papayawhip\" , { 1 , 0.937255 , 0.835294 }}, { \"peachpuff\" , { 1 , 0.854902 , 0.72549 }}, { \"peru\" , { 0.803922 , 0.521569 , 0.247059 }}, { \"pink\" , { 1 , 0.752941 , 0.796078 }}, { \"plum\" , { 0.866667 , 0.627451 , 0.866667 }}, { \"powderblue\" , { 0.690196 , 0.878431 , 0.901961 }}, { \"purple\" , { 0.501961 , 0 , 0.501961 }}, { \"red\" , { 1 , 0 , 0 }}, { \"rosybrown\" , { 0.737255 , 0.560784 , 0.560784 }}, { \"royalblue\" , { 0.254902 , 0.411765 , 0.882353 }}, { \"saddlebrown\" , { 0.545098 , 0.270588 , 0.0745098 }}, { \"salmon\" , { 0.980392 , 0.501961 , 0.447059 }}, { \"sandybrown\" , { 0.956863 , 0.643137 , 0.376471 }}, { \"seagreen\" , { 0.180392 , 0.545098 , 0.341176 }}, { \"seashell\" , { 1 , 0.960784 , 0.933333 }}, { \"sienna\" , { 0.627451 , 0.321569 , 0.176471 }}, { \"silver\" , { 0.752941 , 0.752941 , 0.752941 }}, { \"skyblue\" , { 0.529412 , 0.807843 , 0.921569 }}, { \"slateblue\" , { 0.415686 , 0.352941 , 0.803922 }}, { \"slategray\" , { 0.439216 , 0.501961 , 0.564706 }}, { \"snow\" , { 1 , 0.980392 , 0.980392 }}, { \"springgreen\" , { 0 , 1 , 0.498039 }}, { \"steelblue\" , { 0.27451 , 0.509804 , 0.705882 }}, { \"tan\" , { 0.823529 , 0.705882 , 0.54902 }}, { \"teal\" , { 0 , 0.501961 , 0.501961 }}, { \"thistle\" , { 0.847059 , 0.74902 , 0.847059 }}, { \"tomato\" , { 1 , 0.388235 , 0.278431 }}, { \"turquoise\" , { 0.25098 , 0.878431 , 0.815686 }}, { \"violet\" , { 0.933333 , 0.509804 , 0.933333 }}, { \"wheat\" , { 0.960784 , 0.870588 , 0.701961 }}, { \"white\" , { 1 , 1 , 1 }}, { \"whitesmoke\" , { 0.960784 , 0.960784 , 0.960784 }}, { \"yellow\" , { 1 , 1 , 0 }}, { \"yellowgreen\" , { 0.603922 , 0.803922 , 0.196078 }}, { \"ERROR\" , { 0 , 0 , 0 }}}; } // namespace color_utils #endif // SIMULATION_API__COLOR_UTILS__COLOR_UTILS_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/color_utils/color_utils.hpp"},{"location":"package/simulation_api/markdown/Files/color__utils_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apicolor_utilscolor_utilshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/color_utils/color_utils.hpp"},{"location":"package/simulation_api/markdown/Files/color__utils_8hpp/#namespaces","text":"Name color_utils","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/color__utils_8hpp/#source-code","text":"// Copyright (c) 2019 shuhei yoshida // Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the \"Software\"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions: // The above copyright notice and this permission notice shall be included in // all copies or substantial portions of the Software. // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL // THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. #ifndef SIMULATION_API__COLOR_UTILS__COLOR_UTILS_HPP_ #define SIMULATION_API__COLOR_UTILS__COLOR_UTILS_HPP_ #include <std_msgs/msg/color_rgba.hpp> #include <stdio.h> #include <cassert> #include <map> #include <string> namespace color_utils { void printRed ( const std :: string & text ); void printGreen ( const std :: string & text ); void printYellow ( const std :: string & text ); void printBlue ( const std :: string & text ); void printMagenta ( const std :: string & text ); void printCyan ( const std :: string & text ); void printWhite ( const std :: string & text ); const std_msgs :: msg :: ColorRGBA makeColorMsg ( std :: string preset_name , double alpha = 1.0 ); const std_msgs :: msg :: ColorRGBA fromHsv ( double h , double s , double v , double alpha = 1.0 ); const std_msgs :: msg :: ColorRGBA fromRgba ( double r , double g , double b , double alpha = 1.0 ); const std :: map < std :: string , std :: array < float , 3 >> COLOR_NAME_DICT { // {\"COLOR_NAME\", {R, G, B}} // template { \"aliceblue\" , { 0.941176 , 0.972549 , 1 }}, { \"antiquewhite\" , { 0.980392 , 0.921569 , 0.843137 }}, { \"aqua\" , { 0 , 1 , 1 }}, { \"aquamarine\" , { 0.498039 , 1 , 0.831373 }}, { \"azure\" , { 0.941176 , 1 , 1 }}, { \"beige\" , { 0.960784 , 0.960784 , 0.862745 }}, { \"bisque\" , { 1 , 0.894118 , 0.768627 }}, { \"black\" , { 0 , 0 , 0 }}, { \"blanchedalmond\" , { 1 , 0.921569 , 0.803922 }}, { \"blue\" , { 0 , 0 , 1 }}, { \"blueviolet\" , { 0.541176 , 0.168627 , 0.886275 }}, { \"brown\" , { 0.647059 , 0.164706 , 0.164706 }}, { \"burlywood\" , { 0.870588 , 0.721569 , 0.529412 }}, { \"cadetblue\" , { 0.372549 , 0.619608 , 0.627451 }}, { \"chartreuse\" , { 0.498039 , 1 , 0 }}, { \"chocolate\" , { 0.823529 , 0.411765 , 0.117647 }}, { \"coral\" , { 1 , 0.498039 , 0.313725 }}, { \"cornflowerblue\" , { 0.392157 , 0.584314 , 0.929412 }}, { \"cornsilk\" , { 1 , 0.972549 , 0.862745 }}, { \"crimson\" , { 0.862745 , 0.0784314 , 0.235294 }}, { \"cyan\" , { 0 , 1 , 1 }}, { \"darkblue\" , { 0 , 0 , 0.545098 }}, { \"darkcyan\" , { 0 , 0.545098 , 0.545098 }}, { \"darkgoldenrod\" , { 0.721569 , 0.52549 , 0.0431373 }}, { \"darkgray\" , { 0.662745 , 0.662745 , 0.662745 }}, { \"darkgreen\" , { 0 , 0.392157 , 0 }}, { \"darkkhaki\" , { 0.741176 , 0.717647 , 0.419608 }}, { \"darkmagenta\" , { 0.545098 , 0 , 0.545098 }}, { \"darkolivegreen\" , { 0.333333 , 0.419608 , 0.184314 }}, { \"darkorange\" , { 1 , 0.54902 , 0 }}, { \"darkorchid\" , { 0.6 , 0.196078 , 0.8 }}, { \"darkred\" , { 0.545098 , 0 , 0 }}, { \"darksalmon\" , { 0.913725 , 0.588235 , 0.478431 }}, { \"darkseagreen\" , { 0.560784 , 0.737255 , 0.560784 }}, { \"darkslateblue\" , { 0.282353 , 0.239216 , 0.545098 }}, { \"darkslategray\" , { 0.184314 , 0.309804 , 0.309804 }}, { \"darkturquoise\" , { 0 , 0.807843 , 0.819608 }}, { \"darkviolet\" , { 0.580392 , 0 , 0.827451 }}, { \"deeppink\" , { 1 , 0.0784314 , 0.576471 }}, { \"deepskyblue\" , { 0 , 0.74902 , 1 }}, { \"dimgray\" , { 0.411765 , 0.411765 , 0.411765 }}, { \"dodgerblue\" , { 0.117647 , 0.564706 , 1 }}, { \"firebrick\" , { 0.698039 , 0.133333 , 0.133333 }}, { \"floralwhite\" , { 1 , 0.980392 , 0.941176 }}, { \"forestgreen\" , { 0.133333 , 0.545098 , 0.133333 }}, { \"fuchsia\" , { 1 , 0 , 1 }}, { \"gainsboro\" , { 0.862745 , 0.862745 , 0.862745 }}, { \"ghostwhite\" , { 0.972549 , 0.972549 , 1 }}, { \"gold\" , { 1 , 0.843137 , 0 }}, { \"goldenrod\" , { 0.854902 , 0.647059 , 0.12549 }}, { \"gray\" , { 0.501961 , 0.501961 , 0.501961 }}, { \"green\" , { 0 , 0.501961 , 0 }}, { \"greenyellow\" , { 0.678431 , 1 , 0.184314 }}, { \"honeydew\" , { 0.941176 , 1 , 0.941176 }}, { \"hotpink\" , { 1 , 0.411765 , 0.705882 }}, { \"indianred\" , { 0.803922 , 0.360784 , 0.360784 }}, { \"indigo\" , { 0.294118 , 0 , 0.509804 }}, { \"ivory\" , { 1 , 1 , 0.941176 }}, { \"khaki\" , { 0.941176 , 0.901961 , 0.54902 }}, { \"lavender\" , { 0.901961 , 0.901961 , 0.980392 }}, { \"lavenderblush\" , { 1 , 0.941176 , 0.960784 }}, { \"lawngreen\" , { 0.486275 , 0.988235 , 0 }}, { \"lemonchiffon\" , { 1 , 0.980392 , 0.803922 }}, { \"lightblue\" , { 0.678431 , 0.847059 , 0.901961 }}, { \"lightcoral\" , { 0.941176 , 0.501961 , 0.501961 }}, { \"lightcyan\" , { 0.878431 , 1 , 1 }}, { \"lightgoldenrodyellow\" , { 0.980392 , 0.980392 , 0.823529 }}, { \"lightgray\" , { 0.827451 , 0.827451 , 0.827451 }}, { \"lightgreen\" , { 0.564706 , 0.933333 , 0.564706 }}, { \"lightpink\" , { 1 , 0.713725 , 0.756863 }}, { \"lightsalmon\" , { 1 , 0.627451 , 0.478431 }}, { \"lightseagreen\" , { 0.12549 , 0.698039 , 0.666667 }}, { \"lightskyblue\" , { 0.529412 , 0.807843 , 0.980392 }}, { \"lightslategray\" , { 0.466667 , 0.533333 , 0.6 }}, { \"lightsteelblue\" , { 0.690196 , 0.768627 , 0.870588 }}, { \"lightyellow\" , { 1 , 1 , 0.878431 }}, { \"lime\" , { 0 , 1 , 0 }}, { \"limegreen\" , { 0.196078 , 0.803922 , 0.196078 }}, { \"linen\" , { 0.980392 , 0.941176 , 0.901961 }}, { \"magenta\" , { 1 , 0 , 1 }}, { \"maroon\" , { 0.501961 , 0 , 0 }}, { \"mediumaquamarine\" , { 0.4 , 0.803922 , 0.666667 }}, { \"mediumblue\" , { 0 , 0 , 0.803922 }}, { \"mediumorchid\" , { 0.729412 , 0.333333 , 0.827451 }}, { \"mediumpurple\" , { 0.576471 , 0.439216 , 0.858824 }}, { \"mediumseagreen\" , { 0.235294 , 0.701961 , 0.443137 }}, { \"mediumslateblue\" , { 0.482353 , 0.407843 , 0.933333 }}, { \"mediumspringgreen\" , { 0 , 0.980392 , 0.603922 }}, { \"mediumturquoise\" , { 0.282353 , 0.819608 , 0.8 }}, { \"mediumvioletred\" , { 0.780392 , 0.0823529 , 0.521569 }}, { \"midnightblue\" , { 0.0980392 , 0.0980392 , 0.439216 }}, { \"mintcream\" , { 0.960784 , 1 , 0.980392 }}, { \"mistyrose\" , { 1 , 0.894118 , 0.882353 }}, { \"moccasin\" , { 1 , 0.894118 , 0.709804 }}, { \"navajowhite\" , { 1 , 0.870588 , 0.678431 }}, { \"navy\" , { 0 , 0 , 0.501961 }}, { \"oldlace\" , { 0.992157 , 0.960784 , 0.901961 }}, { \"olive\" , { 0.501961 , 0.501961 , 0 }}, { \"olivedrab\" , { 0.419608 , 0.556863 , 0.137255 }}, { \"orange\" , { 1 , 0.647059 , 0 }}, { \"orangered\" , { 1 , 0.270588 , 0 }}, { \"orchid\" , { 0.854902 , 0.439216 , 0.839216 }}, { \"palegoldenrod\" , { 0.933333 , 0.909804 , 0.666667 }}, { \"palegreen\" , { 0.596078 , 0.984314 , 0.596078 }}, { \"paleturquoise\" , { 0.686275 , 0.933333 , 0.933333 }}, { \"palevioletred\" , { 0.858824 , 0.439216 , 0.576471 }}, { \"papayawhip\" , { 1 , 0.937255 , 0.835294 }}, { \"peachpuff\" , { 1 , 0.854902 , 0.72549 }}, { \"peru\" , { 0.803922 , 0.521569 , 0.247059 }}, { \"pink\" , { 1 , 0.752941 , 0.796078 }}, { \"plum\" , { 0.866667 , 0.627451 , 0.866667 }}, { \"powderblue\" , { 0.690196 , 0.878431 , 0.901961 }}, { \"purple\" , { 0.501961 , 0 , 0.501961 }}, { \"red\" , { 1 , 0 , 0 }}, { \"rosybrown\" , { 0.737255 , 0.560784 , 0.560784 }}, { \"royalblue\" , { 0.254902 , 0.411765 , 0.882353 }}, { \"saddlebrown\" , { 0.545098 , 0.270588 , 0.0745098 }}, { \"salmon\" , { 0.980392 , 0.501961 , 0.447059 }}, { \"sandybrown\" , { 0.956863 , 0.643137 , 0.376471 }}, { \"seagreen\" , { 0.180392 , 0.545098 , 0.341176 }}, { \"seashell\" , { 1 , 0.960784 , 0.933333 }}, { \"sienna\" , { 0.627451 , 0.321569 , 0.176471 }}, { \"silver\" , { 0.752941 , 0.752941 , 0.752941 }}, { \"skyblue\" , { 0.529412 , 0.807843 , 0.921569 }}, { \"slateblue\" , { 0.415686 , 0.352941 , 0.803922 }}, { \"slategray\" , { 0.439216 , 0.501961 , 0.564706 }}, { \"snow\" , { 1 , 0.980392 , 0.980392 }}, { \"springgreen\" , { 0 , 1 , 0.498039 }}, { \"steelblue\" , { 0.27451 , 0.509804 , 0.705882 }}, { \"tan\" , { 0.823529 , 0.705882 , 0.54902 }}, { \"teal\" , { 0 , 0.501961 , 0.501961 }}, { \"thistle\" , { 0.847059 , 0.74902 , 0.847059 }}, { \"tomato\" , { 1 , 0.388235 , 0.278431 }}, { \"turquoise\" , { 0.25098 , 0.878431 , 0.815686 }}, { \"violet\" , { 0.933333 , 0.509804 , 0.933333 }}, { \"wheat\" , { 0.960784 , 0.870588 , 0.701961 }}, { \"white\" , { 1 , 1 , 1 }}, { \"whitesmoke\" , { 0.960784 , 0.960784 , 0.960784 }}, { \"yellow\" , { 1 , 1 , 0 }}, { \"yellowgreen\" , { 0.603922 , 0.803922 , 0.196078 }}, { \"ERROR\" , { 0 , 0 , 0 }}}; } // namespace color_utils #endif // SIMULATION_API__COLOR_UTILS__COLOR_UTILS_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/dir_0b810b4fde226282b79ff02d0f66741e/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper/stop_watch.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper/helper.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper"},{"location":"package/simulation_api/markdown/Files/dir_0b810b4fde226282b79ff02d0f66741e/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apihelper","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper"},{"location":"package/simulation_api/markdown/Files/dir_0b810b4fde226282b79ff02d0f66741e/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper/stop_watch.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper/helper.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_0ecad8a2d603f2370f526b4c50e40e06/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/walk_straight_action.hpp class definition for the walk straight action /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/pedestrian_action_node.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/follow_lane_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/behavior_tree.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian"},{"location":"package/simulation_api/markdown/Files/dir_0ecad8a2d603f2370f526b4c50e40e06/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorpedestrian","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian"},{"location":"package/simulation_api/markdown/Files/dir_0ecad8a2d603f2370f526b4c50e40e06/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/walk_straight_action.hpp class definition for the walk straight action /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/pedestrian_action_node.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/follow_lane_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/behavior_tree.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_1373a00214e0db5b502ebb3770d7a5e6/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api"},{"location":"package/simulation_api/markdown/Files/dir_1373a00214e0db5b502ebb3770d7a5e6/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_api","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api"},{"location":"package/simulation_api/markdown/Files/dir_1373a00214e0db5b502ebb3770d7a5e6/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include Updated on 7 April 2021 at 00:31:55 UTC","title":"Directories"},{"location":"package/simulation_api/markdown/Files/dir_218ef04f3eedd648dd4bac1a9e37c222/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/yield_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/follow_lane_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence"},{"location":"package/simulation_api/markdown/Files/dir_218ef04f3eedd648dd4bac1a9e37c222/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorvehiclefollow_lane_sequence","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence"},{"location":"package/simulation_api/markdown/Files/dir_218ef04f3eedd648dd4bac1a9e37c222/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/yield_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/follow_lane_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_30c5f8d710657dd403fb7c1b23b6a2be/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src/test_math.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src/test_hdmap_utils.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src"},{"location":"package/simulation_api/markdown/Files/dir_30c5f8d710657dd403fb7c1b23b6a2be/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apitestsrc","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src"},{"location":"package/simulation_api/markdown/Files/dir_30c5f8d710657dd403fb7c1b23b6a2be/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src/test_math.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src/test_hdmap_utils.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_3275340185addae2bbc298ed1678a25d/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_util.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_time_delay.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_interface.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_ideal.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model"},{"location":"package/simulation_api/markdown/Files/dir_3275340185addae2bbc298ed1678a25d/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcvehicle_model","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model"},{"location":"package/simulation_api/markdown/Files/dir_3275340185addae2bbc298ed1678a25d/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_util.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_time_delay.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_interface.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_ideal.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_3ce5d9fbd7554101c1bd798dee5d35f4/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/helper # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/helper/helper.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/helper"},{"location":"package/simulation_api/markdown/Files/dir_3ce5d9fbd7554101c1bd798dee5d35f4/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrchelper","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/helper"},{"location":"package/simulation_api/markdown/Files/dir_3ce5d9fbd7554101c1bd798dee5d35f4/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/helper/helper.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_4893bd41c80cae195f8f1073db694ab1/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test"},{"location":"package/simulation_api/markdown/Files/dir_4893bd41c80cae195f8f1073db694ab1/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apitest","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test"},{"location":"package/simulation_api/markdown/Files/dir_4893bd41c80cae195f8f1073db694ab1/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src Updated on 7 April 2021 at 00:31:55 UTC","title":"Directories"},{"location":"package/simulation_api/markdown/Files/dir_52cc93bbfc780e0b3a3b54fb4092334e/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/uuid.hpp header files for generating UUID /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/polynomial_solver.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/hermite_curve.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/distance.hpp functions for calculating distance /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/collision.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/catmull_rom_spline.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/bounding_box.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math"},{"location":"package/simulation_api/markdown/Files/dir_52cc93bbfc780e0b3a3b54fb4092334e/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apimath","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math"},{"location":"package/simulation_api/markdown/Files/dir_52cc93bbfc780e0b3a3b54fb4092334e/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/uuid.hpp header files for generating UUID /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/polynomial_solver.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/hermite_curve.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/distance.hpp functions for calculating distance /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/collision.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/catmull_rom_spline.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/bounding_box.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_5d1dc57edc7f3406282f0844025e9d21/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/vehicle_parameter.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/vehicle_entity.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/pedestrian_parameter.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/pedestrian_entity.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/exception.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/entity_manager.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/entity_base.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/ego_entity.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity"},{"location":"package/simulation_api/markdown/Files/dir_5d1dc57edc7f3406282f0844025e9d21/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apientity","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity"},{"location":"package/simulation_api/markdown/Files/dir_5d1dc57edc7f3406282f0844025e9d21/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/vehicle_parameter.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/vehicle_entity.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/pedestrian_parameter.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/pedestrian_entity.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/exception.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/entity_manager.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/entity_base.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/ego_entity.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_6c00ad14859f8fc851cbbb04cd348996/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/vehicle_action_node.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/lane_change_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/behavior_tree.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle"},{"location":"package/simulation_api/markdown/Files/dir_6c00ad14859f8fc851cbbb04cd348996/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorvehicle","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle"},{"location":"package/simulation_api/markdown/Files/dir_6c00ad14859f8fc851cbbb04cd348996/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence","title":"Directories"},{"location":"package/simulation_api/markdown/Files/dir_6c00ad14859f8fc851cbbb04cd348996/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/vehicle_action_node.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/lane_change_action.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/behavior_tree.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_7401750801aa24951f1427bf80c368ad/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights/traffic_light_manager.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights/traffic_light.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights"},{"location":"package/simulation_api/markdown/Files/dir_7401750801aa24951f1427bf80c368ad/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrctraffic_lights","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights"},{"location":"package/simulation_api/markdown/Files/dir_7401750801aa24951f1427bf80c368ad/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights/traffic_light_manager.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights/traffic_light.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_7487f41de01cca700e4de80b884d7106/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation"},{"location":"package/simulation_api/markdown/Files/dir_7487f41de01cca700e4de80b884d7106/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulation","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation"},{"location":"package/simulation_api/markdown/Files/dir_7487f41de01cca700e4de80b884d7106/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Directories"},{"location":"package/simulation_api/markdown/Files/dir_77cc2c7e3339b6fcf4d858f87d9afe3e/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/uuid.cpp source files for generating UUID /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/polynomial_solver.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/hermite_curve.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/distance.cpp functions for calculating distance /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/collision.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/catmull_rom_spline.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/bounding_box.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math"},{"location":"package/simulation_api/markdown/Files/dir_77cc2c7e3339b6fcf4d858f87d9afe3e/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmath","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math"},{"location":"package/simulation_api/markdown/Files/dir_77cc2c7e3339b6fcf4d858f87d9afe3e/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/uuid.cpp source files for generating UUID /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/polynomial_solver.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/hermite_curve.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/distance.cpp functions for calculating distance /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/collision.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/catmull_rom_spline.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/bounding_box.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_8a8903247d09ea5a4cf1af31a82ad4bb/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/color_utils # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/color_utils/color_utils.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/color_utils"},{"location":"package/simulation_api/markdown/Files/dir_8a8903247d09ea5a4cf1af31a82ad4bb/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apicolor_utils","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/color_utils"},{"location":"package/simulation_api/markdown/Files/dir_8a8903247d09ea5a4cf1af31a82ad4bb/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/color_utils/color_utils.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_9139f52cd423f79555a8ac8c9d7a042b/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/hdmap_utils /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/color_utils /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api"},{"location":"package/simulation_api/markdown/Files/dir_9139f52cd423f79555a8ac8c9d7a042b/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_api","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api"},{"location":"package/simulation_api/markdown/Files/dir_9139f52cd423f79555a8ac8c9d7a042b/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/hdmap_utils /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/color_utils /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/api Updated on 7 April 2021 at 00:31:55 UTC","title":"Directories"},{"location":"package/simulation_api/markdown/Files/dir_9382f57a33d1b62c128da4b0e3162922/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_sink.hpp class definition of the traffic sink /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_module_base.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_controller.hpp class definition for the traffic controller Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic"},{"location":"package/simulation_api/markdown/Files/dir_9382f57a33d1b62c128da4b0e3162922/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apitraffic","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic"},{"location":"package/simulation_api/markdown/Files/dir_9382f57a33d1b62c128da4b0e3162922/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_sink.hpp class definition of the traffic sink /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_module_base.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_controller.hpp class definition for the traffic controller Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_974125ba23e79cc32193c7f2434ba34b/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_util.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_time_delay.hpp simple planning simulator model with time delay and 1-dimensional dynamics for velocity & steering /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_interface.hpp simple planning simulator model interface class /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_ideal.hpp simple planning simulator ideal velocity model (no dynamics for desired velocity & angular-velocity or steering) Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model"},{"location":"package/simulation_api/markdown/Files/dir_974125ba23e79cc32193c7f2434ba34b/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apivehicle_model","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model"},{"location":"package/simulation_api/markdown/Files/dir_974125ba23e79cc32193c7f2434ba34b/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_util.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_time_delay.hpp simple planning simulator model with time delay and 1-dimensional dynamics for velocity & steering /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_interface.hpp simple planning simulator model interface class /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_ideal.hpp simple planning simulator ideal velocity model (no dynamics for desired velocity & angular-velocity or steering) Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_9e23e0cd74888daaed63d98c5e2edc58/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include"},{"location":"package/simulation_api/markdown/Files/dir_9e23e0cd74888daaed63d98c5e2edc58/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiinclude","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include"},{"location":"package/simulation_api/markdown/Files/dir_9e23e0cd74888daaed63d98c5e2edc58/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Directories"},{"location":"package/simulation_api/markdown/Files/dir_a6264388c7db46399f5a28db165809d0/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/hdmap_utils # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/hdmap_utils/hdmap_utils.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/hdmap_utils"},{"location":"package/simulation_api/markdown/Files/dir_a6264388c7db46399f5a28db165809d0/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apihdmap_utils","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/hdmap_utils"},{"location":"package/simulation_api/markdown/Files/dir_a6264388c7db46399f5a28db165809d0/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/hdmap_utils/hdmap_utils.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_a793b67f238b0c8aceaa0bcd36db5b7d/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/route_planner.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/action_node.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior"},{"location":"package/simulation_api/markdown/Files/dir_a793b67f238b0c8aceaa0bcd36db5b7d/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehavior","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior"},{"location":"package/simulation_api/markdown/Files/dir_a793b67f238b0c8aceaa0bcd36db5b7d/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian","title":"Directories"},{"location":"package/simulation_api/markdown/Files/dir_a793b67f238b0c8aceaa0bcd36db5b7d/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/route_planner.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/action_node.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_aec17a348c91d25227e84264c6975c6a/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/traveled_distance_metric.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/reaction_time_metric.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/momentary_stop_metric.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metrics_manager.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metrics.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metric_base.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics"},{"location":"package/simulation_api/markdown/Files/dir_aec17a348c91d25227e84264c6975c6a/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apimetrics","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics"},{"location":"package/simulation_api/markdown/Files/dir_aec17a348c91d25227e84264c6975c6a/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/traveled_distance_metric.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/reaction_time_metric.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/momentary_stop_metric.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metrics_manager.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metrics.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metric_base.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_af2f8e454160dee986435e2f45acff53/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/hdmap_utils # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/hdmap_utils/hdmap_utils.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/hdmap_utils"},{"location":"package/simulation_api/markdown/Files/dir_af2f8e454160dee986435e2f45acff53/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrchdmap_utils","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/hdmap_utils"},{"location":"package/simulation_api/markdown/Files/dir_af2f8e454160dee986435e2f45acff53/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/hdmap_utils/hdmap_utils.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_b03aabed59314b74c899025743752a82/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/route_planner.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/action_node.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior"},{"location":"package/simulation_api/markdown/Files/dir_b03aabed59314b74c899025743752a82/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehavior","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior"},{"location":"package/simulation_api/markdown/Files/dir_b03aabed59314b74c899025743752a82/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian","title":"Directories"},{"location":"package/simulation_api/markdown/Files/dir_b03aabed59314b74c899025743752a82/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/route_planner.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/action_node.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_b1f083f3cedebca7843a46974b01da12/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/traveled_distance_metric.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/reaction_time_metric.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/momentary_stop_metric.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/metrics_manager.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/metric_base.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics"},{"location":"package/simulation_api/markdown/Files/dir_b1f083f3cedebca7843a46974b01da12/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmetrics","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics"},{"location":"package/simulation_api/markdown/Files/dir_b1f083f3cedebca7843a46974b01da12/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/traveled_distance_metric.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/reaction_time_metric.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/momentary_stop_metric.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/metrics_manager.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/metric_base.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_bebb1e69389ff38cf1864569618ea400/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/api # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/api/api.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/api"},{"location":"package/simulation_api/markdown/Files/dir_bebb1e69389ff38cf1864569618ea400/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apiapi","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/api"},{"location":"package/simulation_api/markdown/Files/dir_bebb1e69389ff38cf1864569618ea400/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/api/api.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_c471a8c1b8554b91032d5636d63d91d7/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/api # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/api/api.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/api"},{"location":"package/simulation_api/markdown/Files/dir_c471a8c1b8554b91032d5636d63d91d7/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcapi","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/api"},{"location":"package/simulation_api/markdown/Files/dir_c471a8c1b8554b91032d5636d63d91d7/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/api/api.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_ca92be12b33f5d68025908d89696ac0f/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/walk_straight_action.cpp class implimentation of the walk straight action /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/pedestrian_action_node.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/follow_lane_action.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/behavior_tree.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian"},{"location":"package/simulation_api/markdown/Files/dir_ca92be12b33f5d68025908d89696ac0f/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorpedestrian","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian"},{"location":"package/simulation_api/markdown/Files/dir_ca92be12b33f5d68025908d89696ac0f/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/walk_straight_action.cpp class implimentation of the walk straight action /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/pedestrian_action_node.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/follow_lane_action.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/behavior_tree.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_cf44a5f7bc5a509a5c6903ab3e6620e1/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic/traffic_sink.cpp implementation of the TrafficSink class /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic/traffic_controller.cpp class implementation for the traffic controller Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic"},{"location":"package/simulation_api/markdown/Files/dir_cf44a5f7bc5a509a5c6903ab3e6620e1/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrctraffic","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic"},{"location":"package/simulation_api/markdown/Files/dir_cf44a5f7bc5a509a5c6903ab3e6620e1/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic/traffic_sink.cpp implementation of the TrafficSink class /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic/traffic_controller.cpp class implementation for the traffic controller Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_cfad0463f8b920248f557d23671db86b/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/yield_action.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/follow_lane_action.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence"},{"location":"package/simulation_api/markdown/Files/dir_cfad0463f8b920248f557d23671db86b/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorvehiclefollow_lane_sequence","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence"},{"location":"package/simulation_api/markdown/Files/dir_cfad0463f8b920248f557d23671db86b/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/yield_action.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/follow_lane_action.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_d02a7613f8157020eefbabebf0c581a7/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_state.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_phase.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_manager.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights"},{"location":"package/simulation_api/markdown/Files/dir_d02a7613f8157020eefbabebf0c581a7/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apitraffic_lights","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights"},{"location":"package/simulation_api/markdown/Files/dir_d02a7613f8157020eefbabebf0c581a7/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_state.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_phase.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_manager.hpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light.hpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_d50ae905adeee3e931557abcec1c10b3/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/vehicle_action_node.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/lane_change_action.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/behavior_tree.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle"},{"location":"package/simulation_api/markdown/Files/dir_d50ae905adeee3e931557abcec1c10b3/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorvehicle","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle"},{"location":"package/simulation_api/markdown/Files/dir_d50ae905adeee3e931557abcec1c10b3/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence","title":"Directories"},{"location":"package/simulation_api/markdown/Files/dir_d50ae905adeee3e931557abcec1c10b3/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/vehicle_action_node.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/lane_change_action.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/behavior_tree.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_d8f772cf00714700e76225f4c09b1c6d/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src # Directories # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/helper /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/hdmap_utils /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/color_utils /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src"},{"location":"package/simulation_api/markdown/Files/dir_d8f772cf00714700e76225f4c09b1c6d/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrc","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src"},{"location":"package/simulation_api/markdown/Files/dir_d8f772cf00714700e76225f4c09b1c6d/#directories","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/helper /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/hdmap_utils /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/color_utils /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/api Updated on 7 April 2021 at 00:31:55 UTC","title":"Directories"},{"location":"package/simulation_api/markdown/Files/dir_dc38dd2e6d556441d95679e420053351/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc/scenario_runner_moc_node.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc/catmull_rom_visualization.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc"},{"location":"package/simulation_api/markdown/Files/dir_dc38dd2e6d556441d95679e420053351/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmoc","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc"},{"location":"package/simulation_api/markdown/Files/dir_dc38dd2e6d556441d95679e420053351/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc/scenario_runner_moc_node.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc/catmull_rom_visualization.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_e3b13a53239c0c6462162aee6160846c/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/vehicle_entity.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/pedestrian_entity.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/entity_manager.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/entity_base.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/ego_entity.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity"},{"location":"package/simulation_api/markdown/Files/dir_e3b13a53239c0c6462162aee6160846c/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcentity","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity"},{"location":"package/simulation_api/markdown/Files/dir_e3b13a53239c0c6462162aee6160846c/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/vehicle_entity.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/pedestrian_entity.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/entity_manager.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/entity_base.cpp /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/ego_entity.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/dir_ef01d1c760777643e7cf63ce8c795881/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/color_utils # Files # Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/color_utils/color_utils.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/color_utils"},{"location":"package/simulation_api/markdown/Files/dir_ef01d1c760777643e7cf63ce8c795881/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrccolor_utils","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/color_utils"},{"location":"package/simulation_api/markdown/Files/dir_ef01d1c760777643e7cf63ce8c795881/#files","text":"Name /home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/color_utils/color_utils.cpp Updated on 7 April 2021 at 00:31:55 UTC","title":"Files"},{"location":"package/simulation_api/markdown/Files/distance_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/distance.cpp # functions for calculating distance More... Namespaces # Name simulation_api::math simulation_api Detailed Description # functions for calculating distance Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021} Source code # // Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/math/distance.hpp> #include <cmath> namespace simulation_api { namespace math { double getDistance ( const geometry_msgs :: msg :: Point & p0 , const geometry_msgs :: msg :: Point & p1 ) { return std :: sqrt ( std :: pow ( p0 . x - p1 . x , 2 ) + std :: pow ( p0 . y - p1 . y , 2 ) + std :: pow ( p0 . z - p1 . z , 2 )); } double getDistance ( const geometry_msgs :: msg :: Pose & p0 , const geometry_msgs :: msg :: Point & p1 ) { return getDistance ( p0 . position , p1 ); } double getDistance ( const geometry_msgs :: msg :: Point & p0 , const geometry_msgs :: msg :: Pose & p1 ) { return getDistance ( p0 , p1 . position ); } double getDistance ( const geometry_msgs :: msg :: Pose & p0 , const geometry_msgs :: msg :: Pose & p1 ) { return getDistance ( p0 . position , p1 . position ); } } // namespace math } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/distance.cpp"},{"location":"package/simulation_api/markdown/Files/distance_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmathdistancecpp","text":"functions for calculating distance More...","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/distance.cpp"},{"location":"package/simulation_api/markdown/Files/distance_8cpp/#namespaces","text":"Name simulation_api::math simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/distance_8cpp/#detailed-description","text":"functions for calculating distance Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021}","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Files/distance_8cpp/#source-code","text":"// Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/math/distance.hpp> #include <cmath> namespace simulation_api { namespace math { double getDistance ( const geometry_msgs :: msg :: Point & p0 , const geometry_msgs :: msg :: Point & p1 ) { return std :: sqrt ( std :: pow ( p0 . x - p1 . x , 2 ) + std :: pow ( p0 . y - p1 . y , 2 ) + std :: pow ( p0 . z - p1 . z , 2 )); } double getDistance ( const geometry_msgs :: msg :: Pose & p0 , const geometry_msgs :: msg :: Point & p1 ) { return getDistance ( p0 . position , p1 ); } double getDistance ( const geometry_msgs :: msg :: Point & p0 , const geometry_msgs :: msg :: Pose & p1 ) { return getDistance ( p0 , p1 . position ); } double getDistance ( const geometry_msgs :: msg :: Pose & p0 , const geometry_msgs :: msg :: Pose & p1 ) { return getDistance ( p0 . position , p1 . position ); } } // namespace math } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/distance_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/distance.hpp # functions for calculating distance More... Namespaces # Name simulation_api::math simulation_api Detailed Description # functions for calculating distance Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021} Source code # // Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__MATH__DISTANCE_HPP_ #define SIMULATION_API__MATH__DISTANCE_HPP_ #include <geometry_msgs/msg/pose.hpp> namespace simulation_api { namespace math { double getDistance ( const geometry_msgs :: msg :: Point & p0 , const geometry_msgs :: msg :: Point & p1 ); double getDistance ( const geometry_msgs :: msg :: Pose & p0 , const geometry_msgs :: msg :: Point & p1 ); double getDistance ( const geometry_msgs :: msg :: Point & p0 , const geometry_msgs :: msg :: Pose & p1 ); double getDistance ( const geometry_msgs :: msg :: Pose & p0 , const geometry_msgs :: msg :: Pose & p1 ); } // namespace math } // namespace simulation_api #endif // SIMULATION_API__MATH__DISTANCE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/distance.hpp"},{"location":"package/simulation_api/markdown/Files/distance_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apimathdistancehpp","text":"functions for calculating distance More...","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/distance.hpp"},{"location":"package/simulation_api/markdown/Files/distance_8hpp/#namespaces","text":"Name simulation_api::math simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/distance_8hpp/#detailed-description","text":"functions for calculating distance Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021}","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Files/distance_8hpp/#source-code","text":"// Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__MATH__DISTANCE_HPP_ #define SIMULATION_API__MATH__DISTANCE_HPP_ #include <geometry_msgs/msg/pose.hpp> namespace simulation_api { namespace math { double getDistance ( const geometry_msgs :: msg :: Point & p0 , const geometry_msgs :: msg :: Point & p1 ); double getDistance ( const geometry_msgs :: msg :: Pose & p0 , const geometry_msgs :: msg :: Point & p1 ); double getDistance ( const geometry_msgs :: msg :: Point & p0 , const geometry_msgs :: msg :: Pose & p1 ); double getDistance ( const geometry_msgs :: msg :: Pose & p0 , const geometry_msgs :: msg :: Pose & p1 ); } // namespace math } // namespace simulation_api #endif // SIMULATION_API__MATH__DISTANCE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/ego__entity_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/ego_entity.cpp # Namespaces # Name simulation_api::entity simulation_api Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <awapi_accessor/accessor.hpp> #include <openscenario_msgs/msg/waypoints_array.hpp> #include <quaternion_operation/quaternion_operation.h> #include <simulation_api/entity/ego_entity.hpp> #include <memory> #include <vector> #include <string> #include <unordered_map> namespace simulation_api { namespace entity { std :: unordered_map < std :: string , std :: shared_ptr < autoware_api :: Accessor > > EgoEntity :: autowares {}; void EgoEntity :: requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) { assert ( 1 < waypoints . size ()); const auto destination = ( * hdmap_utils_ptr_ ). toMapPose ( waypoints . back ()); std :: vector < geometry_msgs :: msg :: PoseStamped > constraints {}; for ( auto iter = std :: cbegin ( waypoints ); std :: next ( iter ) != std :: cend ( waypoints ); ++ iter ) { constraints . push_back (( * hdmap_utils_ptr_ ). toMapPose ( * iter )); } return requestAcquirePosition ( destination , constraints ); } openscenario_msgs :: msg :: WaypointsArray EgoEntity :: getWaypoints () const { openscenario_msgs :: msg :: WaypointsArray waypoints {}; for ( const auto & point : std :: atomic_load ( & autowares . at ( name )) -> getTrajectory (). points ) { waypoints . waypoints . emplace_back ( point . pose . position ); } return waypoints ; } bool EgoEntity :: setStatus ( const openscenario_msgs :: msg :: EntityStatus & status ) { // NOTE Currently, setStatus always succeeds. const bool success = VehicleEntity :: setStatus ( status ); const auto current = getStatus (); if ( autoware_initialized ) { updateAutoware ( current . pose ); } if ( ! initial_pose_ ) { initial_pose_ = current . pose ; } return success ; } void EgoEntity :: onUpdate ( double current_time , double step_time ) { Eigen :: VectorXd input ( 2 ); { input << std :: atomic_load ( & autowares . at ( name )) -> getVehicleCommand (). control . velocity , std :: atomic_load ( & autowares . at ( name )) -> getVehicleCommand (). control . steering_angle ; } ( * vehicle_model_ptr_ ). setInput ( input ); ( * vehicle_model_ptr_ ). update ( step_time ); setStatus ( getEntityStatus ( current_time + step_time , step_time )); if ( previous_linear_velocity_ ) { linear_jerk_ = ( vehicle_model_ptr_ -> getVx () - previous_linear_velocity_ . get ()) / step_time ; } else { linear_jerk_ = 0 ; } previous_linear_velocity_ = vehicle_model_ptr_ -> getVx (); previous_angular_velocity_ = vehicle_model_ptr_ -> getWz (); } const openscenario_msgs :: msg :: EntityStatus EgoEntity :: getEntityStatus ( const double time , const double step_time ) const { geometry_msgs :: msg :: Vector3 rpy ; { rpy . x = 0 ; rpy . y = 0 ; rpy . z = vehicle_model_ptr_ -> getYaw (); } geometry_msgs :: msg :: Pose pose ; { pose . position . x = vehicle_model_ptr_ -> getX (); pose . position . y = vehicle_model_ptr_ -> getY (); pose . position . z = 0.0 ; pose . orientation = quaternion_operation :: convertEulerAngleToQuaternion ( rpy ); } geometry_msgs :: msg :: Twist twist ; { twist . linear . x = vehicle_model_ptr_ -> getVx (); twist . angular . z = vehicle_model_ptr_ -> getWz (); } geometry_msgs :: msg :: Accel accel ; { if ( previous_angular_velocity_ && previous_linear_velocity_ ) { accel . linear . x = ( twist . linear . x - previous_linear_velocity_ . get ()) / step_time ; accel . angular . z = ( twist . angular . z - previous_angular_velocity_ . get ()) / step_time ; } } Eigen :: VectorXd v ( 3 ); { v ( 0 ) = pose . position . x ; v ( 1 ) = pose . position . y ; v ( 2 ) = pose . position . z ; v = quaternion_operation :: getRotationMatrix (( * initial_pose_ ). orientation ) * v ; } openscenario_msgs :: msg :: EntityStatus status ; { status . time = time ; status . type . type = openscenario_msgs :: msg :: EntityType :: EGO ; status . bounding_box = getBoundingBox (); status . action_status . twist = twist ; status . action_status . accel = accel ; status . pose . position . x = v ( 0 ) + initial_pose_ . get (). position . x ; status . pose . position . y = v ( 1 ) + initial_pose_ . get (). position . y ; status . pose . position . z = v ( 2 ) + initial_pose_ . get (). position . z ; const auto closest_lanelet_id = hdmap_utils_ptr_ -> getClosetLanletId ( status . pose ); if ( ! closest_lanelet_id ) { throw SimulationRuntimeError ( \"failed to closest lane.\" ); } simulation_api :: math :: CatmullRomSpline spline ( hdmap_utils_ptr_ -> getCenterPoints ( closest_lanelet_id . get ())); const auto s_value = spline . getSValue ( status . pose . position ); if ( s_value ) { status . pose . position . z = spline . getPoint ( s_value . get ()). z ; } status . pose . orientation = initial_pose_ . get (). orientation * pose . orientation ; const auto lanelet_pose = hdmap_utils_ptr_ -> toLaneletPose ( status . pose ); status . lanelet_pose_valid = static_cast < bool > ( lanelet_pose ); if ( lanelet_pose ) { status . lanelet_pose = lanelet_pose . get (); } } return status ; } } // namespace entity } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/ego_entity.cpp"},{"location":"package/simulation_api/markdown/Files/ego__entity_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcentityego_entitycpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/ego_entity.cpp"},{"location":"package/simulation_api/markdown/Files/ego__entity_8cpp/#namespaces","text":"Name simulation_api::entity simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/ego__entity_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <awapi_accessor/accessor.hpp> #include <openscenario_msgs/msg/waypoints_array.hpp> #include <quaternion_operation/quaternion_operation.h> #include <simulation_api/entity/ego_entity.hpp> #include <memory> #include <vector> #include <string> #include <unordered_map> namespace simulation_api { namespace entity { std :: unordered_map < std :: string , std :: shared_ptr < autoware_api :: Accessor > > EgoEntity :: autowares {}; void EgoEntity :: requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) { assert ( 1 < waypoints . size ()); const auto destination = ( * hdmap_utils_ptr_ ). toMapPose ( waypoints . back ()); std :: vector < geometry_msgs :: msg :: PoseStamped > constraints {}; for ( auto iter = std :: cbegin ( waypoints ); std :: next ( iter ) != std :: cend ( waypoints ); ++ iter ) { constraints . push_back (( * hdmap_utils_ptr_ ). toMapPose ( * iter )); } return requestAcquirePosition ( destination , constraints ); } openscenario_msgs :: msg :: WaypointsArray EgoEntity :: getWaypoints () const { openscenario_msgs :: msg :: WaypointsArray waypoints {}; for ( const auto & point : std :: atomic_load ( & autowares . at ( name )) -> getTrajectory (). points ) { waypoints . waypoints . emplace_back ( point . pose . position ); } return waypoints ; } bool EgoEntity :: setStatus ( const openscenario_msgs :: msg :: EntityStatus & status ) { // NOTE Currently, setStatus always succeeds. const bool success = VehicleEntity :: setStatus ( status ); const auto current = getStatus (); if ( autoware_initialized ) { updateAutoware ( current . pose ); } if ( ! initial_pose_ ) { initial_pose_ = current . pose ; } return success ; } void EgoEntity :: onUpdate ( double current_time , double step_time ) { Eigen :: VectorXd input ( 2 ); { input << std :: atomic_load ( & autowares . at ( name )) -> getVehicleCommand (). control . velocity , std :: atomic_load ( & autowares . at ( name )) -> getVehicleCommand (). control . steering_angle ; } ( * vehicle_model_ptr_ ). setInput ( input ); ( * vehicle_model_ptr_ ). update ( step_time ); setStatus ( getEntityStatus ( current_time + step_time , step_time )); if ( previous_linear_velocity_ ) { linear_jerk_ = ( vehicle_model_ptr_ -> getVx () - previous_linear_velocity_ . get ()) / step_time ; } else { linear_jerk_ = 0 ; } previous_linear_velocity_ = vehicle_model_ptr_ -> getVx (); previous_angular_velocity_ = vehicle_model_ptr_ -> getWz (); } const openscenario_msgs :: msg :: EntityStatus EgoEntity :: getEntityStatus ( const double time , const double step_time ) const { geometry_msgs :: msg :: Vector3 rpy ; { rpy . x = 0 ; rpy . y = 0 ; rpy . z = vehicle_model_ptr_ -> getYaw (); } geometry_msgs :: msg :: Pose pose ; { pose . position . x = vehicle_model_ptr_ -> getX (); pose . position . y = vehicle_model_ptr_ -> getY (); pose . position . z = 0.0 ; pose . orientation = quaternion_operation :: convertEulerAngleToQuaternion ( rpy ); } geometry_msgs :: msg :: Twist twist ; { twist . linear . x = vehicle_model_ptr_ -> getVx (); twist . angular . z = vehicle_model_ptr_ -> getWz (); } geometry_msgs :: msg :: Accel accel ; { if ( previous_angular_velocity_ && previous_linear_velocity_ ) { accel . linear . x = ( twist . linear . x - previous_linear_velocity_ . get ()) / step_time ; accel . angular . z = ( twist . angular . z - previous_angular_velocity_ . get ()) / step_time ; } } Eigen :: VectorXd v ( 3 ); { v ( 0 ) = pose . position . x ; v ( 1 ) = pose . position . y ; v ( 2 ) = pose . position . z ; v = quaternion_operation :: getRotationMatrix (( * initial_pose_ ). orientation ) * v ; } openscenario_msgs :: msg :: EntityStatus status ; { status . time = time ; status . type . type = openscenario_msgs :: msg :: EntityType :: EGO ; status . bounding_box = getBoundingBox (); status . action_status . twist = twist ; status . action_status . accel = accel ; status . pose . position . x = v ( 0 ) + initial_pose_ . get (). position . x ; status . pose . position . y = v ( 1 ) + initial_pose_ . get (). position . y ; status . pose . position . z = v ( 2 ) + initial_pose_ . get (). position . z ; const auto closest_lanelet_id = hdmap_utils_ptr_ -> getClosetLanletId ( status . pose ); if ( ! closest_lanelet_id ) { throw SimulationRuntimeError ( \"failed to closest lane.\" ); } simulation_api :: math :: CatmullRomSpline spline ( hdmap_utils_ptr_ -> getCenterPoints ( closest_lanelet_id . get ())); const auto s_value = spline . getSValue ( status . pose . position ); if ( s_value ) { status . pose . position . z = spline . getPoint ( s_value . get ()). z ; } status . pose . orientation = initial_pose_ . get (). orientation * pose . orientation ; const auto lanelet_pose = hdmap_utils_ptr_ -> toLaneletPose ( status . pose ); status . lanelet_pose_valid = static_cast < bool > ( lanelet_pose ); if ( lanelet_pose ) { status . lanelet_pose = lanelet_pose . get (); } } return status ; } } // namespace entity } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/ego__entity_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/ego_entity.hpp # Namespaces # Name simulation_api::entity simulation_api Classes # Name class simulation_api::entity::EgoEntity Defines # Name DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE (STATE) DEBUG_VALUE (...) DEBUG_LINE () Macro Documentation # define DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE # #define DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE( STATE ) define DEBUG_VALUE # #define DEBUG_VALUE( ... ) std :: cout << \" \\x1b [32m\" # __VA_ARGS__ \" = \" << ( __VA_ARGS__ ) << \" \\x1b [0m\" << std :: endl define DEBUG_LINE # #define DEBUG_LINE( ) std :: cout << \" \\x1b [32m\" << __FILE__ << \":\" << __LINE__ << \" \\x1b [0m\" << std :: endl Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__EGO_ENTITY_HPP_ #define SIMULATION_API__ENTITY__EGO_ENTITY_HPP_ #include <simulation_api/entity/vehicle_entity.hpp> #include <simulation_api/vehicle_model/sim_model_ideal.hpp> #include <simulation_api/vehicle_model/sim_model_time_delay.hpp> #undef TRAFFIC_SIMULATOR_ISOLATE_STANDARD_OUTPUT_FROM_AUTOWARE #ifdef TRAFFIC_SIMULATOR_ISOLATE_STANDARD_OUTPUT_FROM_AUTOWARE #include <fcntl.h> #include <sys/stat.h> #include <sys/types.h> #include <unistd.h> #endif #include <autoware_auto_msgs/msg/complex32.hpp> #include <autoware_auto_msgs/msg/vehicle_control_command.hpp> #include <autoware_auto_msgs/msg/vehicle_kinematic_state.hpp> #include <autoware_auto_msgs/msg/vehicle_state_command.hpp> #include <awapi_accessor/accessor.hpp> #include <boost/filesystem.hpp> #include <boost/optional.hpp> #include <pugixml.hpp> #include <sys/wait.h> // for EgoEntity::~EgoEntity #include <tf2/utils.h> #include <algorithm> #include <chrono> #include <cstdlib> #include <future> #include <memory> #include <stdexcept> #include <string> #include <system_error> #include <thread> #include <unordered_map> #include <utility> #include <vector> #define DEBUG_VALUE(...) \\ std::cout << \"\\x1b[32m\" #__VA_ARGS__ \" = \" << (__VA_ARGS__) << \"\\x1b[0m\" << std::endl #define DEBUG_LINE() \\ std::cout << \"\\x1b[32m\" << __FILE__ << \":\" << __LINE__ << \"\\x1b[0m\" << std::endl namespace simulation_api { namespace entity { class EgoEntity : public VehicleEntity { // NOTE: One day we will have to do simultaneous simulations of multiple Autowares. static std :: unordered_map < std :: string , std :: shared_ptr < autoware_api :: Accessor > // TODO(yamacir-kit): virtualize accessor. > autowares ; decltype ( fork ()) autoware_process_id = 0 ; // XXX DIRTY HACK: The EntityManager terribly requires Ego to be Copyable. std :: shared_ptr < std :: promise < void >> accessor_status ; // XXX DIRTY HACK: The EntityManager terribly requires Ego to be Copyable. std :: shared_ptr < std :: thread > accessor_spinner ; /* ---- NOTE ----------------------------------------------------------------- * * If you can't explain the difference between char * and char [], don't * edit this function even if it looks strange. * * ------------------------------------------------------------------------ */ auto execute ( const std :: vector < std :: string > & f_xs ) { std :: vector < std :: vector < char >> buffer {}; buffer . resize ( f_xs . size ()); std :: vector < std :: add_pointer < char >:: type > argv {}; argv . reserve ( f_xs . size ()); for ( const auto & each : f_xs ) { buffer . emplace_back ( std :: begin ( each ), std :: end ( each )); buffer . back (). push_back ( '\\0' ); argv . push_back ( buffer . back (). data ()); } argv . emplace_back ( static_cast < std :: add_pointer < char >:: type > ( 0 )); return :: execvp ( argv [ 0 ], argv . data ()); } public : EgoEntity () = delete ; // TODO(yamacir-kit): EgoEntity(EgoEntity &&) = delete; // TODO(yamacir-kit): EgoEntity(const EgoEntity &) = delete; // TODO(yamacir-kit): EgoEntity & operator=(EgoEntity &&) = delete; // TODO(yamacir-kit): EgoEntity & operator=(const EgoEntity &) = delete; /* ---- NOTE ----------------------------------------------------------------- * * This constructor makes an Ego type entity with the proper initial state. * It is mainly used when writing scenarios in C++. * * ------------------------------------------------------------------------ */ // template<typename ... Ts> // explicit EgoEntity( // const std::string & name, // const openscenario_msgs::msg::EntityStatus & initial_state, Ts && ... xs) // : VehicleEntity(name, initial_state, std::forward<decltype(xs)>(xs)...), // vehicle_model_ptr_( // std::make_shared<SimModelIdealSteer>( // parameters.axles.front_axle.position_x - parameters.axles.rear_axle.position_x)) // { // setStatus(initial_state); // } /* ---- NOTE ----------------------------------------------------------------- * * This constructor builds an Ego-type entity with an ambiguous initial * state. In this case, the values for status_ and current_kinematic_state_ * are boost::none, respectively. * * This constructor is used for the purpose of delaying the transmission of * the initial position from the entity's spawn. If you build an ego-type * entity with this constructor, you must explicitly call setStatus at least * once before the first onUpdate call to establish location and kinematic * state. * * For OpenSCENARIO, setStatus before the onUpdate call is called by * TeleportAction in the Storyboard.Init section. * * ------------------------------------------------------------------------ */ explicit EgoEntity ( const std :: string & name , const boost :: filesystem :: path & lanelet2_map_osm , const double step_time , const openscenario_msgs :: msg :: VehicleParameters & parameters ) : VehicleEntity ( name , parameters ), vehicle_model_ptr_ ( std :: make_shared < SimModelTimeDelaySteer > ( parameters . performance . max_speed , // vel_lim, parameters . axles . front_axle . max_steering , // steer_lim, parameters . performance . max_acceleration , // accel_rate, 5.0 , // steer_rate_lim, parameters . axles . front_axle . position_x - parameters . axles . rear_axle . position_x , step_time , // dt, 0.25 , // vel_time_delay, 0.5 , // vel_time_constant, 0.3 , // steer_time_delay, 0.3 , // steer_time_constant, 0.0 // deadzone_delta_steer )) { auto launch_autoware = [ & ]() { auto get_parameter = []( const std :: string & name , const auto & alternate ) { rclcpp :: Node node { \"get_parameter\" , \"simulation\" }; auto value = alternate ; using value_type = typename std :: decay < decltype ( value ) >:: type ; node . declare_parameter < value_type > ( name , value ); node . get_parameter < value_type > ( name , value ); return value ; }; /* ---- NOTE ----------------------------------------------------------- * * The actual values of these parameters are set by * scenario_test_runner.launch.py as parameters of * openscenario_interpreter_node. * * ------------------------------------------------------------------ */ const auto autoware_launch_package = get_parameter ( \"autoware_launch_package\" , std :: string ( \"\" )); const auto autoware_launch_file = get_parameter ( \"autoware_launch_file\" , std :: string ( \"\" )); auto child = [ & ]() { // DEBUG_VALUE(lanelet2_map_osm); const std :: vector < std :: string > argv { \"python3\" , \"/opt/ros/foxy/bin/ros2\" , // NOTE: The command 'ros2' is a Python script. \"launch\" , autoware_launch_package , autoware_launch_file , std :: string ( \"map_path:=\" ) += lanelet2_map_osm . parent_path (). string (), std :: string ( \"lanelet2_map_file:=\" ) += lanelet2_map_osm . filename (). string () }; // for (const auto & each : argv) { // std::cout << each << (&each != &argv.back() ? ' ' : '\\n'); // } #ifdef TRAFFIC_SIMULATOR_ISOLATE_STANDARD_OUTPUT_FROM_AUTOWARE const std :: string name = \"/tmp/scenario_test_runner/autoware-output.txt\" ; const auto fd = :: open ( name . c_str (), O_RDWR | O_CREAT , S_IRUSR | S_IWUSR ); :: dup2 ( fd , STDOUT_FILENO ); :: dup2 ( fd , STDERR_FILENO ); :: close ( fd ); #endif if ( execute ( argv ) < 0 ) { std :: cout << std :: system_error ( errno , std :: system_category ()). what () << std :: endl ; std :: exit ( EXIT_FAILURE ); } }; if (( autoware_process_id = fork ()) < 0 ) { throw std :: system_error ( errno , std :: system_category ()); } else if ( autoware_process_id == 0 ) { return child (); } }; if ( autowares . find ( name ) == std :: end ( autowares )) { auto my_name = name ; std :: replace ( std :: begin ( my_name ), std :: end ( my_name ), ' ' , '_' ); autowares . emplace ( name , std :: make_shared < autoware_api :: Accessor > ( \"awapi_accessor\" , \"simulation/\" + my_name , // NOTE: Specified in scenario_test_runner.launch.py rclcpp :: NodeOptions (). use_global_arguments ( false ))); launch_autoware (); } /* ---- NOTE --------------------------------------------------------------- * * The simulator needs to run in a fixed-cycle loop, but the communication * part with Autoware needs to run at a higher frequency (e.g. the * transform in map -> base_link needs to be updated at a higher frequency * even if the value does not change). We also need to keep collecting the * latest values of topics from Autoware, independently of the simulator. * * For this reason, autoware_api::Accessor, which is responsible for * communication with Autoware, should run in an independent thread. This * is probably an EXTREMELY DIRTY HACK. * * Ideally, the constructor caller of traffic_simulator::API should * provide a std::shared_ptr to autoware_api::Accessor and spin that node * with MultiThreadedExecutor. * * If you have a nice idea to solve this, and are interested in improving * the quality of the Tier IV simulator, please contact @yamacir-kit. * * ---------------------------------------------------------------------- */ if ( autowares . at ( name ). use_count () < 2 ) { accessor_status = std :: make_shared < std :: promise < void >> (); accessor_spinner = std :: make_shared < std :: thread > ( []( const auto node , auto status ) // NOTE: This copy increments use_count to 2 from 1. { while ( rclcpp :: ok () && status . wait_for ( std :: chrono :: milliseconds ( 1 )) == std :: future_status :: timeout ) { rclcpp :: spin_some ( node ); } }, autowares . at ( name ), std :: move ( accessor_status -> get_future ())); } } ~ EgoEntity () override { if ( accessor_spinner && accessor_spinner . use_count () < 2 && accessor_spinner -> joinable ()) { accessor_status -> set_value (); accessor_spinner -> join (); autowares . erase ( name ); int status = 0 ; if ( :: kill ( autoware_process_id , SIGINT ) < 0 || :: waitpid ( autoware_process_id , & status , WUNTRACED ) < 0 ) { std :: cout << std :: system_error ( errno , std :: system_category ()). what () << std :: endl ; std :: exit ( EXIT_FAILURE ); } } } bool autoware_initialized = false ; auto initializeAutoware () { const auto current_entity_status = getStatus (); if ( ! std :: exchange ( autoware_initialized , true )) { waitForAutowareStateToBeInitializingVehicle ( [ & ]() { return updateAutoware ( current_entity_status . pose ); }); /* ---- NOTE --------------------------------------------------------------- * * awapi_awiv_adapter requires at least 'initialpose' and 'initialtwist' * and tf to be published. Member function EgoEntity::waitForAutowareToBe* * are depends a topic '/awapi/autoware/get/status' published by * awapi_awiv_adapter. * * ---------------------------------------------------------------------- */ waitForAutowareStateToBeWaitingForRoute ( [ & ]() { std :: atomic_load ( & autowares . at ( name )) -> setInitialPose ( current_entity_status . pose ); return updateAutoware ( current_entity_status . pose ); }); } } void requestAcquirePosition ( const geometry_msgs :: msg :: PoseStamped & goal_pose , const std :: vector < geometry_msgs :: msg :: PoseStamped > & constraints = {}) { if ( ! autoware_initialized ) { initializeAutoware (); } const auto current_pose = getStatus (). pose ; waitForAutowareStateToBeWaitingForRoute ( [ & ]() // NOTE: This is assertion. { return updateAutoware ( current_pose ); }); waitForAutowareStateToBePlanning ( [ & ]() { std :: atomic_load ( & autowares . at ( name )) -> setGoalPose ( goal_pose ); for ( const auto & constraint : constraints ) { std :: atomic_load ( & autowares . at ( name )) -> setCheckpoint ( constraint ); } return updateAutoware ( current_pose ); }); waitForAutowareStateToBeWaitingForEngage ( [ & ]() { return updateAutoware ( current_pose ); }); waitForAutowareStateToBeDriving ( [ & ]() { std :: atomic_load ( & autowares . at ( name )) -> setAutowareEngage ( true ); return updateAutoware ( current_pose ); }); } void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) override ; decltype ( auto ) setTargetSpeed ( const double value , const bool ) { const auto current = getStatus (); Eigen :: VectorXd v ( 5 ); { v << 0 , 0 , 0 , value , 0 ; } ( * vehicle_model_ptr_ ). setState ( v ); } const std :: string getCurrentAction () const { return std :: atomic_load ( & autowares . at ( name )) -> getAutowareStatus (). autoware_state ; } void onUpdate ( double current_time , double step_time ); bool setStatus ( const openscenario_msgs :: msg :: EntityStatus & status ); openscenario_msgs :: msg :: WaypointsArray getWaypoints () const ; private : // TODO(yamacir-kit): Define AutowareError type as struct based on std::runtime_error #define DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE(STATE) \\ template<typename Thunk> \\ void waitForAutowareStateToBe ## STATE(Thunk thunk, std::size_t count_max = 300) const \\ { \\ std::size_t count = 0; \\ for ( \\ rclcpp::WallRate rate {std::chrono::milliseconds(100)}; \\ !std::atomic_load(&autowares.at(name))->is ## STATE(); \\ rate.sleep()) \\ { \\ if (count++ < count_max) { \\ thunk(); \\ } else { \\ const auto current_state = \\ std::atomic_load(&autowares.at(name))->getAutowareStatus().autoware_state; \\ std::stringstream ss {}; \\ ss << \"The simulator waited \" \\ << (count / 10) \\ << \" seconds, expecting the Autoware state to transitioning to \" \\ << #STATE \\ << \", but there was no change. The current Autoware state is \" \\ << (current_state.empty() ? \"NOT PUBLISHED YET\" : current_state) \\ << \". This error is most likely due to the Autoware state transition \" \\ << \"conditions changing with the update. Please report this error to \" \\ << \"the developer. This error message was written by @yamacir-kit.\"; \\ using AutowareError = std::runtime_error; \\ throw AutowareError(ss.str()); \\ } \\ } \\ RCLCPP_INFO_STREAM( \\ std::atomic_load(&autowares.at(name))->get_logger(), \\ \"Autoware is \" #STATE \" now.\"); \\ } static_assert(true, \"\") DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( InitializingVehicle ); DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( WaitingForRoute ); DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( Planning ); DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( WaitingForEngage ); DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( Driving ); DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( ArrivedGoal ); DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( Emergency ); DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( Finalizing ); #undef DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE void updateAutoware ( const geometry_msgs :: msg :: Pose & current_pose ) { geometry_msgs :: msg :: Twist current_twist ; { current_twist . linear . x = ( * vehicle_model_ptr_ ). getVx (); current_twist . angular . z = ( * vehicle_model_ptr_ ). getWz (); } // DEBUG_VALUE(current_twist.linear.x); // DEBUG_VALUE(current_twist.angular.z); // // DEBUG_VALUE(current_pose.position.x); // DEBUG_VALUE(current_pose.position.y); // DEBUG_VALUE(current_pose.position.z); std :: atomic_load ( & autowares . at ( name )) -> setCurrentControlMode (); std :: atomic_load ( & autowares . at ( name )) -> setCurrentPose ( current_pose ); std :: atomic_load ( & autowares . at ( name )) -> setCurrentShift ( current_twist ); std :: atomic_load ( & autowares . at ( name )) -> setCurrentSteering ( current_twist ); std :: atomic_load ( & autowares . at ( name )) -> setCurrentTurnSignal (); std :: atomic_load ( & autowares . at ( name )) -> setCurrentTwist ( current_twist ); std :: atomic_load ( & autowares . at ( name )) -> setCurrentVelocity ( current_twist ); std :: atomic_load ( & autowares . at ( name )) -> setLaneChangeApproval (); std :: atomic_load ( & autowares . at ( name )) -> setTransform ( current_pose ); std :: atomic_load ( & autowares . at ( name )) -> setVehicleVelocity ( parameters . performance . max_speed ); } private : const openscenario_msgs :: msg :: EntityStatus getEntityStatus ( const double time , const double step_time ) const ; boost :: optional < geometry_msgs :: msg :: Pose > initial_pose_ ; const std :: shared_ptr < SimModelInterface > vehicle_model_ptr_ ; boost :: optional < double > previous_linear_velocity_ ; boost :: optional < double > previous_angular_velocity_ ; }; } // namespace entity } // namespace simulation_api #endif // SIMULATION_API__ENTITY__EGO_ENTITY_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/ego_entity.hpp"},{"location":"package/simulation_api/markdown/Files/ego__entity_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apientityego_entityhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/ego_entity.hpp"},{"location":"package/simulation_api/markdown/Files/ego__entity_8hpp/#namespaces","text":"Name simulation_api::entity simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/ego__entity_8hpp/#classes","text":"Name class simulation_api::entity::EgoEntity","title":"Classes"},{"location":"package/simulation_api/markdown/Files/ego__entity_8hpp/#defines","text":"Name DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE (STATE) DEBUG_VALUE (...) DEBUG_LINE ()","title":"Defines"},{"location":"package/simulation_api/markdown/Files/ego__entity_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/simulation_api/markdown/Files/ego__entity_8hpp/#define-define_wait_for_autoware_state_to_be","text":"#define DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE( STATE )","title":"define DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE"},{"location":"package/simulation_api/markdown/Files/ego__entity_8hpp/#define-debug_value","text":"#define DEBUG_VALUE( ... ) std :: cout << \" \\x1b [32m\" # __VA_ARGS__ \" = \" << ( __VA_ARGS__ ) << \" \\x1b [0m\" << std :: endl","title":"define DEBUG_VALUE"},{"location":"package/simulation_api/markdown/Files/ego__entity_8hpp/#define-debug_line","text":"#define DEBUG_LINE( ) std :: cout << \" \\x1b [32m\" << __FILE__ << \":\" << __LINE__ << \" \\x1b [0m\" << std :: endl","title":"define DEBUG_LINE"},{"location":"package/simulation_api/markdown/Files/ego__entity_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__EGO_ENTITY_HPP_ #define SIMULATION_API__ENTITY__EGO_ENTITY_HPP_ #include <simulation_api/entity/vehicle_entity.hpp> #include <simulation_api/vehicle_model/sim_model_ideal.hpp> #include <simulation_api/vehicle_model/sim_model_time_delay.hpp> #undef TRAFFIC_SIMULATOR_ISOLATE_STANDARD_OUTPUT_FROM_AUTOWARE #ifdef TRAFFIC_SIMULATOR_ISOLATE_STANDARD_OUTPUT_FROM_AUTOWARE #include <fcntl.h> #include <sys/stat.h> #include <sys/types.h> #include <unistd.h> #endif #include <autoware_auto_msgs/msg/complex32.hpp> #include <autoware_auto_msgs/msg/vehicle_control_command.hpp> #include <autoware_auto_msgs/msg/vehicle_kinematic_state.hpp> #include <autoware_auto_msgs/msg/vehicle_state_command.hpp> #include <awapi_accessor/accessor.hpp> #include <boost/filesystem.hpp> #include <boost/optional.hpp> #include <pugixml.hpp> #include <sys/wait.h> // for EgoEntity::~EgoEntity #include <tf2/utils.h> #include <algorithm> #include <chrono> #include <cstdlib> #include <future> #include <memory> #include <stdexcept> #include <string> #include <system_error> #include <thread> #include <unordered_map> #include <utility> #include <vector> #define DEBUG_VALUE(...) \\ std::cout << \"\\x1b[32m\" #__VA_ARGS__ \" = \" << (__VA_ARGS__) << \"\\x1b[0m\" << std::endl #define DEBUG_LINE() \\ std::cout << \"\\x1b[32m\" << __FILE__ << \":\" << __LINE__ << \"\\x1b[0m\" << std::endl namespace simulation_api { namespace entity { class EgoEntity : public VehicleEntity { // NOTE: One day we will have to do simultaneous simulations of multiple Autowares. static std :: unordered_map < std :: string , std :: shared_ptr < autoware_api :: Accessor > // TODO(yamacir-kit): virtualize accessor. > autowares ; decltype ( fork ()) autoware_process_id = 0 ; // XXX DIRTY HACK: The EntityManager terribly requires Ego to be Copyable. std :: shared_ptr < std :: promise < void >> accessor_status ; // XXX DIRTY HACK: The EntityManager terribly requires Ego to be Copyable. std :: shared_ptr < std :: thread > accessor_spinner ; /* ---- NOTE ----------------------------------------------------------------- * * If you can't explain the difference between char * and char [], don't * edit this function even if it looks strange. * * ------------------------------------------------------------------------ */ auto execute ( const std :: vector < std :: string > & f_xs ) { std :: vector < std :: vector < char >> buffer {}; buffer . resize ( f_xs . size ()); std :: vector < std :: add_pointer < char >:: type > argv {}; argv . reserve ( f_xs . size ()); for ( const auto & each : f_xs ) { buffer . emplace_back ( std :: begin ( each ), std :: end ( each )); buffer . back (). push_back ( '\\0' ); argv . push_back ( buffer . back (). data ()); } argv . emplace_back ( static_cast < std :: add_pointer < char >:: type > ( 0 )); return :: execvp ( argv [ 0 ], argv . data ()); } public : EgoEntity () = delete ; // TODO(yamacir-kit): EgoEntity(EgoEntity &&) = delete; // TODO(yamacir-kit): EgoEntity(const EgoEntity &) = delete; // TODO(yamacir-kit): EgoEntity & operator=(EgoEntity &&) = delete; // TODO(yamacir-kit): EgoEntity & operator=(const EgoEntity &) = delete; /* ---- NOTE ----------------------------------------------------------------- * * This constructor makes an Ego type entity with the proper initial state. * It is mainly used when writing scenarios in C++. * * ------------------------------------------------------------------------ */ // template<typename ... Ts> // explicit EgoEntity( // const std::string & name, // const openscenario_msgs::msg::EntityStatus & initial_state, Ts && ... xs) // : VehicleEntity(name, initial_state, std::forward<decltype(xs)>(xs)...), // vehicle_model_ptr_( // std::make_shared<SimModelIdealSteer>( // parameters.axles.front_axle.position_x - parameters.axles.rear_axle.position_x)) // { // setStatus(initial_state); // } /* ---- NOTE ----------------------------------------------------------------- * * This constructor builds an Ego-type entity with an ambiguous initial * state. In this case, the values for status_ and current_kinematic_state_ * are boost::none, respectively. * * This constructor is used for the purpose of delaying the transmission of * the initial position from the entity's spawn. If you build an ego-type * entity with this constructor, you must explicitly call setStatus at least * once before the first onUpdate call to establish location and kinematic * state. * * For OpenSCENARIO, setStatus before the onUpdate call is called by * TeleportAction in the Storyboard.Init section. * * ------------------------------------------------------------------------ */ explicit EgoEntity ( const std :: string & name , const boost :: filesystem :: path & lanelet2_map_osm , const double step_time , const openscenario_msgs :: msg :: VehicleParameters & parameters ) : VehicleEntity ( name , parameters ), vehicle_model_ptr_ ( std :: make_shared < SimModelTimeDelaySteer > ( parameters . performance . max_speed , // vel_lim, parameters . axles . front_axle . max_steering , // steer_lim, parameters . performance . max_acceleration , // accel_rate, 5.0 , // steer_rate_lim, parameters . axles . front_axle . position_x - parameters . axles . rear_axle . position_x , step_time , // dt, 0.25 , // vel_time_delay, 0.5 , // vel_time_constant, 0.3 , // steer_time_delay, 0.3 , // steer_time_constant, 0.0 // deadzone_delta_steer )) { auto launch_autoware = [ & ]() { auto get_parameter = []( const std :: string & name , const auto & alternate ) { rclcpp :: Node node { \"get_parameter\" , \"simulation\" }; auto value = alternate ; using value_type = typename std :: decay < decltype ( value ) >:: type ; node . declare_parameter < value_type > ( name , value ); node . get_parameter < value_type > ( name , value ); return value ; }; /* ---- NOTE ----------------------------------------------------------- * * The actual values of these parameters are set by * scenario_test_runner.launch.py as parameters of * openscenario_interpreter_node. * * ------------------------------------------------------------------ */ const auto autoware_launch_package = get_parameter ( \"autoware_launch_package\" , std :: string ( \"\" )); const auto autoware_launch_file = get_parameter ( \"autoware_launch_file\" , std :: string ( \"\" )); auto child = [ & ]() { // DEBUG_VALUE(lanelet2_map_osm); const std :: vector < std :: string > argv { \"python3\" , \"/opt/ros/foxy/bin/ros2\" , // NOTE: The command 'ros2' is a Python script. \"launch\" , autoware_launch_package , autoware_launch_file , std :: string ( \"map_path:=\" ) += lanelet2_map_osm . parent_path (). string (), std :: string ( \"lanelet2_map_file:=\" ) += lanelet2_map_osm . filename (). string () }; // for (const auto & each : argv) { // std::cout << each << (&each != &argv.back() ? ' ' : '\\n'); // } #ifdef TRAFFIC_SIMULATOR_ISOLATE_STANDARD_OUTPUT_FROM_AUTOWARE const std :: string name = \"/tmp/scenario_test_runner/autoware-output.txt\" ; const auto fd = :: open ( name . c_str (), O_RDWR | O_CREAT , S_IRUSR | S_IWUSR ); :: dup2 ( fd , STDOUT_FILENO ); :: dup2 ( fd , STDERR_FILENO ); :: close ( fd ); #endif if ( execute ( argv ) < 0 ) { std :: cout << std :: system_error ( errno , std :: system_category ()). what () << std :: endl ; std :: exit ( EXIT_FAILURE ); } }; if (( autoware_process_id = fork ()) < 0 ) { throw std :: system_error ( errno , std :: system_category ()); } else if ( autoware_process_id == 0 ) { return child (); } }; if ( autowares . find ( name ) == std :: end ( autowares )) { auto my_name = name ; std :: replace ( std :: begin ( my_name ), std :: end ( my_name ), ' ' , '_' ); autowares . emplace ( name , std :: make_shared < autoware_api :: Accessor > ( \"awapi_accessor\" , \"simulation/\" + my_name , // NOTE: Specified in scenario_test_runner.launch.py rclcpp :: NodeOptions (). use_global_arguments ( false ))); launch_autoware (); } /* ---- NOTE --------------------------------------------------------------- * * The simulator needs to run in a fixed-cycle loop, but the communication * part with Autoware needs to run at a higher frequency (e.g. the * transform in map -> base_link needs to be updated at a higher frequency * even if the value does not change). We also need to keep collecting the * latest values of topics from Autoware, independently of the simulator. * * For this reason, autoware_api::Accessor, which is responsible for * communication with Autoware, should run in an independent thread. This * is probably an EXTREMELY DIRTY HACK. * * Ideally, the constructor caller of traffic_simulator::API should * provide a std::shared_ptr to autoware_api::Accessor and spin that node * with MultiThreadedExecutor. * * If you have a nice idea to solve this, and are interested in improving * the quality of the Tier IV simulator, please contact @yamacir-kit. * * ---------------------------------------------------------------------- */ if ( autowares . at ( name ). use_count () < 2 ) { accessor_status = std :: make_shared < std :: promise < void >> (); accessor_spinner = std :: make_shared < std :: thread > ( []( const auto node , auto status ) // NOTE: This copy increments use_count to 2 from 1. { while ( rclcpp :: ok () && status . wait_for ( std :: chrono :: milliseconds ( 1 )) == std :: future_status :: timeout ) { rclcpp :: spin_some ( node ); } }, autowares . at ( name ), std :: move ( accessor_status -> get_future ())); } } ~ EgoEntity () override { if ( accessor_spinner && accessor_spinner . use_count () < 2 && accessor_spinner -> joinable ()) { accessor_status -> set_value (); accessor_spinner -> join (); autowares . erase ( name ); int status = 0 ; if ( :: kill ( autoware_process_id , SIGINT ) < 0 || :: waitpid ( autoware_process_id , & status , WUNTRACED ) < 0 ) { std :: cout << std :: system_error ( errno , std :: system_category ()). what () << std :: endl ; std :: exit ( EXIT_FAILURE ); } } } bool autoware_initialized = false ; auto initializeAutoware () { const auto current_entity_status = getStatus (); if ( ! std :: exchange ( autoware_initialized , true )) { waitForAutowareStateToBeInitializingVehicle ( [ & ]() { return updateAutoware ( current_entity_status . pose ); }); /* ---- NOTE --------------------------------------------------------------- * * awapi_awiv_adapter requires at least 'initialpose' and 'initialtwist' * and tf to be published. Member function EgoEntity::waitForAutowareToBe* * are depends a topic '/awapi/autoware/get/status' published by * awapi_awiv_adapter. * * ---------------------------------------------------------------------- */ waitForAutowareStateToBeWaitingForRoute ( [ & ]() { std :: atomic_load ( & autowares . at ( name )) -> setInitialPose ( current_entity_status . pose ); return updateAutoware ( current_entity_status . pose ); }); } } void requestAcquirePosition ( const geometry_msgs :: msg :: PoseStamped & goal_pose , const std :: vector < geometry_msgs :: msg :: PoseStamped > & constraints = {}) { if ( ! autoware_initialized ) { initializeAutoware (); } const auto current_pose = getStatus (). pose ; waitForAutowareStateToBeWaitingForRoute ( [ & ]() // NOTE: This is assertion. { return updateAutoware ( current_pose ); }); waitForAutowareStateToBePlanning ( [ & ]() { std :: atomic_load ( & autowares . at ( name )) -> setGoalPose ( goal_pose ); for ( const auto & constraint : constraints ) { std :: atomic_load ( & autowares . at ( name )) -> setCheckpoint ( constraint ); } return updateAutoware ( current_pose ); }); waitForAutowareStateToBeWaitingForEngage ( [ & ]() { return updateAutoware ( current_pose ); }); waitForAutowareStateToBeDriving ( [ & ]() { std :: atomic_load ( & autowares . at ( name )) -> setAutowareEngage ( true ); return updateAutoware ( current_pose ); }); } void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) override ; decltype ( auto ) setTargetSpeed ( const double value , const bool ) { const auto current = getStatus (); Eigen :: VectorXd v ( 5 ); { v << 0 , 0 , 0 , value , 0 ; } ( * vehicle_model_ptr_ ). setState ( v ); } const std :: string getCurrentAction () const { return std :: atomic_load ( & autowares . at ( name )) -> getAutowareStatus (). autoware_state ; } void onUpdate ( double current_time , double step_time ); bool setStatus ( const openscenario_msgs :: msg :: EntityStatus & status ); openscenario_msgs :: msg :: WaypointsArray getWaypoints () const ; private : // TODO(yamacir-kit): Define AutowareError type as struct based on std::runtime_error #define DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE(STATE) \\ template<typename Thunk> \\ void waitForAutowareStateToBe ## STATE(Thunk thunk, std::size_t count_max = 300) const \\ { \\ std::size_t count = 0; \\ for ( \\ rclcpp::WallRate rate {std::chrono::milliseconds(100)}; \\ !std::atomic_load(&autowares.at(name))->is ## STATE(); \\ rate.sleep()) \\ { \\ if (count++ < count_max) { \\ thunk(); \\ } else { \\ const auto current_state = \\ std::atomic_load(&autowares.at(name))->getAutowareStatus().autoware_state; \\ std::stringstream ss {}; \\ ss << \"The simulator waited \" \\ << (count / 10) \\ << \" seconds, expecting the Autoware state to transitioning to \" \\ << #STATE \\ << \", but there was no change. The current Autoware state is \" \\ << (current_state.empty() ? \"NOT PUBLISHED YET\" : current_state) \\ << \". This error is most likely due to the Autoware state transition \" \\ << \"conditions changing with the update. Please report this error to \" \\ << \"the developer. This error message was written by @yamacir-kit.\"; \\ using AutowareError = std::runtime_error; \\ throw AutowareError(ss.str()); \\ } \\ } \\ RCLCPP_INFO_STREAM( \\ std::atomic_load(&autowares.at(name))->get_logger(), \\ \"Autoware is \" #STATE \" now.\"); \\ } static_assert(true, \"\") DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( InitializingVehicle ); DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( WaitingForRoute ); DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( Planning ); DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( WaitingForEngage ); DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( Driving ); DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( ArrivedGoal ); DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( Emergency ); DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE ( Finalizing ); #undef DEFINE_WAIT_FOR_AUTOWARE_STATE_TO_BE void updateAutoware ( const geometry_msgs :: msg :: Pose & current_pose ) { geometry_msgs :: msg :: Twist current_twist ; { current_twist . linear . x = ( * vehicle_model_ptr_ ). getVx (); current_twist . angular . z = ( * vehicle_model_ptr_ ). getWz (); } // DEBUG_VALUE(current_twist.linear.x); // DEBUG_VALUE(current_twist.angular.z); // // DEBUG_VALUE(current_pose.position.x); // DEBUG_VALUE(current_pose.position.y); // DEBUG_VALUE(current_pose.position.z); std :: atomic_load ( & autowares . at ( name )) -> setCurrentControlMode (); std :: atomic_load ( & autowares . at ( name )) -> setCurrentPose ( current_pose ); std :: atomic_load ( & autowares . at ( name )) -> setCurrentShift ( current_twist ); std :: atomic_load ( & autowares . at ( name )) -> setCurrentSteering ( current_twist ); std :: atomic_load ( & autowares . at ( name )) -> setCurrentTurnSignal (); std :: atomic_load ( & autowares . at ( name )) -> setCurrentTwist ( current_twist ); std :: atomic_load ( & autowares . at ( name )) -> setCurrentVelocity ( current_twist ); std :: atomic_load ( & autowares . at ( name )) -> setLaneChangeApproval (); std :: atomic_load ( & autowares . at ( name )) -> setTransform ( current_pose ); std :: atomic_load ( & autowares . at ( name )) -> setVehicleVelocity ( parameters . performance . max_speed ); } private : const openscenario_msgs :: msg :: EntityStatus getEntityStatus ( const double time , const double step_time ) const ; boost :: optional < geometry_msgs :: msg :: Pose > initial_pose_ ; const std :: shared_ptr < SimModelInterface > vehicle_model_ptr_ ; boost :: optional < double > previous_linear_velocity_ ; boost :: optional < double > previous_angular_velocity_ ; }; } // namespace entity } // namespace simulation_api #endif // SIMULATION_API__ENTITY__EGO_ENTITY_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/entity__base_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/entity_base.cpp # Namespaces # Name simulation_api::entity simulation_api Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/entity/exception.hpp> #include <rclcpp/rclcpp.hpp> #include <unordered_map> #include <limits> #include <string> #include <queue> #include <vector> namespace simulation_api { namespace entity { EntityBase :: EntityBase ( std :: string type , std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state ) : type ( type ), name ( name ) { status_ = initial_state ; visibility_ = true ; verbose_ = true ; } EntityBase :: EntityBase ( std :: string type , std :: string name ) : type ( type ), name ( name ) { status_ = boost :: none ; visibility_ = true ; verbose_ = true ; } boost :: optional < double > EntityBase :: getStandStillDuration () const { return stand_still_duration_ ; } void EntityBase :: updateStandStillDuration ( double step_time ) { if ( ! status_ ) { stand_still_duration_ = boost :: none ; } else { if ( ! stand_still_duration_ ) { stand_still_duration_ = 0 ; } if ( std :: fabs ( status_ -> action_status . twist . linear . x ) <= std :: numeric_limits < double >:: epsilon ()) { stand_still_duration_ = step_time + stand_still_duration_ . get (); } else { stand_still_duration_ = 0 ; } } } void EntityBase :: setOtherStatus ( const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > & status ) { std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > other_status ; for ( const auto & each : status ) { if ( each . first != name ) { other_status . insert ( each ); } } other_status_ = other_status ; } const openscenario_msgs :: msg :: EntityStatus EntityBase :: getStatus () const { if ( ! status_ ) { throw SimulationRuntimeError ( \"status is not set\" ); } return this -> status_ . get (); } bool EntityBase :: setStatus ( const openscenario_msgs :: msg :: EntityStatus & status ) { this -> status_ = status ; this -> status_ -> name = name ; return true ; } bool EntityBase :: setVisibility ( bool visibility ) { visibility_ = visibility ; return visibility_ ; } bool EntityBase :: getVisibility () { return visibility_ ; } void EntityBase :: stopAtEndOfRoad () { if ( ! status_ ) { throw SimulationRuntimeError ( \"status is not set\" ); } status_ . get (). action_status . twist = geometry_msgs :: msg :: Twist (); status_ . get (). action_status . accel = geometry_msgs :: msg :: Accel (); } } // namespace entity } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/entity_base.cpp"},{"location":"package/simulation_api/markdown/Files/entity__base_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcentityentity_basecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/entity_base.cpp"},{"location":"package/simulation_api/markdown/Files/entity__base_8cpp/#namespaces","text":"Name simulation_api::entity simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/entity__base_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/entity/exception.hpp> #include <rclcpp/rclcpp.hpp> #include <unordered_map> #include <limits> #include <string> #include <queue> #include <vector> namespace simulation_api { namespace entity { EntityBase :: EntityBase ( std :: string type , std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state ) : type ( type ), name ( name ) { status_ = initial_state ; visibility_ = true ; verbose_ = true ; } EntityBase :: EntityBase ( std :: string type , std :: string name ) : type ( type ), name ( name ) { status_ = boost :: none ; visibility_ = true ; verbose_ = true ; } boost :: optional < double > EntityBase :: getStandStillDuration () const { return stand_still_duration_ ; } void EntityBase :: updateStandStillDuration ( double step_time ) { if ( ! status_ ) { stand_still_duration_ = boost :: none ; } else { if ( ! stand_still_duration_ ) { stand_still_duration_ = 0 ; } if ( std :: fabs ( status_ -> action_status . twist . linear . x ) <= std :: numeric_limits < double >:: epsilon ()) { stand_still_duration_ = step_time + stand_still_duration_ . get (); } else { stand_still_duration_ = 0 ; } } } void EntityBase :: setOtherStatus ( const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > & status ) { std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > other_status ; for ( const auto & each : status ) { if ( each . first != name ) { other_status . insert ( each ); } } other_status_ = other_status ; } const openscenario_msgs :: msg :: EntityStatus EntityBase :: getStatus () const { if ( ! status_ ) { throw SimulationRuntimeError ( \"status is not set\" ); } return this -> status_ . get (); } bool EntityBase :: setStatus ( const openscenario_msgs :: msg :: EntityStatus & status ) { this -> status_ = status ; this -> status_ -> name = name ; return true ; } bool EntityBase :: setVisibility ( bool visibility ) { visibility_ = visibility ; return visibility_ ; } bool EntityBase :: getVisibility () { return visibility_ ; } void EntityBase :: stopAtEndOfRoad () { if ( ! status_ ) { throw SimulationRuntimeError ( \"status is not set\" ); } status_ . get (). action_status . twist = geometry_msgs :: msg :: Twist (); status_ . get (). action_status . accel = geometry_msgs :: msg :: Accel (); } } // namespace entity } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/entity__base_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/entity_base.hpp # Namespaces # Name simulation_api::entity simulation_api Classes # Name class simulation_api::entity::EntityBase Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__ENTITY_BASE_HPP_ #define SIMULATION_API__ENTITY__ENTITY_BASE_HPP_ #include <simulation_api/traffic_lights/traffic_light_manager.hpp> #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <openscenario_msgs/msg/bounding_box.hpp> #include <openscenario_msgs/msg/entity_status.hpp> #include <visualization_msgs/msg/marker_array.hpp> #include <boost/optional.hpp> // headers in STL #include <string> #include <memory> #include <unordered_map> #include <vector> #include <queue> namespace simulation_api { namespace entity { enum class Direction { STRAIGHT = 0 , LEFT = 1 , RIGHT = 2 }; class EntityBase { public : EntityBase ( std :: string type , std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state ); EntityBase ( std :: string type , std :: string name ); virtual ~ EntityBase () = default ; const std :: string type ; const std :: string name ; const openscenario_msgs :: msg :: EntityStatus getStatus () const ; bool setStatus ( const openscenario_msgs :: msg :: EntityStatus & status ); bool setVisibility ( bool visibility ); bool getVisibility (); void setHdMapUtils ( std :: shared_ptr < hdmap_utils :: HdMapUtils > ptr ) { hdmap_utils_ptr_ = ptr ; } void setTrafficLightManager ( std :: shared_ptr < simulation_api :: TrafficLightManager > ptr ) { traffic_light_manager_ = ptr ; } virtual void onUpdate ( double current_time , double step_time ) = 0 ; bool statusSetted () const { if ( status_ ) { return true ; } return false ; } void setVerbose ( bool verbose ) { verbose_ = verbose ; } void setEntityTypeList ( const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > & entity_type_list ) { entity_type_list_ = entity_type_list ; } void setOtherStatus ( const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > & status ); void updateStandStillDuration ( double step_time ); boost :: optional < double > getStandStillDuration () const ; virtual const openscenario_msgs :: msg :: BoundingBox getBoundingBox () const = 0 ; virtual const std :: string getCurrentAction () const = 0 ; void stopAtEndOfRoad (); boost :: optional < double > getLinearJerk () const { return linear_jerk_ ; } virtual void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) = 0 ; protected : bool visibility_ ; boost :: optional < openscenario_msgs :: msg :: LaneletPose > next_waypoint_ ; std :: queue < openscenario_msgs :: msg :: LaneletPose > waypoints_ ; boost :: optional < openscenario_msgs :: msg :: EntityStatus > status_ ; boost :: optional < double > linear_jerk_ ; std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ptr_ ; std :: shared_ptr < simulation_api :: TrafficLightManager > traffic_light_manager_ ; bool verbose_ ; std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > other_status_ ; std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > entity_type_list_ ; boost :: optional < double > stand_still_duration_ ; visualization_msgs :: msg :: MarkerArray current_marker_ ; }; } // namespace entity } // namespace simulation_api #endif // SIMULATION_API__ENTITY__ENTITY_BASE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/entity_base.hpp"},{"location":"package/simulation_api/markdown/Files/entity__base_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apientityentity_basehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/entity_base.hpp"},{"location":"package/simulation_api/markdown/Files/entity__base_8hpp/#namespaces","text":"Name simulation_api::entity simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/entity__base_8hpp/#classes","text":"Name class simulation_api::entity::EntityBase","title":"Classes"},{"location":"package/simulation_api/markdown/Files/entity__base_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__ENTITY_BASE_HPP_ #define SIMULATION_API__ENTITY__ENTITY_BASE_HPP_ #include <simulation_api/traffic_lights/traffic_light_manager.hpp> #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <openscenario_msgs/msg/bounding_box.hpp> #include <openscenario_msgs/msg/entity_status.hpp> #include <visualization_msgs/msg/marker_array.hpp> #include <boost/optional.hpp> // headers in STL #include <string> #include <memory> #include <unordered_map> #include <vector> #include <queue> namespace simulation_api { namespace entity { enum class Direction { STRAIGHT = 0 , LEFT = 1 , RIGHT = 2 }; class EntityBase { public : EntityBase ( std :: string type , std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state ); EntityBase ( std :: string type , std :: string name ); virtual ~ EntityBase () = default ; const std :: string type ; const std :: string name ; const openscenario_msgs :: msg :: EntityStatus getStatus () const ; bool setStatus ( const openscenario_msgs :: msg :: EntityStatus & status ); bool setVisibility ( bool visibility ); bool getVisibility (); void setHdMapUtils ( std :: shared_ptr < hdmap_utils :: HdMapUtils > ptr ) { hdmap_utils_ptr_ = ptr ; } void setTrafficLightManager ( std :: shared_ptr < simulation_api :: TrafficLightManager > ptr ) { traffic_light_manager_ = ptr ; } virtual void onUpdate ( double current_time , double step_time ) = 0 ; bool statusSetted () const { if ( status_ ) { return true ; } return false ; } void setVerbose ( bool verbose ) { verbose_ = verbose ; } void setEntityTypeList ( const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > & entity_type_list ) { entity_type_list_ = entity_type_list ; } void setOtherStatus ( const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > & status ); void updateStandStillDuration ( double step_time ); boost :: optional < double > getStandStillDuration () const ; virtual const openscenario_msgs :: msg :: BoundingBox getBoundingBox () const = 0 ; virtual const std :: string getCurrentAction () const = 0 ; void stopAtEndOfRoad (); boost :: optional < double > getLinearJerk () const { return linear_jerk_ ; } virtual void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) = 0 ; protected : bool visibility_ ; boost :: optional < openscenario_msgs :: msg :: LaneletPose > next_waypoint_ ; std :: queue < openscenario_msgs :: msg :: LaneletPose > waypoints_ ; boost :: optional < openscenario_msgs :: msg :: EntityStatus > status_ ; boost :: optional < double > linear_jerk_ ; std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ptr_ ; std :: shared_ptr < simulation_api :: TrafficLightManager > traffic_light_manager_ ; bool verbose_ ; std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > other_status_ ; std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > entity_type_list_ ; boost :: optional < double > stand_still_duration_ ; visualization_msgs :: msg :: MarkerArray current_marker_ ; }; } // namespace entity } // namespace simulation_api #endif // SIMULATION_API__ENTITY__ENTITY_BASE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/entity__manager_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/entity_manager.cpp # Namespaces # Name simulation_api::entity simulation_api Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/entity/entity_manager.hpp> #include <simulation_api/helper/helper.hpp> #include <simulation_api/math/bounding_box.hpp> #include <simulation_api/math/collision.hpp> #include <limits> #include <sstream> #include <stdexcept> #include <string> #include <unordered_map> #include <vector> #include <queue> #include <memory> namespace simulation_api { namespace entity { bool EntityManager :: isStopping ( const std :: string & name ) const { const auto status = getEntityStatus ( name ); if ( ! status ) { throw simulation_api :: SimulationRuntimeError ( \"failed to get entity : \" + name + \" status\" ); } return std :: fabs ( status -> action_status . twist . linear . x ) < std :: numeric_limits < double >:: epsilon (); } void EntityManager :: setDriverModel ( const std :: string & name , const openscenario_msgs :: msg :: DriverModel & model ) { auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { throw simulation_api :: SimulationRuntimeError ( \"entity : \" + name + \" does not exist\" ); } if ( it -> second . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( it -> second ). setDriverModel ( model ); } if ( it -> second . type () == typeid ( EgoEntity )) { return ; } if ( it -> second . type () == typeid ( PedestrianEntity )) { throw simulation_api :: SimulationRuntimeError ( \"entity : \" + name + \" pedestrian\" ); } } const geometry_msgs :: msg :: Pose EntityManager :: toMapPose ( const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ) const { return hdmap_utils_ptr_ -> toMapPose ( lanelet_pose ). pose ; } const std :: shared_ptr < hdmap_utils :: HdMapUtils > EntityManager :: getHdmapUtils () { return hdmap_utils_ptr_ ; } void EntityManager :: setVerbose ( bool verbose ) { verbose_ = verbose ; for ( auto & each : entities_ ) { if ( each . second . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( each . second ). setVerbose ( verbose ); } if ( each . second . type () == typeid ( EgoEntity )) { boost :: any_cast < EgoEntity &> ( each . second ). setVerbose ( verbose ); } if ( each . second . type () == typeid ( PedestrianEntity )) { boost :: any_cast < PedestrianEntity &> ( each . second ). setVerbose ( verbose ); } } } bool EntityManager :: isEgo ( const std :: string & name ) const { return getEntityType ( name ). type == openscenario_msgs :: msg :: EntityType :: EGO ; } std :: size_t EntityManager :: getNumberOfEgo () const { return std :: count_if ( std :: begin ( entities_ ), std :: end ( entities_ ), []( const auto & each ) { return each . second . type () == typeid ( EgoEntity ); }); } boost :: optional < openscenario_msgs :: msg :: LaneletPose > EntityManager :: getLaneletPose ( const std :: string & name ) { const auto status = getEntityStatus ( name ); if ( ! status ) { return boost :: none ; } if ( status -> lanelet_pose_valid ) { return status -> lanelet_pose ; } return toLaneletPose ( status -> pose ); } boost :: optional < double > EntityManager :: getDistanceToCrosswalk ( const std :: string & name , const std :: int64_t target_crosswalk_id ) { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return boost :: none ; } if ( getWaypoints ( name ). waypoints . empty ()) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( getWaypoints ( name ). waypoints ); auto polygon = hdmap_utils_ptr_ -> getLaneletPolygon ( target_crosswalk_id ); return spline . getCollisionPointIn2D ( polygon ); } boost :: optional < double > EntityManager :: getSValueInRoute ( const std :: string & name , const std :: vector < std :: int64_t > & route ) { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return boost :: none ; } const auto lanelet_pose = getLaneletPose ( name ); if ( ! lanelet_pose ) { return boost :: none ; } double s = 0 ; for ( const auto id : route ) { if ( id == lanelet_pose -> lanelet_id ) { s = s + lanelet_pose -> s ; return s ; } else { s = s + hdmap_utils_ptr_ -> getLaneletLength ( id ); } } return boost :: none ; } boost :: optional < double > EntityManager :: getDistanceToStopLine ( const std :: string & name , const std :: int64_t target_stop_line_id ) { auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return boost :: none ; } if ( getWaypoints ( name ). waypoints . empty ()) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( getWaypoints ( name ). waypoints ); auto polygon = hdmap_utils_ptr_ -> getStopLinePolygon ( target_stop_line_id ); return spline . getCollisionPointIn2D ( polygon ); } void EntityManager :: requestAssignRoute ( const std :: string & name , const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) { auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return ; } if ( it -> second . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( it -> second ). requestAssignRoute ( waypoints ); } if ( it -> second . type () == typeid ( EgoEntity )) { boost :: any_cast < EgoEntity &> ( it -> second ). requestAssignRoute ( waypoints ); } if ( it -> second . type () == typeid ( PedestrianEntity )) { boost :: any_cast < PedestrianEntity &> ( it -> second ). requestAssignRoute ( waypoints ); } } void EntityManager :: requestAcquirePosition ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ) { auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return ; } if ( it -> second . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( it -> second ). requestAcquirePosition ( lanelet_pose ); } if ( it -> second . type () == typeid ( EgoEntity )) { boost :: any_cast < EgoEntity &> ( it -> second ). requestAcquirePosition ( ( * hdmap_utils_ptr_ ). toMapPose ( lanelet_pose )); } if ( it -> second . type () == typeid ( PedestrianEntity )) { boost :: any_cast < PedestrianEntity &> ( it -> second ). requestAcquirePosition ( lanelet_pose ); } } void EntityManager :: requestLaneChange ( const std :: string & name , const std :: int64_t to_lanelet_id ) { auto & entity = reference ( name ); if ( entity . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( entity ). requestLaneChange ( to_lanelet_id ); } else if ( entity . type () == typeid ( EgoEntity )) { std :: stringstream what {}; what << \"From scenario, a lane change was requested to Ego type entity '\" << name << \"'. \" ; what << \"In general, such a request is an error, \" ; what << \"since Ego cars make autonomous decisions about everything but their destination.\" ; throw std :: runtime_error ( what . str ()); } } void EntityManager :: requestWalkStraight ( const std :: string & name ) { auto & entity = reference ( name ); if ( entity . type () == typeid ( PedestrianEntity )) { boost :: any_cast < PedestrianEntity &> ( entity ). requestWalkStraight (); } else { throw std :: runtime_error ( \"target of requestWalkStaraight function should be pedestrian.\" ); } } void EntityManager :: requestLaneChange ( const std :: string & name , const Direction & direction ) { auto status = getEntityStatus ( name ); if ( status ) { if ( direction == Direction :: LEFT ) { const auto target = hdmap_utils_ptr_ -> getLaneChangeableLenletId ( status -> lanelet_pose . lanelet_id , \"left\" ); if ( target ) { requestLaneChange ( name , target . get ()); } } else if ( direction == Direction :: RIGHT ) { const auto target = hdmap_utils_ptr_ -> getLaneChangeableLenletId ( status -> lanelet_pose . lanelet_id , \"right\" ); if ( target ) { requestLaneChange ( name , target . get ()); } } } } boost :: optional < double > EntityManager :: getBoundingBoxDistance ( const std :: string & from , const std :: string & to ) { const auto bbox0 = getBoundingBox ( from ); const auto pose0 = getMapPose ( from ); const auto bbox1 = getBoundingBox ( to ); const auto pose1 = getMapPose ( to ); return math :: getPolygonDistance ( pose0 , bbox0 , pose1 , bbox1 ); } boost :: optional < double > EntityManager :: getLongitudinalDistance ( const std :: string & from , const std :: string & to , const double max_distance ) { if ( ! entityStatusSetted ( from ) || ! entityStatusSetted ( to )) { return boost :: none ; } else { const auto from_status = getEntityStatus ( from ); const auto to_status = getEntityStatus ( to ); if ( from_status && to_status ) { const auto distance = hdmap_utils_ptr_ -> getLongitudinalDistance ( from_status -> lanelet_pose . lanelet_id , from_status -> lanelet_pose . s , to_status -> lanelet_pose . lanelet_id , to_status -> lanelet_pose . s ); return ( distance && distance <= max_distance ) ? distance : boost :: none ; } else { return boost :: none ; } } } geometry_msgs :: msg :: Pose EntityManager :: getMapPose ( const std :: string & entity_name ) { const auto status = getEntityStatus ( entity_name ); if ( ! status ) { throw simulation_api :: SimulationRuntimeError ( \"failed to get status of \" + entity_name + \" entity in getMapPose\" ); } return status -> pose ; } geometry_msgs :: msg :: Pose EntityManager :: getMapPose ( const std :: string & reference_entity_name , const geometry_msgs :: msg :: Pose & relative_pose ) { const auto ref_status = getEntityStatus ( reference_entity_name ); if ( ! ref_status ) { throw simulation_api :: SimulationRuntimeError ( \"failed to get status of \" + reference_entity_name + \" entity in getMapPose\" ); } tf2 :: Transform ref_transfrom , relative_transform ; tf2 :: fromMsg ( ref_status -> pose , ref_transfrom ); tf2 :: fromMsg ( relative_pose , relative_transform ); geometry_msgs :: msg :: Pose ret ; tf2 :: toMsg ( ref_transfrom * relative_transform , ret ); return ret ; } geometry_msgs :: msg :: Pose EntityManager :: getRelativePose ( const std :: string & from , const std :: string & to ) { const auto from_status = getEntityStatus ( from ); const auto to_status = getEntityStatus ( to ); if ( ! from_status ) { throw simulation_api :: SimulationRuntimeError ( \"failed to get status of \" + from + \" entity in getRelativePose\" ); } if ( ! to_status ) { throw simulation_api :: SimulationRuntimeError ( \"failed to get status of \" + to + \" entity in getRelativePose\" ); } return getRelativePose ( from_status -> pose , to_status -> pose ); } geometry_msgs :: msg :: Pose EntityManager :: getRelativePose ( const std :: string & from , const geometry_msgs :: msg :: Pose & to ) { const auto from_status = getEntityStatus ( from ); if ( ! from_status ) { throw simulation_api :: SimulationRuntimeError ( \"failed to get status of \" + from + \" entity in getRelativePose\" ); } return getRelativePose ( from_status -> pose , to ); } geometry_msgs :: msg :: Pose EntityManager :: getRelativePose ( const geometry_msgs :: msg :: Pose & from , const std :: string & to ) { const auto to_status = getEntityStatus ( to ); if ( ! to_status ) { throw simulation_api :: SimulationRuntimeError ( \"failed to get status of \" + to + \" entity in getRelativePose\" ); } return getRelativePose ( from , to_status -> pose ); } geometry_msgs :: msg :: Pose EntityManager :: getRelativePose ( const geometry_msgs :: msg :: Pose & from , const geometry_msgs :: msg :: Pose & to ) const { geometry_msgs :: msg :: Transform from_translation ; { from_translation . translation . x = from . position . x ; from_translation . translation . y = from . position . y ; from_translation . translation . z = from . position . z ; from_translation . rotation = from . orientation ; } tf2 :: Transform from_tf ; { tf2 :: fromMsg ( from_translation , from_tf ); } geometry_msgs :: msg :: Transform to_translation ; { to_translation . translation . x = to . position . x ; to_translation . translation . y = to . position . y ; to_translation . translation . z = to . position . z ; to_translation . rotation = to . orientation ; } tf2 :: Transform to_tf ; { tf2 :: fromMsg ( to_translation , to_tf ); } tf2 :: Transform tf_delta = from_tf . inverse () * to_tf ; geometry_msgs :: msg :: Pose ret ; { tf2 :: toMsg ( tf_delta , ret ); } return ret ; } const boost :: optional < openscenario_msgs :: msg :: VehicleParameters > EntityManager :: getVehicleParameters ( const std :: string & name ) const { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return boost :: none ; } if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < const VehicleEntity &> ( it -> second ). parameters ; } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < const EgoEntity &> ( it -> second ). parameters ; } return boost :: none ; } bool EntityManager :: isInLanelet ( const std :: string & name , const std :: int64_t lanelet_id , const double tolerance ) { if ( ! entityStatusSetted ( name )) { return false ; } double l = hdmap_utils_ptr_ -> getLaneletLength ( lanelet_id ); auto status = getEntityStatus ( name ); if ( ! status ) { return false ; } if ( ! status -> lanelet_pose_valid ) { return false ; } if ( status -> lanelet_pose . lanelet_id == lanelet_id ) { return true ; } else { auto dist0 = hdmap_utils_ptr_ -> getLongitudinalDistance ( lanelet_id , l , status -> lanelet_pose . lanelet_id , status -> lanelet_pose . s ); auto dist1 = hdmap_utils_ptr_ -> getLongitudinalDistance ( status -> lanelet_pose . lanelet_id , status -> lanelet_pose . s , lanelet_id , 0 ); if ( dist0 ) { if ( dist0 . get () < tolerance ) { return true ; } } if ( dist1 ) { if ( dist1 . get () < tolerance ) { return true ; } } } return false ; } const std :: vector < std :: string > EntityManager :: getEntityNames () const { std :: vector < std :: string > names {}; for ( const auto & each : entities_ ) { names . push_back ( each . first ); } return names ; } bool EntityManager :: setEntityStatus ( const std :: string & name , openscenario_msgs :: msg :: EntityStatus status ) { status . name = name ; // XXX UGLY CODE const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return false ; } if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < VehicleEntity &> ( it -> second ). setStatus ( status ); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < EgoEntity &> ( it -> second ). setStatus ( status ); } if ( it -> second . type () == typeid ( PedestrianEntity )) { return boost :: any_cast < PedestrianEntity &> ( it -> second ). setStatus ( status ); } return false ; } const boost :: optional < openscenario_msgs :: msg :: EntityStatus > EntityManager :: getEntityStatus ( const std :: string & name ) const { openscenario_msgs :: msg :: EntityStatus status_msg ; auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return boost :: none ; } if ( it -> second . type () == typeid ( VehicleEntity )) { status_msg = boost :: any_cast < const VehicleEntity &> ( it -> second ). getStatus (); } else if ( it -> second . type () == typeid ( EgoEntity )) { status_msg = boost :: any_cast < const EgoEntity &> ( it -> second ). getStatus (); } else if ( it -> second . type () == typeid ( PedestrianEntity )) { status_msg = boost :: any_cast < const PedestrianEntity &> ( it -> second ). getStatus (); } else { return boost :: none ; } status_msg . bounding_box = getBoundingBox ( name ); status_msg . action_status . current_action = getCurrentAction ( name ); switch ( getEntityType ( name ). type ) { case openscenario_msgs :: msg :: EntityType :: EGO : status_msg . type . type = status_msg . type . EGO ; break ; case openscenario_msgs :: msg :: EntityType :: VEHICLE : status_msg . type . type = status_msg . type . VEHICLE ; break ; case openscenario_msgs :: msg :: EntityType :: PEDESTRIAN : status_msg . type . type = status_msg . type . PEDESTRIAN ; break ; } status_msg . time = current_time_ ; status_msg . name = name ; return status_msg ; } bool EntityManager :: checkCollision ( const std :: string & name0 , const std :: string & name1 ) { if ( name0 == name1 ) { return false ; } if ( ! entityStatusSetted ( name0 )) { return false ; } if ( ! entityStatusSetted ( name1 )) { return false ; } auto status0 = getEntityStatus ( name0 ); if ( ! status0 ) { throw simulation_api :: SimulationRuntimeError ( \"failed to calculate map pose : \" + name0 ); return false ; } auto status1 = getEntityStatus ( name1 ); if ( ! status1 ) { throw simulation_api :: SimulationRuntimeError ( \"failed to calculate map pose : \" + name1 ); } auto bbox0 = getBoundingBox ( name0 ); auto bbox1 = getBoundingBox ( name1 ); return simulation_api :: math :: checkCollision2D ( status0 -> pose , bbox0 , status1 -> pose , bbox1 ); } const openscenario_msgs :: msg :: BoundingBox EntityManager :: getBoundingBox ( const std :: string & name ) const { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting bounding box : \" + name ); } if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < const VehicleEntity &> ( it -> second ). getBoundingBox (); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < const EgoEntity &> ( it -> second ). getBoundingBox (); } if ( it -> second . type () == typeid ( PedestrianEntity )) { return boost :: any_cast < const PedestrianEntity &> ( it -> second ). getBoundingBox (); } throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting bounding box : \" + name ); } boost :: optional < openscenario_msgs :: msg :: Obstacle > EntityManager :: getObstacle ( const std :: string & name ) { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting obstacle : \" + name ); } if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < VehicleEntity &> ( it -> second ). getObstacle (); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: none ; } if ( it -> second . type () == typeid ( PedestrianEntity )) { return boost :: none ; } throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting obstacle : \" + name ); } openscenario_msgs :: msg :: WaypointsArray EntityManager :: getWaypoints ( const std :: string & name ) { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting wayoints : \" + name ); } if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < VehicleEntity &> ( it -> second ). getWaypoints (); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < EgoEntity &> ( it -> second ). getWaypoints (); } if ( it -> second . type () == typeid ( PedestrianEntity )) { return openscenario_msgs :: msg :: WaypointsArray (); } throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting waypoints : \" + name ); } boost :: optional < double > EntityManager :: getLinearJerk ( const std :: string & name ) const { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { throw simulation_api :: SimulationRuntimeError ( \"entity \" + name + \" does not exist\" ); } if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < const VehicleEntity &> ( it -> second ). getLinearJerk (); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < const EgoEntity &> ( it -> second ). getLinearJerk (); } if ( it -> second . type () == typeid ( PedestrianEntity )) { return boost :: any_cast < const PedestrianEntity &> ( it -> second ). getLinearJerk (); } return boost :: none ; } bool EntityManager :: entityStatusSetted ( const std :: string & name ) const { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return false ; } if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < const VehicleEntity &> ( it -> second ). statusSetted (); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < const EgoEntity &> ( it -> second ). statusSetted (); } if ( it -> second . type () == typeid ( PedestrianEntity )) { return boost :: any_cast < const PedestrianEntity &> ( it -> second ). statusSetted (); } return false ; } void EntityManager :: setTargetSpeed ( const std :: string & name , const double target_speed , const bool continuous ) { auto & entity = reference ( name ); if ( entity . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( entity ). setTargetSpeed ( target_speed , continuous ); } else if ( entity . type () == typeid ( EgoEntity )) { boost :: any_cast < EgoEntity &> ( entity ). setTargetSpeed ( target_speed , continuous ); } else if ( entity . type () == typeid ( PedestrianEntity )) { boost :: any_cast < PedestrianEntity &> ( entity ). setTargetSpeed ( target_speed , continuous ); } else { std :: stringstream what {}; what << \"Entity '\" << name << \"' is typed with the unexpected type '\" ; what << entity . type (). name () << \"'.\" ; throw SimulationRuntimeError ( what . str ()); } } std :: vector < std :: int64_t > EntityManager :: getRouteLanelets ( const std :: string & name , const double horizon ) { auto & entity = reference ( name ); if ( entity . type () == typeid ( VehicleEntity )) { return boost :: any_cast < VehicleEntity &> ( entity ). getRouteLanelets ( horizon ); } else if ( entity . type () == typeid ( EgoEntity )) { return boost :: any_cast < EgoEntity &> ( entity ). getRouteLanelets ( horizon ); } else if ( entity . type () == typeid ( PedestrianEntity )) { return boost :: any_cast < PedestrianEntity &> ( entity ). getRouteLanelets ( horizon ); } else { std :: stringstream what {}; what << \"Entity '\" << name << \"' is typed with the unexpected type '\" ; what << entity . type (). name () << \"'.\" ; throw SimulationRuntimeError ( what . str ()); } } std :: vector < std :: int64_t > EntityManager :: getConflictingEntityOnRouteLanelets ( const std :: string & name , const double horizon ) { auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { throw SimulationRuntimeError ( \"entity \" + name + \" does not exist\" ); } const auto route = getRouteLanelets ( name , horizon ); return hdmap_utils_ptr_ -> getConflictingCrosswalkIds ( route ); } double EntityManager :: getStepTime () const noexcept { return step_time_ ; } double EntityManager :: getCurrentTime () const noexcept { return current_time_ ; } void EntityManager :: update ( const double current_time , const double step_time ) { std :: chrono :: system_clock :: time_point start , end ; start = std :: chrono :: system_clock :: now (); step_time_ = step_time ; traffic_light_manager_ptr_ -> update ( step_time_ ); current_time_ = current_time ; if ( verbose_ ) { std :: cout << \"-------------------------- UPDATE --------------------------\" << std :: endl ; } if ( getNumberOfEgo () >= 2 ) { throw SimulationRuntimeError ( \"multi ego simulation does not support yet.\" ); } setVerbose ( verbose_ ); auto type_list = getEntityTypeList (); std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > all_status ; for ( auto it = entities_ . begin (); it != entities_ . end (); it ++ ) { if ( verbose_ ) { std :: cout << \"update \" << it -> first << \" behavior\" << std :: endl ; } if ( it -> second . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( it -> second ). setEntityTypeList ( type_list ); boost :: any_cast < VehicleEntity &> ( it -> second ). onUpdate ( current_time , step_time ); if ( boost :: any_cast < VehicleEntity &> ( it -> second ). statusSetted ()) { auto status = boost :: any_cast < VehicleEntity &> ( it -> second ). getStatus (); all_status [ boost :: any_cast < VehicleEntity &> ( it -> second ). name ] = status ; } } if ( it -> second . type () == typeid ( EgoEntity )) { boost :: any_cast < EgoEntity &> ( it -> second ). setEntityTypeList ( type_list ); boost :: any_cast < EgoEntity &> ( it -> second ). onUpdate ( current_time , step_time ); if ( boost :: any_cast < EgoEntity &> ( it -> second ). statusSetted ()) { auto status = boost :: any_cast < EgoEntity &> ( it -> second ). getStatus (); all_status [ boost :: any_cast < EgoEntity &> ( it -> second ). name ] = status ; } } if ( it -> second . type () == typeid ( PedestrianEntity )) { boost :: any_cast < PedestrianEntity &> ( it -> second ). setEntityTypeList ( type_list ); boost :: any_cast < PedestrianEntity &> ( it -> second ). onUpdate ( current_time , step_time ); if ( boost :: any_cast < PedestrianEntity &> ( it -> second ). statusSetted ()) { auto status = boost :: any_cast < PedestrianEntity &> ( it -> second ). getStatus (); all_status [ boost :: any_cast < PedestrianEntity &> ( it -> second ). name ] = status ; } } } for ( auto it = entities_ . begin (); it != entities_ . end (); it ++ ) { if ( it -> second . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( it -> second ). setOtherStatus ( all_status ); } if ( it -> second . type () == typeid ( EgoEntity )) { boost :: any_cast < EgoEntity &> ( it -> second ). setOtherStatus ( all_status ); } if ( it -> second . type () == typeid ( PedestrianEntity )) { boost :: any_cast < PedestrianEntity &> ( it -> second ). setOtherStatus ( all_status ); } } auto entity_type_list = getEntityTypeList (); openscenario_msgs :: msg :: EntityStatusWithTrajectoryArray status_array_msg ; for ( const auto & status : all_status ) { openscenario_msgs :: msg :: EntityStatusWithTrajectory status_with_traj ; auto status_msg = status . second ; status_msg . name = status . first ; status_msg . bounding_box = getBoundingBox ( status . first ); status_msg . action_status . current_action = getCurrentAction ( status . first ); switch ( getEntityType ( status . first ). type ) { case openscenario_msgs :: msg :: EntityType :: EGO : status_msg . type . type = status_msg . type . EGO ; break ; case openscenario_msgs :: msg :: EntityType :: VEHICLE : status_msg . type . type = status_msg . type . VEHICLE ; break ; case openscenario_msgs :: msg :: EntityType :: PEDESTRIAN : status_msg . type . type = status_msg . type . PEDESTRIAN ; break ; } status_with_traj . waypoint = getWaypoints ( status . first ); const auto obstacle = getObstacle ( status . first ); if ( obstacle ) { status_with_traj . obstacle = obstacle . get (); status_with_traj . obstacle_find = true ; } else { status_with_traj . obstacle_find = false ; } status_with_traj . status = status_msg ; status_with_traj . name = status . first ; status_with_traj . time = current_time + step_time ; status_array_msg . data . emplace_back ( status_with_traj ); } entity_status_array_pub_ptr_ -> publish ( status_array_msg ); end = std :: chrono :: system_clock :: now (); double elapsed = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( end - start ). count (); if ( verbose_ ) { std :: cout << \"elapsed \" << elapsed / 1000 << \" secands in update function.\" << std :: endl ; } } void EntityManager :: broadcastTransform ( const geometry_msgs :: msg :: PoseStamped & pose , const bool static_transform ) { geometry_msgs :: msg :: TransformStamped transform_stamped ; { transform_stamped . header . stamp = pose . header . stamp ; transform_stamped . header . frame_id = \"map\" ; transform_stamped . child_frame_id = pose . header . frame_id ; transform_stamped . transform . translation . x = pose . pose . position . x ; transform_stamped . transform . translation . y = pose . pose . position . y ; transform_stamped . transform . translation . z = pose . pose . position . z ; transform_stamped . transform . rotation = pose . pose . orientation ; } if ( static_transform ) { broadcaster_ . sendTransform ( transform_stamped ); } else { base_link_broadcaster_ . sendTransform ( transform_stamped ); } } bool EntityManager :: reachPosition ( const std :: string & name , const std :: string & target_name , const double tolerance ) const { const auto status = getEntityStatus ( target_name ); return status && reachPosition ( name , status -> pose , tolerance ); } bool EntityManager :: reachPosition ( const std :: string & name , const geometry_msgs :: msg :: Pose & target_pose , const double tolerance ) const { const auto status = getEntityStatus ( name ); if ( ! status ) { throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting entity stauts, target entity : \" + name ); } const auto pose = status -> pose ; const double distance = std :: sqrt ( std :: pow ( pose . position . x - target_pose . position . x , 2 ) + std :: pow ( pose . position . y - target_pose . position . y , 2 ) + std :: pow ( pose . position . z - target_pose . position . z , 2 )); return distance < tolerance ; } bool EntityManager :: reachPosition ( const std :: string & name , const std :: int64_t lanelet_id , const double s , const double offset , const double tolerance ) const { openscenario_msgs :: msg :: LaneletPose lanelet_pose ; { lanelet_pose . lanelet_id = lanelet_id ; lanelet_pose . s = s ; lanelet_pose . offset = offset ; } const auto target_pose = hdmap_utils_ptr_ -> toMapPose ( lanelet_pose ); return reachPosition ( name , target_pose . pose , tolerance ); } void EntityManager :: broadcastBaseLinkTransform () { // for (const auto & name : getEntityNames()) { // if (getEntityType(name).type == openscenario_msgs::msg::EntityType::EGO) { // auto status = getEntityStatus(name); // if (status) { // geometry_msgs::msg::PoseStamped pose; // pose.pose = status->pose; // pose.header.stamp = clock_ptr_->now(); // pose.header.frame_id = \"base_link\"; // broadcastTransform(pose, false); // } // return; // } // } } void EntityManager :: broadcastEntityTransform () { std :: vector < std :: string > names = getEntityNames (); for ( auto it = names . begin (); it != names . end (); it ++ ) { if ( entityStatusSetted ( * it )) { auto status = getEntityStatus ( * it ); if ( status ) { geometry_msgs :: msg :: PoseStamped pose ; pose . pose = status -> pose ; pose . header . stamp = clock_ptr_ -> now (); pose . header . frame_id = * it ; broadcastTransform ( pose ); } } } // broadcastBaseLinkTransform(); } const boost :: optional < double > EntityManager :: getStandStillDuration ( const std :: string & name ) const { const auto it = entities_ . find ( name ); if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < const VehicleEntity &> ( it -> second ). getStandStillDuration (); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < const EgoEntity &> ( it -> second ). getStandStillDuration (); } if ( it -> second . type () == typeid ( PedestrianEntity )) { return boost :: any_cast < const PedestrianEntity &> ( it -> second ). getStandStillDuration (); } throw simulation_api :: SimulationRuntimeError ( \"entity \" + name + \"does not exist\" ); } const std :: string EntityManager :: getCurrentAction ( const std :: string & name ) const { const auto it = entities_ . find ( name ); if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < const VehicleEntity &> ( it -> second ). getCurrentAction (); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < const EgoEntity &> ( it -> second ). getCurrentAction (); } if ( it -> second . type () == typeid ( PedestrianEntity )) { return boost :: any_cast < const PedestrianEntity &> ( it -> second ). getCurrentAction (); } throw simulation_api :: SimulationRuntimeError ( \"entity \" + name + \"does not exist\" ); } openscenario_msgs :: msg :: EntityType EntityManager :: getEntityType ( const std :: string & name ) const { const auto it = entities_ . find ( name ); if ( it -> second . type () == typeid ( VehicleEntity )) { openscenario_msgs :: msg :: EntityType type ; type . type = openscenario_msgs :: msg :: EntityType :: VEHICLE ; return type ; } if ( it -> second . type () == typeid ( EgoEntity )) { openscenario_msgs :: msg :: EntityType type ; type . type = openscenario_msgs :: msg :: EntityType :: EGO ; return type ; } if ( it -> second . type () == typeid ( PedestrianEntity )) { openscenario_msgs :: msg :: EntityType type ; type . type = openscenario_msgs :: msg :: EntityType :: PEDESTRIAN ; return type ; } throw simulation_api :: SimulationRuntimeError ( \"entity \" + name + \"does not exist\" ); } const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > EntityManager :: getEntityTypeList () const { std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > ret ; for ( auto it = entities_ . begin (); it != entities_ . end (); it ++ ) { if ( it -> second . type () == typeid ( VehicleEntity )) { openscenario_msgs :: msg :: EntityType type ; type . type = openscenario_msgs :: msg :: EntityType :: VEHICLE ; ret [ it -> first ] = type ; } if ( it -> second . type () == typeid ( EgoEntity )) { openscenario_msgs :: msg :: EntityType type ; type . type = openscenario_msgs :: msg :: EntityType :: EGO ; ret [ it -> first ] = type ; } if ( it -> second . type () == typeid ( PedestrianEntity )) { openscenario_msgs :: msg :: EntityType type ; type . type = openscenario_msgs :: msg :: EntityType :: PEDESTRIAN ; ret [ it -> first ] = type ; } } return ret ; } } // namespace entity } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/entity_manager.cpp"},{"location":"package/simulation_api/markdown/Files/entity__manager_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcentityentity_managercpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/entity_manager.cpp"},{"location":"package/simulation_api/markdown/Files/entity__manager_8cpp/#namespaces","text":"Name simulation_api::entity simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/entity__manager_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/entity/entity_manager.hpp> #include <simulation_api/helper/helper.hpp> #include <simulation_api/math/bounding_box.hpp> #include <simulation_api/math/collision.hpp> #include <limits> #include <sstream> #include <stdexcept> #include <string> #include <unordered_map> #include <vector> #include <queue> #include <memory> namespace simulation_api { namespace entity { bool EntityManager :: isStopping ( const std :: string & name ) const { const auto status = getEntityStatus ( name ); if ( ! status ) { throw simulation_api :: SimulationRuntimeError ( \"failed to get entity : \" + name + \" status\" ); } return std :: fabs ( status -> action_status . twist . linear . x ) < std :: numeric_limits < double >:: epsilon (); } void EntityManager :: setDriverModel ( const std :: string & name , const openscenario_msgs :: msg :: DriverModel & model ) { auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { throw simulation_api :: SimulationRuntimeError ( \"entity : \" + name + \" does not exist\" ); } if ( it -> second . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( it -> second ). setDriverModel ( model ); } if ( it -> second . type () == typeid ( EgoEntity )) { return ; } if ( it -> second . type () == typeid ( PedestrianEntity )) { throw simulation_api :: SimulationRuntimeError ( \"entity : \" + name + \" pedestrian\" ); } } const geometry_msgs :: msg :: Pose EntityManager :: toMapPose ( const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ) const { return hdmap_utils_ptr_ -> toMapPose ( lanelet_pose ). pose ; } const std :: shared_ptr < hdmap_utils :: HdMapUtils > EntityManager :: getHdmapUtils () { return hdmap_utils_ptr_ ; } void EntityManager :: setVerbose ( bool verbose ) { verbose_ = verbose ; for ( auto & each : entities_ ) { if ( each . second . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( each . second ). setVerbose ( verbose ); } if ( each . second . type () == typeid ( EgoEntity )) { boost :: any_cast < EgoEntity &> ( each . second ). setVerbose ( verbose ); } if ( each . second . type () == typeid ( PedestrianEntity )) { boost :: any_cast < PedestrianEntity &> ( each . second ). setVerbose ( verbose ); } } } bool EntityManager :: isEgo ( const std :: string & name ) const { return getEntityType ( name ). type == openscenario_msgs :: msg :: EntityType :: EGO ; } std :: size_t EntityManager :: getNumberOfEgo () const { return std :: count_if ( std :: begin ( entities_ ), std :: end ( entities_ ), []( const auto & each ) { return each . second . type () == typeid ( EgoEntity ); }); } boost :: optional < openscenario_msgs :: msg :: LaneletPose > EntityManager :: getLaneletPose ( const std :: string & name ) { const auto status = getEntityStatus ( name ); if ( ! status ) { return boost :: none ; } if ( status -> lanelet_pose_valid ) { return status -> lanelet_pose ; } return toLaneletPose ( status -> pose ); } boost :: optional < double > EntityManager :: getDistanceToCrosswalk ( const std :: string & name , const std :: int64_t target_crosswalk_id ) { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return boost :: none ; } if ( getWaypoints ( name ). waypoints . empty ()) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( getWaypoints ( name ). waypoints ); auto polygon = hdmap_utils_ptr_ -> getLaneletPolygon ( target_crosswalk_id ); return spline . getCollisionPointIn2D ( polygon ); } boost :: optional < double > EntityManager :: getSValueInRoute ( const std :: string & name , const std :: vector < std :: int64_t > & route ) { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return boost :: none ; } const auto lanelet_pose = getLaneletPose ( name ); if ( ! lanelet_pose ) { return boost :: none ; } double s = 0 ; for ( const auto id : route ) { if ( id == lanelet_pose -> lanelet_id ) { s = s + lanelet_pose -> s ; return s ; } else { s = s + hdmap_utils_ptr_ -> getLaneletLength ( id ); } } return boost :: none ; } boost :: optional < double > EntityManager :: getDistanceToStopLine ( const std :: string & name , const std :: int64_t target_stop_line_id ) { auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return boost :: none ; } if ( getWaypoints ( name ). waypoints . empty ()) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( getWaypoints ( name ). waypoints ); auto polygon = hdmap_utils_ptr_ -> getStopLinePolygon ( target_stop_line_id ); return spline . getCollisionPointIn2D ( polygon ); } void EntityManager :: requestAssignRoute ( const std :: string & name , const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) { auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return ; } if ( it -> second . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( it -> second ). requestAssignRoute ( waypoints ); } if ( it -> second . type () == typeid ( EgoEntity )) { boost :: any_cast < EgoEntity &> ( it -> second ). requestAssignRoute ( waypoints ); } if ( it -> second . type () == typeid ( PedestrianEntity )) { boost :: any_cast < PedestrianEntity &> ( it -> second ). requestAssignRoute ( waypoints ); } } void EntityManager :: requestAcquirePosition ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ) { auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return ; } if ( it -> second . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( it -> second ). requestAcquirePosition ( lanelet_pose ); } if ( it -> second . type () == typeid ( EgoEntity )) { boost :: any_cast < EgoEntity &> ( it -> second ). requestAcquirePosition ( ( * hdmap_utils_ptr_ ). toMapPose ( lanelet_pose )); } if ( it -> second . type () == typeid ( PedestrianEntity )) { boost :: any_cast < PedestrianEntity &> ( it -> second ). requestAcquirePosition ( lanelet_pose ); } } void EntityManager :: requestLaneChange ( const std :: string & name , const std :: int64_t to_lanelet_id ) { auto & entity = reference ( name ); if ( entity . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( entity ). requestLaneChange ( to_lanelet_id ); } else if ( entity . type () == typeid ( EgoEntity )) { std :: stringstream what {}; what << \"From scenario, a lane change was requested to Ego type entity '\" << name << \"'. \" ; what << \"In general, such a request is an error, \" ; what << \"since Ego cars make autonomous decisions about everything but their destination.\" ; throw std :: runtime_error ( what . str ()); } } void EntityManager :: requestWalkStraight ( const std :: string & name ) { auto & entity = reference ( name ); if ( entity . type () == typeid ( PedestrianEntity )) { boost :: any_cast < PedestrianEntity &> ( entity ). requestWalkStraight (); } else { throw std :: runtime_error ( \"target of requestWalkStaraight function should be pedestrian.\" ); } } void EntityManager :: requestLaneChange ( const std :: string & name , const Direction & direction ) { auto status = getEntityStatus ( name ); if ( status ) { if ( direction == Direction :: LEFT ) { const auto target = hdmap_utils_ptr_ -> getLaneChangeableLenletId ( status -> lanelet_pose . lanelet_id , \"left\" ); if ( target ) { requestLaneChange ( name , target . get ()); } } else if ( direction == Direction :: RIGHT ) { const auto target = hdmap_utils_ptr_ -> getLaneChangeableLenletId ( status -> lanelet_pose . lanelet_id , \"right\" ); if ( target ) { requestLaneChange ( name , target . get ()); } } } } boost :: optional < double > EntityManager :: getBoundingBoxDistance ( const std :: string & from , const std :: string & to ) { const auto bbox0 = getBoundingBox ( from ); const auto pose0 = getMapPose ( from ); const auto bbox1 = getBoundingBox ( to ); const auto pose1 = getMapPose ( to ); return math :: getPolygonDistance ( pose0 , bbox0 , pose1 , bbox1 ); } boost :: optional < double > EntityManager :: getLongitudinalDistance ( const std :: string & from , const std :: string & to , const double max_distance ) { if ( ! entityStatusSetted ( from ) || ! entityStatusSetted ( to )) { return boost :: none ; } else { const auto from_status = getEntityStatus ( from ); const auto to_status = getEntityStatus ( to ); if ( from_status && to_status ) { const auto distance = hdmap_utils_ptr_ -> getLongitudinalDistance ( from_status -> lanelet_pose . lanelet_id , from_status -> lanelet_pose . s , to_status -> lanelet_pose . lanelet_id , to_status -> lanelet_pose . s ); return ( distance && distance <= max_distance ) ? distance : boost :: none ; } else { return boost :: none ; } } } geometry_msgs :: msg :: Pose EntityManager :: getMapPose ( const std :: string & entity_name ) { const auto status = getEntityStatus ( entity_name ); if ( ! status ) { throw simulation_api :: SimulationRuntimeError ( \"failed to get status of \" + entity_name + \" entity in getMapPose\" ); } return status -> pose ; } geometry_msgs :: msg :: Pose EntityManager :: getMapPose ( const std :: string & reference_entity_name , const geometry_msgs :: msg :: Pose & relative_pose ) { const auto ref_status = getEntityStatus ( reference_entity_name ); if ( ! ref_status ) { throw simulation_api :: SimulationRuntimeError ( \"failed to get status of \" + reference_entity_name + \" entity in getMapPose\" ); } tf2 :: Transform ref_transfrom , relative_transform ; tf2 :: fromMsg ( ref_status -> pose , ref_transfrom ); tf2 :: fromMsg ( relative_pose , relative_transform ); geometry_msgs :: msg :: Pose ret ; tf2 :: toMsg ( ref_transfrom * relative_transform , ret ); return ret ; } geometry_msgs :: msg :: Pose EntityManager :: getRelativePose ( const std :: string & from , const std :: string & to ) { const auto from_status = getEntityStatus ( from ); const auto to_status = getEntityStatus ( to ); if ( ! from_status ) { throw simulation_api :: SimulationRuntimeError ( \"failed to get status of \" + from + \" entity in getRelativePose\" ); } if ( ! to_status ) { throw simulation_api :: SimulationRuntimeError ( \"failed to get status of \" + to + \" entity in getRelativePose\" ); } return getRelativePose ( from_status -> pose , to_status -> pose ); } geometry_msgs :: msg :: Pose EntityManager :: getRelativePose ( const std :: string & from , const geometry_msgs :: msg :: Pose & to ) { const auto from_status = getEntityStatus ( from ); if ( ! from_status ) { throw simulation_api :: SimulationRuntimeError ( \"failed to get status of \" + from + \" entity in getRelativePose\" ); } return getRelativePose ( from_status -> pose , to ); } geometry_msgs :: msg :: Pose EntityManager :: getRelativePose ( const geometry_msgs :: msg :: Pose & from , const std :: string & to ) { const auto to_status = getEntityStatus ( to ); if ( ! to_status ) { throw simulation_api :: SimulationRuntimeError ( \"failed to get status of \" + to + \" entity in getRelativePose\" ); } return getRelativePose ( from , to_status -> pose ); } geometry_msgs :: msg :: Pose EntityManager :: getRelativePose ( const geometry_msgs :: msg :: Pose & from , const geometry_msgs :: msg :: Pose & to ) const { geometry_msgs :: msg :: Transform from_translation ; { from_translation . translation . x = from . position . x ; from_translation . translation . y = from . position . y ; from_translation . translation . z = from . position . z ; from_translation . rotation = from . orientation ; } tf2 :: Transform from_tf ; { tf2 :: fromMsg ( from_translation , from_tf ); } geometry_msgs :: msg :: Transform to_translation ; { to_translation . translation . x = to . position . x ; to_translation . translation . y = to . position . y ; to_translation . translation . z = to . position . z ; to_translation . rotation = to . orientation ; } tf2 :: Transform to_tf ; { tf2 :: fromMsg ( to_translation , to_tf ); } tf2 :: Transform tf_delta = from_tf . inverse () * to_tf ; geometry_msgs :: msg :: Pose ret ; { tf2 :: toMsg ( tf_delta , ret ); } return ret ; } const boost :: optional < openscenario_msgs :: msg :: VehicleParameters > EntityManager :: getVehicleParameters ( const std :: string & name ) const { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return boost :: none ; } if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < const VehicleEntity &> ( it -> second ). parameters ; } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < const EgoEntity &> ( it -> second ). parameters ; } return boost :: none ; } bool EntityManager :: isInLanelet ( const std :: string & name , const std :: int64_t lanelet_id , const double tolerance ) { if ( ! entityStatusSetted ( name )) { return false ; } double l = hdmap_utils_ptr_ -> getLaneletLength ( lanelet_id ); auto status = getEntityStatus ( name ); if ( ! status ) { return false ; } if ( ! status -> lanelet_pose_valid ) { return false ; } if ( status -> lanelet_pose . lanelet_id == lanelet_id ) { return true ; } else { auto dist0 = hdmap_utils_ptr_ -> getLongitudinalDistance ( lanelet_id , l , status -> lanelet_pose . lanelet_id , status -> lanelet_pose . s ); auto dist1 = hdmap_utils_ptr_ -> getLongitudinalDistance ( status -> lanelet_pose . lanelet_id , status -> lanelet_pose . s , lanelet_id , 0 ); if ( dist0 ) { if ( dist0 . get () < tolerance ) { return true ; } } if ( dist1 ) { if ( dist1 . get () < tolerance ) { return true ; } } } return false ; } const std :: vector < std :: string > EntityManager :: getEntityNames () const { std :: vector < std :: string > names {}; for ( const auto & each : entities_ ) { names . push_back ( each . first ); } return names ; } bool EntityManager :: setEntityStatus ( const std :: string & name , openscenario_msgs :: msg :: EntityStatus status ) { status . name = name ; // XXX UGLY CODE const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return false ; } if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < VehicleEntity &> ( it -> second ). setStatus ( status ); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < EgoEntity &> ( it -> second ). setStatus ( status ); } if ( it -> second . type () == typeid ( PedestrianEntity )) { return boost :: any_cast < PedestrianEntity &> ( it -> second ). setStatus ( status ); } return false ; } const boost :: optional < openscenario_msgs :: msg :: EntityStatus > EntityManager :: getEntityStatus ( const std :: string & name ) const { openscenario_msgs :: msg :: EntityStatus status_msg ; auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return boost :: none ; } if ( it -> second . type () == typeid ( VehicleEntity )) { status_msg = boost :: any_cast < const VehicleEntity &> ( it -> second ). getStatus (); } else if ( it -> second . type () == typeid ( EgoEntity )) { status_msg = boost :: any_cast < const EgoEntity &> ( it -> second ). getStatus (); } else if ( it -> second . type () == typeid ( PedestrianEntity )) { status_msg = boost :: any_cast < const PedestrianEntity &> ( it -> second ). getStatus (); } else { return boost :: none ; } status_msg . bounding_box = getBoundingBox ( name ); status_msg . action_status . current_action = getCurrentAction ( name ); switch ( getEntityType ( name ). type ) { case openscenario_msgs :: msg :: EntityType :: EGO : status_msg . type . type = status_msg . type . EGO ; break ; case openscenario_msgs :: msg :: EntityType :: VEHICLE : status_msg . type . type = status_msg . type . VEHICLE ; break ; case openscenario_msgs :: msg :: EntityType :: PEDESTRIAN : status_msg . type . type = status_msg . type . PEDESTRIAN ; break ; } status_msg . time = current_time_ ; status_msg . name = name ; return status_msg ; } bool EntityManager :: checkCollision ( const std :: string & name0 , const std :: string & name1 ) { if ( name0 == name1 ) { return false ; } if ( ! entityStatusSetted ( name0 )) { return false ; } if ( ! entityStatusSetted ( name1 )) { return false ; } auto status0 = getEntityStatus ( name0 ); if ( ! status0 ) { throw simulation_api :: SimulationRuntimeError ( \"failed to calculate map pose : \" + name0 ); return false ; } auto status1 = getEntityStatus ( name1 ); if ( ! status1 ) { throw simulation_api :: SimulationRuntimeError ( \"failed to calculate map pose : \" + name1 ); } auto bbox0 = getBoundingBox ( name0 ); auto bbox1 = getBoundingBox ( name1 ); return simulation_api :: math :: checkCollision2D ( status0 -> pose , bbox0 , status1 -> pose , bbox1 ); } const openscenario_msgs :: msg :: BoundingBox EntityManager :: getBoundingBox ( const std :: string & name ) const { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting bounding box : \" + name ); } if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < const VehicleEntity &> ( it -> second ). getBoundingBox (); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < const EgoEntity &> ( it -> second ). getBoundingBox (); } if ( it -> second . type () == typeid ( PedestrianEntity )) { return boost :: any_cast < const PedestrianEntity &> ( it -> second ). getBoundingBox (); } throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting bounding box : \" + name ); } boost :: optional < openscenario_msgs :: msg :: Obstacle > EntityManager :: getObstacle ( const std :: string & name ) { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting obstacle : \" + name ); } if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < VehicleEntity &> ( it -> second ). getObstacle (); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: none ; } if ( it -> second . type () == typeid ( PedestrianEntity )) { return boost :: none ; } throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting obstacle : \" + name ); } openscenario_msgs :: msg :: WaypointsArray EntityManager :: getWaypoints ( const std :: string & name ) { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting wayoints : \" + name ); } if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < VehicleEntity &> ( it -> second ). getWaypoints (); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < EgoEntity &> ( it -> second ). getWaypoints (); } if ( it -> second . type () == typeid ( PedestrianEntity )) { return openscenario_msgs :: msg :: WaypointsArray (); } throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting waypoints : \" + name ); } boost :: optional < double > EntityManager :: getLinearJerk ( const std :: string & name ) const { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { throw simulation_api :: SimulationRuntimeError ( \"entity \" + name + \" does not exist\" ); } if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < const VehicleEntity &> ( it -> second ). getLinearJerk (); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < const EgoEntity &> ( it -> second ). getLinearJerk (); } if ( it -> second . type () == typeid ( PedestrianEntity )) { return boost :: any_cast < const PedestrianEntity &> ( it -> second ). getLinearJerk (); } return boost :: none ; } bool EntityManager :: entityStatusSetted ( const std :: string & name ) const { const auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { return false ; } if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < const VehicleEntity &> ( it -> second ). statusSetted (); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < const EgoEntity &> ( it -> second ). statusSetted (); } if ( it -> second . type () == typeid ( PedestrianEntity )) { return boost :: any_cast < const PedestrianEntity &> ( it -> second ). statusSetted (); } return false ; } void EntityManager :: setTargetSpeed ( const std :: string & name , const double target_speed , const bool continuous ) { auto & entity = reference ( name ); if ( entity . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( entity ). setTargetSpeed ( target_speed , continuous ); } else if ( entity . type () == typeid ( EgoEntity )) { boost :: any_cast < EgoEntity &> ( entity ). setTargetSpeed ( target_speed , continuous ); } else if ( entity . type () == typeid ( PedestrianEntity )) { boost :: any_cast < PedestrianEntity &> ( entity ). setTargetSpeed ( target_speed , continuous ); } else { std :: stringstream what {}; what << \"Entity '\" << name << \"' is typed with the unexpected type '\" ; what << entity . type (). name () << \"'.\" ; throw SimulationRuntimeError ( what . str ()); } } std :: vector < std :: int64_t > EntityManager :: getRouteLanelets ( const std :: string & name , const double horizon ) { auto & entity = reference ( name ); if ( entity . type () == typeid ( VehicleEntity )) { return boost :: any_cast < VehicleEntity &> ( entity ). getRouteLanelets ( horizon ); } else if ( entity . type () == typeid ( EgoEntity )) { return boost :: any_cast < EgoEntity &> ( entity ). getRouteLanelets ( horizon ); } else if ( entity . type () == typeid ( PedestrianEntity )) { return boost :: any_cast < PedestrianEntity &> ( entity ). getRouteLanelets ( horizon ); } else { std :: stringstream what {}; what << \"Entity '\" << name << \"' is typed with the unexpected type '\" ; what << entity . type (). name () << \"'.\" ; throw SimulationRuntimeError ( what . str ()); } } std :: vector < std :: int64_t > EntityManager :: getConflictingEntityOnRouteLanelets ( const std :: string & name , const double horizon ) { auto it = entities_ . find ( name ); if ( it == entities_ . end ()) { throw SimulationRuntimeError ( \"entity \" + name + \" does not exist\" ); } const auto route = getRouteLanelets ( name , horizon ); return hdmap_utils_ptr_ -> getConflictingCrosswalkIds ( route ); } double EntityManager :: getStepTime () const noexcept { return step_time_ ; } double EntityManager :: getCurrentTime () const noexcept { return current_time_ ; } void EntityManager :: update ( const double current_time , const double step_time ) { std :: chrono :: system_clock :: time_point start , end ; start = std :: chrono :: system_clock :: now (); step_time_ = step_time ; traffic_light_manager_ptr_ -> update ( step_time_ ); current_time_ = current_time ; if ( verbose_ ) { std :: cout << \"-------------------------- UPDATE --------------------------\" << std :: endl ; } if ( getNumberOfEgo () >= 2 ) { throw SimulationRuntimeError ( \"multi ego simulation does not support yet.\" ); } setVerbose ( verbose_ ); auto type_list = getEntityTypeList (); std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityStatus > all_status ; for ( auto it = entities_ . begin (); it != entities_ . end (); it ++ ) { if ( verbose_ ) { std :: cout << \"update \" << it -> first << \" behavior\" << std :: endl ; } if ( it -> second . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( it -> second ). setEntityTypeList ( type_list ); boost :: any_cast < VehicleEntity &> ( it -> second ). onUpdate ( current_time , step_time ); if ( boost :: any_cast < VehicleEntity &> ( it -> second ). statusSetted ()) { auto status = boost :: any_cast < VehicleEntity &> ( it -> second ). getStatus (); all_status [ boost :: any_cast < VehicleEntity &> ( it -> second ). name ] = status ; } } if ( it -> second . type () == typeid ( EgoEntity )) { boost :: any_cast < EgoEntity &> ( it -> second ). setEntityTypeList ( type_list ); boost :: any_cast < EgoEntity &> ( it -> second ). onUpdate ( current_time , step_time ); if ( boost :: any_cast < EgoEntity &> ( it -> second ). statusSetted ()) { auto status = boost :: any_cast < EgoEntity &> ( it -> second ). getStatus (); all_status [ boost :: any_cast < EgoEntity &> ( it -> second ). name ] = status ; } } if ( it -> second . type () == typeid ( PedestrianEntity )) { boost :: any_cast < PedestrianEntity &> ( it -> second ). setEntityTypeList ( type_list ); boost :: any_cast < PedestrianEntity &> ( it -> second ). onUpdate ( current_time , step_time ); if ( boost :: any_cast < PedestrianEntity &> ( it -> second ). statusSetted ()) { auto status = boost :: any_cast < PedestrianEntity &> ( it -> second ). getStatus (); all_status [ boost :: any_cast < PedestrianEntity &> ( it -> second ). name ] = status ; } } } for ( auto it = entities_ . begin (); it != entities_ . end (); it ++ ) { if ( it -> second . type () == typeid ( VehicleEntity )) { boost :: any_cast < VehicleEntity &> ( it -> second ). setOtherStatus ( all_status ); } if ( it -> second . type () == typeid ( EgoEntity )) { boost :: any_cast < EgoEntity &> ( it -> second ). setOtherStatus ( all_status ); } if ( it -> second . type () == typeid ( PedestrianEntity )) { boost :: any_cast < PedestrianEntity &> ( it -> second ). setOtherStatus ( all_status ); } } auto entity_type_list = getEntityTypeList (); openscenario_msgs :: msg :: EntityStatusWithTrajectoryArray status_array_msg ; for ( const auto & status : all_status ) { openscenario_msgs :: msg :: EntityStatusWithTrajectory status_with_traj ; auto status_msg = status . second ; status_msg . name = status . first ; status_msg . bounding_box = getBoundingBox ( status . first ); status_msg . action_status . current_action = getCurrentAction ( status . first ); switch ( getEntityType ( status . first ). type ) { case openscenario_msgs :: msg :: EntityType :: EGO : status_msg . type . type = status_msg . type . EGO ; break ; case openscenario_msgs :: msg :: EntityType :: VEHICLE : status_msg . type . type = status_msg . type . VEHICLE ; break ; case openscenario_msgs :: msg :: EntityType :: PEDESTRIAN : status_msg . type . type = status_msg . type . PEDESTRIAN ; break ; } status_with_traj . waypoint = getWaypoints ( status . first ); const auto obstacle = getObstacle ( status . first ); if ( obstacle ) { status_with_traj . obstacle = obstacle . get (); status_with_traj . obstacle_find = true ; } else { status_with_traj . obstacle_find = false ; } status_with_traj . status = status_msg ; status_with_traj . name = status . first ; status_with_traj . time = current_time + step_time ; status_array_msg . data . emplace_back ( status_with_traj ); } entity_status_array_pub_ptr_ -> publish ( status_array_msg ); end = std :: chrono :: system_clock :: now (); double elapsed = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( end - start ). count (); if ( verbose_ ) { std :: cout << \"elapsed \" << elapsed / 1000 << \" secands in update function.\" << std :: endl ; } } void EntityManager :: broadcastTransform ( const geometry_msgs :: msg :: PoseStamped & pose , const bool static_transform ) { geometry_msgs :: msg :: TransformStamped transform_stamped ; { transform_stamped . header . stamp = pose . header . stamp ; transform_stamped . header . frame_id = \"map\" ; transform_stamped . child_frame_id = pose . header . frame_id ; transform_stamped . transform . translation . x = pose . pose . position . x ; transform_stamped . transform . translation . y = pose . pose . position . y ; transform_stamped . transform . translation . z = pose . pose . position . z ; transform_stamped . transform . rotation = pose . pose . orientation ; } if ( static_transform ) { broadcaster_ . sendTransform ( transform_stamped ); } else { base_link_broadcaster_ . sendTransform ( transform_stamped ); } } bool EntityManager :: reachPosition ( const std :: string & name , const std :: string & target_name , const double tolerance ) const { const auto status = getEntityStatus ( target_name ); return status && reachPosition ( name , status -> pose , tolerance ); } bool EntityManager :: reachPosition ( const std :: string & name , const geometry_msgs :: msg :: Pose & target_pose , const double tolerance ) const { const auto status = getEntityStatus ( name ); if ( ! status ) { throw simulation_api :: SimulationRuntimeError ( \"error occurs while getting entity stauts, target entity : \" + name ); } const auto pose = status -> pose ; const double distance = std :: sqrt ( std :: pow ( pose . position . x - target_pose . position . x , 2 ) + std :: pow ( pose . position . y - target_pose . position . y , 2 ) + std :: pow ( pose . position . z - target_pose . position . z , 2 )); return distance < tolerance ; } bool EntityManager :: reachPosition ( const std :: string & name , const std :: int64_t lanelet_id , const double s , const double offset , const double tolerance ) const { openscenario_msgs :: msg :: LaneletPose lanelet_pose ; { lanelet_pose . lanelet_id = lanelet_id ; lanelet_pose . s = s ; lanelet_pose . offset = offset ; } const auto target_pose = hdmap_utils_ptr_ -> toMapPose ( lanelet_pose ); return reachPosition ( name , target_pose . pose , tolerance ); } void EntityManager :: broadcastBaseLinkTransform () { // for (const auto & name : getEntityNames()) { // if (getEntityType(name).type == openscenario_msgs::msg::EntityType::EGO) { // auto status = getEntityStatus(name); // if (status) { // geometry_msgs::msg::PoseStamped pose; // pose.pose = status->pose; // pose.header.stamp = clock_ptr_->now(); // pose.header.frame_id = \"base_link\"; // broadcastTransform(pose, false); // } // return; // } // } } void EntityManager :: broadcastEntityTransform () { std :: vector < std :: string > names = getEntityNames (); for ( auto it = names . begin (); it != names . end (); it ++ ) { if ( entityStatusSetted ( * it )) { auto status = getEntityStatus ( * it ); if ( status ) { geometry_msgs :: msg :: PoseStamped pose ; pose . pose = status -> pose ; pose . header . stamp = clock_ptr_ -> now (); pose . header . frame_id = * it ; broadcastTransform ( pose ); } } } // broadcastBaseLinkTransform(); } const boost :: optional < double > EntityManager :: getStandStillDuration ( const std :: string & name ) const { const auto it = entities_ . find ( name ); if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < const VehicleEntity &> ( it -> second ). getStandStillDuration (); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < const EgoEntity &> ( it -> second ). getStandStillDuration (); } if ( it -> second . type () == typeid ( PedestrianEntity )) { return boost :: any_cast < const PedestrianEntity &> ( it -> second ). getStandStillDuration (); } throw simulation_api :: SimulationRuntimeError ( \"entity \" + name + \"does not exist\" ); } const std :: string EntityManager :: getCurrentAction ( const std :: string & name ) const { const auto it = entities_ . find ( name ); if ( it -> second . type () == typeid ( VehicleEntity )) { return boost :: any_cast < const VehicleEntity &> ( it -> second ). getCurrentAction (); } if ( it -> second . type () == typeid ( EgoEntity )) { return boost :: any_cast < const EgoEntity &> ( it -> second ). getCurrentAction (); } if ( it -> second . type () == typeid ( PedestrianEntity )) { return boost :: any_cast < const PedestrianEntity &> ( it -> second ). getCurrentAction (); } throw simulation_api :: SimulationRuntimeError ( \"entity \" + name + \"does not exist\" ); } openscenario_msgs :: msg :: EntityType EntityManager :: getEntityType ( const std :: string & name ) const { const auto it = entities_ . find ( name ); if ( it -> second . type () == typeid ( VehicleEntity )) { openscenario_msgs :: msg :: EntityType type ; type . type = openscenario_msgs :: msg :: EntityType :: VEHICLE ; return type ; } if ( it -> second . type () == typeid ( EgoEntity )) { openscenario_msgs :: msg :: EntityType type ; type . type = openscenario_msgs :: msg :: EntityType :: EGO ; return type ; } if ( it -> second . type () == typeid ( PedestrianEntity )) { openscenario_msgs :: msg :: EntityType type ; type . type = openscenario_msgs :: msg :: EntityType :: PEDESTRIAN ; return type ; } throw simulation_api :: SimulationRuntimeError ( \"entity \" + name + \"does not exist\" ); } const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > EntityManager :: getEntityTypeList () const { std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > ret ; for ( auto it = entities_ . begin (); it != entities_ . end (); it ++ ) { if ( it -> second . type () == typeid ( VehicleEntity )) { openscenario_msgs :: msg :: EntityType type ; type . type = openscenario_msgs :: msg :: EntityType :: VEHICLE ; ret [ it -> first ] = type ; } if ( it -> second . type () == typeid ( EgoEntity )) { openscenario_msgs :: msg :: EntityType type ; type . type = openscenario_msgs :: msg :: EntityType :: EGO ; ret [ it -> first ] = type ; } if ( it -> second . type () == typeid ( PedestrianEntity )) { openscenario_msgs :: msg :: EntityType type ; type . type = openscenario_msgs :: msg :: EntityType :: PEDESTRIAN ; ret [ it -> first ] = type ; } } return ret ; } } // namespace entity } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/entity__manager_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/entity_manager.hpp # Namespaces # Name simulation_api::entity simulation_api Classes # Name class simulation_api::entity::LaneletMarkerQoS class simulation_api::entity::EntityMarkerQoS class simulation_api::entity::EntityManager Defines # Name FORWARD_TO_HDMAP_UTILS (NAME) DEFINE_SET_TRAFFIC_LIGHT (NAME) DEFINE_GET_TRAFFIC_LIGHT (NAME) Macro Documentation # define FORWARD_TO_HDMAP_UTILS # #define FORWARD_TO_HDMAP_UTILS( NAME ) template < typename ... Ts > \\ decltype ( auto ) NAME ( Ts && ... xs ) const \\ { \\ return hdmap_utils_ptr_ -> NAME ( std :: forward < decltype ( xs ) > ( xs )...); \\ } static_assert ( true , \"\" ) define DEFINE_SET_TRAFFIC_LIGHT # #define DEFINE_SET_TRAFFIC_LIGHT( NAME ) template < typename ... Ts > \\ decltype ( auto ) setTrafficLight ## NAME ( Ts && ... xs ) \\ { \\ return traffic_light_manager_ptr_ -> set ## NAME ( std :: forward < decltype ( xs ) > ( xs )...); \\ } static_assert ( true , \"\" ) define DEFINE_GET_TRAFFIC_LIGHT # #define DEFINE_GET_TRAFFIC_LIGHT( NAME ) template < typename ... Ts > \\ decltype ( auto ) getTrafficLight ## NAME ( Ts && ... xs ) \\ { \\ return traffic_light_manager_ptr_ -> get ## NAME ( std :: forward < decltype ( xs ) > ( xs )...); \\ } static_assert ( true , \"\" ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__ENTITY_MANAGER_HPP_ #define SIMULATION_API__ENTITY__ENTITY_MANAGER_HPP_ #include <simulation_api/entity/ego_entity.hpp> #include <simulation_api/entity/exception.hpp> #include <simulation_api/entity/pedestrian_entity.hpp> #include <simulation_api/entity/vehicle_entity.hpp> #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <simulation_api/traffic/traffic_sink.hpp> #include <simulation_api/traffic_lights/traffic_light_manager.hpp> #include <autoware_auto_msgs/msg/vehicle_control_command.hpp> #include <autoware_auto_msgs/msg/vehicle_kinematic_state.hpp> #include <autoware_auto_msgs/msg/vehicle_state_command.hpp> #include <boost/any.hpp> #include <boost/optional.hpp> #include <openscenario_msgs/msg/bounding_box.hpp> #include <openscenario_msgs/msg/driver_model.hpp> #include <openscenario_msgs/msg/entity_status_with_trajectory_array.hpp> #include <openscenario_msgs/msg/vehicle_parameters.hpp> #include <rclcpp/rclcpp.hpp> #include <tf2/LinearMath/Quaternion.h> #include <tf2_geometry_msgs/tf2_geometry_msgs.h> #include <tf2_ros/static_transform_broadcaster.h> #include <tf2_ros/transform_broadcaster.h> #include <visualization_msgs/msg/marker_array.hpp> #include <map> #include <memory> #include <stdexcept> // TODO(yamacir-kit): Remove this! #include <string> #include <type_traits> #include <typeinfo> #include <unordered_map> #include <utility> #include <vector> namespace simulation_api { namespace entity { class LaneletMarkerQoS : public rclcpp :: QoS { public : explicit LaneletMarkerQoS ( std :: size_t depth = 1 ) : rclcpp :: QoS ( depth ) { transient_local (); } }; class EntityMarkerQoS : public rclcpp :: QoS { public : explicit EntityMarkerQoS ( std :: size_t depth = 100 ) : rclcpp :: QoS ( depth ) {} }; class EntityManager { private : bool verbose_ ; tf2_ros :: StaticTransformBroadcaster broadcaster_ ; tf2_ros :: TransformBroadcaster base_link_broadcaster_ ; rclcpp :: Clock :: SharedPtr clock_ptr_ ; std :: unordered_map < std :: string , boost :: any > entities_ ; // rclcpp::TimerBase::SharedPtr hdmap_marker_timer_; boost :: optional < autoware_auto_msgs :: msg :: VehicleControlCommand > control_cmd_ ; boost :: optional < autoware_auto_msgs :: msg :: VehicleStateCommand > state_cmd_ ; double step_time_ ; double current_time_ ; using EntityStatusWithTrajectoryArray = openscenario_msgs :: msg :: EntityStatusWithTrajectoryArray ; rclcpp :: Publisher < EntityStatusWithTrajectoryArray >:: SharedPtr entity_status_array_pub_ptr_ ; using MarkerArray = visualization_msgs :: msg :: MarkerArray ; rclcpp :: Publisher < MarkerArray >:: SharedPtr lanelet_marker_pub_ptr_ ; MarkerArray markers_raw_ ; using VehicleKinematicState = autoware_auto_msgs :: msg :: VehicleKinematicState ; rclcpp :: Publisher < VehicleKinematicState >:: SharedPtr kinematic_state_pub_ptr_ ; std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ptr_ ; std :: shared_ptr < TrafficLightManager > traffic_light_manager_ptr_ ; std :: size_t getNumberOfEgo () const ; public : #define DEFINE_SET_TRAFFIC_LIGHT(NAME) \\ template<typename ... Ts> \\ decltype(auto) setTrafficLight ## NAME(Ts && ... xs) \\ { \\ return traffic_light_manager_ptr_->set ## NAME(std::forward<decltype(xs)>(xs)...); \\ } static_assert(true, \"\") DEFINE_SET_TRAFFIC_LIGHT ( Arrow ); DEFINE_SET_TRAFFIC_LIGHT ( ArrowPhase ); DEFINE_SET_TRAFFIC_LIGHT ( Color ); DEFINE_SET_TRAFFIC_LIGHT ( ColorPhase ); #undef DEFINE_SET_TRAFFIC_LIGHT #define DEFINE_GET_TRAFFIC_LIGHT(NAME) \\ template<typename ... Ts> \\ decltype(auto) getTrafficLight ## NAME(Ts && ... xs) \\ { \\ return traffic_light_manager_ptr_->get ## NAME(std::forward<decltype(xs)>(xs)...); \\ } static_assert(true, \"\") DEFINE_GET_TRAFFIC_LIGHT ( Color ); DEFINE_GET_TRAFFIC_LIGHT ( Arrow ); #undef DEFINE_GET_TRAFFIC_LIGHT #define FORWARD_TO_HDMAP_UTILS(NAME) \\ template<typename ... Ts> \\ decltype(auto) NAME(Ts && ... xs) const \\ { \\ return hdmap_utils_ptr_->NAME(std::forward<decltype(xs)>(xs)...); \\ } static_assert(true, \"\") FORWARD_TO_HDMAP_UTILS ( toLaneletPose ); // FORWARD_TO_HDMAP_UTILS(toMapPose); public : template < class NodeT , class AllocatorT = std :: allocator < void >> explicit EntityManager ( NodeT && node , const std :: string & map_path ) : verbose_ ( false ), broadcaster_ ( node ), base_link_broadcaster_ ( node ), clock_ptr_ ( node -> get_clock ()), entity_status_array_pub_ptr_ ( rclcpp :: create_publisher < EntityStatusWithTrajectoryArray > ( node , \"entity/status\" , EntityMarkerQoS (), rclcpp :: PublisherOptionsWithAllocator < AllocatorT > ())), lanelet_marker_pub_ptr_ ( rclcpp :: create_publisher < MarkerArray > ( node , \"lanelet/marker\" , LaneletMarkerQoS (), rclcpp :: PublisherOptionsWithAllocator < AllocatorT > ())), kinematic_state_pub_ptr_ ( rclcpp :: create_publisher < VehicleKinematicState > ( node , \"output/kinematic_state\" , LaneletMarkerQoS (), rclcpp :: PublisherOptionsWithAllocator < AllocatorT > ())) { geographic_msgs :: msg :: GeoPoint origin ; { node -> declare_parameter ( \"origin_latitude\" , 0.0 ); node -> declare_parameter ( \"origin_longitude\" , 0.0 ); // node->declare_parameter(\"origin_altitude\", 0.0); node -> get_parameter ( \"origin_latitude\" , origin . latitude ); node -> get_parameter ( \"origin_longitude\" , origin . longitude ); // node->get_parameter(\"origin_altitude\", origin.altitude); node -> undeclare_parameter ( \"origin_latitude\" ); node -> undeclare_parameter ( \"origin_longitude\" ); // node->undeclare_parameter(\"origin_altitude\"); } hdmap_utils_ptr_ = std :: make_shared < hdmap_utils :: HdMapUtils > ( map_path , origin ); markers_raw_ = hdmap_utils_ptr_ -> generateMarker (); updateHdmapMarker (); const auto traffic_light_marker_pub = rclcpp :: create_publisher < MarkerArray > ( node , \"traffic_light/marker\" , LaneletMarkerQoS (), rclcpp :: PublisherOptionsWithAllocator < AllocatorT > ()); traffic_light_manager_ptr_ = std :: make_shared < TrafficLightManager > ( hdmap_utils_ptr_ , traffic_light_marker_pub , clock_ptr_ ); } ~ EntityManager () = default ; void updateHdmapMarker () { MarkerArray markers ; const auto stamp = clock_ptr_ -> now (); for ( const auto & marker_raw : markers_raw_ . markers ) { visualization_msgs :: msg :: Marker marker = marker_raw ; marker . header . stamp = stamp ; markers . markers . emplace_back ( marker ); } lanelet_marker_pub_ptr_ -> publish ( markers ); } const std :: shared_ptr < hdmap_utils :: HdMapUtils > getHdmapUtils (); boost :: optional < double > getLinearJerk ( const std :: string & name ) const ; double getStepTime () const noexcept ; double getCurrentTime () const noexcept ; void setDriverModel ( const std :: string & name , const openscenario_msgs :: msg :: DriverModel & model ); const openscenario_msgs :: msg :: BoundingBox getBoundingBox ( const std :: string & name ) const ; const geometry_msgs :: msg :: Pose toMapPose ( const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ) const ; bool checkCollision ( const std :: string & name0 , const std :: string & name1 ); void setVerbose ( bool verbose ); void requestAcquirePosition ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ); void requestAssignRoute ( const std :: string & name , const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ); void requestLaneChange ( const std :: string & name , std :: int64_t to_lanelet_id ); void requestLaneChange ( const std :: string & name , const Direction & direction ); void requestWalkStraight ( const std :: string & name ); std :: vector < std :: int64_t > getConflictingEntityOnRouteLanelets ( const std :: string & name , const double horizon ); std :: vector < std :: int64_t > getRouteLanelets ( const std :: string & name , const double horizon ); openscenario_msgs :: msg :: WaypointsArray getWaypoints ( const std :: string & name ); boost :: optional < openscenario_msgs :: msg :: Obstacle > getObstacle ( const std :: string & name ); boost :: optional < double > getLongitudinalDistance ( const std :: string & from , const std :: string & to , const double max_distance = 100 ); boost :: optional < double > getBoundingBoxDistance ( const std :: string & from , const std :: string & to ); geometry_msgs :: msg :: Pose getRelativePose ( const std :: string & from , const std :: string & to ); geometry_msgs :: msg :: Pose getRelativePose ( const std :: string & from , const geometry_msgs :: msg :: Pose & to ); geometry_msgs :: msg :: Pose getRelativePose ( const geometry_msgs :: msg :: Pose & from , const std :: string & to ); geometry_msgs :: msg :: Pose getRelativePose ( const geometry_msgs :: msg :: Pose & from , const geometry_msgs :: msg :: Pose & to ) const ; geometry_msgs :: msg :: Pose getMapPose ( const std :: string & entity_name ); geometry_msgs :: msg :: Pose getMapPose ( const std :: string & reference_entity_name , const geometry_msgs :: msg :: Pose & relative_pose ); const boost :: optional < openscenario_msgs :: msg :: VehicleParameters > getVehicleParameters ( const std :: string & name ) const ; const std :: vector < std :: string > getEntityNames () const ; bool setEntityStatus ( const std :: string & name , openscenario_msgs :: msg :: EntityStatus status ); const boost :: optional < openscenario_msgs :: msg :: EntityStatus > getEntityStatus ( const std :: string & name ) const ; boost :: optional < double > getSValueInRoute ( const std :: string & name , const std :: vector < std :: int64_t > & route ); bool isInLanelet ( const std :: string & name , const std :: int64_t lanelet_id , const double tolerance ); bool entityStatusSetted ( const std :: string & name ) const ; void setTargetSpeed ( const std :: string & name , const double target_speed , const bool continuous ); void update ( const double current_time , const double step_time ); void broadcastTransform ( const geometry_msgs :: msg :: PoseStamped & pose , const bool static_transform = true ); boost :: optional < double > getDistanceToStopLine ( const std :: string & name , const std :: int64_t target_stop_line_id ); boost :: optional < double > getDistanceToCrosswalk ( const std :: string & name , const std :: int64_t target_crosswalk_id ); bool reachPosition ( const std :: string & name , const geometry_msgs :: msg :: Pose & target_pose , const double tolerance ) const ; bool reachPosition ( const std :: string & name , const std :: int64_t lanelet_id , const double s , const double offset , const double tolerance ) const ; bool reachPosition ( const std :: string & name , const std :: string & target_name , const double tolerance ) const ; void broadcastEntityTransform (); void broadcastBaseLinkTransform (); const boost :: optional < double > getStandStillDuration ( const std :: string & name ) const ; bool isStopping ( const std :: string & name ) const ; const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > getEntityTypeList () const ; bool isEgo ( const std :: string & name ) const ; openscenario_msgs :: msg :: EntityType getEntityType ( const std :: string & name ) const ; const std :: string getCurrentAction ( const std :: string & name ) const ; boost :: optional < openscenario_msgs :: msg :: LaneletPose > getLaneletPose ( const std :: string & name ); template < typename Entity , typename = typename std :: enable_if < std :: is_base_of < EntityBase , typename std :: decay < Entity >:: type >:: value >:: type > bool spawnEntity ( Entity && entity ) { if ( entities_ . count ( entity . name ) != 0 ) { throw simulation_api :: SimulationRuntimeError ( \"entity \" + entity . name + \" already exist.\" ); } else { entity . setHdMapUtils ( hdmap_utils_ptr_ ); entity . setTrafficLightManager ( traffic_light_manager_ptr_ ); entities_ . emplace ( entity . name , std :: forward < decltype ( entity ) > ( entity )); return true ; } } bool despawnEntity ( const std :: string & name ) { return entityExists ( name ) && entities_ . erase ( name ); } bool entityExists ( const std :: string & name ) { return entities_ . find ( name ) != std :: end ( entities_ ); } decltype ( auto ) reference ( const std :: string & name ) { const auto iter = entities_ . find ( name ); if ( iter != std :: end ( entities_ )) { return std :: get < 1 > ( * iter ); } else { std :: stringstream ss {}; ss << \"Unknown entity '\" << name << \"' has been referenced.\" ; ss << \"Check the scenario.\" ; throw SimulationRuntimeError ( ss . str ()); } } }; } // namespace entity } // namespace simulation_api #endif // SIMULATION_API__ENTITY__ENTITY_MANAGER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/entity_manager.hpp"},{"location":"package/simulation_api/markdown/Files/entity__manager_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apientityentity_managerhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/entity_manager.hpp"},{"location":"package/simulation_api/markdown/Files/entity__manager_8hpp/#namespaces","text":"Name simulation_api::entity simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/entity__manager_8hpp/#classes","text":"Name class simulation_api::entity::LaneletMarkerQoS class simulation_api::entity::EntityMarkerQoS class simulation_api::entity::EntityManager","title":"Classes"},{"location":"package/simulation_api/markdown/Files/entity__manager_8hpp/#defines","text":"Name FORWARD_TO_HDMAP_UTILS (NAME) DEFINE_SET_TRAFFIC_LIGHT (NAME) DEFINE_GET_TRAFFIC_LIGHT (NAME)","title":"Defines"},{"location":"package/simulation_api/markdown/Files/entity__manager_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/simulation_api/markdown/Files/entity__manager_8hpp/#define-forward_to_hdmap_utils","text":"#define FORWARD_TO_HDMAP_UTILS( NAME ) template < typename ... Ts > \\ decltype ( auto ) NAME ( Ts && ... xs ) const \\ { \\ return hdmap_utils_ptr_ -> NAME ( std :: forward < decltype ( xs ) > ( xs )...); \\ } static_assert ( true , \"\" )","title":"define FORWARD_TO_HDMAP_UTILS"},{"location":"package/simulation_api/markdown/Files/entity__manager_8hpp/#define-define_set_traffic_light","text":"#define DEFINE_SET_TRAFFIC_LIGHT( NAME ) template < typename ... Ts > \\ decltype ( auto ) setTrafficLight ## NAME ( Ts && ... xs ) \\ { \\ return traffic_light_manager_ptr_ -> set ## NAME ( std :: forward < decltype ( xs ) > ( xs )...); \\ } static_assert ( true , \"\" )","title":"define DEFINE_SET_TRAFFIC_LIGHT"},{"location":"package/simulation_api/markdown/Files/entity__manager_8hpp/#define-define_get_traffic_light","text":"#define DEFINE_GET_TRAFFIC_LIGHT( NAME ) template < typename ... Ts > \\ decltype ( auto ) getTrafficLight ## NAME ( Ts && ... xs ) \\ { \\ return traffic_light_manager_ptr_ -> get ## NAME ( std :: forward < decltype ( xs ) > ( xs )...); \\ } static_assert ( true , \"\" )","title":"define DEFINE_GET_TRAFFIC_LIGHT"},{"location":"package/simulation_api/markdown/Files/entity__manager_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__ENTITY_MANAGER_HPP_ #define SIMULATION_API__ENTITY__ENTITY_MANAGER_HPP_ #include <simulation_api/entity/ego_entity.hpp> #include <simulation_api/entity/exception.hpp> #include <simulation_api/entity/pedestrian_entity.hpp> #include <simulation_api/entity/vehicle_entity.hpp> #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <simulation_api/traffic/traffic_sink.hpp> #include <simulation_api/traffic_lights/traffic_light_manager.hpp> #include <autoware_auto_msgs/msg/vehicle_control_command.hpp> #include <autoware_auto_msgs/msg/vehicle_kinematic_state.hpp> #include <autoware_auto_msgs/msg/vehicle_state_command.hpp> #include <boost/any.hpp> #include <boost/optional.hpp> #include <openscenario_msgs/msg/bounding_box.hpp> #include <openscenario_msgs/msg/driver_model.hpp> #include <openscenario_msgs/msg/entity_status_with_trajectory_array.hpp> #include <openscenario_msgs/msg/vehicle_parameters.hpp> #include <rclcpp/rclcpp.hpp> #include <tf2/LinearMath/Quaternion.h> #include <tf2_geometry_msgs/tf2_geometry_msgs.h> #include <tf2_ros/static_transform_broadcaster.h> #include <tf2_ros/transform_broadcaster.h> #include <visualization_msgs/msg/marker_array.hpp> #include <map> #include <memory> #include <stdexcept> // TODO(yamacir-kit): Remove this! #include <string> #include <type_traits> #include <typeinfo> #include <unordered_map> #include <utility> #include <vector> namespace simulation_api { namespace entity { class LaneletMarkerQoS : public rclcpp :: QoS { public : explicit LaneletMarkerQoS ( std :: size_t depth = 1 ) : rclcpp :: QoS ( depth ) { transient_local (); } }; class EntityMarkerQoS : public rclcpp :: QoS { public : explicit EntityMarkerQoS ( std :: size_t depth = 100 ) : rclcpp :: QoS ( depth ) {} }; class EntityManager { private : bool verbose_ ; tf2_ros :: StaticTransformBroadcaster broadcaster_ ; tf2_ros :: TransformBroadcaster base_link_broadcaster_ ; rclcpp :: Clock :: SharedPtr clock_ptr_ ; std :: unordered_map < std :: string , boost :: any > entities_ ; // rclcpp::TimerBase::SharedPtr hdmap_marker_timer_; boost :: optional < autoware_auto_msgs :: msg :: VehicleControlCommand > control_cmd_ ; boost :: optional < autoware_auto_msgs :: msg :: VehicleStateCommand > state_cmd_ ; double step_time_ ; double current_time_ ; using EntityStatusWithTrajectoryArray = openscenario_msgs :: msg :: EntityStatusWithTrajectoryArray ; rclcpp :: Publisher < EntityStatusWithTrajectoryArray >:: SharedPtr entity_status_array_pub_ptr_ ; using MarkerArray = visualization_msgs :: msg :: MarkerArray ; rclcpp :: Publisher < MarkerArray >:: SharedPtr lanelet_marker_pub_ptr_ ; MarkerArray markers_raw_ ; using VehicleKinematicState = autoware_auto_msgs :: msg :: VehicleKinematicState ; rclcpp :: Publisher < VehicleKinematicState >:: SharedPtr kinematic_state_pub_ptr_ ; std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ptr_ ; std :: shared_ptr < TrafficLightManager > traffic_light_manager_ptr_ ; std :: size_t getNumberOfEgo () const ; public : #define DEFINE_SET_TRAFFIC_LIGHT(NAME) \\ template<typename ... Ts> \\ decltype(auto) setTrafficLight ## NAME(Ts && ... xs) \\ { \\ return traffic_light_manager_ptr_->set ## NAME(std::forward<decltype(xs)>(xs)...); \\ } static_assert(true, \"\") DEFINE_SET_TRAFFIC_LIGHT ( Arrow ); DEFINE_SET_TRAFFIC_LIGHT ( ArrowPhase ); DEFINE_SET_TRAFFIC_LIGHT ( Color ); DEFINE_SET_TRAFFIC_LIGHT ( ColorPhase ); #undef DEFINE_SET_TRAFFIC_LIGHT #define DEFINE_GET_TRAFFIC_LIGHT(NAME) \\ template<typename ... Ts> \\ decltype(auto) getTrafficLight ## NAME(Ts && ... xs) \\ { \\ return traffic_light_manager_ptr_->get ## NAME(std::forward<decltype(xs)>(xs)...); \\ } static_assert(true, \"\") DEFINE_GET_TRAFFIC_LIGHT ( Color ); DEFINE_GET_TRAFFIC_LIGHT ( Arrow ); #undef DEFINE_GET_TRAFFIC_LIGHT #define FORWARD_TO_HDMAP_UTILS(NAME) \\ template<typename ... Ts> \\ decltype(auto) NAME(Ts && ... xs) const \\ { \\ return hdmap_utils_ptr_->NAME(std::forward<decltype(xs)>(xs)...); \\ } static_assert(true, \"\") FORWARD_TO_HDMAP_UTILS ( toLaneletPose ); // FORWARD_TO_HDMAP_UTILS(toMapPose); public : template < class NodeT , class AllocatorT = std :: allocator < void >> explicit EntityManager ( NodeT && node , const std :: string & map_path ) : verbose_ ( false ), broadcaster_ ( node ), base_link_broadcaster_ ( node ), clock_ptr_ ( node -> get_clock ()), entity_status_array_pub_ptr_ ( rclcpp :: create_publisher < EntityStatusWithTrajectoryArray > ( node , \"entity/status\" , EntityMarkerQoS (), rclcpp :: PublisherOptionsWithAllocator < AllocatorT > ())), lanelet_marker_pub_ptr_ ( rclcpp :: create_publisher < MarkerArray > ( node , \"lanelet/marker\" , LaneletMarkerQoS (), rclcpp :: PublisherOptionsWithAllocator < AllocatorT > ())), kinematic_state_pub_ptr_ ( rclcpp :: create_publisher < VehicleKinematicState > ( node , \"output/kinematic_state\" , LaneletMarkerQoS (), rclcpp :: PublisherOptionsWithAllocator < AllocatorT > ())) { geographic_msgs :: msg :: GeoPoint origin ; { node -> declare_parameter ( \"origin_latitude\" , 0.0 ); node -> declare_parameter ( \"origin_longitude\" , 0.0 ); // node->declare_parameter(\"origin_altitude\", 0.0); node -> get_parameter ( \"origin_latitude\" , origin . latitude ); node -> get_parameter ( \"origin_longitude\" , origin . longitude ); // node->get_parameter(\"origin_altitude\", origin.altitude); node -> undeclare_parameter ( \"origin_latitude\" ); node -> undeclare_parameter ( \"origin_longitude\" ); // node->undeclare_parameter(\"origin_altitude\"); } hdmap_utils_ptr_ = std :: make_shared < hdmap_utils :: HdMapUtils > ( map_path , origin ); markers_raw_ = hdmap_utils_ptr_ -> generateMarker (); updateHdmapMarker (); const auto traffic_light_marker_pub = rclcpp :: create_publisher < MarkerArray > ( node , \"traffic_light/marker\" , LaneletMarkerQoS (), rclcpp :: PublisherOptionsWithAllocator < AllocatorT > ()); traffic_light_manager_ptr_ = std :: make_shared < TrafficLightManager > ( hdmap_utils_ptr_ , traffic_light_marker_pub , clock_ptr_ ); } ~ EntityManager () = default ; void updateHdmapMarker () { MarkerArray markers ; const auto stamp = clock_ptr_ -> now (); for ( const auto & marker_raw : markers_raw_ . markers ) { visualization_msgs :: msg :: Marker marker = marker_raw ; marker . header . stamp = stamp ; markers . markers . emplace_back ( marker ); } lanelet_marker_pub_ptr_ -> publish ( markers ); } const std :: shared_ptr < hdmap_utils :: HdMapUtils > getHdmapUtils (); boost :: optional < double > getLinearJerk ( const std :: string & name ) const ; double getStepTime () const noexcept ; double getCurrentTime () const noexcept ; void setDriverModel ( const std :: string & name , const openscenario_msgs :: msg :: DriverModel & model ); const openscenario_msgs :: msg :: BoundingBox getBoundingBox ( const std :: string & name ) const ; const geometry_msgs :: msg :: Pose toMapPose ( const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ) const ; bool checkCollision ( const std :: string & name0 , const std :: string & name1 ); void setVerbose ( bool verbose ); void requestAcquirePosition ( const std :: string & name , const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ); void requestAssignRoute ( const std :: string & name , const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ); void requestLaneChange ( const std :: string & name , std :: int64_t to_lanelet_id ); void requestLaneChange ( const std :: string & name , const Direction & direction ); void requestWalkStraight ( const std :: string & name ); std :: vector < std :: int64_t > getConflictingEntityOnRouteLanelets ( const std :: string & name , const double horizon ); std :: vector < std :: int64_t > getRouteLanelets ( const std :: string & name , const double horizon ); openscenario_msgs :: msg :: WaypointsArray getWaypoints ( const std :: string & name ); boost :: optional < openscenario_msgs :: msg :: Obstacle > getObstacle ( const std :: string & name ); boost :: optional < double > getLongitudinalDistance ( const std :: string & from , const std :: string & to , const double max_distance = 100 ); boost :: optional < double > getBoundingBoxDistance ( const std :: string & from , const std :: string & to ); geometry_msgs :: msg :: Pose getRelativePose ( const std :: string & from , const std :: string & to ); geometry_msgs :: msg :: Pose getRelativePose ( const std :: string & from , const geometry_msgs :: msg :: Pose & to ); geometry_msgs :: msg :: Pose getRelativePose ( const geometry_msgs :: msg :: Pose & from , const std :: string & to ); geometry_msgs :: msg :: Pose getRelativePose ( const geometry_msgs :: msg :: Pose & from , const geometry_msgs :: msg :: Pose & to ) const ; geometry_msgs :: msg :: Pose getMapPose ( const std :: string & entity_name ); geometry_msgs :: msg :: Pose getMapPose ( const std :: string & reference_entity_name , const geometry_msgs :: msg :: Pose & relative_pose ); const boost :: optional < openscenario_msgs :: msg :: VehicleParameters > getVehicleParameters ( const std :: string & name ) const ; const std :: vector < std :: string > getEntityNames () const ; bool setEntityStatus ( const std :: string & name , openscenario_msgs :: msg :: EntityStatus status ); const boost :: optional < openscenario_msgs :: msg :: EntityStatus > getEntityStatus ( const std :: string & name ) const ; boost :: optional < double > getSValueInRoute ( const std :: string & name , const std :: vector < std :: int64_t > & route ); bool isInLanelet ( const std :: string & name , const std :: int64_t lanelet_id , const double tolerance ); bool entityStatusSetted ( const std :: string & name ) const ; void setTargetSpeed ( const std :: string & name , const double target_speed , const bool continuous ); void update ( const double current_time , const double step_time ); void broadcastTransform ( const geometry_msgs :: msg :: PoseStamped & pose , const bool static_transform = true ); boost :: optional < double > getDistanceToStopLine ( const std :: string & name , const std :: int64_t target_stop_line_id ); boost :: optional < double > getDistanceToCrosswalk ( const std :: string & name , const std :: int64_t target_crosswalk_id ); bool reachPosition ( const std :: string & name , const geometry_msgs :: msg :: Pose & target_pose , const double tolerance ) const ; bool reachPosition ( const std :: string & name , const std :: int64_t lanelet_id , const double s , const double offset , const double tolerance ) const ; bool reachPosition ( const std :: string & name , const std :: string & target_name , const double tolerance ) const ; void broadcastEntityTransform (); void broadcastBaseLinkTransform (); const boost :: optional < double > getStandStillDuration ( const std :: string & name ) const ; bool isStopping ( const std :: string & name ) const ; const std :: unordered_map < std :: string , openscenario_msgs :: msg :: EntityType > getEntityTypeList () const ; bool isEgo ( const std :: string & name ) const ; openscenario_msgs :: msg :: EntityType getEntityType ( const std :: string & name ) const ; const std :: string getCurrentAction ( const std :: string & name ) const ; boost :: optional < openscenario_msgs :: msg :: LaneletPose > getLaneletPose ( const std :: string & name ); template < typename Entity , typename = typename std :: enable_if < std :: is_base_of < EntityBase , typename std :: decay < Entity >:: type >:: value >:: type > bool spawnEntity ( Entity && entity ) { if ( entities_ . count ( entity . name ) != 0 ) { throw simulation_api :: SimulationRuntimeError ( \"entity \" + entity . name + \" already exist.\" ); } else { entity . setHdMapUtils ( hdmap_utils_ptr_ ); entity . setTrafficLightManager ( traffic_light_manager_ptr_ ); entities_ . emplace ( entity . name , std :: forward < decltype ( entity ) > ( entity )); return true ; } } bool despawnEntity ( const std :: string & name ) { return entityExists ( name ) && entities_ . erase ( name ); } bool entityExists ( const std :: string & name ) { return entities_ . find ( name ) != std :: end ( entities_ ); } decltype ( auto ) reference ( const std :: string & name ) { const auto iter = entities_ . find ( name ); if ( iter != std :: end ( entities_ )) { return std :: get < 1 > ( * iter ); } else { std :: stringstream ss {}; ss << \"Unknown entity '\" << name << \"' has been referenced.\" ; ss << \"Check the scenario.\" ; throw SimulationRuntimeError ( ss . str ()); } } }; } // namespace entity } // namespace simulation_api #endif // SIMULATION_API__ENTITY__ENTITY_MANAGER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/exception_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/exception.hpp # Namespaces # Name simulation_api Classes # Name class simulation_api::SplineInterpolationError class simulation_api::SimulationRuntimeError Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__EXCEPTION_HPP_ #define SIMULATION_API__ENTITY__EXCEPTION_HPP_ #include <string> #include <exception> namespace simulation_api { class SimulationRuntimeError : public std :: runtime_error { public : explicit SimulationRuntimeError ( const char * message ) : runtime_error ( message ) {} explicit SimulationRuntimeError ( std :: string message ) : runtime_error ( message . c_str ()) {} }; class SplineInterpolationError : public std :: runtime_error { public : explicit SplineInterpolationError ( const char * message ) : runtime_error ( message ) {} }; } // namespace simulation_api #endif // SIMULATION_API__ENTITY__EXCEPTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/exception.hpp"},{"location":"package/simulation_api/markdown/Files/exception_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apientityexceptionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/exception.hpp"},{"location":"package/simulation_api/markdown/Files/exception_8hpp/#namespaces","text":"Name simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/exception_8hpp/#classes","text":"Name class simulation_api::SplineInterpolationError class simulation_api::SimulationRuntimeError","title":"Classes"},{"location":"package/simulation_api/markdown/Files/exception_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__EXCEPTION_HPP_ #define SIMULATION_API__ENTITY__EXCEPTION_HPP_ #include <string> #include <exception> namespace simulation_api { class SimulationRuntimeError : public std :: runtime_error { public : explicit SimulationRuntimeError ( const char * message ) : runtime_error ( message ) {} explicit SimulationRuntimeError ( std :: string message ) : runtime_error ( message . c_str ()) {} }; class SplineInterpolationError : public std :: runtime_error { public : explicit SplineInterpolationError ( const char * message ) : runtime_error ( message ) {} }; } // namespace simulation_api #endif // SIMULATION_API__ENTITY__EXCEPTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/follow__front__entity__action_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.cpp # Namespaces # Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <boost/algorithm/clamp.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { FollowFrontEntityAction :: FollowFrontEntityAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: VehicleActionNode ( name , config ) {} const boost :: optional < openscenario_msgs :: msg :: Obstacle > FollowFrontEntityAction :: calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) { if ( ! distance_to_front_entity_ ) { return boost :: none ; } if ( distance_to_front_entity_ . get () < 0 ) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( waypoints . waypoints ); if ( distance_to_front_entity_ . get () > spline . getLength ()) { return boost :: none ; } openscenario_msgs :: msg :: Obstacle obstacle ; obstacle . type = obstacle . ENTITY ; obstacle . s = distance_to_front_entity_ . get (); return obstacle ; } const openscenario_msgs :: msg :: WaypointsArray FollowFrontEntityAction :: calculateWaypoints () { if ( ! entity_status . lanelet_pose_valid ) { throw BehaviorTreeRuntimeError ( \"failed to assign lane\" ); } if ( entity_status . action_status . twist . linear . x >= 0 ) { openscenario_msgs :: msg :: WaypointsArray waypoints ; double horizon = boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x * 5 , 20 , 50 ); simulation_api :: math :: CatmullRomSpline spline ( hdmap_utils -> getCenterPoints ( route_lanelets )); waypoints . waypoints = spline . getTrajectory ( entity_status . lanelet_pose . s , entity_status . lanelet_pose . s + horizon , 1.0 ); return waypoints ; } else { return openscenario_msgs :: msg :: WaypointsArray (); } } BT :: NodeStatus FollowFrontEntityAction :: tick () { getBlackBoardValues (); if ( request != \"none\" && request != \"follow_lane\" ) { return BT :: NodeStatus :: FAILURE ; } if ( getRightOfWayEntities ( route_lanelets ). size () != 0 ) { return BT :: NodeStatus :: FAILURE ; } if ( ! driver_model . see_around ) { return BT :: NodeStatus :: FAILURE ; } const auto waypoints = calculateWaypoints (); auto distance_to_stopline = hdmap_utils -> getDistanceToStopLine ( route_lanelets , waypoints . waypoints ); auto distance_to_crossing_entity = getDistanceToConflictingEntity ( route_lanelets ); distance_to_front_entity_ = getDistanceToFrontEntity (); if ( ! distance_to_front_entity_ ) { return BT :: NodeStatus :: FAILURE ; } if ( distance_to_crossing_entity ) { if ( distance_to_front_entity_ . get () > distance_to_crossing_entity . get ()) { return BT :: NodeStatus :: FAILURE ; } } if ( distance_to_stopline ) { if ( distance_to_front_entity_ . get () > distance_to_stopline . get ()) { return BT :: NodeStatus :: FAILURE ; } } auto front_entity_status = getFrontEntityStatus (); if ( ! front_entity_status ) { return BT :: NodeStatus :: FAILURE ; } if ( distance_to_front_entity_ . get () >= ( calculateStopDistance () + vehicle_parameters . bounding_box . dimensions . x + 5 )) { auto entity_status_updated = calculateEntityStatusUpdated ( front_entity_status . get (). action_status . twist . linear . x + 2 ); setOutput ( \"updated_status\" , entity_status_updated ); return BT :: NodeStatus :: RUNNING ; } else if ( distance_to_front_entity_ . get () <= calculateStopDistance ()) { auto entity_status_updated = calculateEntityStatusUpdated ( front_entity_status . get (). action_status . twist . linear . x - 2 ); setOutput ( \"updated_status\" , entity_status_updated ); return BT :: NodeStatus :: RUNNING ; } else { auto entity_status_updated = calculateEntityStatusUpdated ( front_entity_status . get (). action_status . twist . linear . x ); setOutput ( \"updated_status\" , entity_status_updated ); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: RUNNING ; } } } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.cpp"},{"location":"package/simulation_api/markdown/Files/follow__front__entity__action_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorvehiclefollow_lane_sequencefollow_front_entity_actioncpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.cpp"},{"location":"package/simulation_api/markdown/Files/follow__front__entity__action_8cpp/#namespaces","text":"Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/follow__front__entity__action_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <boost/algorithm/clamp.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { FollowFrontEntityAction :: FollowFrontEntityAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: VehicleActionNode ( name , config ) {} const boost :: optional < openscenario_msgs :: msg :: Obstacle > FollowFrontEntityAction :: calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) { if ( ! distance_to_front_entity_ ) { return boost :: none ; } if ( distance_to_front_entity_ . get () < 0 ) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( waypoints . waypoints ); if ( distance_to_front_entity_ . get () > spline . getLength ()) { return boost :: none ; } openscenario_msgs :: msg :: Obstacle obstacle ; obstacle . type = obstacle . ENTITY ; obstacle . s = distance_to_front_entity_ . get (); return obstacle ; } const openscenario_msgs :: msg :: WaypointsArray FollowFrontEntityAction :: calculateWaypoints () { if ( ! entity_status . lanelet_pose_valid ) { throw BehaviorTreeRuntimeError ( \"failed to assign lane\" ); } if ( entity_status . action_status . twist . linear . x >= 0 ) { openscenario_msgs :: msg :: WaypointsArray waypoints ; double horizon = boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x * 5 , 20 , 50 ); simulation_api :: math :: CatmullRomSpline spline ( hdmap_utils -> getCenterPoints ( route_lanelets )); waypoints . waypoints = spline . getTrajectory ( entity_status . lanelet_pose . s , entity_status . lanelet_pose . s + horizon , 1.0 ); return waypoints ; } else { return openscenario_msgs :: msg :: WaypointsArray (); } } BT :: NodeStatus FollowFrontEntityAction :: tick () { getBlackBoardValues (); if ( request != \"none\" && request != \"follow_lane\" ) { return BT :: NodeStatus :: FAILURE ; } if ( getRightOfWayEntities ( route_lanelets ). size () != 0 ) { return BT :: NodeStatus :: FAILURE ; } if ( ! driver_model . see_around ) { return BT :: NodeStatus :: FAILURE ; } const auto waypoints = calculateWaypoints (); auto distance_to_stopline = hdmap_utils -> getDistanceToStopLine ( route_lanelets , waypoints . waypoints ); auto distance_to_crossing_entity = getDistanceToConflictingEntity ( route_lanelets ); distance_to_front_entity_ = getDistanceToFrontEntity (); if ( ! distance_to_front_entity_ ) { return BT :: NodeStatus :: FAILURE ; } if ( distance_to_crossing_entity ) { if ( distance_to_front_entity_ . get () > distance_to_crossing_entity . get ()) { return BT :: NodeStatus :: FAILURE ; } } if ( distance_to_stopline ) { if ( distance_to_front_entity_ . get () > distance_to_stopline . get ()) { return BT :: NodeStatus :: FAILURE ; } } auto front_entity_status = getFrontEntityStatus (); if ( ! front_entity_status ) { return BT :: NodeStatus :: FAILURE ; } if ( distance_to_front_entity_ . get () >= ( calculateStopDistance () + vehicle_parameters . bounding_box . dimensions . x + 5 )) { auto entity_status_updated = calculateEntityStatusUpdated ( front_entity_status . get (). action_status . twist . linear . x + 2 ); setOutput ( \"updated_status\" , entity_status_updated ); return BT :: NodeStatus :: RUNNING ; } else if ( distance_to_front_entity_ . get () <= calculateStopDistance ()) { auto entity_status_updated = calculateEntityStatusUpdated ( front_entity_status . get (). action_status . twist . linear . x - 2 ); setOutput ( \"updated_status\" , entity_status_updated ); return BT :: NodeStatus :: RUNNING ; } else { auto entity_status_updated = calculateEntityStatusUpdated ( front_entity_status . get (). action_status . twist . linear . x ); setOutput ( \"updated_status\" , entity_status_updated ); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: RUNNING ; } } } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/follow__front__entity__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.hpp # Namespaces # Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior Classes # Name class entity_behavior::vehicle::follow_lane_sequence::FollowFrontEntityAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__FOLLOW_FRONT_ENTITY_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__FOLLOW_FRONT_ENTITY_ACTION_HPP_ #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { class FollowFrontEntityAction : public entity_behavior :: VehicleActionNode { public : FollowFrontEntityAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: VehicleActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override ; const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override ; private : boost :: optional < double > distance_to_front_entity_ ; }; } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__FOLLOW_FRONT_ENTITY_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.hpp"},{"location":"package/simulation_api/markdown/Files/follow__front__entity__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorvehiclefollow_lane_sequencefollow_front_entity_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.hpp"},{"location":"package/simulation_api/markdown/Files/follow__front__entity__action_8hpp/#namespaces","text":"Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/follow__front__entity__action_8hpp/#classes","text":"Name class entity_behavior::vehicle::follow_lane_sequence::FollowFrontEntityAction","title":"Classes"},{"location":"package/simulation_api/markdown/Files/follow__front__entity__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__FOLLOW_FRONT_ENTITY_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__FOLLOW_FRONT_ENTITY_ACTION_HPP_ #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { class FollowFrontEntityAction : public entity_behavior :: VehicleActionNode { public : FollowFrontEntityAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: VehicleActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override ; const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override ; private : boost :: optional < double > distance_to_front_entity_ ; }; } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__FOLLOW_FRONT_ENTITY_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/hdmap__utils_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/hdmap_utils/hdmap_utils.cpp # Namespaces # Name hdmap_utils Defines # Name EXPERIMENTAL_AUTOWARE_IV_SUPPORT Macro Documentation # define EXPERIMENTAL_AUTOWARE_IV_SUPPORT # #define EXPERIMENTAL_AUTOWARE_IV_SUPPORT Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/color_utils/color_utils.hpp> #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <simulation_api/math/hermite_curve.hpp> #include <quaternion_operation/quaternion_operation.h> #include <lanelet2_core/utility/Units.h> #include <lanelet2_extension_psim/io/autoware_osm_parser.hpp> #include <lanelet2_extension_psim/projection/mgrs_projector.hpp> #include <lanelet2_extension_psim/utility/message_conversion.hpp> #include <lanelet2_extension_psim/utility/utilities.hpp> #include <lanelet2_extension_psim/utility/query.hpp> #include <lanelet2_extension_psim/visualization/visualization.hpp> #include <lanelet2_io/Io.h> #include <lanelet2_io/io_handlers/Serialize.h> #include <lanelet2_projection/UTM.h> #include <boost/archive/binary_iarchive.hpp> #include <boost/archive/binary_oarchive.hpp> #include <boost/geometry.hpp> #include <boost/geometry/geometries/point_xy.hpp> #include <boost/geometry/geometries/polygon.hpp> #include <boost/geometry/geometries/box.hpp> #include <boost/assign/list_of.hpp> #include <algorithm> #include <deque> #include <memory> #include <set> #include <string> #include <unordered_map> #include <utility> #include <vector> #define EXPERIMENTAL_AUTOWARE_IV_SUPPORT namespace hdmap_utils { HdMapUtils :: HdMapUtils ( std :: string lanelet_path , geographic_msgs :: msg :: GeoPoint origin ) { #ifndef EXPERIMENTAL_AUTOWARE_IV_SUPPORT lanelet :: GPSPoint origin_gps_point { origin . latitude , origin . longitude , origin . altitude }; lanelet :: Origin origin_lanelet { origin_gps_point }; lanelet :: projection :: UtmProjector projector ( origin_lanelet ); #else lanelet :: projection :: MGRSProjector projector {}; // TODO(yamacir-kit) #endif lanelet :: ErrorMessages errors ; lanelet_map_ptr_ = lanelet :: load ( lanelet_path , projector , & errors ); if ( ! errors . empty ()) { for ( const auto & error : errors ) { std :: cerr << error << std :: endl ; } throw HdMapError ( \"failed to load lanelet map\" ); } overwriteLaneletsCenterline (); traffic_rules_vehicle_ptr_ = lanelet :: traffic_rules :: TrafficRulesFactory :: create ( lanelet :: Locations :: Germany , lanelet :: Participants :: Vehicle ); vehicle_routing_graph_ptr_ = lanelet :: routing :: RoutingGraph :: build ( * lanelet_map_ptr_ , * traffic_rules_vehicle_ptr_ ); traffic_rules_pedestrian_ptr_ = lanelet :: traffic_rules :: TrafficRulesFactory :: create ( lanelet :: Locations :: Germany , lanelet :: Participants :: Pedestrian ); pedestrian_routing_graph_ptr_ = lanelet :: routing :: RoutingGraph :: build ( * lanelet_map_ptr_ , * traffic_rules_pedestrian_ptr_ ); std :: vector < lanelet :: routing :: RoutingGraphConstPtr > all_graphs ; all_graphs . push_back ( vehicle_routing_graph_ptr_ ); all_graphs . push_back ( pedestrian_routing_graph_ptr_ ); } const std :: vector < std :: int64_t > HdMapUtils :: getLaneletIds () { std :: vector < std :: int64_t > ret ; for ( const auto & lanelet : lanelet_map_ptr_ -> laneletLayer ) { ret . emplace_back ( lanelet . id ()); } return ret ; } const std :: vector < geometry_msgs :: msg :: Point > HdMapUtils :: getLaneletPolygon ( std :: int64_t lanelet_id ) { std :: vector < geometry_msgs :: msg :: Point > points ; lanelet :: CompoundPolygon3d lanelet_polygon = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ). polygon3d (); for ( const auto & lanelet_point : lanelet_polygon ) { geometry_msgs :: msg :: Point p ; p . x = lanelet_point . x (); p . y = lanelet_point . y (); p . z = lanelet_point . z (); points . emplace_back ( p ); } return points ; } double HdMapUtils :: getHeight ( const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ) { return toMapPose ( lanelet_pose ). pose . position . z ; } boost :: optional < double > HdMapUtils :: getCollisionPointInLaneCoordinate ( std :: int64_t lanelet_id , std :: int64_t crossing_lanelet_id ) { namespace bg = boost :: geometry ; using Point = bg :: model :: d2 :: point_xy < double > ; using Line = bg :: model :: linestring < Point > ; using Polygon = bg :: model :: polygon < Point , false > ; auto center_points = getCenterPoints ( lanelet_id ); std :: vector < Point > path_collision_points ; lanelet_map_ptr_ -> laneletLayer . get ( crossing_lanelet_id ); lanelet :: CompoundPolygon3d lanelet_polygon = lanelet_map_ptr_ -> laneletLayer . get ( crossing_lanelet_id ). polygon3d (); Polygon crosswalk_polygon ; for ( const auto & lanelet_point : lanelet_polygon ) { crosswalk_polygon . outer (). push_back ( bg :: make < Point > ( lanelet_point . x (), lanelet_point . y ())); } crosswalk_polygon . outer (). push_back ( crosswalk_polygon . outer (). front ()); double s_in_lanelet = 0 ; for ( size_t i = 0 ; i < center_points . size () - 1 ; ++ i ) { const auto p0 = center_points . at ( i ); const auto p1 = center_points . at ( i + 1 ); const Line line {{ p0 . x , p0 . y }, { p1 . x , p1 . y }}; double line_length = std :: sqrt ( std :: pow ( p0 . x - p1 . x , 2 ) + std :: pow ( p0 . y - p1 . y , 2 ) + std :: pow ( p0 . z - p1 . z , 2 )); std :: vector < Point > line_collision_points ; bg :: intersection ( crosswalk_polygon , line , line_collision_points ); if ( line_collision_points . empty ()) { continue ; } std :: vector < double > dist ; for ( size_t j = 0 ; j < line_collision_points . size (); ++ j ) { double s_in_line = 0 ; if ( std :: fabs ( p1 . x - p0 . x ) < DBL_EPSILON ) { if ( std :: fabs ( p1 . y - p1 . y < DBL_EPSILON )) {} else { s_in_line = ( line_collision_points [ j ]. y () - p0 . y ) / ( p1 . y - p0 . y ); return s_in_lanelet + s_in_line * line_length ; } } else { s_in_line = ( line_collision_points [ j ]. x () - p0 . x ) / ( p1 . x - p0 . x ); return s_in_lanelet + s_in_line * line_length ; } } s_in_lanelet = s_in_lanelet + line_length ; } return boost :: none ; } std :: vector < std :: int64_t > HdMapUtils :: getConflictingCrosswalkIds ( std :: vector < std :: int64_t > lanelet_ids ) const { std :: vector < std :: int64_t > ret ; std :: vector < lanelet :: routing :: RoutingGraphConstPtr > graphs ; graphs . emplace_back ( vehicle_routing_graph_ptr_ ); graphs . emplace_back ( pedestrian_routing_graph_ptr_ ); lanelet :: routing :: RoutingGraphContainer container ( graphs ); for ( const auto & lanelet_id : lanelet_ids ) { const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); double height_clearance = 4 ; size_t routing_graph_id = 1 ; const auto conflicting_crosswalks = container . conflictingInGraph ( lanelet , routing_graph_id , height_clearance ); for ( const auto & crosswalk : conflicting_crosswalks ) { ret . emplace_back ( crosswalk . id ()); } } return ret ; } std :: vector < geometry_msgs :: msg :: Point > HdMapUtils :: clipTrajectoryFromLaneletIds ( std :: int64_t lanelet_id , double s , std :: vector < std :: int64_t > lanelet_ids , double foward_distance ) { std :: vector < geometry_msgs :: msg :: Point > ret ; bool on_traj = false ; double rest_distance = foward_distance ; for ( auto id_itr = lanelet_ids . begin (); id_itr != lanelet_ids . end (); id_itr ++ ) { double l = getLaneletLength ( * id_itr ); if ( on_traj ) { if ( rest_distance < l ) { for ( double s_val = 0 ; s_val < rest_distance ; s_val = s_val + 1.0 ) { auto map_pose = toMapPose ( * id_itr , s_val , 0 ); ret . emplace_back ( map_pose . pose . position ); } break ; } else { rest_distance = rest_distance - l ; for ( double s_val = 0 ; s_val < l ; s_val = s_val + 1.0 ) { auto map_pose = toMapPose ( * id_itr , s_val , 0 ); ret . emplace_back ( map_pose . pose . position ); } continue ; } } if ( lanelet_id == * id_itr ) { on_traj = true ; if (( s + foward_distance ) < l ) { for ( double s_val = s ; s_val < s + foward_distance ; s_val = s_val + 1.0 ) { auto map_pose = toMapPose ( lanelet_id , s_val , 0 ); ret . emplace_back ( map_pose . pose . position ); } break ; } else { rest_distance = rest_distance - ( l - s ); for ( double s_val = s ; s_val < l ; s_val = s_val + 1.0 ) { auto map_pose = toMapPose ( lanelet_id , s_val , 0 ); ret . emplace_back ( map_pose . pose . position ); } continue ; } } } return ret ; } std :: vector < std :: pair < double , lanelet :: Lanelet >> HdMapUtils :: excludeSubtypeLaneletsWithDistance ( const std :: vector < std :: pair < double , lanelet :: Lanelet >> & lls , const char subtype []) { std :: vector < std :: pair < double , lanelet :: Lanelet >> exclude_subtype_lanelets ; for ( const auto & ll : lls ) { if ( ll . second . hasAttribute ( lanelet :: AttributeName :: Subtype )) { lanelet :: Attribute attr = ll . second . attribute ( lanelet :: AttributeName :: Subtype ); if ( attr . value () != subtype ) { exclude_subtype_lanelets . push_back ( ll ); } } } return exclude_subtype_lanelets ; } boost :: optional < openscenario_msgs :: msg :: LaneletPose > HdMapUtils :: toLaneletPose ( geometry_msgs :: msg :: Pose pose ) { const auto lanelet_id = getClosetLanletId ( pose ); if ( ! lanelet_id ) { return boost :: none ; } const auto center_points = getCenterPoints ( lanelet_id . get ()); simulation_api :: math :: CatmullRomSpline spline ( center_points ); const auto s = spline . getSValue ( pose . position ); if ( ! s ) { return boost :: none ; } auto pose_on_centerline = spline . getPose ( s . get ()); auto rpy = quaternion_operation :: convertQuaternionToEulerAngle ( quaternion_operation :: getRotation ( pose_on_centerline . orientation , pose . orientation )); double offset = spline . getSquaredDistanceIn2D ( pose . position , s . get ()); openscenario_msgs :: msg :: LaneletPose lanelet_pose ; lanelet_pose . lanelet_id = lanelet_id . get (); lanelet_pose . s = s . get (); lanelet_pose . offset = offset ; lanelet_pose . rpy = rpy ; return lanelet_pose ; } boost :: optional < std :: int64_t > HdMapUtils :: getClosetLanletId ( geometry_msgs :: msg :: Pose pose , double distance_thresh ) { lanelet :: BasicPoint2d search_point ( pose . position . x , pose . position . y ); std :: vector < std :: pair < double , lanelet :: Lanelet >> nearest_lanelet = lanelet :: geometry :: findNearest ( lanelet_map_ptr_ -> laneletLayer , search_point , 3 ); const auto nearest_road_lanelet = excludeSubtypeLaneletsWithDistance ( nearest_lanelet , lanelet :: AttributeValueString :: Crosswalk ); if ( nearest_road_lanelet . empty ()) { return boost :: none ; } if ( nearest_road_lanelet . front (). first > distance_thresh ) { return boost :: none ; } lanelet :: Lanelet closest_lanelet ; closest_lanelet = nearest_road_lanelet . front (). second ; return closest_lanelet . id (); } double HdMapUtils :: getSpeedLimit ( std :: vector < std :: int64_t > lanelet_ids ) { std :: vector < double > limits ; if ( lanelet_ids . empty ()) { throw HdMapError ( \"size of the vector lanelet ids should be more than 1\" ); } for ( auto itr = lanelet_ids . begin (); itr != lanelet_ids . end (); itr ++ ) { const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( * itr ); const auto limit = traffic_rules_vehicle_ptr_ -> speedLimit ( lanelet ); limits . push_back ( lanelet :: units :: KmHQuantity ( limit . speedLimit ). value () / 3.6 ); } return * std :: min_element ( limits . begin (), limits . end ()); } boost :: optional < int > HdMapUtils :: getLaneChangeableLenletId ( std :: int64_t lanelet_id , std :: string direction ) { const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); if ( direction == \"left\" ) { auto left_lanlet = vehicle_routing_graph_ptr_ -> left ( lanelet ); if ( left_lanlet ) { return left_lanlet -> id (); } } if ( direction == \"right\" ) { auto right_lanlet = vehicle_routing_graph_ptr_ -> right ( lanelet ); if ( right_lanlet ) { return right_lanlet -> id (); } } return boost :: none ; } std :: vector < std :: int64_t > HdMapUtils :: getPreviousLanelets ( std :: int64_t lanelet_id , double distance ) { std :: vector < std :: int64_t > ret ; double total_dist = 0.0 ; ret . push_back ( lanelet_id ); while ( total_dist < distance ) { auto ids = getPreviousLaneletIds ( lanelet_id , \"straight\" ); if ( ids . size () != 0 ) { lanelet_id = ids [ 0 ]; total_dist = total_dist + getLaneletLength ( lanelet_id ); ret . push_back ( lanelet_id ); continue ; } else { auto else_ids = getPreviousLaneletIds ( lanelet_id ); if ( else_ids . size () != 0 ) { lanelet_id = else_ids [ 0 ]; total_dist = total_dist + getLaneletLength ( lanelet_id ); ret . push_back ( lanelet_id ); continue ; } else { break ; } } } return ret ; } bool HdMapUtils :: isInRoute ( std :: int64_t lanelet_id , std :: vector < std :: int64_t > route ) const { for ( const auto id : route ) { if ( id == lanelet_id ) { return true ; } } return false ; } std :: vector < std :: int64_t > HdMapUtils :: getFollowingLanelets ( std :: int64_t lanelet_id , std :: vector < std :: int64_t > candidate_lanelet_ids , double distance , bool include_self ) { if ( candidate_lanelet_ids . empty ()) { return {}; } std :: vector < std :: int64_t > ret ; double total_dist = 0.0 ; bool found = false ; for ( const auto id : candidate_lanelet_ids ) { if ( found ) { ret . emplace_back ( id ); total_dist = total_dist + getLaneletLength ( id ); if ( total_dist > distance ) { return ret ; } } if ( id == lanelet_id ) { found = true ; if ( include_self ) { ret . emplace_back ( id ); } } } if ( ! found ) { throw HdMapError ( \"lanelet id did not match.\" ); } if ( total_dist > distance ) { return ret ; } std :: int64_t end_lanelet = candidate_lanelet_ids [ candidate_lanelet_ids . size () - 1 ]; const auto followings = getFollowingLanelets ( end_lanelet , distance - total_dist , false ); std :: copy ( followings . begin (), followings . end (), std :: back_inserter ( ret )); return ret ; } std :: vector < std :: int64_t > HdMapUtils :: getFollowingLanelets ( std :: int64_t lanelet_id , double distance , bool include_self ) { std :: vector < std :: int64_t > ret ; double total_dist = 0.0 ; if ( include_self ) { ret . push_back ( lanelet_id ); } while ( total_dist < distance ) { const auto straight_ids = getNextLaneletIds ( lanelet_id , \"straight\" ); if ( straight_ids . size () != 0 ) { lanelet_id = straight_ids [ 0 ]; total_dist = total_dist + getLaneletLength ( lanelet_id ); ret . push_back ( lanelet_id ); continue ; } const auto ids = getNextLaneletIds ( lanelet_id ); if ( ids . size () != 0 ) { lanelet_id = ids [ 0 ]; total_dist = total_dist + getLaneletLength ( lanelet_id ); ret . push_back ( lanelet_id ); continue ; } else { break ; } } return ret ; } std :: vector < std :: int64_t > HdMapUtils :: getRoute ( std :: int64_t from_lanelet_id , std :: int64_t to_lanelet_id ) { std :: vector < std :: int64_t > ret ; const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( from_lanelet_id ); const auto to_lanelet = lanelet_map_ptr_ -> laneletLayer . get ( to_lanelet_id ); lanelet :: Optional < lanelet :: routing :: Route > route = vehicle_routing_graph_ptr_ -> getRoute ( lanelet , to_lanelet , 0 , true ); if ( ! route ) { return ret ; } lanelet :: routing :: LaneletPath shortest_path = route -> shortestPath (); if ( shortest_path . empty ()) { return ret ; } for ( auto lane_itr = shortest_path . begin (); lane_itr != shortest_path . end (); lane_itr ++ ) { ret . push_back ( lane_itr -> id ()); } return ret ; } std :: vector < geometry_msgs :: msg :: Point > HdMapUtils :: getCenterPoints ( std :: vector < std :: int64_t > lanelet_ids ) { std :: vector < geometry_msgs :: msg :: Point > ret ; if ( lanelet_ids . empty ()) { return ret ; } for ( const auto lanelet_id : lanelet_ids ) { std :: vector < geometry_msgs :: msg :: Point > center_points = getCenterPoints ( lanelet_id ); std :: copy ( center_points . begin (), center_points . end (), std :: back_inserter ( ret )); } return ret ; } std :: vector < geometry_msgs :: msg :: Point > HdMapUtils :: getCenterPoints ( std :: int64_t lanelet_id ) { std :: vector < geometry_msgs :: msg :: Point > ret ; if ( ! lanelet_map_ptr_ ) { throw HdMapError ( \"lanelet map is null pointer.\" ); } if ( lanelet_map_ptr_ -> laneletLayer . empty ()) { throw HdMapError ( \"lanelet layer is empty.\" ); } const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto centerline = lanelet . centerline (); for ( const auto & point : centerline ) { geometry_msgs :: msg :: Point p ; p . x = point . x (); p . y = point . y (); p . z = point . z (); ret . push_back ( p ); } return ret ; } double HdMapUtils :: getLaneletLength ( std :: int64_t lanelet_id ) const { return lanelet :: utils :: getLaneletLength2d ( lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id )); } std :: vector < std :: int64_t > HdMapUtils :: getPreviousLaneletIds ( std :: int64_t lanelet_id ) const { std :: vector < std :: int64_t > ret ; const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto previous_lanelets = vehicle_routing_graph_ptr_ -> previous ( lanelet ); for ( const auto & llt : previous_lanelets ) { ret . push_back ( llt . id ()); } return ret ; } std :: vector < std :: int64_t > HdMapUtils :: getPreviousLaneletIds ( std :: int64_t lanelet_id , std :: string turn_direction ) { std :: vector < std :: int64_t > ret ; const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto previous_lanelets = vehicle_routing_graph_ptr_ -> previous ( lanelet ); for ( const auto & llt : previous_lanelets ) { const std :: string turn_direction_llt = llt . attributeOr ( \"turn_direction\" , \"else\" ); if ( turn_direction_llt == turn_direction ) { ret . push_back ( llt . id ()); } } return ret ; } std :: vector < std :: int64_t > HdMapUtils :: getNextLaneletIds ( std :: int64_t lanelet_id ) const { std :: vector < std :: int64_t > ret ; const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto following_lanelets = vehicle_routing_graph_ptr_ -> following ( lanelet ); for ( const auto & llt : following_lanelets ) { ret . push_back ( llt . id ()); } return ret ; } std :: vector < std :: int64_t > HdMapUtils :: getNextLaneletIds ( std :: int64_t lanelet_id , std :: string turn_direction ) { std :: vector < std :: int64_t > ret ; const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto following_lanelets = vehicle_routing_graph_ptr_ -> following ( lanelet ); for ( const auto & llt : following_lanelets ) { const std :: string turn_direction_llt = llt . attributeOr ( \"turn_direction\" , \"else\" ); if ( turn_direction_llt == turn_direction ) { ret . push_back ( llt . id ()); } } return ret ; } const std :: vector < std :: int64_t > HdMapUtils :: getTrafficLightIds () const { std :: vector < std :: int64_t > ret ; lanelet :: ConstLanelets all_lanelets = lanelet :: utils :: query :: laneletLayer ( lanelet_map_ptr_ ); auto autoware_traffic_lights = lanelet :: utils :: query :: autowareTrafficLights ( all_lanelets ); for ( const auto light : autoware_traffic_lights ) { for ( auto light_string : light -> lightBulbs ()) { if ( light_string . hasAttribute ( \"traffic_light_id\" )) { auto id = light_string . attribute ( \"traffic_light_id\" ). asId (); if ( id ) { ret . emplace_back ( id . get ()); } } } } return ret ; } const boost :: optional < geometry_msgs :: msg :: Point > HdMapUtils :: getTrafficLightBulbPosition ( std :: int64_t traffic_light_id , simulation_api :: TrafficLightColor color ) const { if ( color == simulation_api :: TrafficLightColor :: NONE ) { return boost :: none ; } lanelet :: ConstLanelets all_lanelets = lanelet :: utils :: query :: laneletLayer ( lanelet_map_ptr_ ); auto autoware_traffic_lights = lanelet :: utils :: query :: autowareTrafficLights ( all_lanelets ); for ( const auto light : autoware_traffic_lights ) { for ( auto light_string : light -> lightBulbs ()) { if ( light_string . hasAttribute ( \"traffic_light_id\" )) { auto id = light_string . attribute ( \"traffic_light_id\" ). asId (); if ( id ) { if ( id . get () == traffic_light_id ) { const auto light_bulbs = light -> lightBulbs (); for ( auto ls : light_bulbs ) { lanelet :: ConstLineString3d l = static_cast < lanelet :: ConstLineString3d > ( ls ); for ( auto pt : l ) { if ( pt . hasAttribute ( \"color\" )) { std :: string color_string ; switch ( color ) { case simulation_api :: TrafficLightColor :: GREEN : color_string = \"green\" ; break ; case simulation_api :: TrafficLightColor :: YELLOW : color_string = \"yellow\" ; break ; case simulation_api :: TrafficLightColor :: RED : color_string = \"red\" ; break ; case simulation_api :: TrafficLightColor :: NONE : return boost :: none ; } lanelet :: Attribute attr = pt . attribute ( \"color\" ); if ( attr . value (). compare ( color_string ) == 0 ) { geometry_msgs :: msg :: Point point ; point . x = pt . x (); point . y = pt . y (); point . z = pt . z (); return point ; } } } } } } } } } return boost :: none ; } boost :: optional < std :: pair < simulation_api :: math :: HermiteCurve , double >> HdMapUtils :: getLaneChangeTrajectory ( geometry_msgs :: msg :: Pose from_pose , std :: int64_t to_lanelet_id ) { double to_length = getLaneletLength ( to_lanelet_id ); std :: vector < double > evaluation , target_s ; std :: vector < simulation_api :: math :: HermiteCurve > curves ; for ( double to_s = 0 ; to_s < to_length ; to_s = to_s + 1.0 ) { auto goal_pose = toMapPose ( to_lanelet_id , to_s , 0 ); double start_to_goal_dist = std :: sqrt ( std :: pow ( from_pose . position . x - goal_pose . pose . position . x , 2 ) + std :: pow ( from_pose . position . y - goal_pose . pose . position . y , 2 ) + std :: pow ( from_pose . position . z - goal_pose . pose . position . z , 2 )); auto traj = getLaneChangeTrajectory ( from_pose , to_lanelet_id , to_s , start_to_goal_dist * 0.5 ); if ( traj ) { if ( traj -> getMaximu2DCurvature () < 1.0 ) { double eval = std :: fabs ( 20 - traj -> getLength ()); evaluation . push_back ( eval ); curves . push_back ( traj . get ()); target_s . push_back ( to_s ); } } } if ( evaluation . empty ()) { return boost :: none ; } std :: vector < double >:: iterator min_itr = std :: min_element ( evaluation . begin (), evaluation . end ()); size_t min_index = std :: distance ( evaluation . begin (), min_itr ); return std :: make_pair ( curves [ min_index ], target_s [ min_index ]); } boost :: optional < simulation_api :: math :: HermiteCurve > HdMapUtils :: getLaneChangeTrajectory ( geometry_msgs :: msg :: Pose from_pose , std :: int64_t to_lanelet_id , double to_s , double tangent_vector_size ) { std :: vector < geometry_msgs :: msg :: Point > ret ; auto to_vec = getTangentVector ( to_lanelet_id , to_s ); auto goal_pose = toMapPose ( to_lanelet_id , to_s , 0 ); geometry_msgs :: msg :: Vector3 start_vec = getVectorFromPose ( from_pose , tangent_vector_size ); geometry_msgs :: msg :: Vector3 goal_vec = to_vec . get (); goal_vec . x = goal_vec . x * tangent_vector_size ; goal_vec . y = goal_vec . y * tangent_vector_size ; goal_vec . z = goal_vec . z * tangent_vector_size ; simulation_api :: math :: HermiteCurve curve ( from_pose , goal_pose . pose , start_vec , goal_vec ); return curve ; } geometry_msgs :: msg :: Vector3 HdMapUtils :: getVectorFromPose ( geometry_msgs :: msg :: Pose pose , double magnitude ) { geometry_msgs :: msg :: Vector3 dir = quaternion_operation :: convertQuaternionToEulerAngle ( pose . orientation ); geometry_msgs :: msg :: Vector3 vector ; vector . x = magnitude * std :: cos ( dir . z ); vector . y = magnitude * std :: sin ( dir . z ); vector . z = 0 ; return vector ; } bool HdMapUtils :: isInLanelet ( std :: int64_t lanelet_id , double s ) { const auto center_points = getCenterPoints ( lanelet_id ); simulation_api :: math :: CatmullRomSpline spline ( center_points ); double l = spline . getLength (); if ( s > l ) { return false ; } else if ( s < 0 ) { return false ; } return true ; } std :: vector < geometry_msgs :: msg :: Point > HdMapUtils :: toMapPoints ( std :: int64_t lanelet_id , std :: vector < double > s ) { std :: vector < geometry_msgs :: msg :: Point > ret ; const auto center_points = getCenterPoints ( lanelet_id ); simulation_api :: math :: CatmullRomSpline spline ( center_points ); for ( const auto & s_value : s ) { ret . push_back ( spline . getPoint ( s_value )); } return ret ; } geometry_msgs :: msg :: PoseStamped HdMapUtils :: toMapPose ( std :: int64_t lanelet_id , double s , double offset , geometry_msgs :: msg :: Quaternion quat ) { geometry_msgs :: msg :: PoseStamped ret ; ret . header . frame_id = \"map\" ; const auto center_points = getCenterPoints ( lanelet_id ); simulation_api :: math :: CatmullRomSpline spline ( center_points ); ret . pose = spline . getPose ( s ); const auto tangent_vec = spline . getTangentVector ( s ); geometry_msgs :: msg :: Vector3 rpy ; rpy . x = 0.0 ; rpy . y = 0.0 ; rpy . z = std :: atan2 ( tangent_vec . y , tangent_vec . x ); ret . pose . position . x = ret . pose . position . x - std :: sin ( rpy . z ) * offset ; ret . pose . position . y = ret . pose . position . y - std :: cos ( rpy . z ) * offset ; ret . pose . position . z = ret . pose . position . z ; ret . pose . orientation = quaternion_operation :: convertEulerAngleToQuaternion ( rpy ); ret . pose . orientation = ret . pose . orientation * quat ; return ret ; } geometry_msgs :: msg :: PoseStamped HdMapUtils :: toMapPose ( openscenario_msgs :: msg :: LaneletPose lanlet_pose ) { return toMapPose ( lanlet_pose . lanelet_id , lanlet_pose . s , lanlet_pose . offset , quaternion_operation :: convertEulerAngleToQuaternion ( lanlet_pose . rpy )); } geometry_msgs :: msg :: PoseStamped HdMapUtils :: toMapPose ( std :: int64_t lanelet_id , double s , double offset ) { openscenario_msgs :: msg :: LaneletPose lanelet_pose ; lanelet_pose . lanelet_id = lanelet_id ; lanelet_pose . s = s ; lanelet_pose . offset = offset ; return toMapPose ( lanelet_pose ); } boost :: optional < geometry_msgs :: msg :: Vector3 > HdMapUtils :: getTangentVector ( std :: int64_t lanelet_id , double s ) { const auto center_points = getCenterPoints ( lanelet_id ); simulation_api :: math :: CatmullRomSpline spline ( center_points ); return spline . getTangentVector ( s ); } bool HdMapUtils :: canChangeLane ( std :: int64_t from_lanelet_id , std :: int64_t to_lanelet_id ) { const auto from_lanelet = lanelet_map_ptr_ -> laneletLayer . get ( from_lanelet_id ); const auto to_lanelet = lanelet_map_ptr_ -> laneletLayer . get ( to_lanelet_id ); return traffic_rules_vehicle_ptr_ -> canChangeLane ( from_lanelet , to_lanelet ); } boost :: optional < double > HdMapUtils :: getLongitudinalDistance ( openscenario_msgs :: msg :: LaneletPose from , openscenario_msgs :: msg :: LaneletPose to ) { return getLongitudinalDistance ( from . lanelet_id , from . s , to . lanelet_id , to . s ); } boost :: optional < double > HdMapUtils :: getLongitudinalDistance ( std :: int64_t from_lanelet_id , double from_s , std :: int64_t to_lanelet_id , double to_s ) { if ( from_lanelet_id == to_lanelet_id ) { if ( from_s > to_s ) { return boost :: none ; } else { return to_s - from_s ; } } const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( from_lanelet_id ); const auto to_lanelet = lanelet_map_ptr_ -> laneletLayer . get ( to_lanelet_id ); lanelet :: Optional < lanelet :: routing :: Route > route = vehicle_routing_graph_ptr_ -> getRoute ( lanelet , to_lanelet , 0 , true ); if ( ! route ) { return boost :: none ; } lanelet :: routing :: LaneletPath shortest_path = route -> shortestPath (); double dist = 0.0 ; if ( shortest_path . empty ()) { return boost :: none ; } for ( auto lane_itr = shortest_path . begin (); lane_itr != shortest_path . end (); lane_itr ++ ) { if ( lane_itr -> id () == from_lanelet_id ) { dist = dist + getLaneletLength ( from_lanelet_id ) - from_s ; } else if ( lane_itr -> id () == to_lanelet_id ) { dist = dist + to_s ; } else { dist = dist + getLaneletLength ( lane_itr -> id ()); } } return dist ; } const autoware_auto_msgs :: msg :: HADMapBin HdMapUtils :: toMapBin () { std :: stringstream ss ; boost :: archive :: binary_oarchive oa ( ss ); oa << * lanelet_map_ptr_ ; auto id_counter = lanelet :: utils :: getId (); oa << id_counter ; std :: string tmp_str = ss . str (); autoware_auto_msgs :: msg :: HADMapBin msg ; msg . data . clear (); msg . data . resize ( tmp_str . size ()); msg . data . assign ( tmp_str . begin (), tmp_str . end ()); msg . header . frame_id = \"map\" ; return msg ; } void HdMapUtils :: insertMarkerArray ( visualization_msgs :: msg :: MarkerArray & a1 , const visualization_msgs :: msg :: MarkerArray & a2 ) const { a1 . markers . insert ( a1 . markers . end (), a2 . markers . begin (), a2 . markers . end ()); } const visualization_msgs :: msg :: MarkerArray HdMapUtils :: generateMarker () const { visualization_msgs :: msg :: MarkerArray markers ; lanelet :: ConstLanelets all_lanelets = lanelet :: utils :: query :: laneletLayer ( lanelet_map_ptr_ ); lanelet :: ConstLanelets road_lanelets = lanelet :: utils :: query :: roadLanelets ( all_lanelets ); lanelet :: ConstLanelets crosswalk_lanelets = lanelet :: utils :: query :: crosswalkLanelets ( all_lanelets ); lanelet :: ConstLanelets walkway_lanelets = lanelet :: utils :: query :: walkwayLanelets ( all_lanelets ); std :: vector < lanelet :: ConstLineString3d > stop_lines = lanelet :: utils :: query :: stopLinesLanelets ( road_lanelets ); std :: vector < lanelet :: AutowareTrafficLightConstPtr > aw_tl_reg_elems = lanelet :: utils :: query :: autowareTrafficLights ( all_lanelets ); std :: vector < lanelet :: DetectionAreaConstPtr > da_reg_elems = lanelet :: utils :: query :: detectionAreas ( all_lanelets ); lanelet :: ConstLineStrings3d parking_spaces = lanelet :: utils :: query :: getAllParkingSpaces ( lanelet_map_ptr_ ); lanelet :: ConstPolygons3d parking_lots = lanelet :: utils :: query :: getAllParkingLots ( lanelet_map_ptr_ ); auto cl_ll_borders = color_utils :: fromRgba ( 1.0 , 1.0 , 1.0 , 0.999 ); auto cl_road = color_utils :: fromRgba ( 0.2 , 0.7 , 0.7 , 0.3 ); auto cl_cross = color_utils :: fromRgba ( 0.2 , 0.7 , 0.2 , 0.3 ); auto cl_stoplines = color_utils :: fromRgba ( 1.0 , 0.0 , 0.0 , 0.5 ); auto cl_trafficlights = color_utils :: fromRgba ( 0.7 , 0.7 , 0.7 , 0.8 ); auto cl_detection_areas = color_utils :: fromRgba ( 0.7 , 0.7 , 0.7 , 0.3 ); auto cl_parking_lots = color_utils :: fromRgba ( 0.7 , 0.7 , 0.0 , 0.3 ); auto cl_parking_spaces = color_utils :: fromRgba ( 1.0 , 0.647 , 0.0 , 0.6 ); auto cl_lanelet_id = color_utils :: fromRgba ( 0.8 , 0.2 , 0.2 , 0.999 ); insertMarkerArray ( markers , lanelet :: visualization :: laneletsBoundaryAsMarkerArray ( road_lanelets , cl_ll_borders , true )); insertMarkerArray ( markers , lanelet :: visualization :: laneletsAsTriangleMarkerArray ( \"road_lanelets\" , road_lanelets , cl_road )); insertMarkerArray ( markers , lanelet :: visualization :: laneletsAsTriangleMarkerArray ( \"crosswalk_lanelets\" , crosswalk_lanelets , cl_cross )); insertMarkerArray ( markers , lanelet :: visualization :: laneletsAsTriangleMarkerArray ( \"walkway_lanelets\" , walkway_lanelets , cl_cross )); insertMarkerArray ( markers , lanelet :: visualization :: laneletDirectionAsMarkerArray ( road_lanelets )); insertMarkerArray ( markers , lanelet :: visualization :: lineStringsAsMarkerArray ( stop_lines , \"stop_lines\" , cl_stoplines )); insertMarkerArray ( markers , lanelet :: visualization :: autowareTrafficLightsAsMarkerArray ( aw_tl_reg_elems , cl_trafficlights )); insertMarkerArray ( markers , lanelet :: visualization :: detectionAreasAsMarkerArray ( da_reg_elems , cl_detection_areas )); insertMarkerArray ( markers , lanelet :: visualization :: parkingLotsAsMarkerArray ( parking_lots , cl_parking_lots )); insertMarkerArray ( markers , lanelet :: visualization :: parkingSpacesAsMarkerArray ( parking_spaces , cl_parking_spaces )); insertMarkerArray ( markers , lanelet :: visualization :: generateLaneletIdMarker ( road_lanelets , cl_lanelet_id )); insertMarkerArray ( markers , lanelet :: visualization :: generateLaneletIdMarker ( crosswalk_lanelets , cl_lanelet_id )); return markers ; } void HdMapUtils :: overwriteLaneletsCenterline () { for ( auto & lanelet_obj : lanelet_map_ptr_ -> laneletLayer ) { if ( ! lanelet_obj . hasCustomCenterline ()) { const auto fine_center_line = generateFineCenterline ( lanelet_obj , 2.0 ); lanelet_obj . setCenterline ( fine_center_line ); } } } std :: pair < size_t , size_t > HdMapUtils :: findNearestIndexPair ( const std :: vector < double > & accumulated_lengths , const double target_length ) { // List size const auto N = accumulated_lengths . size (); // Front if ( target_length < accumulated_lengths . at ( 1 )) { return std :: make_pair ( 0 , 1 ); } // Back if ( target_length > accumulated_lengths . at ( N - 2 )) { return std :: make_pair ( N - 2 , N - 1 ); } // Middle for ( size_t i = 1 ; i < N ; ++ i ) { if ( accumulated_lengths . at ( i - 1 ) <= target_length && target_length <= accumulated_lengths . at ( i )) { return std :: make_pair ( i - 1 , i ); } } // Throw an exception because this never happens throw HdMapError ( \"findNearestIndexPair(): No nearest point found.\" ); } const std :: unordered_map < std :: int64_t , std :: vector < std :: int64_t >> HdMapUtils :: getRightOfWayLaneletIds ( std :: vector < std :: int64_t > lanelet_ids ) const { std :: unordered_map < std :: int64_t , std :: vector < std :: int64_t >> ret ; for ( const auto & lanelet_id : lanelet_ids ) { ret . emplace ( lanelet_id , getRightOfWayLaneletIds ( lanelet_id )); } return ret ; } const std :: vector < std :: int64_t > HdMapUtils :: getRightOfWayLaneletIds ( std :: int64_t lanelet_id ) const { std :: vector < std :: int64_t > ret ; const auto & assigned_lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto right_of_ways = assigned_lanelet . regulatoryElementsAs < lanelet :: RightOfWay > (); for ( const auto & right_of_way : right_of_ways ) { const auto right_of_Way_lanelets = right_of_way -> rightOfWayLanelets (); for ( const auto & ll : right_of_Way_lanelets ) { ret . emplace_back ( ll . id ()); } } return ret ; } std :: vector < std :: shared_ptr < const lanelet :: TrafficSign >> HdMapUtils :: getTrafficSignRegElementsOnPath ( std :: vector < std :: int64_t > lanelet_ids ) { std :: vector < std :: shared_ptr < const lanelet :: TrafficSign >> ret ; for ( const auto & lanelet_id : lanelet_ids ) { const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto traffic_signs = lanelet . regulatoryElementsAs < const lanelet :: TrafficSign > (); for ( const auto traffic_sign : traffic_signs ) { ret . push_back ( traffic_sign ); } } return ret ; } std :: vector < std :: shared_ptr < const lanelet :: autoware :: AutowareTrafficLight >> HdMapUtils :: getTrafficLightRegElementsOnPath ( const std :: vector < std :: int64_t > & lanelet_ids ) const { std :: vector < std :: shared_ptr < const lanelet :: autoware :: AutowareTrafficLight >> ret ; for ( const auto & lanelet_id : lanelet_ids ) { const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto traffic_lights = lanelet . regulatoryElementsAs < const lanelet :: autoware :: AutowareTrafficLight > (); for ( const auto traffic_light : traffic_lights ) { ret . push_back ( traffic_light ); } } return ret ; } std :: vector < lanelet :: ConstLineString3d > HdMapUtils :: getStopLinesOnPath ( std :: vector < std :: int64_t > lanelet_ids ) { std :: vector < lanelet :: ConstLineString3d > ret ; const auto traffic_signs = getTrafficSignRegElementsOnPath ( lanelet_ids ); for ( const auto & traffic_sign : traffic_signs ) { if ( traffic_sign -> type () != \"stop_sign\" ) { continue ; } for ( const auto & stop_line : traffic_sign -> refLines ()) { ret . emplace_back ( stop_line ); } } return ret ; } lanelet :: AutowareTrafficLightConstPtr HdMapUtils :: getTrafficLight ( const std :: int64_t traffic_light_id ) const { lanelet :: ConstLanelets all_lanelets = lanelet :: utils :: query :: laneletLayer ( lanelet_map_ptr_ ); auto autoware_traffic_lights = lanelet :: utils :: query :: autowareTrafficLights ( all_lanelets ); for ( const auto light : autoware_traffic_lights ) { for ( auto light_string : light -> lightBulbs ()) { if ( light_string . hasAttribute ( \"traffic_light_id\" )) { auto id = light_string . attribute ( \"traffic_light_id\" ). asId (); if ( id ) { return light ; } } } } std :: string message = \"traffic_light_id does not match. ID : \" + std :: to_string ( traffic_light_id ); throw HdMapError ( message . c_str ()); } const boost :: optional < std :: int64_t > HdMapUtils :: getTrafficLightStopLineId ( const std :: int64_t & traffic_light_id ) const { const auto traffic_light = getTrafficLight ( traffic_light_id ); if ( traffic_light -> stopLine ()) { return traffic_light -> stopLine () -> id (); } return boost :: none ; } const std :: vector < geometry_msgs :: msg :: Point > HdMapUtils :: getTrafficLightStopLinePoints ( std :: int64_t traffic_light_id ) const { std :: vector < geometry_msgs :: msg :: Point > ret ; const auto traffic_light = getTrafficLight ( traffic_light_id ); const auto stop_line = traffic_light -> stopLine (); if ( stop_line ) { for ( const auto point : stop_line . get ()) { geometry_msgs :: msg :: Point p ; p . x = point . x (); p . y = point . y (); p . z = point . z (); ret . emplace_back ( p ); } } return ret ; } const std :: vector < geometry_msgs :: msg :: Point > HdMapUtils :: getStopLinePolygon ( std :: int64_t lanelet_id ) { std :: vector < geometry_msgs :: msg :: Point > points ; const auto stop_line = lanelet_map_ptr_ -> lineStringLayer . get ( lanelet_id ); for ( const auto point : stop_line ) { geometry_msgs :: msg :: Point p ; p . x = point . x (); p . y = point . y (); p . z = point . z (); points . emplace_back ( p ); } return points ; } const std :: vector < std :: int64_t > HdMapUtils :: getTrafficLightIdsOnPath ( const std :: vector < std :: int64_t > & route_lanelets ) const { std :: vector < std :: int64_t > ret ; auto traffic_lights = getTrafficLightRegElementsOnPath ( route_lanelets ); for ( const auto traffic_light : traffic_lights ) { for ( auto light_string : traffic_light -> lightBulbs ()) { if ( light_string . hasAttribute ( \"traffic_light_id\" )) { auto id = light_string . attribute ( \"traffic_light_id\" ). asId (); if ( id ) { ret . emplace_back ( id . get ()); } } } } return ret ; } const boost :: optional < double > HdMapUtils :: getDistanceToTrafficLightStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ) const { auto traffic_light_ids = getTrafficLightIdsOnPath ( route_lanelets ); if ( traffic_light_ids . size () == 0 ) { return boost :: none ; } std :: set < double > collision_points ; for ( const auto id : traffic_light_ids ) { const auto collision_point = getDistanceToTrafficLightStopLine ( waypoints , id ); if ( collision_point ) { collision_points . insert ( collision_point . get ()); } } if ( collision_points . empty ()) { return boost :: none ; } return * collision_points . begin (); } const boost :: optional < double > HdMapUtils :: getDistanceToTrafficLightStopLine ( const std :: vector < geometry_msgs :: msg :: Point > & waypoints , const std :: int64_t & traffic_light_id ) const { if ( waypoints . empty ()) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( waypoints ); const auto stop_line = getTrafficLightStopLinePoints ( traffic_light_id ); if ( stop_line . size () <= 1 ) { return boost :: none ; } const auto collision_point = spline . getCollisionPointIn2D ( stop_line ); return collision_point ; } boost :: optional < double > HdMapUtils :: getDistanceToStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ) { if ( waypoints . empty ()) { return boost :: none ; } std :: set < double > collision_points ; if ( waypoints . empty ()) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( waypoints ); const auto stop_lines = getStopLinesOnPath ({ route_lanelets }); for ( const auto & stop_line : stop_lines ) { std :: vector < geometry_msgs :: msg :: Point > stop_line_points ; for ( const auto & point : stop_line ) { geometry_msgs :: msg :: Point p ; p . x = point . x (); p . y = point . y (); p . z = point . z (); stop_line_points . emplace_back ( p ); } const auto collision_point = spline . getCollisionPointIn2D ( stop_line_points ); if ( collision_point ) { collision_points . insert ( collision_point . get ()); } } if ( collision_points . empty ()) { return boost :: none ; } return * collision_points . begin (); } std :: vector < double > HdMapUtils :: calculateSegmentDistances ( const lanelet :: ConstLineString3d & line_string ) { std :: vector < double > segment_distances ; segment_distances . reserve ( line_string . size () - 1 ); for ( size_t i = 1 ; i < line_string . size (); ++ i ) { const auto distance = lanelet :: geometry :: distance ( line_string [ i ], line_string [ i - 1 ]); segment_distances . push_back ( distance ); } return segment_distances ; } std :: vector < double > HdMapUtils :: calculateAccumulatedLengths ( const lanelet :: ConstLineString3d & line_string ) { const auto segment_distances = calculateSegmentDistances ( line_string ); std :: vector < double > accumulated_lengths { 0 }; accumulated_lengths . reserve ( segment_distances . size () + 1 ); std :: partial_sum ( std :: begin ( segment_distances ), std :: end ( segment_distances ), std :: back_inserter ( accumulated_lengths )); return accumulated_lengths ; } std :: vector < lanelet :: BasicPoint3d > HdMapUtils :: resamplePoints ( const lanelet :: ConstLineString3d & line_string , const int32_t num_segments ) { // Calculate length const auto line_length = lanelet :: geometry :: length ( line_string ); // Calculate accumulated lengths const auto accumulated_lengths = calculateAccumulatedLengths ( line_string ); // Create each segment std :: vector < lanelet :: BasicPoint3d > resampled_points ; for ( auto i = 0 ; i <= num_segments ; ++ i ) { // Find two nearest points const double target_length = ( static_cast < double > ( i ) / num_segments ) * static_cast < double > ( line_length ); const auto index_pair = findNearestIndexPair ( accumulated_lengths , target_length ); // Apply linear interpolation const lanelet :: BasicPoint3d back_point = line_string [ index_pair . first ]; const lanelet :: BasicPoint3d front_point = line_string [ index_pair . second ]; const auto direction_vector = ( front_point - back_point ); const auto back_length = accumulated_lengths . at ( index_pair . first ); const auto front_length = accumulated_lengths . at ( index_pair . second ); const auto segment_length = front_length - back_length ; const auto target_point = back_point + ( direction_vector * ( target_length - back_length ) / segment_length ); // Add to list resampled_points . push_back ( target_point ); } return resampled_points ; } lanelet :: LineString3d HdMapUtils :: generateFineCenterline ( const lanelet :: ConstLanelet & lanelet_obj , const double resolution ) { // Get length of longer border const double left_length = static_cast < double > ( lanelet :: geometry :: length ( lanelet_obj . leftBound ())); const double right_length = static_cast < double > ( lanelet :: geometry :: length ( lanelet_obj . rightBound ())); const double longer_distance = ( left_length > right_length ) ? left_length : right_length ; const int32_t num_segments = std :: max ( static_cast < int32_t > ( ceil ( longer_distance / resolution )), 1 ); // Resample points const auto left_points = resamplePoints ( lanelet_obj . leftBound (), num_segments ); const auto right_points = resamplePoints ( lanelet_obj . rightBound (), num_segments ); // Create centerline lanelet :: LineString3d centerline ( lanelet :: utils :: getId ()); for ( size_t i = 0 ; i < static_cast < size_t > ( num_segments + 1 ); i ++ ) { // Add ID for the average point of left and right const auto center_basic_point = ( right_points . at ( i ) + left_points . at ( i )) / 2.0 ; const lanelet :: Point3d center_point ( lanelet :: utils :: getId (), center_basic_point . x (), center_basic_point . y (), center_basic_point . z ()); centerline . push_back ( center_point ); } return centerline ; } std :: vector < double > HdMapUtils :: calcEuclidDist ( const std :: vector < double > & x , const std :: vector < double > & y , const std :: vector < double > & z ) { std :: vector < double > dist_v ; dist_v . push_back ( 0.0 ); for ( size_t i = 0 ; i < x . size () - 1 ; ++ i ) { const double dx = x . at ( i + 1 ) - x . at ( i ); const double dy = y . at ( i + 1 ) - y . at ( i ); const double dz = z . at ( i + 1 ) - z . at ( i ); const double d = std :: sqrt ( dx * dx + dy * dy + dz * dz ); dist_v . push_back ( dist_v . at ( i ) + d ); } return dist_v ; } } // namespace hdmap_utils Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/hdmap_utils/hdmap_utils.cpp"},{"location":"package/simulation_api/markdown/Files/hdmap__utils_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrchdmap_utilshdmap_utilscpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/hdmap_utils/hdmap_utils.cpp"},{"location":"package/simulation_api/markdown/Files/hdmap__utils_8cpp/#namespaces","text":"Name hdmap_utils","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/hdmap__utils_8cpp/#defines","text":"Name EXPERIMENTAL_AUTOWARE_IV_SUPPORT","title":"Defines"},{"location":"package/simulation_api/markdown/Files/hdmap__utils_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/simulation_api/markdown/Files/hdmap__utils_8cpp/#define-experimental_autoware_iv_support","text":"#define EXPERIMENTAL_AUTOWARE_IV_SUPPORT","title":"define EXPERIMENTAL_AUTOWARE_IV_SUPPORT"},{"location":"package/simulation_api/markdown/Files/hdmap__utils_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/color_utils/color_utils.hpp> #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <simulation_api/math/hermite_curve.hpp> #include <quaternion_operation/quaternion_operation.h> #include <lanelet2_core/utility/Units.h> #include <lanelet2_extension_psim/io/autoware_osm_parser.hpp> #include <lanelet2_extension_psim/projection/mgrs_projector.hpp> #include <lanelet2_extension_psim/utility/message_conversion.hpp> #include <lanelet2_extension_psim/utility/utilities.hpp> #include <lanelet2_extension_psim/utility/query.hpp> #include <lanelet2_extension_psim/visualization/visualization.hpp> #include <lanelet2_io/Io.h> #include <lanelet2_io/io_handlers/Serialize.h> #include <lanelet2_projection/UTM.h> #include <boost/archive/binary_iarchive.hpp> #include <boost/archive/binary_oarchive.hpp> #include <boost/geometry.hpp> #include <boost/geometry/geometries/point_xy.hpp> #include <boost/geometry/geometries/polygon.hpp> #include <boost/geometry/geometries/box.hpp> #include <boost/assign/list_of.hpp> #include <algorithm> #include <deque> #include <memory> #include <set> #include <string> #include <unordered_map> #include <utility> #include <vector> #define EXPERIMENTAL_AUTOWARE_IV_SUPPORT namespace hdmap_utils { HdMapUtils :: HdMapUtils ( std :: string lanelet_path , geographic_msgs :: msg :: GeoPoint origin ) { #ifndef EXPERIMENTAL_AUTOWARE_IV_SUPPORT lanelet :: GPSPoint origin_gps_point { origin . latitude , origin . longitude , origin . altitude }; lanelet :: Origin origin_lanelet { origin_gps_point }; lanelet :: projection :: UtmProjector projector ( origin_lanelet ); #else lanelet :: projection :: MGRSProjector projector {}; // TODO(yamacir-kit) #endif lanelet :: ErrorMessages errors ; lanelet_map_ptr_ = lanelet :: load ( lanelet_path , projector , & errors ); if ( ! errors . empty ()) { for ( const auto & error : errors ) { std :: cerr << error << std :: endl ; } throw HdMapError ( \"failed to load lanelet map\" ); } overwriteLaneletsCenterline (); traffic_rules_vehicle_ptr_ = lanelet :: traffic_rules :: TrafficRulesFactory :: create ( lanelet :: Locations :: Germany , lanelet :: Participants :: Vehicle ); vehicle_routing_graph_ptr_ = lanelet :: routing :: RoutingGraph :: build ( * lanelet_map_ptr_ , * traffic_rules_vehicle_ptr_ ); traffic_rules_pedestrian_ptr_ = lanelet :: traffic_rules :: TrafficRulesFactory :: create ( lanelet :: Locations :: Germany , lanelet :: Participants :: Pedestrian ); pedestrian_routing_graph_ptr_ = lanelet :: routing :: RoutingGraph :: build ( * lanelet_map_ptr_ , * traffic_rules_pedestrian_ptr_ ); std :: vector < lanelet :: routing :: RoutingGraphConstPtr > all_graphs ; all_graphs . push_back ( vehicle_routing_graph_ptr_ ); all_graphs . push_back ( pedestrian_routing_graph_ptr_ ); } const std :: vector < std :: int64_t > HdMapUtils :: getLaneletIds () { std :: vector < std :: int64_t > ret ; for ( const auto & lanelet : lanelet_map_ptr_ -> laneletLayer ) { ret . emplace_back ( lanelet . id ()); } return ret ; } const std :: vector < geometry_msgs :: msg :: Point > HdMapUtils :: getLaneletPolygon ( std :: int64_t lanelet_id ) { std :: vector < geometry_msgs :: msg :: Point > points ; lanelet :: CompoundPolygon3d lanelet_polygon = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ). polygon3d (); for ( const auto & lanelet_point : lanelet_polygon ) { geometry_msgs :: msg :: Point p ; p . x = lanelet_point . x (); p . y = lanelet_point . y (); p . z = lanelet_point . z (); points . emplace_back ( p ); } return points ; } double HdMapUtils :: getHeight ( const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ) { return toMapPose ( lanelet_pose ). pose . position . z ; } boost :: optional < double > HdMapUtils :: getCollisionPointInLaneCoordinate ( std :: int64_t lanelet_id , std :: int64_t crossing_lanelet_id ) { namespace bg = boost :: geometry ; using Point = bg :: model :: d2 :: point_xy < double > ; using Line = bg :: model :: linestring < Point > ; using Polygon = bg :: model :: polygon < Point , false > ; auto center_points = getCenterPoints ( lanelet_id ); std :: vector < Point > path_collision_points ; lanelet_map_ptr_ -> laneletLayer . get ( crossing_lanelet_id ); lanelet :: CompoundPolygon3d lanelet_polygon = lanelet_map_ptr_ -> laneletLayer . get ( crossing_lanelet_id ). polygon3d (); Polygon crosswalk_polygon ; for ( const auto & lanelet_point : lanelet_polygon ) { crosswalk_polygon . outer (). push_back ( bg :: make < Point > ( lanelet_point . x (), lanelet_point . y ())); } crosswalk_polygon . outer (). push_back ( crosswalk_polygon . outer (). front ()); double s_in_lanelet = 0 ; for ( size_t i = 0 ; i < center_points . size () - 1 ; ++ i ) { const auto p0 = center_points . at ( i ); const auto p1 = center_points . at ( i + 1 ); const Line line {{ p0 . x , p0 . y }, { p1 . x , p1 . y }}; double line_length = std :: sqrt ( std :: pow ( p0 . x - p1 . x , 2 ) + std :: pow ( p0 . y - p1 . y , 2 ) + std :: pow ( p0 . z - p1 . z , 2 )); std :: vector < Point > line_collision_points ; bg :: intersection ( crosswalk_polygon , line , line_collision_points ); if ( line_collision_points . empty ()) { continue ; } std :: vector < double > dist ; for ( size_t j = 0 ; j < line_collision_points . size (); ++ j ) { double s_in_line = 0 ; if ( std :: fabs ( p1 . x - p0 . x ) < DBL_EPSILON ) { if ( std :: fabs ( p1 . y - p1 . y < DBL_EPSILON )) {} else { s_in_line = ( line_collision_points [ j ]. y () - p0 . y ) / ( p1 . y - p0 . y ); return s_in_lanelet + s_in_line * line_length ; } } else { s_in_line = ( line_collision_points [ j ]. x () - p0 . x ) / ( p1 . x - p0 . x ); return s_in_lanelet + s_in_line * line_length ; } } s_in_lanelet = s_in_lanelet + line_length ; } return boost :: none ; } std :: vector < std :: int64_t > HdMapUtils :: getConflictingCrosswalkIds ( std :: vector < std :: int64_t > lanelet_ids ) const { std :: vector < std :: int64_t > ret ; std :: vector < lanelet :: routing :: RoutingGraphConstPtr > graphs ; graphs . emplace_back ( vehicle_routing_graph_ptr_ ); graphs . emplace_back ( pedestrian_routing_graph_ptr_ ); lanelet :: routing :: RoutingGraphContainer container ( graphs ); for ( const auto & lanelet_id : lanelet_ids ) { const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); double height_clearance = 4 ; size_t routing_graph_id = 1 ; const auto conflicting_crosswalks = container . conflictingInGraph ( lanelet , routing_graph_id , height_clearance ); for ( const auto & crosswalk : conflicting_crosswalks ) { ret . emplace_back ( crosswalk . id ()); } } return ret ; } std :: vector < geometry_msgs :: msg :: Point > HdMapUtils :: clipTrajectoryFromLaneletIds ( std :: int64_t lanelet_id , double s , std :: vector < std :: int64_t > lanelet_ids , double foward_distance ) { std :: vector < geometry_msgs :: msg :: Point > ret ; bool on_traj = false ; double rest_distance = foward_distance ; for ( auto id_itr = lanelet_ids . begin (); id_itr != lanelet_ids . end (); id_itr ++ ) { double l = getLaneletLength ( * id_itr ); if ( on_traj ) { if ( rest_distance < l ) { for ( double s_val = 0 ; s_val < rest_distance ; s_val = s_val + 1.0 ) { auto map_pose = toMapPose ( * id_itr , s_val , 0 ); ret . emplace_back ( map_pose . pose . position ); } break ; } else { rest_distance = rest_distance - l ; for ( double s_val = 0 ; s_val < l ; s_val = s_val + 1.0 ) { auto map_pose = toMapPose ( * id_itr , s_val , 0 ); ret . emplace_back ( map_pose . pose . position ); } continue ; } } if ( lanelet_id == * id_itr ) { on_traj = true ; if (( s + foward_distance ) < l ) { for ( double s_val = s ; s_val < s + foward_distance ; s_val = s_val + 1.0 ) { auto map_pose = toMapPose ( lanelet_id , s_val , 0 ); ret . emplace_back ( map_pose . pose . position ); } break ; } else { rest_distance = rest_distance - ( l - s ); for ( double s_val = s ; s_val < l ; s_val = s_val + 1.0 ) { auto map_pose = toMapPose ( lanelet_id , s_val , 0 ); ret . emplace_back ( map_pose . pose . position ); } continue ; } } } return ret ; } std :: vector < std :: pair < double , lanelet :: Lanelet >> HdMapUtils :: excludeSubtypeLaneletsWithDistance ( const std :: vector < std :: pair < double , lanelet :: Lanelet >> & lls , const char subtype []) { std :: vector < std :: pair < double , lanelet :: Lanelet >> exclude_subtype_lanelets ; for ( const auto & ll : lls ) { if ( ll . second . hasAttribute ( lanelet :: AttributeName :: Subtype )) { lanelet :: Attribute attr = ll . second . attribute ( lanelet :: AttributeName :: Subtype ); if ( attr . value () != subtype ) { exclude_subtype_lanelets . push_back ( ll ); } } } return exclude_subtype_lanelets ; } boost :: optional < openscenario_msgs :: msg :: LaneletPose > HdMapUtils :: toLaneletPose ( geometry_msgs :: msg :: Pose pose ) { const auto lanelet_id = getClosetLanletId ( pose ); if ( ! lanelet_id ) { return boost :: none ; } const auto center_points = getCenterPoints ( lanelet_id . get ()); simulation_api :: math :: CatmullRomSpline spline ( center_points ); const auto s = spline . getSValue ( pose . position ); if ( ! s ) { return boost :: none ; } auto pose_on_centerline = spline . getPose ( s . get ()); auto rpy = quaternion_operation :: convertQuaternionToEulerAngle ( quaternion_operation :: getRotation ( pose_on_centerline . orientation , pose . orientation )); double offset = spline . getSquaredDistanceIn2D ( pose . position , s . get ()); openscenario_msgs :: msg :: LaneletPose lanelet_pose ; lanelet_pose . lanelet_id = lanelet_id . get (); lanelet_pose . s = s . get (); lanelet_pose . offset = offset ; lanelet_pose . rpy = rpy ; return lanelet_pose ; } boost :: optional < std :: int64_t > HdMapUtils :: getClosetLanletId ( geometry_msgs :: msg :: Pose pose , double distance_thresh ) { lanelet :: BasicPoint2d search_point ( pose . position . x , pose . position . y ); std :: vector < std :: pair < double , lanelet :: Lanelet >> nearest_lanelet = lanelet :: geometry :: findNearest ( lanelet_map_ptr_ -> laneletLayer , search_point , 3 ); const auto nearest_road_lanelet = excludeSubtypeLaneletsWithDistance ( nearest_lanelet , lanelet :: AttributeValueString :: Crosswalk ); if ( nearest_road_lanelet . empty ()) { return boost :: none ; } if ( nearest_road_lanelet . front (). first > distance_thresh ) { return boost :: none ; } lanelet :: Lanelet closest_lanelet ; closest_lanelet = nearest_road_lanelet . front (). second ; return closest_lanelet . id (); } double HdMapUtils :: getSpeedLimit ( std :: vector < std :: int64_t > lanelet_ids ) { std :: vector < double > limits ; if ( lanelet_ids . empty ()) { throw HdMapError ( \"size of the vector lanelet ids should be more than 1\" ); } for ( auto itr = lanelet_ids . begin (); itr != lanelet_ids . end (); itr ++ ) { const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( * itr ); const auto limit = traffic_rules_vehicle_ptr_ -> speedLimit ( lanelet ); limits . push_back ( lanelet :: units :: KmHQuantity ( limit . speedLimit ). value () / 3.6 ); } return * std :: min_element ( limits . begin (), limits . end ()); } boost :: optional < int > HdMapUtils :: getLaneChangeableLenletId ( std :: int64_t lanelet_id , std :: string direction ) { const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); if ( direction == \"left\" ) { auto left_lanlet = vehicle_routing_graph_ptr_ -> left ( lanelet ); if ( left_lanlet ) { return left_lanlet -> id (); } } if ( direction == \"right\" ) { auto right_lanlet = vehicle_routing_graph_ptr_ -> right ( lanelet ); if ( right_lanlet ) { return right_lanlet -> id (); } } return boost :: none ; } std :: vector < std :: int64_t > HdMapUtils :: getPreviousLanelets ( std :: int64_t lanelet_id , double distance ) { std :: vector < std :: int64_t > ret ; double total_dist = 0.0 ; ret . push_back ( lanelet_id ); while ( total_dist < distance ) { auto ids = getPreviousLaneletIds ( lanelet_id , \"straight\" ); if ( ids . size () != 0 ) { lanelet_id = ids [ 0 ]; total_dist = total_dist + getLaneletLength ( lanelet_id ); ret . push_back ( lanelet_id ); continue ; } else { auto else_ids = getPreviousLaneletIds ( lanelet_id ); if ( else_ids . size () != 0 ) { lanelet_id = else_ids [ 0 ]; total_dist = total_dist + getLaneletLength ( lanelet_id ); ret . push_back ( lanelet_id ); continue ; } else { break ; } } } return ret ; } bool HdMapUtils :: isInRoute ( std :: int64_t lanelet_id , std :: vector < std :: int64_t > route ) const { for ( const auto id : route ) { if ( id == lanelet_id ) { return true ; } } return false ; } std :: vector < std :: int64_t > HdMapUtils :: getFollowingLanelets ( std :: int64_t lanelet_id , std :: vector < std :: int64_t > candidate_lanelet_ids , double distance , bool include_self ) { if ( candidate_lanelet_ids . empty ()) { return {}; } std :: vector < std :: int64_t > ret ; double total_dist = 0.0 ; bool found = false ; for ( const auto id : candidate_lanelet_ids ) { if ( found ) { ret . emplace_back ( id ); total_dist = total_dist + getLaneletLength ( id ); if ( total_dist > distance ) { return ret ; } } if ( id == lanelet_id ) { found = true ; if ( include_self ) { ret . emplace_back ( id ); } } } if ( ! found ) { throw HdMapError ( \"lanelet id did not match.\" ); } if ( total_dist > distance ) { return ret ; } std :: int64_t end_lanelet = candidate_lanelet_ids [ candidate_lanelet_ids . size () - 1 ]; const auto followings = getFollowingLanelets ( end_lanelet , distance - total_dist , false ); std :: copy ( followings . begin (), followings . end (), std :: back_inserter ( ret )); return ret ; } std :: vector < std :: int64_t > HdMapUtils :: getFollowingLanelets ( std :: int64_t lanelet_id , double distance , bool include_self ) { std :: vector < std :: int64_t > ret ; double total_dist = 0.0 ; if ( include_self ) { ret . push_back ( lanelet_id ); } while ( total_dist < distance ) { const auto straight_ids = getNextLaneletIds ( lanelet_id , \"straight\" ); if ( straight_ids . size () != 0 ) { lanelet_id = straight_ids [ 0 ]; total_dist = total_dist + getLaneletLength ( lanelet_id ); ret . push_back ( lanelet_id ); continue ; } const auto ids = getNextLaneletIds ( lanelet_id ); if ( ids . size () != 0 ) { lanelet_id = ids [ 0 ]; total_dist = total_dist + getLaneletLength ( lanelet_id ); ret . push_back ( lanelet_id ); continue ; } else { break ; } } return ret ; } std :: vector < std :: int64_t > HdMapUtils :: getRoute ( std :: int64_t from_lanelet_id , std :: int64_t to_lanelet_id ) { std :: vector < std :: int64_t > ret ; const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( from_lanelet_id ); const auto to_lanelet = lanelet_map_ptr_ -> laneletLayer . get ( to_lanelet_id ); lanelet :: Optional < lanelet :: routing :: Route > route = vehicle_routing_graph_ptr_ -> getRoute ( lanelet , to_lanelet , 0 , true ); if ( ! route ) { return ret ; } lanelet :: routing :: LaneletPath shortest_path = route -> shortestPath (); if ( shortest_path . empty ()) { return ret ; } for ( auto lane_itr = shortest_path . begin (); lane_itr != shortest_path . end (); lane_itr ++ ) { ret . push_back ( lane_itr -> id ()); } return ret ; } std :: vector < geometry_msgs :: msg :: Point > HdMapUtils :: getCenterPoints ( std :: vector < std :: int64_t > lanelet_ids ) { std :: vector < geometry_msgs :: msg :: Point > ret ; if ( lanelet_ids . empty ()) { return ret ; } for ( const auto lanelet_id : lanelet_ids ) { std :: vector < geometry_msgs :: msg :: Point > center_points = getCenterPoints ( lanelet_id ); std :: copy ( center_points . begin (), center_points . end (), std :: back_inserter ( ret )); } return ret ; } std :: vector < geometry_msgs :: msg :: Point > HdMapUtils :: getCenterPoints ( std :: int64_t lanelet_id ) { std :: vector < geometry_msgs :: msg :: Point > ret ; if ( ! lanelet_map_ptr_ ) { throw HdMapError ( \"lanelet map is null pointer.\" ); } if ( lanelet_map_ptr_ -> laneletLayer . empty ()) { throw HdMapError ( \"lanelet layer is empty.\" ); } const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto centerline = lanelet . centerline (); for ( const auto & point : centerline ) { geometry_msgs :: msg :: Point p ; p . x = point . x (); p . y = point . y (); p . z = point . z (); ret . push_back ( p ); } return ret ; } double HdMapUtils :: getLaneletLength ( std :: int64_t lanelet_id ) const { return lanelet :: utils :: getLaneletLength2d ( lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id )); } std :: vector < std :: int64_t > HdMapUtils :: getPreviousLaneletIds ( std :: int64_t lanelet_id ) const { std :: vector < std :: int64_t > ret ; const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto previous_lanelets = vehicle_routing_graph_ptr_ -> previous ( lanelet ); for ( const auto & llt : previous_lanelets ) { ret . push_back ( llt . id ()); } return ret ; } std :: vector < std :: int64_t > HdMapUtils :: getPreviousLaneletIds ( std :: int64_t lanelet_id , std :: string turn_direction ) { std :: vector < std :: int64_t > ret ; const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto previous_lanelets = vehicle_routing_graph_ptr_ -> previous ( lanelet ); for ( const auto & llt : previous_lanelets ) { const std :: string turn_direction_llt = llt . attributeOr ( \"turn_direction\" , \"else\" ); if ( turn_direction_llt == turn_direction ) { ret . push_back ( llt . id ()); } } return ret ; } std :: vector < std :: int64_t > HdMapUtils :: getNextLaneletIds ( std :: int64_t lanelet_id ) const { std :: vector < std :: int64_t > ret ; const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto following_lanelets = vehicle_routing_graph_ptr_ -> following ( lanelet ); for ( const auto & llt : following_lanelets ) { ret . push_back ( llt . id ()); } return ret ; } std :: vector < std :: int64_t > HdMapUtils :: getNextLaneletIds ( std :: int64_t lanelet_id , std :: string turn_direction ) { std :: vector < std :: int64_t > ret ; const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto following_lanelets = vehicle_routing_graph_ptr_ -> following ( lanelet ); for ( const auto & llt : following_lanelets ) { const std :: string turn_direction_llt = llt . attributeOr ( \"turn_direction\" , \"else\" ); if ( turn_direction_llt == turn_direction ) { ret . push_back ( llt . id ()); } } return ret ; } const std :: vector < std :: int64_t > HdMapUtils :: getTrafficLightIds () const { std :: vector < std :: int64_t > ret ; lanelet :: ConstLanelets all_lanelets = lanelet :: utils :: query :: laneletLayer ( lanelet_map_ptr_ ); auto autoware_traffic_lights = lanelet :: utils :: query :: autowareTrafficLights ( all_lanelets ); for ( const auto light : autoware_traffic_lights ) { for ( auto light_string : light -> lightBulbs ()) { if ( light_string . hasAttribute ( \"traffic_light_id\" )) { auto id = light_string . attribute ( \"traffic_light_id\" ). asId (); if ( id ) { ret . emplace_back ( id . get ()); } } } } return ret ; } const boost :: optional < geometry_msgs :: msg :: Point > HdMapUtils :: getTrafficLightBulbPosition ( std :: int64_t traffic_light_id , simulation_api :: TrafficLightColor color ) const { if ( color == simulation_api :: TrafficLightColor :: NONE ) { return boost :: none ; } lanelet :: ConstLanelets all_lanelets = lanelet :: utils :: query :: laneletLayer ( lanelet_map_ptr_ ); auto autoware_traffic_lights = lanelet :: utils :: query :: autowareTrafficLights ( all_lanelets ); for ( const auto light : autoware_traffic_lights ) { for ( auto light_string : light -> lightBulbs ()) { if ( light_string . hasAttribute ( \"traffic_light_id\" )) { auto id = light_string . attribute ( \"traffic_light_id\" ). asId (); if ( id ) { if ( id . get () == traffic_light_id ) { const auto light_bulbs = light -> lightBulbs (); for ( auto ls : light_bulbs ) { lanelet :: ConstLineString3d l = static_cast < lanelet :: ConstLineString3d > ( ls ); for ( auto pt : l ) { if ( pt . hasAttribute ( \"color\" )) { std :: string color_string ; switch ( color ) { case simulation_api :: TrafficLightColor :: GREEN : color_string = \"green\" ; break ; case simulation_api :: TrafficLightColor :: YELLOW : color_string = \"yellow\" ; break ; case simulation_api :: TrafficLightColor :: RED : color_string = \"red\" ; break ; case simulation_api :: TrafficLightColor :: NONE : return boost :: none ; } lanelet :: Attribute attr = pt . attribute ( \"color\" ); if ( attr . value (). compare ( color_string ) == 0 ) { geometry_msgs :: msg :: Point point ; point . x = pt . x (); point . y = pt . y (); point . z = pt . z (); return point ; } } } } } } } } } return boost :: none ; } boost :: optional < std :: pair < simulation_api :: math :: HermiteCurve , double >> HdMapUtils :: getLaneChangeTrajectory ( geometry_msgs :: msg :: Pose from_pose , std :: int64_t to_lanelet_id ) { double to_length = getLaneletLength ( to_lanelet_id ); std :: vector < double > evaluation , target_s ; std :: vector < simulation_api :: math :: HermiteCurve > curves ; for ( double to_s = 0 ; to_s < to_length ; to_s = to_s + 1.0 ) { auto goal_pose = toMapPose ( to_lanelet_id , to_s , 0 ); double start_to_goal_dist = std :: sqrt ( std :: pow ( from_pose . position . x - goal_pose . pose . position . x , 2 ) + std :: pow ( from_pose . position . y - goal_pose . pose . position . y , 2 ) + std :: pow ( from_pose . position . z - goal_pose . pose . position . z , 2 )); auto traj = getLaneChangeTrajectory ( from_pose , to_lanelet_id , to_s , start_to_goal_dist * 0.5 ); if ( traj ) { if ( traj -> getMaximu2DCurvature () < 1.0 ) { double eval = std :: fabs ( 20 - traj -> getLength ()); evaluation . push_back ( eval ); curves . push_back ( traj . get ()); target_s . push_back ( to_s ); } } } if ( evaluation . empty ()) { return boost :: none ; } std :: vector < double >:: iterator min_itr = std :: min_element ( evaluation . begin (), evaluation . end ()); size_t min_index = std :: distance ( evaluation . begin (), min_itr ); return std :: make_pair ( curves [ min_index ], target_s [ min_index ]); } boost :: optional < simulation_api :: math :: HermiteCurve > HdMapUtils :: getLaneChangeTrajectory ( geometry_msgs :: msg :: Pose from_pose , std :: int64_t to_lanelet_id , double to_s , double tangent_vector_size ) { std :: vector < geometry_msgs :: msg :: Point > ret ; auto to_vec = getTangentVector ( to_lanelet_id , to_s ); auto goal_pose = toMapPose ( to_lanelet_id , to_s , 0 ); geometry_msgs :: msg :: Vector3 start_vec = getVectorFromPose ( from_pose , tangent_vector_size ); geometry_msgs :: msg :: Vector3 goal_vec = to_vec . get (); goal_vec . x = goal_vec . x * tangent_vector_size ; goal_vec . y = goal_vec . y * tangent_vector_size ; goal_vec . z = goal_vec . z * tangent_vector_size ; simulation_api :: math :: HermiteCurve curve ( from_pose , goal_pose . pose , start_vec , goal_vec ); return curve ; } geometry_msgs :: msg :: Vector3 HdMapUtils :: getVectorFromPose ( geometry_msgs :: msg :: Pose pose , double magnitude ) { geometry_msgs :: msg :: Vector3 dir = quaternion_operation :: convertQuaternionToEulerAngle ( pose . orientation ); geometry_msgs :: msg :: Vector3 vector ; vector . x = magnitude * std :: cos ( dir . z ); vector . y = magnitude * std :: sin ( dir . z ); vector . z = 0 ; return vector ; } bool HdMapUtils :: isInLanelet ( std :: int64_t lanelet_id , double s ) { const auto center_points = getCenterPoints ( lanelet_id ); simulation_api :: math :: CatmullRomSpline spline ( center_points ); double l = spline . getLength (); if ( s > l ) { return false ; } else if ( s < 0 ) { return false ; } return true ; } std :: vector < geometry_msgs :: msg :: Point > HdMapUtils :: toMapPoints ( std :: int64_t lanelet_id , std :: vector < double > s ) { std :: vector < geometry_msgs :: msg :: Point > ret ; const auto center_points = getCenterPoints ( lanelet_id ); simulation_api :: math :: CatmullRomSpline spline ( center_points ); for ( const auto & s_value : s ) { ret . push_back ( spline . getPoint ( s_value )); } return ret ; } geometry_msgs :: msg :: PoseStamped HdMapUtils :: toMapPose ( std :: int64_t lanelet_id , double s , double offset , geometry_msgs :: msg :: Quaternion quat ) { geometry_msgs :: msg :: PoseStamped ret ; ret . header . frame_id = \"map\" ; const auto center_points = getCenterPoints ( lanelet_id ); simulation_api :: math :: CatmullRomSpline spline ( center_points ); ret . pose = spline . getPose ( s ); const auto tangent_vec = spline . getTangentVector ( s ); geometry_msgs :: msg :: Vector3 rpy ; rpy . x = 0.0 ; rpy . y = 0.0 ; rpy . z = std :: atan2 ( tangent_vec . y , tangent_vec . x ); ret . pose . position . x = ret . pose . position . x - std :: sin ( rpy . z ) * offset ; ret . pose . position . y = ret . pose . position . y - std :: cos ( rpy . z ) * offset ; ret . pose . position . z = ret . pose . position . z ; ret . pose . orientation = quaternion_operation :: convertEulerAngleToQuaternion ( rpy ); ret . pose . orientation = ret . pose . orientation * quat ; return ret ; } geometry_msgs :: msg :: PoseStamped HdMapUtils :: toMapPose ( openscenario_msgs :: msg :: LaneletPose lanlet_pose ) { return toMapPose ( lanlet_pose . lanelet_id , lanlet_pose . s , lanlet_pose . offset , quaternion_operation :: convertEulerAngleToQuaternion ( lanlet_pose . rpy )); } geometry_msgs :: msg :: PoseStamped HdMapUtils :: toMapPose ( std :: int64_t lanelet_id , double s , double offset ) { openscenario_msgs :: msg :: LaneletPose lanelet_pose ; lanelet_pose . lanelet_id = lanelet_id ; lanelet_pose . s = s ; lanelet_pose . offset = offset ; return toMapPose ( lanelet_pose ); } boost :: optional < geometry_msgs :: msg :: Vector3 > HdMapUtils :: getTangentVector ( std :: int64_t lanelet_id , double s ) { const auto center_points = getCenterPoints ( lanelet_id ); simulation_api :: math :: CatmullRomSpline spline ( center_points ); return spline . getTangentVector ( s ); } bool HdMapUtils :: canChangeLane ( std :: int64_t from_lanelet_id , std :: int64_t to_lanelet_id ) { const auto from_lanelet = lanelet_map_ptr_ -> laneletLayer . get ( from_lanelet_id ); const auto to_lanelet = lanelet_map_ptr_ -> laneletLayer . get ( to_lanelet_id ); return traffic_rules_vehicle_ptr_ -> canChangeLane ( from_lanelet , to_lanelet ); } boost :: optional < double > HdMapUtils :: getLongitudinalDistance ( openscenario_msgs :: msg :: LaneletPose from , openscenario_msgs :: msg :: LaneletPose to ) { return getLongitudinalDistance ( from . lanelet_id , from . s , to . lanelet_id , to . s ); } boost :: optional < double > HdMapUtils :: getLongitudinalDistance ( std :: int64_t from_lanelet_id , double from_s , std :: int64_t to_lanelet_id , double to_s ) { if ( from_lanelet_id == to_lanelet_id ) { if ( from_s > to_s ) { return boost :: none ; } else { return to_s - from_s ; } } const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( from_lanelet_id ); const auto to_lanelet = lanelet_map_ptr_ -> laneletLayer . get ( to_lanelet_id ); lanelet :: Optional < lanelet :: routing :: Route > route = vehicle_routing_graph_ptr_ -> getRoute ( lanelet , to_lanelet , 0 , true ); if ( ! route ) { return boost :: none ; } lanelet :: routing :: LaneletPath shortest_path = route -> shortestPath (); double dist = 0.0 ; if ( shortest_path . empty ()) { return boost :: none ; } for ( auto lane_itr = shortest_path . begin (); lane_itr != shortest_path . end (); lane_itr ++ ) { if ( lane_itr -> id () == from_lanelet_id ) { dist = dist + getLaneletLength ( from_lanelet_id ) - from_s ; } else if ( lane_itr -> id () == to_lanelet_id ) { dist = dist + to_s ; } else { dist = dist + getLaneletLength ( lane_itr -> id ()); } } return dist ; } const autoware_auto_msgs :: msg :: HADMapBin HdMapUtils :: toMapBin () { std :: stringstream ss ; boost :: archive :: binary_oarchive oa ( ss ); oa << * lanelet_map_ptr_ ; auto id_counter = lanelet :: utils :: getId (); oa << id_counter ; std :: string tmp_str = ss . str (); autoware_auto_msgs :: msg :: HADMapBin msg ; msg . data . clear (); msg . data . resize ( tmp_str . size ()); msg . data . assign ( tmp_str . begin (), tmp_str . end ()); msg . header . frame_id = \"map\" ; return msg ; } void HdMapUtils :: insertMarkerArray ( visualization_msgs :: msg :: MarkerArray & a1 , const visualization_msgs :: msg :: MarkerArray & a2 ) const { a1 . markers . insert ( a1 . markers . end (), a2 . markers . begin (), a2 . markers . end ()); } const visualization_msgs :: msg :: MarkerArray HdMapUtils :: generateMarker () const { visualization_msgs :: msg :: MarkerArray markers ; lanelet :: ConstLanelets all_lanelets = lanelet :: utils :: query :: laneletLayer ( lanelet_map_ptr_ ); lanelet :: ConstLanelets road_lanelets = lanelet :: utils :: query :: roadLanelets ( all_lanelets ); lanelet :: ConstLanelets crosswalk_lanelets = lanelet :: utils :: query :: crosswalkLanelets ( all_lanelets ); lanelet :: ConstLanelets walkway_lanelets = lanelet :: utils :: query :: walkwayLanelets ( all_lanelets ); std :: vector < lanelet :: ConstLineString3d > stop_lines = lanelet :: utils :: query :: stopLinesLanelets ( road_lanelets ); std :: vector < lanelet :: AutowareTrafficLightConstPtr > aw_tl_reg_elems = lanelet :: utils :: query :: autowareTrafficLights ( all_lanelets ); std :: vector < lanelet :: DetectionAreaConstPtr > da_reg_elems = lanelet :: utils :: query :: detectionAreas ( all_lanelets ); lanelet :: ConstLineStrings3d parking_spaces = lanelet :: utils :: query :: getAllParkingSpaces ( lanelet_map_ptr_ ); lanelet :: ConstPolygons3d parking_lots = lanelet :: utils :: query :: getAllParkingLots ( lanelet_map_ptr_ ); auto cl_ll_borders = color_utils :: fromRgba ( 1.0 , 1.0 , 1.0 , 0.999 ); auto cl_road = color_utils :: fromRgba ( 0.2 , 0.7 , 0.7 , 0.3 ); auto cl_cross = color_utils :: fromRgba ( 0.2 , 0.7 , 0.2 , 0.3 ); auto cl_stoplines = color_utils :: fromRgba ( 1.0 , 0.0 , 0.0 , 0.5 ); auto cl_trafficlights = color_utils :: fromRgba ( 0.7 , 0.7 , 0.7 , 0.8 ); auto cl_detection_areas = color_utils :: fromRgba ( 0.7 , 0.7 , 0.7 , 0.3 ); auto cl_parking_lots = color_utils :: fromRgba ( 0.7 , 0.7 , 0.0 , 0.3 ); auto cl_parking_spaces = color_utils :: fromRgba ( 1.0 , 0.647 , 0.0 , 0.6 ); auto cl_lanelet_id = color_utils :: fromRgba ( 0.8 , 0.2 , 0.2 , 0.999 ); insertMarkerArray ( markers , lanelet :: visualization :: laneletsBoundaryAsMarkerArray ( road_lanelets , cl_ll_borders , true )); insertMarkerArray ( markers , lanelet :: visualization :: laneletsAsTriangleMarkerArray ( \"road_lanelets\" , road_lanelets , cl_road )); insertMarkerArray ( markers , lanelet :: visualization :: laneletsAsTriangleMarkerArray ( \"crosswalk_lanelets\" , crosswalk_lanelets , cl_cross )); insertMarkerArray ( markers , lanelet :: visualization :: laneletsAsTriangleMarkerArray ( \"walkway_lanelets\" , walkway_lanelets , cl_cross )); insertMarkerArray ( markers , lanelet :: visualization :: laneletDirectionAsMarkerArray ( road_lanelets )); insertMarkerArray ( markers , lanelet :: visualization :: lineStringsAsMarkerArray ( stop_lines , \"stop_lines\" , cl_stoplines )); insertMarkerArray ( markers , lanelet :: visualization :: autowareTrafficLightsAsMarkerArray ( aw_tl_reg_elems , cl_trafficlights )); insertMarkerArray ( markers , lanelet :: visualization :: detectionAreasAsMarkerArray ( da_reg_elems , cl_detection_areas )); insertMarkerArray ( markers , lanelet :: visualization :: parkingLotsAsMarkerArray ( parking_lots , cl_parking_lots )); insertMarkerArray ( markers , lanelet :: visualization :: parkingSpacesAsMarkerArray ( parking_spaces , cl_parking_spaces )); insertMarkerArray ( markers , lanelet :: visualization :: generateLaneletIdMarker ( road_lanelets , cl_lanelet_id )); insertMarkerArray ( markers , lanelet :: visualization :: generateLaneletIdMarker ( crosswalk_lanelets , cl_lanelet_id )); return markers ; } void HdMapUtils :: overwriteLaneletsCenterline () { for ( auto & lanelet_obj : lanelet_map_ptr_ -> laneletLayer ) { if ( ! lanelet_obj . hasCustomCenterline ()) { const auto fine_center_line = generateFineCenterline ( lanelet_obj , 2.0 ); lanelet_obj . setCenterline ( fine_center_line ); } } } std :: pair < size_t , size_t > HdMapUtils :: findNearestIndexPair ( const std :: vector < double > & accumulated_lengths , const double target_length ) { // List size const auto N = accumulated_lengths . size (); // Front if ( target_length < accumulated_lengths . at ( 1 )) { return std :: make_pair ( 0 , 1 ); } // Back if ( target_length > accumulated_lengths . at ( N - 2 )) { return std :: make_pair ( N - 2 , N - 1 ); } // Middle for ( size_t i = 1 ; i < N ; ++ i ) { if ( accumulated_lengths . at ( i - 1 ) <= target_length && target_length <= accumulated_lengths . at ( i )) { return std :: make_pair ( i - 1 , i ); } } // Throw an exception because this never happens throw HdMapError ( \"findNearestIndexPair(): No nearest point found.\" ); } const std :: unordered_map < std :: int64_t , std :: vector < std :: int64_t >> HdMapUtils :: getRightOfWayLaneletIds ( std :: vector < std :: int64_t > lanelet_ids ) const { std :: unordered_map < std :: int64_t , std :: vector < std :: int64_t >> ret ; for ( const auto & lanelet_id : lanelet_ids ) { ret . emplace ( lanelet_id , getRightOfWayLaneletIds ( lanelet_id )); } return ret ; } const std :: vector < std :: int64_t > HdMapUtils :: getRightOfWayLaneletIds ( std :: int64_t lanelet_id ) const { std :: vector < std :: int64_t > ret ; const auto & assigned_lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto right_of_ways = assigned_lanelet . regulatoryElementsAs < lanelet :: RightOfWay > (); for ( const auto & right_of_way : right_of_ways ) { const auto right_of_Way_lanelets = right_of_way -> rightOfWayLanelets (); for ( const auto & ll : right_of_Way_lanelets ) { ret . emplace_back ( ll . id ()); } } return ret ; } std :: vector < std :: shared_ptr < const lanelet :: TrafficSign >> HdMapUtils :: getTrafficSignRegElementsOnPath ( std :: vector < std :: int64_t > lanelet_ids ) { std :: vector < std :: shared_ptr < const lanelet :: TrafficSign >> ret ; for ( const auto & lanelet_id : lanelet_ids ) { const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto traffic_signs = lanelet . regulatoryElementsAs < const lanelet :: TrafficSign > (); for ( const auto traffic_sign : traffic_signs ) { ret . push_back ( traffic_sign ); } } return ret ; } std :: vector < std :: shared_ptr < const lanelet :: autoware :: AutowareTrafficLight >> HdMapUtils :: getTrafficLightRegElementsOnPath ( const std :: vector < std :: int64_t > & lanelet_ids ) const { std :: vector < std :: shared_ptr < const lanelet :: autoware :: AutowareTrafficLight >> ret ; for ( const auto & lanelet_id : lanelet_ids ) { const auto lanelet = lanelet_map_ptr_ -> laneletLayer . get ( lanelet_id ); const auto traffic_lights = lanelet . regulatoryElementsAs < const lanelet :: autoware :: AutowareTrafficLight > (); for ( const auto traffic_light : traffic_lights ) { ret . push_back ( traffic_light ); } } return ret ; } std :: vector < lanelet :: ConstLineString3d > HdMapUtils :: getStopLinesOnPath ( std :: vector < std :: int64_t > lanelet_ids ) { std :: vector < lanelet :: ConstLineString3d > ret ; const auto traffic_signs = getTrafficSignRegElementsOnPath ( lanelet_ids ); for ( const auto & traffic_sign : traffic_signs ) { if ( traffic_sign -> type () != \"stop_sign\" ) { continue ; } for ( const auto & stop_line : traffic_sign -> refLines ()) { ret . emplace_back ( stop_line ); } } return ret ; } lanelet :: AutowareTrafficLightConstPtr HdMapUtils :: getTrafficLight ( const std :: int64_t traffic_light_id ) const { lanelet :: ConstLanelets all_lanelets = lanelet :: utils :: query :: laneletLayer ( lanelet_map_ptr_ ); auto autoware_traffic_lights = lanelet :: utils :: query :: autowareTrafficLights ( all_lanelets ); for ( const auto light : autoware_traffic_lights ) { for ( auto light_string : light -> lightBulbs ()) { if ( light_string . hasAttribute ( \"traffic_light_id\" )) { auto id = light_string . attribute ( \"traffic_light_id\" ). asId (); if ( id ) { return light ; } } } } std :: string message = \"traffic_light_id does not match. ID : \" + std :: to_string ( traffic_light_id ); throw HdMapError ( message . c_str ()); } const boost :: optional < std :: int64_t > HdMapUtils :: getTrafficLightStopLineId ( const std :: int64_t & traffic_light_id ) const { const auto traffic_light = getTrafficLight ( traffic_light_id ); if ( traffic_light -> stopLine ()) { return traffic_light -> stopLine () -> id (); } return boost :: none ; } const std :: vector < geometry_msgs :: msg :: Point > HdMapUtils :: getTrafficLightStopLinePoints ( std :: int64_t traffic_light_id ) const { std :: vector < geometry_msgs :: msg :: Point > ret ; const auto traffic_light = getTrafficLight ( traffic_light_id ); const auto stop_line = traffic_light -> stopLine (); if ( stop_line ) { for ( const auto point : stop_line . get ()) { geometry_msgs :: msg :: Point p ; p . x = point . x (); p . y = point . y (); p . z = point . z (); ret . emplace_back ( p ); } } return ret ; } const std :: vector < geometry_msgs :: msg :: Point > HdMapUtils :: getStopLinePolygon ( std :: int64_t lanelet_id ) { std :: vector < geometry_msgs :: msg :: Point > points ; const auto stop_line = lanelet_map_ptr_ -> lineStringLayer . get ( lanelet_id ); for ( const auto point : stop_line ) { geometry_msgs :: msg :: Point p ; p . x = point . x (); p . y = point . y (); p . z = point . z (); points . emplace_back ( p ); } return points ; } const std :: vector < std :: int64_t > HdMapUtils :: getTrafficLightIdsOnPath ( const std :: vector < std :: int64_t > & route_lanelets ) const { std :: vector < std :: int64_t > ret ; auto traffic_lights = getTrafficLightRegElementsOnPath ( route_lanelets ); for ( const auto traffic_light : traffic_lights ) { for ( auto light_string : traffic_light -> lightBulbs ()) { if ( light_string . hasAttribute ( \"traffic_light_id\" )) { auto id = light_string . attribute ( \"traffic_light_id\" ). asId (); if ( id ) { ret . emplace_back ( id . get ()); } } } } return ret ; } const boost :: optional < double > HdMapUtils :: getDistanceToTrafficLightStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ) const { auto traffic_light_ids = getTrafficLightIdsOnPath ( route_lanelets ); if ( traffic_light_ids . size () == 0 ) { return boost :: none ; } std :: set < double > collision_points ; for ( const auto id : traffic_light_ids ) { const auto collision_point = getDistanceToTrafficLightStopLine ( waypoints , id ); if ( collision_point ) { collision_points . insert ( collision_point . get ()); } } if ( collision_points . empty ()) { return boost :: none ; } return * collision_points . begin (); } const boost :: optional < double > HdMapUtils :: getDistanceToTrafficLightStopLine ( const std :: vector < geometry_msgs :: msg :: Point > & waypoints , const std :: int64_t & traffic_light_id ) const { if ( waypoints . empty ()) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( waypoints ); const auto stop_line = getTrafficLightStopLinePoints ( traffic_light_id ); if ( stop_line . size () <= 1 ) { return boost :: none ; } const auto collision_point = spline . getCollisionPointIn2D ( stop_line ); return collision_point ; } boost :: optional < double > HdMapUtils :: getDistanceToStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ) { if ( waypoints . empty ()) { return boost :: none ; } std :: set < double > collision_points ; if ( waypoints . empty ()) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( waypoints ); const auto stop_lines = getStopLinesOnPath ({ route_lanelets }); for ( const auto & stop_line : stop_lines ) { std :: vector < geometry_msgs :: msg :: Point > stop_line_points ; for ( const auto & point : stop_line ) { geometry_msgs :: msg :: Point p ; p . x = point . x (); p . y = point . y (); p . z = point . z (); stop_line_points . emplace_back ( p ); } const auto collision_point = spline . getCollisionPointIn2D ( stop_line_points ); if ( collision_point ) { collision_points . insert ( collision_point . get ()); } } if ( collision_points . empty ()) { return boost :: none ; } return * collision_points . begin (); } std :: vector < double > HdMapUtils :: calculateSegmentDistances ( const lanelet :: ConstLineString3d & line_string ) { std :: vector < double > segment_distances ; segment_distances . reserve ( line_string . size () - 1 ); for ( size_t i = 1 ; i < line_string . size (); ++ i ) { const auto distance = lanelet :: geometry :: distance ( line_string [ i ], line_string [ i - 1 ]); segment_distances . push_back ( distance ); } return segment_distances ; } std :: vector < double > HdMapUtils :: calculateAccumulatedLengths ( const lanelet :: ConstLineString3d & line_string ) { const auto segment_distances = calculateSegmentDistances ( line_string ); std :: vector < double > accumulated_lengths { 0 }; accumulated_lengths . reserve ( segment_distances . size () + 1 ); std :: partial_sum ( std :: begin ( segment_distances ), std :: end ( segment_distances ), std :: back_inserter ( accumulated_lengths )); return accumulated_lengths ; } std :: vector < lanelet :: BasicPoint3d > HdMapUtils :: resamplePoints ( const lanelet :: ConstLineString3d & line_string , const int32_t num_segments ) { // Calculate length const auto line_length = lanelet :: geometry :: length ( line_string ); // Calculate accumulated lengths const auto accumulated_lengths = calculateAccumulatedLengths ( line_string ); // Create each segment std :: vector < lanelet :: BasicPoint3d > resampled_points ; for ( auto i = 0 ; i <= num_segments ; ++ i ) { // Find two nearest points const double target_length = ( static_cast < double > ( i ) / num_segments ) * static_cast < double > ( line_length ); const auto index_pair = findNearestIndexPair ( accumulated_lengths , target_length ); // Apply linear interpolation const lanelet :: BasicPoint3d back_point = line_string [ index_pair . first ]; const lanelet :: BasicPoint3d front_point = line_string [ index_pair . second ]; const auto direction_vector = ( front_point - back_point ); const auto back_length = accumulated_lengths . at ( index_pair . first ); const auto front_length = accumulated_lengths . at ( index_pair . second ); const auto segment_length = front_length - back_length ; const auto target_point = back_point + ( direction_vector * ( target_length - back_length ) / segment_length ); // Add to list resampled_points . push_back ( target_point ); } return resampled_points ; } lanelet :: LineString3d HdMapUtils :: generateFineCenterline ( const lanelet :: ConstLanelet & lanelet_obj , const double resolution ) { // Get length of longer border const double left_length = static_cast < double > ( lanelet :: geometry :: length ( lanelet_obj . leftBound ())); const double right_length = static_cast < double > ( lanelet :: geometry :: length ( lanelet_obj . rightBound ())); const double longer_distance = ( left_length > right_length ) ? left_length : right_length ; const int32_t num_segments = std :: max ( static_cast < int32_t > ( ceil ( longer_distance / resolution )), 1 ); // Resample points const auto left_points = resamplePoints ( lanelet_obj . leftBound (), num_segments ); const auto right_points = resamplePoints ( lanelet_obj . rightBound (), num_segments ); // Create centerline lanelet :: LineString3d centerline ( lanelet :: utils :: getId ()); for ( size_t i = 0 ; i < static_cast < size_t > ( num_segments + 1 ); i ++ ) { // Add ID for the average point of left and right const auto center_basic_point = ( right_points . at ( i ) + left_points . at ( i )) / 2.0 ; const lanelet :: Point3d center_point ( lanelet :: utils :: getId (), center_basic_point . x (), center_basic_point . y (), center_basic_point . z ()); centerline . push_back ( center_point ); } return centerline ; } std :: vector < double > HdMapUtils :: calcEuclidDist ( const std :: vector < double > & x , const std :: vector < double > & y , const std :: vector < double > & z ) { std :: vector < double > dist_v ; dist_v . push_back ( 0.0 ); for ( size_t i = 0 ; i < x . size () - 1 ; ++ i ) { const double dx = x . at ( i + 1 ) - x . at ( i ); const double dy = y . at ( i + 1 ) - y . at ( i ); const double dz = z . at ( i + 1 ) - z . at ( i ); const double d = std :: sqrt ( dx * dx + dy * dy + dz * dz ); dist_v . push_back ( dist_v . at ( i ) + d ); } return dist_v ; } } // namespace hdmap_utils Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/hdmap__utils_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/hdmap_utils/hdmap_utils.hpp # Namespaces # Name hdmap_utils Classes # Name class hdmap_utils::HdMapUtils class hdmap_utils::HdMapError Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__HDMAP_UTILS__HDMAP_UTILS_HPP_ #define SIMULATION_API__HDMAP_UTILS__HDMAP_UTILS_HPP_ #include <simulation_api/math/hermite_curve.hpp> #include <simulation_api/traffic_lights/traffic_light_state.hpp> #include <rclcpp/rclcpp.hpp> #include <openscenario_msgs/msg/entity_status.hpp> #include <geometry_msgs/msg/pose_stamped.hpp> #include <autoware_auto_msgs/msg/had_map_bin.hpp> #include <geometry_msgs/msg/vector3.h> #include <geographic_msgs/msg/geo_point.hpp> #include <tf2_geometry_msgs/tf2_geometry_msgs.h> #include <tf2/LinearMath/Matrix3x3.h> #include <lanelet2_core/LaneletMap.h> #include <lanelet2_core/geometry/Lanelet.h> #include <lanelet2_core/primitives/BasicRegulatoryElements.h> #include <lanelet2_core/primitives/LaneletSequence.h> #include <lanelet2_extension_psim/utility/message_conversion.hpp> #include <lanelet2_extension_psim/utility/utilities.hpp> #include <lanelet2_extension_psim/utility/query.hpp> #include <lanelet2_routing/Route.h> #include <lanelet2_routing/RoutingCost.h> #include <lanelet2_routing/RoutingGraph.h> #include <lanelet2_routing/RoutingGraphContainer.h> #include <lanelet2_traffic_rules/TrafficRulesFactory.h> #include <visualization_msgs/msg/marker_array.hpp> #include <boost/optional.hpp> #include <map> #include <unordered_map> #include <string> #include <utility> #include <vector> #include <memory> namespace hdmap_utils { class HdMapError : public std :: runtime_error { public : explicit HdMapError ( const char * message ) : runtime_error ( message ) {} }; class HdMapUtils { public : explicit HdMapUtils ( std :: string lanelet_path , geographic_msgs :: msg :: GeoPoint origin ); const autoware_auto_msgs :: msg :: HADMapBin toMapBin (); void insertMarkerArray ( visualization_msgs :: msg :: MarkerArray & a1 , const visualization_msgs :: msg :: MarkerArray & a2 ) const ; std :: vector < geometry_msgs :: msg :: Point > toMapPoints ( std :: int64_t lanelet_id , std :: vector < double > s ); boost :: optional < openscenario_msgs :: msg :: LaneletPose > toLaneletPose ( geometry_msgs :: msg :: Pose pose ); geometry_msgs :: msg :: PoseStamped toMapPose ( std :: int64_t lanelet_id , double s , double offset , geometry_msgs :: msg :: Quaternion quat ); geometry_msgs :: msg :: PoseStamped toMapPose ( openscenario_msgs :: msg :: LaneletPose lanlet_pose ); geometry_msgs :: msg :: PoseStamped toMapPose ( std :: int64_t lanelet_id , double s , double offset ); double getHeight ( const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ); const std :: vector < std :: int64_t > getLaneletIds (); std :: vector < std :: int64_t > getNextLaneletIds ( std :: int64_t lanelet_id , std :: string turn_direction ); std :: vector < std :: int64_t > getNextLaneletIds ( std :: int64_t lanelet_id ) const ; std :: vector < std :: int64_t > getPreviousLaneletIds ( std :: int64_t lanelet_id , std :: string turn_direction ); std :: vector < std :: int64_t > getPreviousLaneletIds ( std :: int64_t lanelet_id ) const ; boost :: optional < int > getLaneChangeableLenletId ( std :: int64_t lanelet_id , std :: string direction ); boost :: optional < double > getDistanceToStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ); double getLaneletLength ( std :: int64_t lanelet_id ) const ; bool isInLanelet ( std :: int64_t lanelet_id , double s ); boost :: optional < double > getLongitudinalDistance ( openscenario_msgs :: msg :: LaneletPose from , openscenario_msgs :: msg :: LaneletPose to ); boost :: optional < double > getLongitudinalDistance ( std :: int64_t from_lanelet_id , double from_s , std :: int64_t to_lanelet_id , double to_s ); double getSpeedLimit ( std :: vector < std :: int64_t > lanelet_ids ); bool isInRoute ( std :: int64_t lanelet_id , std :: vector < std :: int64_t > route ) const ; std :: vector < std :: int64_t > getFollowingLanelets ( std :: int64_t lanelet_id , double distance = 100 , bool include_self = true ); std :: vector < std :: int64_t > getFollowingLanelets ( std :: int64_t lanelet_id , std :: vector < std :: int64_t > candidate_lanelet_ids , double distance = 100 , bool include_self = true ); std :: vector < std :: int64_t > getPreviousLanelets ( std :: int64_t lanelet_id , double distance = 100 ); std :: vector < geometry_msgs :: msg :: Point > getCenterPoints ( std :: int64_t lanelet_id ); std :: vector < geometry_msgs :: msg :: Point > getCenterPoints ( std :: vector < std :: int64_t > lanelet_ids ); std :: vector < geometry_msgs :: msg :: Point > clipTrajectoryFromLaneletIds ( std :: int64_t lanelet_id , double s , std :: vector < std :: int64_t > lanelet_ids , double foward_distance = 20 ); bool canChangeLane ( std :: int64_t from_lanelet_id , std :: int64_t to_lanelet_id ); boost :: optional < std :: pair < simulation_api :: math :: HermiteCurve , double >> getLaneChangeTrajectory ( geometry_msgs :: msg :: Pose from_pose , std :: int64_t to_lanelet_id ); boost :: optional < simulation_api :: math :: HermiteCurve > getLaneChangeTrajectory ( geometry_msgs :: msg :: Pose from_pose , std :: int64_t to_lanelet_id , double to_s , double tangent_vector_size = 100 ); boost :: optional < geometry_msgs :: msg :: Vector3 > getTangentVector ( std :: int64_t lanelet_id , double s ); std :: vector < std :: int64_t > getRoute ( std :: int64_t from_lanelet_id , std :: int64_t to_lanelet_id ); std :: vector < std :: int64_t > getConflictingCrosswalkIds ( std :: vector < std :: int64_t > lanelet_ids ) const ; boost :: optional < double > getCollisionPointInLaneCoordinate ( std :: int64_t lanelet_id , std :: int64_t crossing_lanelet_id ); const visualization_msgs :: msg :: MarkerArray generateMarker () const ; const std :: vector < std :: int64_t > getRightOfWayLaneletIds ( std :: int64_t lanelet_id ) const ; const std :: unordered_map < std :: int64_t , std :: vector < std :: int64_t >> getRightOfWayLaneletIds ( std :: vector < std :: int64_t > lanelet_ids ) const ; boost :: optional < std :: int64_t > getClosetLanletId ( geometry_msgs :: msg :: Pose pose , double distance_thresh = 30.0 ); const std :: vector < geometry_msgs :: msg :: Point > getLaneletPolygon ( std :: int64_t lanelet_id ); const std :: vector < geometry_msgs :: msg :: Point > getStopLinePolygon ( std :: int64_t lanelet_id ); const std :: vector < std :: int64_t > getTrafficLightIds () const ; const boost :: optional < geometry_msgs :: msg :: Point > getTrafficLightBulbPosition ( std :: int64_t traffic_light_id , simulation_api :: TrafficLightColor color ) const ; const boost :: optional < std :: int64_t > getTrafficLightStopLineId ( const std :: int64_t & traffic_light_id ) const ; const std :: vector < geometry_msgs :: msg :: Point > getTrafficLightStopLinePoints ( std :: int64_t traffic_light_id ) const ; const boost :: optional < double > getDistanceToTrafficLightStopLine ( const std :: vector < geometry_msgs :: msg :: Point > & waypoints , const std :: int64_t & traffic_light_id ) const ; const boost :: optional < double > getDistanceToTrafficLightStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ) const ; const std :: vector < std :: int64_t > getTrafficLightIdsOnPath ( const std :: vector < std :: int64_t > & route_lanelets ) const ; private : lanelet :: AutowareTrafficLightConstPtr getTrafficLight ( const std :: int64_t traffic_light_id ) const ; std :: vector < std :: pair < double , lanelet :: Lanelet >> excludeSubtypeLaneletsWithDistance ( const std :: vector < std :: pair < double , lanelet :: Lanelet >> & lls , const char subtype []); std :: vector < std :: shared_ptr < const lanelet :: autoware :: AutowareTrafficLight >> getTrafficLightRegElementsOnPath ( const std :: vector < std :: int64_t > & lanelet_ids ) const ; std :: vector < std :: shared_ptr < const lanelet :: TrafficSign >> getTrafficSignRegElementsOnPath ( std :: vector < std :: int64_t > lanelet_ids ); std :: vector < lanelet :: ConstLineString3d > getStopLinesOnPath ( std :: vector < std :: int64_t > lanelet_ids ); geometry_msgs :: msg :: Vector3 getVectorFromPose ( geometry_msgs :: msg :: Pose pose , double magnitude ); void mapCallback ( const autoware_auto_msgs :: msg :: HADMapBin & msg ); lanelet :: LaneletMapPtr lanelet_map_ptr_ ; lanelet :: routing :: RoutingGraphConstPtr vehicle_routing_graph_ptr_ ; lanelet :: traffic_rules :: TrafficRulesPtr traffic_rules_vehicle_ptr_ ; lanelet :: routing :: RoutingGraphConstPtr pedestrian_routing_graph_ptr_ ; lanelet :: traffic_rules :: TrafficRulesPtr traffic_rules_pedestrian_ptr_ ; std :: vector < double > calcEuclidDist ( const std :: vector < double > & x , const std :: vector < double > & y , const std :: vector < double > & z ); void overwriteLaneletsCenterline (); lanelet :: LineString3d generateFineCenterline ( const lanelet :: ConstLanelet & lanelet_obj , const double resolution ); std :: vector < lanelet :: BasicPoint3d > resamplePoints ( const lanelet :: ConstLineString3d & line_string , const int32_t num_segments ); std :: pair < size_t , size_t > findNearestIndexPair ( const std :: vector < double > & accumulated_lengths , const double target_length ); std :: vector < double > calculateAccumulatedLengths ( const lanelet :: ConstLineString3d & line_string ); std :: vector < double > calculateSegmentDistances ( const lanelet :: ConstLineString3d & line_string ); }; } // namespace hdmap_utils #endif // SIMULATION_API__HDMAP_UTILS__HDMAP_UTILS_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/hdmap_utils/hdmap_utils.hpp"},{"location":"package/simulation_api/markdown/Files/hdmap__utils_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apihdmap_utilshdmap_utilshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/hdmap_utils/hdmap_utils.hpp"},{"location":"package/simulation_api/markdown/Files/hdmap__utils_8hpp/#namespaces","text":"Name hdmap_utils","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/hdmap__utils_8hpp/#classes","text":"Name class hdmap_utils::HdMapUtils class hdmap_utils::HdMapError","title":"Classes"},{"location":"package/simulation_api/markdown/Files/hdmap__utils_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__HDMAP_UTILS__HDMAP_UTILS_HPP_ #define SIMULATION_API__HDMAP_UTILS__HDMAP_UTILS_HPP_ #include <simulation_api/math/hermite_curve.hpp> #include <simulation_api/traffic_lights/traffic_light_state.hpp> #include <rclcpp/rclcpp.hpp> #include <openscenario_msgs/msg/entity_status.hpp> #include <geometry_msgs/msg/pose_stamped.hpp> #include <autoware_auto_msgs/msg/had_map_bin.hpp> #include <geometry_msgs/msg/vector3.h> #include <geographic_msgs/msg/geo_point.hpp> #include <tf2_geometry_msgs/tf2_geometry_msgs.h> #include <tf2/LinearMath/Matrix3x3.h> #include <lanelet2_core/LaneletMap.h> #include <lanelet2_core/geometry/Lanelet.h> #include <lanelet2_core/primitives/BasicRegulatoryElements.h> #include <lanelet2_core/primitives/LaneletSequence.h> #include <lanelet2_extension_psim/utility/message_conversion.hpp> #include <lanelet2_extension_psim/utility/utilities.hpp> #include <lanelet2_extension_psim/utility/query.hpp> #include <lanelet2_routing/Route.h> #include <lanelet2_routing/RoutingCost.h> #include <lanelet2_routing/RoutingGraph.h> #include <lanelet2_routing/RoutingGraphContainer.h> #include <lanelet2_traffic_rules/TrafficRulesFactory.h> #include <visualization_msgs/msg/marker_array.hpp> #include <boost/optional.hpp> #include <map> #include <unordered_map> #include <string> #include <utility> #include <vector> #include <memory> namespace hdmap_utils { class HdMapError : public std :: runtime_error { public : explicit HdMapError ( const char * message ) : runtime_error ( message ) {} }; class HdMapUtils { public : explicit HdMapUtils ( std :: string lanelet_path , geographic_msgs :: msg :: GeoPoint origin ); const autoware_auto_msgs :: msg :: HADMapBin toMapBin (); void insertMarkerArray ( visualization_msgs :: msg :: MarkerArray & a1 , const visualization_msgs :: msg :: MarkerArray & a2 ) const ; std :: vector < geometry_msgs :: msg :: Point > toMapPoints ( std :: int64_t lanelet_id , std :: vector < double > s ); boost :: optional < openscenario_msgs :: msg :: LaneletPose > toLaneletPose ( geometry_msgs :: msg :: Pose pose ); geometry_msgs :: msg :: PoseStamped toMapPose ( std :: int64_t lanelet_id , double s , double offset , geometry_msgs :: msg :: Quaternion quat ); geometry_msgs :: msg :: PoseStamped toMapPose ( openscenario_msgs :: msg :: LaneletPose lanlet_pose ); geometry_msgs :: msg :: PoseStamped toMapPose ( std :: int64_t lanelet_id , double s , double offset ); double getHeight ( const openscenario_msgs :: msg :: LaneletPose & lanelet_pose ); const std :: vector < std :: int64_t > getLaneletIds (); std :: vector < std :: int64_t > getNextLaneletIds ( std :: int64_t lanelet_id , std :: string turn_direction ); std :: vector < std :: int64_t > getNextLaneletIds ( std :: int64_t lanelet_id ) const ; std :: vector < std :: int64_t > getPreviousLaneletIds ( std :: int64_t lanelet_id , std :: string turn_direction ); std :: vector < std :: int64_t > getPreviousLaneletIds ( std :: int64_t lanelet_id ) const ; boost :: optional < int > getLaneChangeableLenletId ( std :: int64_t lanelet_id , std :: string direction ); boost :: optional < double > getDistanceToStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ); double getLaneletLength ( std :: int64_t lanelet_id ) const ; bool isInLanelet ( std :: int64_t lanelet_id , double s ); boost :: optional < double > getLongitudinalDistance ( openscenario_msgs :: msg :: LaneletPose from , openscenario_msgs :: msg :: LaneletPose to ); boost :: optional < double > getLongitudinalDistance ( std :: int64_t from_lanelet_id , double from_s , std :: int64_t to_lanelet_id , double to_s ); double getSpeedLimit ( std :: vector < std :: int64_t > lanelet_ids ); bool isInRoute ( std :: int64_t lanelet_id , std :: vector < std :: int64_t > route ) const ; std :: vector < std :: int64_t > getFollowingLanelets ( std :: int64_t lanelet_id , double distance = 100 , bool include_self = true ); std :: vector < std :: int64_t > getFollowingLanelets ( std :: int64_t lanelet_id , std :: vector < std :: int64_t > candidate_lanelet_ids , double distance = 100 , bool include_self = true ); std :: vector < std :: int64_t > getPreviousLanelets ( std :: int64_t lanelet_id , double distance = 100 ); std :: vector < geometry_msgs :: msg :: Point > getCenterPoints ( std :: int64_t lanelet_id ); std :: vector < geometry_msgs :: msg :: Point > getCenterPoints ( std :: vector < std :: int64_t > lanelet_ids ); std :: vector < geometry_msgs :: msg :: Point > clipTrajectoryFromLaneletIds ( std :: int64_t lanelet_id , double s , std :: vector < std :: int64_t > lanelet_ids , double foward_distance = 20 ); bool canChangeLane ( std :: int64_t from_lanelet_id , std :: int64_t to_lanelet_id ); boost :: optional < std :: pair < simulation_api :: math :: HermiteCurve , double >> getLaneChangeTrajectory ( geometry_msgs :: msg :: Pose from_pose , std :: int64_t to_lanelet_id ); boost :: optional < simulation_api :: math :: HermiteCurve > getLaneChangeTrajectory ( geometry_msgs :: msg :: Pose from_pose , std :: int64_t to_lanelet_id , double to_s , double tangent_vector_size = 100 ); boost :: optional < geometry_msgs :: msg :: Vector3 > getTangentVector ( std :: int64_t lanelet_id , double s ); std :: vector < std :: int64_t > getRoute ( std :: int64_t from_lanelet_id , std :: int64_t to_lanelet_id ); std :: vector < std :: int64_t > getConflictingCrosswalkIds ( std :: vector < std :: int64_t > lanelet_ids ) const ; boost :: optional < double > getCollisionPointInLaneCoordinate ( std :: int64_t lanelet_id , std :: int64_t crossing_lanelet_id ); const visualization_msgs :: msg :: MarkerArray generateMarker () const ; const std :: vector < std :: int64_t > getRightOfWayLaneletIds ( std :: int64_t lanelet_id ) const ; const std :: unordered_map < std :: int64_t , std :: vector < std :: int64_t >> getRightOfWayLaneletIds ( std :: vector < std :: int64_t > lanelet_ids ) const ; boost :: optional < std :: int64_t > getClosetLanletId ( geometry_msgs :: msg :: Pose pose , double distance_thresh = 30.0 ); const std :: vector < geometry_msgs :: msg :: Point > getLaneletPolygon ( std :: int64_t lanelet_id ); const std :: vector < geometry_msgs :: msg :: Point > getStopLinePolygon ( std :: int64_t lanelet_id ); const std :: vector < std :: int64_t > getTrafficLightIds () const ; const boost :: optional < geometry_msgs :: msg :: Point > getTrafficLightBulbPosition ( std :: int64_t traffic_light_id , simulation_api :: TrafficLightColor color ) const ; const boost :: optional < std :: int64_t > getTrafficLightStopLineId ( const std :: int64_t & traffic_light_id ) const ; const std :: vector < geometry_msgs :: msg :: Point > getTrafficLightStopLinePoints ( std :: int64_t traffic_light_id ) const ; const boost :: optional < double > getDistanceToTrafficLightStopLine ( const std :: vector < geometry_msgs :: msg :: Point > & waypoints , const std :: int64_t & traffic_light_id ) const ; const boost :: optional < double > getDistanceToTrafficLightStopLine ( const std :: vector < std :: int64_t > & route_lanelets , const std :: vector < geometry_msgs :: msg :: Point > & waypoints ) const ; const std :: vector < std :: int64_t > getTrafficLightIdsOnPath ( const std :: vector < std :: int64_t > & route_lanelets ) const ; private : lanelet :: AutowareTrafficLightConstPtr getTrafficLight ( const std :: int64_t traffic_light_id ) const ; std :: vector < std :: pair < double , lanelet :: Lanelet >> excludeSubtypeLaneletsWithDistance ( const std :: vector < std :: pair < double , lanelet :: Lanelet >> & lls , const char subtype []); std :: vector < std :: shared_ptr < const lanelet :: autoware :: AutowareTrafficLight >> getTrafficLightRegElementsOnPath ( const std :: vector < std :: int64_t > & lanelet_ids ) const ; std :: vector < std :: shared_ptr < const lanelet :: TrafficSign >> getTrafficSignRegElementsOnPath ( std :: vector < std :: int64_t > lanelet_ids ); std :: vector < lanelet :: ConstLineString3d > getStopLinesOnPath ( std :: vector < std :: int64_t > lanelet_ids ); geometry_msgs :: msg :: Vector3 getVectorFromPose ( geometry_msgs :: msg :: Pose pose , double magnitude ); void mapCallback ( const autoware_auto_msgs :: msg :: HADMapBin & msg ); lanelet :: LaneletMapPtr lanelet_map_ptr_ ; lanelet :: routing :: RoutingGraphConstPtr vehicle_routing_graph_ptr_ ; lanelet :: traffic_rules :: TrafficRulesPtr traffic_rules_vehicle_ptr_ ; lanelet :: routing :: RoutingGraphConstPtr pedestrian_routing_graph_ptr_ ; lanelet :: traffic_rules :: TrafficRulesPtr traffic_rules_pedestrian_ptr_ ; std :: vector < double > calcEuclidDist ( const std :: vector < double > & x , const std :: vector < double > & y , const std :: vector < double > & z ); void overwriteLaneletsCenterline (); lanelet :: LineString3d generateFineCenterline ( const lanelet :: ConstLanelet & lanelet_obj , const double resolution ); std :: vector < lanelet :: BasicPoint3d > resamplePoints ( const lanelet :: ConstLineString3d & line_string , const int32_t num_segments ); std :: pair < size_t , size_t > findNearestIndexPair ( const std :: vector < double > & accumulated_lengths , const double target_length ); std :: vector < double > calculateAccumulatedLengths ( const lanelet :: ConstLineString3d & line_string ); std :: vector < double > calculateSegmentDistances ( const lanelet :: ConstLineString3d & line_string ); }; } // namespace hdmap_utils #endif // SIMULATION_API__HDMAP_UTILS__HDMAP_UTILS_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/helper_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/helper/helper.cpp # Namespaces # Name simulation_api::helper simulation_api Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/helper/helper.hpp> #include <quaternion_operation/quaternion_operation.h> #include <string> namespace simulation_api { namespace helper { openscenario_msgs :: msg :: ActionStatus constructActionStatus ( double linear_vel , double angular_vel , double linear_accel , double angular_accel ) { openscenario_msgs :: msg :: ActionStatus status ; geometry_msgs :: msg :: Twist twist ; twist . linear . x = linear_vel ; twist . angular . z = angular_vel ; geometry_msgs :: msg :: Accel accel ; accel . linear . x = linear_accel ; accel . angular . z = angular_accel ; status . twist = twist ; status . accel = accel ; return status ; } openscenario_msgs :: msg :: LaneletPose constructLaneletPose ( std :: int64_t lanelet_id , double s , double offset , double roll , double pitch , double yaw ) { openscenario_msgs :: msg :: LaneletPose lanelet_pose ; lanelet_pose . lanelet_id = lanelet_id ; lanelet_pose . s = s ; lanelet_pose . offset = offset ; lanelet_pose . rpy . x = roll ; lanelet_pose . rpy . y = pitch ; lanelet_pose . rpy . z = yaw ; return lanelet_pose ; } geometry_msgs :: msg :: Vector3 constructRPY ( double roll , double pitch , double yaw ) { geometry_msgs :: msg :: Vector3 rpy ; rpy . x = roll ; rpy . y = pitch ; rpy . z = yaw ; return rpy ; } geometry_msgs :: msg :: Vector3 constructRPYfronQuaternion ( geometry_msgs :: msg :: Quaternion quaternion ) { return quaternion_operation :: convertQuaternionToEulerAngle ( quaternion ); } geometry_msgs :: msg :: Pose constructPose ( double x , double y , double z , double roll , double pitch , double yaw ) { geometry_msgs :: msg :: Pose pose ; pose . position . x = x ; pose . position . y = y ; pose . position . z = z ; pose . orientation = quaternion_operation :: convertEulerAngleToQuaternion ( constructRPY ( roll , pitch , yaw )); return pose ; } std :: ostream & operator << ( std :: ostream & os , const openscenario_msgs :: msg :: LaneletPose & ll_pose ) { os << \"lanelet id : \" << ll_pose . lanelet_id << \" \\n s : \" << ll_pose . s ; return os ; } const simulation_api_schema :: DetectionSensorConfiguration constructDetectionSensorConfiguration ( std :: string entity , std :: string topic_name , double update_duration ) { simulation_api_schema :: DetectionSensorConfiguration configuration ; configuration . set_entity ( entity ); configuration . set_topic_name ( topic_name ); configuration . set_update_duration ( update_duration ); return configuration ; } const simulation_api_schema :: LidarConfiguration constructLidarConfiguration ( LidarType type , std :: string entity , std :: string topic_name , double horizontal_resolution ) { simulation_api_schema :: LidarConfiguration configuration ; configuration . set_horizontal_resolution ( horizontal_resolution ); configuration . set_topic_name ( topic_name ); configuration . set_entity ( entity ); switch ( type ) { case LidarType :: VLP16 : configuration . set_scan_duration ( 0.1 ); configuration . add_vertical_angles ( -15.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -13.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -11.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -9.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -7.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -5.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -3.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -1.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 1.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 3.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 5.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 7.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 9.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 11.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 13.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 15.0 / 180.0 * M_PI ); break ; case LidarType :: VLP32 : configuration . set_scan_duration ( 0.1 ); configuration . add_vertical_angles ( -15.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -13.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( -12.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( -11.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -9.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( -8.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( -7.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -5.66666667 / 180 * M_PI ); configuration . add_vertical_angles ( -4.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( -3.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -1.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( -0.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( 1.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 2.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( 3.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( 5.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 6.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( 7.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( 9.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 10.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( 11.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( 13.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 14.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( 15.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( 17.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 18.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( 19.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( 21.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 22.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( 23.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( 25.0 / 180.0 * M_PI ); break ; } return configuration ; } } // namespace helper } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/helper/helper.cpp"},{"location":"package/simulation_api/markdown/Files/helper_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrchelperhelpercpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/helper/helper.cpp"},{"location":"package/simulation_api/markdown/Files/helper_8cpp/#namespaces","text":"Name simulation_api::helper simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/helper_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/helper/helper.hpp> #include <quaternion_operation/quaternion_operation.h> #include <string> namespace simulation_api { namespace helper { openscenario_msgs :: msg :: ActionStatus constructActionStatus ( double linear_vel , double angular_vel , double linear_accel , double angular_accel ) { openscenario_msgs :: msg :: ActionStatus status ; geometry_msgs :: msg :: Twist twist ; twist . linear . x = linear_vel ; twist . angular . z = angular_vel ; geometry_msgs :: msg :: Accel accel ; accel . linear . x = linear_accel ; accel . angular . z = angular_accel ; status . twist = twist ; status . accel = accel ; return status ; } openscenario_msgs :: msg :: LaneletPose constructLaneletPose ( std :: int64_t lanelet_id , double s , double offset , double roll , double pitch , double yaw ) { openscenario_msgs :: msg :: LaneletPose lanelet_pose ; lanelet_pose . lanelet_id = lanelet_id ; lanelet_pose . s = s ; lanelet_pose . offset = offset ; lanelet_pose . rpy . x = roll ; lanelet_pose . rpy . y = pitch ; lanelet_pose . rpy . z = yaw ; return lanelet_pose ; } geometry_msgs :: msg :: Vector3 constructRPY ( double roll , double pitch , double yaw ) { geometry_msgs :: msg :: Vector3 rpy ; rpy . x = roll ; rpy . y = pitch ; rpy . z = yaw ; return rpy ; } geometry_msgs :: msg :: Vector3 constructRPYfronQuaternion ( geometry_msgs :: msg :: Quaternion quaternion ) { return quaternion_operation :: convertQuaternionToEulerAngle ( quaternion ); } geometry_msgs :: msg :: Pose constructPose ( double x , double y , double z , double roll , double pitch , double yaw ) { geometry_msgs :: msg :: Pose pose ; pose . position . x = x ; pose . position . y = y ; pose . position . z = z ; pose . orientation = quaternion_operation :: convertEulerAngleToQuaternion ( constructRPY ( roll , pitch , yaw )); return pose ; } std :: ostream & operator << ( std :: ostream & os , const openscenario_msgs :: msg :: LaneletPose & ll_pose ) { os << \"lanelet id : \" << ll_pose . lanelet_id << \" \\n s : \" << ll_pose . s ; return os ; } const simulation_api_schema :: DetectionSensorConfiguration constructDetectionSensorConfiguration ( std :: string entity , std :: string topic_name , double update_duration ) { simulation_api_schema :: DetectionSensorConfiguration configuration ; configuration . set_entity ( entity ); configuration . set_topic_name ( topic_name ); configuration . set_update_duration ( update_duration ); return configuration ; } const simulation_api_schema :: LidarConfiguration constructLidarConfiguration ( LidarType type , std :: string entity , std :: string topic_name , double horizontal_resolution ) { simulation_api_schema :: LidarConfiguration configuration ; configuration . set_horizontal_resolution ( horizontal_resolution ); configuration . set_topic_name ( topic_name ); configuration . set_entity ( entity ); switch ( type ) { case LidarType :: VLP16 : configuration . set_scan_duration ( 0.1 ); configuration . add_vertical_angles ( -15.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -13.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -11.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -9.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -7.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -5.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -3.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -1.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 1.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 3.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 5.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 7.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 9.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 11.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 13.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 15.0 / 180.0 * M_PI ); break ; case LidarType :: VLP32 : configuration . set_scan_duration ( 0.1 ); configuration . add_vertical_angles ( -15.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -13.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( -12.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( -11.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -9.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( -8.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( -7.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -5.66666667 / 180 * M_PI ); configuration . add_vertical_angles ( -4.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( -3.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( -1.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( -0.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( 1.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 2.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( 3.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( 5.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 6.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( 7.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( 9.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 10.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( 11.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( 13.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 14.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( 15.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( 17.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 18.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( 19.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( 21.0 / 180.0 * M_PI ); configuration . add_vertical_angles ( 22.33333333 / 180.0 * M_PI ); configuration . add_vertical_angles ( 23.66666667 / 180.0 * M_PI ); configuration . add_vertical_angles ( 25.0 / 180.0 * M_PI ); break ; } return configuration ; } } // namespace helper } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/helper_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper/helper.hpp # Namespaces # Name simulation_api::helper simulation_api Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__HELPER__HELPER_HPP_ #define SIMULATION_API__HELPER__HELPER_HPP_ #include <geometry_msgs/msg/pose.hpp> #include <geometry_msgs/msg/quaternion.hpp> #include <openscenario_msgs/msg/lanelet_pose.hpp> #include <openscenario_msgs/msg/action_status.hpp> #include <simulation_api_schema.pb.h> #include <iostream> #include <cmath> #include <string> namespace simulation_api { namespace helper { openscenario_msgs :: msg :: ActionStatus constructActionStatus ( double linear_vel = 0 , double angular_vel = 0 , double linear_accel = 0 , double angular_accel = 0 ); openscenario_msgs :: msg :: LaneletPose constructLaneletPose ( std :: int64_t lanelet_id , double s , double offset = 0 , double roll = 0 , double pitch = 0 , double yaw = 0 ); geometry_msgs :: msg :: Vector3 constructRPY ( double roll = 0 , double pitch = 0 , double yaw = 0 ); geometry_msgs :: msg :: Vector3 constructRPYfronQuaternion ( geometry_msgs :: msg :: Quaternion quaternion ); geometry_msgs :: msg :: Pose constructPose ( double x , double y , double z , double roll , double pitch , double yaw ); std :: ostream & operator << ( std :: ostream & os , const openscenario_msgs :: msg :: LaneletPose & ll_pose ); enum class LidarType { VLP16 , VLP32 }; const simulation_api_schema :: LidarConfiguration constructLidarConfiguration ( LidarType type , std :: string entity , std :: string topic_name , double horizontal_resolution = 1.0 / 180.0 * M_PI ); const simulation_api_schema :: DetectionSensorConfiguration constructDetectionSensorConfiguration ( std :: string entity , std :: string topic_name , double update_duration ); } // namespace helper } // namespace simulation_api #endif // SIMULATION_API__HELPER__HELPER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper/helper.hpp"},{"location":"package/simulation_api/markdown/Files/helper_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apihelperhelperhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper/helper.hpp"},{"location":"package/simulation_api/markdown/Files/helper_8hpp/#namespaces","text":"Name simulation_api::helper simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/helper_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__HELPER__HELPER_HPP_ #define SIMULATION_API__HELPER__HELPER_HPP_ #include <geometry_msgs/msg/pose.hpp> #include <geometry_msgs/msg/quaternion.hpp> #include <openscenario_msgs/msg/lanelet_pose.hpp> #include <openscenario_msgs/msg/action_status.hpp> #include <simulation_api_schema.pb.h> #include <iostream> #include <cmath> #include <string> namespace simulation_api { namespace helper { openscenario_msgs :: msg :: ActionStatus constructActionStatus ( double linear_vel = 0 , double angular_vel = 0 , double linear_accel = 0 , double angular_accel = 0 ); openscenario_msgs :: msg :: LaneletPose constructLaneletPose ( std :: int64_t lanelet_id , double s , double offset = 0 , double roll = 0 , double pitch = 0 , double yaw = 0 ); geometry_msgs :: msg :: Vector3 constructRPY ( double roll = 0 , double pitch = 0 , double yaw = 0 ); geometry_msgs :: msg :: Vector3 constructRPYfronQuaternion ( geometry_msgs :: msg :: Quaternion quaternion ); geometry_msgs :: msg :: Pose constructPose ( double x , double y , double z , double roll , double pitch , double yaw ); std :: ostream & operator << ( std :: ostream & os , const openscenario_msgs :: msg :: LaneletPose & ll_pose ); enum class LidarType { VLP16 , VLP32 }; const simulation_api_schema :: LidarConfiguration constructLidarConfiguration ( LidarType type , std :: string entity , std :: string topic_name , double horizontal_resolution = 1.0 / 180.0 * M_PI ); const simulation_api_schema :: DetectionSensorConfiguration constructDetectionSensorConfiguration ( std :: string entity , std :: string topic_name , double update_duration ); } // namespace helper } // namespace simulation_api #endif // SIMULATION_API__HELPER__HELPER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/hermite__curve_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/hermite_curve.cpp # Namespaces # Name simulation_api::math simulation_api Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/math/hermite_curve.hpp> #include <vector> #include <algorithm> #include <iostream> #include <cmath> #include <limits> namespace simulation_api { namespace math { HermiteCurve :: HermiteCurve ( double ax , double bx , double cx , double dx , double ay , double by , double cy , double dy , double az , double bz , double cz , double dz ) : ax_ ( ax ), bx_ ( bx ), cx_ ( cx ), dx_ ( dx ), ay_ ( ay ), by_ ( by ), cy_ ( cy ), dy_ ( dy ), az_ ( az ), bz_ ( bz ), cz_ ( cz ), dz_ ( dz ) {} HermiteCurve :: HermiteCurve ( const openscenario_msgs :: msg :: HermiteCurve & curve ) : ax_ ( curve . ax ), bx_ ( curve . bx ), cx_ ( curve . cx ), dx_ ( curve . dx ), ay_ ( curve . ax ), by_ ( curve . by ), cy_ ( curve . cy ), dy_ ( curve . dy ), az_ ( curve . ax ), bz_ ( curve . bz ), cz_ ( curve . cz ), dz_ ( curve . dz ) {} HermiteCurve :: HermiteCurve ( geometry_msgs :: msg :: Pose start_pose , geometry_msgs :: msg :: Pose goal_pose , geometry_msgs :: msg :: Vector3 start_vec , geometry_msgs :: msg :: Vector3 goal_vec ) { ax_ = 2 * start_pose . position . x - 2 * goal_pose . position . x + start_vec . x + goal_vec . x ; bx_ = -3 * start_pose . position . x + 3 * goal_pose . position . x - 2 * start_vec . x - goal_vec . x ; cx_ = start_vec . x ; dx_ = start_pose . position . x ; ay_ = 2 * start_pose . position . y - 2 * goal_pose . position . y + start_vec . y + goal_vec . y ; by_ = -3 * start_pose . position . y + 3 * goal_pose . position . y - 2 * start_vec . y - goal_vec . y ; cy_ = start_vec . y ; dy_ = start_pose . position . y ; az_ = 2 * start_pose . position . z - 2 * goal_pose . position . z + start_vec . z + goal_vec . z ; bz_ = -3 * start_pose . position . z + 3 * goal_pose . position . z - 2 * start_vec . z - goal_vec . z ; cz_ = start_vec . z ; dz_ = start_pose . position . z ; } const openscenario_msgs :: msg :: HermiteCurve HermiteCurve :: toRosMsg () const { openscenario_msgs :: msg :: HermiteCurve curve ; curve . ax = ax_ ; curve . bx = bx_ ; curve . cx = cx_ ; curve . dx = dx_ ; curve . ay = ay_ ; curve . by = by_ ; curve . cy = cy_ ; curve . dy = dy_ ; curve . az = az_ ; curve . bz = bz_ ; curve . cz = cz_ ; curve . dz = dz_ ; return curve ; } double HermiteCurve :: getSquaredDistanceIn2D ( geometry_msgs :: msg :: Point point , double s , bool autoscale ) const { const auto point_on_curve = getPoint ( s , autoscale ); double x_term = std :: pow ( point . x - point_on_curve . x , 2 ); double y_term = std :: pow ( point . y - point_on_curve . y , 2 ); double ret = x_term + y_term ; return ret ; } double HermiteCurve :: getNewtonMethodStepSize ( geometry_msgs :: msg :: Point point , double s , bool autoscale ) const { if ( autoscale ) { s = s / getLength (); } const auto point_on_curve = getPoint ( s , autoscale ); double s2 = std :: pow ( s , 2 ); double x_term_diff = 2 * ( point . x - point_on_curve . x ) * ( -3 * ax_ * s2 - 2 * bx_ * s - cx_ ); double y_term_diff = 2 * ( point . y - point_on_curve . y ) * ( -3 * ay_ * s2 - 2 * by_ * s - cy_ ); double ret = getSquaredDistanceIn2D ( point , s , autoscale ) / ( x_term_diff + y_term_diff ); return ret ; } boost :: optional < double > HermiteCurve :: getCollisionPointIn2D ( std :: vector < geometry_msgs :: msg :: Point > polygon , bool search_backward ) const { size_t n = polygon . size (); if ( n <= 1 ) { return boost :: none ; } std :: vector < double > s_values ; for ( size_t i = 0 ; i < ( n - 1 ); i ++ ) { const auto p0 = polygon [ i ]; const auto p1 = polygon [ i + 1 ]; auto s = getCollisionPointIn2D ( p0 , p1 , search_backward ); if ( s ) { s_values . emplace_back ( s . get ()); } } if ( s_values . empty ()) { return boost :: none ; } if ( search_backward ) { return * std :: max_element ( s_values . begin (), s_values . end ()); } return * std :: min_element ( s_values . begin (), s_values . end ()); } boost :: optional < double > HermiteCurve :: getCollisionPointIn2D ( geometry_msgs :: msg :: Point point0 , geometry_msgs :: msg :: Point point1 , bool search_backward ) const { std :: vector < double > s_values ; double l = std :: hypot ( point0 . x - point1 . x , point0 . y - point1 . y ); double fx = point0 . x ; double ex = ( point0 . x - point1 . x ) / l ; double fy = point0 . y ; double ey = ( point0 . y - point1 . y ) / l ; constexpr double e = std :: numeric_limits < double >:: epsilon (); if ( std :: abs ( point0 . x - point1 . x ) <= e ) { if ( std :: abs ( point0 . y - point1 . y ) <= e ) { return boost :: none ; } auto solutions = solver_ . solveCubicEquation ( ax_ , bx_ , cx_ , dx_ - fx ); for ( const auto solution : solutions ) { double t = ( point0 . y - fy ) / ey ; if ( std :: fabs ( t ) < l ) { s_values . emplace_back ( solution ); } } } else if ( std :: abs ( point0 . y - point1 . y ) <= e ) { auto solutions = solver_ . solveCubicEquation ( ay_ , by_ , cy_ , dy_ - fy ); for ( const auto solution : solutions ) { double t = ( point0 . x - fx ) / ex ; if ( std :: fabs ( t ) < l ) { s_values . emplace_back ( solution ); } } } else { double ratio = ey / ex ; double a = ax_ * ratio - ay_ ; double b = bx_ * ratio - by_ ; double c = cx_ * ratio - cy_ ; double d = ( dx_ - fx ) * ratio - ( dy_ - fy ); auto solutions = solver_ . solveCubicEquation ( a , b , c , d ); for ( const auto solution : solutions ) { double y = solver_ . cubicFunction ( ay_ , by_ , cy_ , dy_ , solution ); double t = ( y - fy ) / ratio ; if ( std :: fabs ( t ) < l ) { s_values . emplace_back ( solution ); } } } if ( s_values . empty ()) { return boost :: none ; } if ( search_backward ) { return * std :: max_element ( s_values . begin (), s_values . end ()); } return * std :: min_element ( s_values . begin (), s_values . end ()); } boost :: optional < double > HermiteCurve :: getSValue ( geometry_msgs :: msg :: Point point , double threadhold_distance , unsigned int initial_resolution , unsigned int max_iteration , double tolerance , bool autoscale ) const { double step_size = static_cast < double > ( 1.0 ) / static_cast < double > ( initial_resolution ); double ret = 0.0 ; std :: vector < double > initial_value_candidates ( initial_resolution ); std :: vector < double > initial_errors ( initial_resolution ); for ( unsigned int i = 0 ; i < initial_resolution ; i ++ ) { initial_value_candidates [ i ] = ( 0.5 + static_cast < double > ( i )) * step_size ; initial_errors [ i ] = std :: fabs ( getSquaredDistanceIn2D ( point , initial_value_candidates [ i ])); } std :: vector < double >:: iterator iter = std :: min_element ( initial_errors . begin (), initial_errors . end ()); size_t index = std :: distance ( initial_errors . begin (), iter ); ret = initial_value_candidates [ index ]; std :: vector < double > errors ; std :: vector < double > s_values ; for ( unsigned i = 0 ; i < max_iteration ; i ++ ) { double error = getSquaredDistanceIn2D ( point , ret ); if ( std :: fabs ( error ) < ( tolerance * tolerance )) { return ret ; } s_values . push_back ( ret ); errors . push_back ( error ); ret = ret - getNewtonMethodStepSize ( point , ret ); } std :: vector < double >:: iterator min_iter = std :: min_element ( errors . begin (), errors . end ()); double min_error = * std :: min_element ( errors . begin (), errors . end ()); if ( min_error > ( threadhold_distance * threadhold_distance )) { return boost :: none ; } size_t value_index = std :: distance ( errors . begin (), min_iter ); ret = s_values [ value_index ]; if ( ret < 0 ) { double error = getSquaredDistanceIn2D ( point , 0 , false ); if ( error < ( threadhold_distance * threadhold_distance )) { ret = 0 ; } else { return boost :: none ; } } if ( ret > 1 ) { double error = getSquaredDistanceIn2D ( point , 0 , false ); if ( error < ( threadhold_distance * threadhold_distance )) { ret = 1 ; } else { return boost :: none ; } } if ( autoscale ) { ret = ret * getLength (); } return ret ; } const std :: vector < geometry_msgs :: msg :: Point > HermiteCurve :: getTrajectory ( double start_s , double end_s , double resolution , bool autoscale ) const { resolution = std :: fabs ( resolution ); if ( start_s <= end_s ) { std :: vector < geometry_msgs :: msg :: Point > ret ; double s = start_s ; while ( s <= end_s ) { s = s + resolution ; ret . emplace_back ( getPoint ( s , autoscale )); } return ret ; } else { std :: vector < geometry_msgs :: msg :: Point > ret ; double s = start_s ; while ( s >= end_s ) { s = s - resolution ; ret . emplace_back ( getPoint ( s , autoscale )); } return ret ; } } std :: vector < geometry_msgs :: msg :: Point > HermiteCurve :: getTrajectory ( size_t num_points ) const { std :: vector < geometry_msgs :: msg :: Point > ret ; for ( size_t i = 0 ; i <= num_points ; i ++ ) { double t = static_cast < double > ( i ) / 100.0 ; ret . emplace_back ( getPoint ( t , false )); } return ret ; } const geometry_msgs :: msg :: Vector3 HermiteCurve :: getNormalVector ( double s , bool autoscale ) const { if ( autoscale ) { s = s / getLength (); } geometry_msgs :: msg :: Vector3 vec ; vec . x = 3 * ay_ * s * s + 2 * by_ * s + cy_ ; vec . y = ( 3 * ax_ * s * s + 2 * bx_ * s + cx_ ) * -1 ; return vec ; } const geometry_msgs :: msg :: Vector3 HermiteCurve :: getTangentVector ( double s , bool autoscale ) const { if ( autoscale ) { s = s / getLength (); } geometry_msgs :: msg :: Vector3 vec ; vec . x = 3 * ax_ * s * s + 2 * bx_ * s + cx_ ; vec . y = 3 * ay_ * s * s + 2 * by_ * s + cy_ ; vec . z = 3 * az_ * s * s + 2 * bz_ * s + cz_ ; return vec ; } const geometry_msgs :: msg :: Pose HermiteCurve :: getPose ( double s , bool autoscale ) const { if ( autoscale ) { s = s / getLength (); } geometry_msgs :: msg :: Pose pose ; geometry_msgs :: msg :: Vector3 tangent_vec = getTangentVector ( s , false ); geometry_msgs :: msg :: Vector3 rpy ; rpy . x = 0.0 ; rpy . y = 0.0 ; rpy . z = std :: atan2 ( tangent_vec . y , tangent_vec . x ); pose . orientation = quaternion_operation :: convertEulerAngleToQuaternion ( rpy ); pose . position = getPoint ( s ); return pose ; } double HermiteCurve :: get2DCurvature ( double s , bool autoscale ) const { if ( autoscale ) { s = s / getLength (); } double s2 = s * s ; double x_dot = 3 * ax_ * s2 + 2 * bx_ * s + cx_ ; double x_dot_dot = 6 * ax_ * s + 2 * bx_ ; double y_dot = 3 * ay_ * s2 + 2 * by_ * s + cy_ ; double y_dot_dot = 6 * ay_ * s + 2 * by_ ; return ( x_dot * y_dot_dot - x_dot_dot * y_dot ) / std :: pow ( x_dot * x_dot + y_dot * y_dot , 1.5 ); } double HermiteCurve :: getMaximu2DCurvature () const { std :: vector < double > curvatures ; for ( double s = 0 ; s <= 1 ; s = s + 0.01 ) { double curvature = get2DCurvature ( s ); curvatures . push_back ( curvature ); } return * std :: max_element ( curvatures . begin (), curvatures . end ()); } double HermiteCurve :: getLength ( size_t num_points ) const { auto trajectory = getTrajectory ( num_points ); double ret = 0.0 ; for ( size_t i = 0 ; i < trajectory . size () - 1 ; i ++ ) { ret = ret + std :: sqrt ( std :: pow ( trajectory [ i + 1 ]. x - trajectory [ i ]. x , 2 ) + std :: pow ( trajectory [ i + 1 ]. y - trajectory [ i ]. y , 2 ) + std :: pow ( trajectory [ i + 1 ]. z - trajectory [ i ]. z , 2 )); } return ret ; } const geometry_msgs :: msg :: Point HermiteCurve :: getPoint ( double s , bool autoscale ) const { if ( autoscale ) { s = s / getLength (); } geometry_msgs :: msg :: Point p ; p . x = ax_ * std :: pow ( s , 3 ) + bx_ * std :: pow ( s , 2 ) + cx_ * s + dx_ ; p . y = ay_ * std :: pow ( s , 3 ) + by_ * std :: pow ( s , 2 ) + cy_ * s + dy_ ; p . z = az_ * std :: pow ( s , 3 ) + bz_ * std :: pow ( s , 2 ) + cz_ * s + dz_ ; return p ; } } // namespace math } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/hermite_curve.cpp"},{"location":"package/simulation_api/markdown/Files/hermite__curve_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmathhermite_curvecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/hermite_curve.cpp"},{"location":"package/simulation_api/markdown/Files/hermite__curve_8cpp/#namespaces","text":"Name simulation_api::math simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/hermite__curve_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/math/hermite_curve.hpp> #include <vector> #include <algorithm> #include <iostream> #include <cmath> #include <limits> namespace simulation_api { namespace math { HermiteCurve :: HermiteCurve ( double ax , double bx , double cx , double dx , double ay , double by , double cy , double dy , double az , double bz , double cz , double dz ) : ax_ ( ax ), bx_ ( bx ), cx_ ( cx ), dx_ ( dx ), ay_ ( ay ), by_ ( by ), cy_ ( cy ), dy_ ( dy ), az_ ( az ), bz_ ( bz ), cz_ ( cz ), dz_ ( dz ) {} HermiteCurve :: HermiteCurve ( const openscenario_msgs :: msg :: HermiteCurve & curve ) : ax_ ( curve . ax ), bx_ ( curve . bx ), cx_ ( curve . cx ), dx_ ( curve . dx ), ay_ ( curve . ax ), by_ ( curve . by ), cy_ ( curve . cy ), dy_ ( curve . dy ), az_ ( curve . ax ), bz_ ( curve . bz ), cz_ ( curve . cz ), dz_ ( curve . dz ) {} HermiteCurve :: HermiteCurve ( geometry_msgs :: msg :: Pose start_pose , geometry_msgs :: msg :: Pose goal_pose , geometry_msgs :: msg :: Vector3 start_vec , geometry_msgs :: msg :: Vector3 goal_vec ) { ax_ = 2 * start_pose . position . x - 2 * goal_pose . position . x + start_vec . x + goal_vec . x ; bx_ = -3 * start_pose . position . x + 3 * goal_pose . position . x - 2 * start_vec . x - goal_vec . x ; cx_ = start_vec . x ; dx_ = start_pose . position . x ; ay_ = 2 * start_pose . position . y - 2 * goal_pose . position . y + start_vec . y + goal_vec . y ; by_ = -3 * start_pose . position . y + 3 * goal_pose . position . y - 2 * start_vec . y - goal_vec . y ; cy_ = start_vec . y ; dy_ = start_pose . position . y ; az_ = 2 * start_pose . position . z - 2 * goal_pose . position . z + start_vec . z + goal_vec . z ; bz_ = -3 * start_pose . position . z + 3 * goal_pose . position . z - 2 * start_vec . z - goal_vec . z ; cz_ = start_vec . z ; dz_ = start_pose . position . z ; } const openscenario_msgs :: msg :: HermiteCurve HermiteCurve :: toRosMsg () const { openscenario_msgs :: msg :: HermiteCurve curve ; curve . ax = ax_ ; curve . bx = bx_ ; curve . cx = cx_ ; curve . dx = dx_ ; curve . ay = ay_ ; curve . by = by_ ; curve . cy = cy_ ; curve . dy = dy_ ; curve . az = az_ ; curve . bz = bz_ ; curve . cz = cz_ ; curve . dz = dz_ ; return curve ; } double HermiteCurve :: getSquaredDistanceIn2D ( geometry_msgs :: msg :: Point point , double s , bool autoscale ) const { const auto point_on_curve = getPoint ( s , autoscale ); double x_term = std :: pow ( point . x - point_on_curve . x , 2 ); double y_term = std :: pow ( point . y - point_on_curve . y , 2 ); double ret = x_term + y_term ; return ret ; } double HermiteCurve :: getNewtonMethodStepSize ( geometry_msgs :: msg :: Point point , double s , bool autoscale ) const { if ( autoscale ) { s = s / getLength (); } const auto point_on_curve = getPoint ( s , autoscale ); double s2 = std :: pow ( s , 2 ); double x_term_diff = 2 * ( point . x - point_on_curve . x ) * ( -3 * ax_ * s2 - 2 * bx_ * s - cx_ ); double y_term_diff = 2 * ( point . y - point_on_curve . y ) * ( -3 * ay_ * s2 - 2 * by_ * s - cy_ ); double ret = getSquaredDistanceIn2D ( point , s , autoscale ) / ( x_term_diff + y_term_diff ); return ret ; } boost :: optional < double > HermiteCurve :: getCollisionPointIn2D ( std :: vector < geometry_msgs :: msg :: Point > polygon , bool search_backward ) const { size_t n = polygon . size (); if ( n <= 1 ) { return boost :: none ; } std :: vector < double > s_values ; for ( size_t i = 0 ; i < ( n - 1 ); i ++ ) { const auto p0 = polygon [ i ]; const auto p1 = polygon [ i + 1 ]; auto s = getCollisionPointIn2D ( p0 , p1 , search_backward ); if ( s ) { s_values . emplace_back ( s . get ()); } } if ( s_values . empty ()) { return boost :: none ; } if ( search_backward ) { return * std :: max_element ( s_values . begin (), s_values . end ()); } return * std :: min_element ( s_values . begin (), s_values . end ()); } boost :: optional < double > HermiteCurve :: getCollisionPointIn2D ( geometry_msgs :: msg :: Point point0 , geometry_msgs :: msg :: Point point1 , bool search_backward ) const { std :: vector < double > s_values ; double l = std :: hypot ( point0 . x - point1 . x , point0 . y - point1 . y ); double fx = point0 . x ; double ex = ( point0 . x - point1 . x ) / l ; double fy = point0 . y ; double ey = ( point0 . y - point1 . y ) / l ; constexpr double e = std :: numeric_limits < double >:: epsilon (); if ( std :: abs ( point0 . x - point1 . x ) <= e ) { if ( std :: abs ( point0 . y - point1 . y ) <= e ) { return boost :: none ; } auto solutions = solver_ . solveCubicEquation ( ax_ , bx_ , cx_ , dx_ - fx ); for ( const auto solution : solutions ) { double t = ( point0 . y - fy ) / ey ; if ( std :: fabs ( t ) < l ) { s_values . emplace_back ( solution ); } } } else if ( std :: abs ( point0 . y - point1 . y ) <= e ) { auto solutions = solver_ . solveCubicEquation ( ay_ , by_ , cy_ , dy_ - fy ); for ( const auto solution : solutions ) { double t = ( point0 . x - fx ) / ex ; if ( std :: fabs ( t ) < l ) { s_values . emplace_back ( solution ); } } } else { double ratio = ey / ex ; double a = ax_ * ratio - ay_ ; double b = bx_ * ratio - by_ ; double c = cx_ * ratio - cy_ ; double d = ( dx_ - fx ) * ratio - ( dy_ - fy ); auto solutions = solver_ . solveCubicEquation ( a , b , c , d ); for ( const auto solution : solutions ) { double y = solver_ . cubicFunction ( ay_ , by_ , cy_ , dy_ , solution ); double t = ( y - fy ) / ratio ; if ( std :: fabs ( t ) < l ) { s_values . emplace_back ( solution ); } } } if ( s_values . empty ()) { return boost :: none ; } if ( search_backward ) { return * std :: max_element ( s_values . begin (), s_values . end ()); } return * std :: min_element ( s_values . begin (), s_values . end ()); } boost :: optional < double > HermiteCurve :: getSValue ( geometry_msgs :: msg :: Point point , double threadhold_distance , unsigned int initial_resolution , unsigned int max_iteration , double tolerance , bool autoscale ) const { double step_size = static_cast < double > ( 1.0 ) / static_cast < double > ( initial_resolution ); double ret = 0.0 ; std :: vector < double > initial_value_candidates ( initial_resolution ); std :: vector < double > initial_errors ( initial_resolution ); for ( unsigned int i = 0 ; i < initial_resolution ; i ++ ) { initial_value_candidates [ i ] = ( 0.5 + static_cast < double > ( i )) * step_size ; initial_errors [ i ] = std :: fabs ( getSquaredDistanceIn2D ( point , initial_value_candidates [ i ])); } std :: vector < double >:: iterator iter = std :: min_element ( initial_errors . begin (), initial_errors . end ()); size_t index = std :: distance ( initial_errors . begin (), iter ); ret = initial_value_candidates [ index ]; std :: vector < double > errors ; std :: vector < double > s_values ; for ( unsigned i = 0 ; i < max_iteration ; i ++ ) { double error = getSquaredDistanceIn2D ( point , ret ); if ( std :: fabs ( error ) < ( tolerance * tolerance )) { return ret ; } s_values . push_back ( ret ); errors . push_back ( error ); ret = ret - getNewtonMethodStepSize ( point , ret ); } std :: vector < double >:: iterator min_iter = std :: min_element ( errors . begin (), errors . end ()); double min_error = * std :: min_element ( errors . begin (), errors . end ()); if ( min_error > ( threadhold_distance * threadhold_distance )) { return boost :: none ; } size_t value_index = std :: distance ( errors . begin (), min_iter ); ret = s_values [ value_index ]; if ( ret < 0 ) { double error = getSquaredDistanceIn2D ( point , 0 , false ); if ( error < ( threadhold_distance * threadhold_distance )) { ret = 0 ; } else { return boost :: none ; } } if ( ret > 1 ) { double error = getSquaredDistanceIn2D ( point , 0 , false ); if ( error < ( threadhold_distance * threadhold_distance )) { ret = 1 ; } else { return boost :: none ; } } if ( autoscale ) { ret = ret * getLength (); } return ret ; } const std :: vector < geometry_msgs :: msg :: Point > HermiteCurve :: getTrajectory ( double start_s , double end_s , double resolution , bool autoscale ) const { resolution = std :: fabs ( resolution ); if ( start_s <= end_s ) { std :: vector < geometry_msgs :: msg :: Point > ret ; double s = start_s ; while ( s <= end_s ) { s = s + resolution ; ret . emplace_back ( getPoint ( s , autoscale )); } return ret ; } else { std :: vector < geometry_msgs :: msg :: Point > ret ; double s = start_s ; while ( s >= end_s ) { s = s - resolution ; ret . emplace_back ( getPoint ( s , autoscale )); } return ret ; } } std :: vector < geometry_msgs :: msg :: Point > HermiteCurve :: getTrajectory ( size_t num_points ) const { std :: vector < geometry_msgs :: msg :: Point > ret ; for ( size_t i = 0 ; i <= num_points ; i ++ ) { double t = static_cast < double > ( i ) / 100.0 ; ret . emplace_back ( getPoint ( t , false )); } return ret ; } const geometry_msgs :: msg :: Vector3 HermiteCurve :: getNormalVector ( double s , bool autoscale ) const { if ( autoscale ) { s = s / getLength (); } geometry_msgs :: msg :: Vector3 vec ; vec . x = 3 * ay_ * s * s + 2 * by_ * s + cy_ ; vec . y = ( 3 * ax_ * s * s + 2 * bx_ * s + cx_ ) * -1 ; return vec ; } const geometry_msgs :: msg :: Vector3 HermiteCurve :: getTangentVector ( double s , bool autoscale ) const { if ( autoscale ) { s = s / getLength (); } geometry_msgs :: msg :: Vector3 vec ; vec . x = 3 * ax_ * s * s + 2 * bx_ * s + cx_ ; vec . y = 3 * ay_ * s * s + 2 * by_ * s + cy_ ; vec . z = 3 * az_ * s * s + 2 * bz_ * s + cz_ ; return vec ; } const geometry_msgs :: msg :: Pose HermiteCurve :: getPose ( double s , bool autoscale ) const { if ( autoscale ) { s = s / getLength (); } geometry_msgs :: msg :: Pose pose ; geometry_msgs :: msg :: Vector3 tangent_vec = getTangentVector ( s , false ); geometry_msgs :: msg :: Vector3 rpy ; rpy . x = 0.0 ; rpy . y = 0.0 ; rpy . z = std :: atan2 ( tangent_vec . y , tangent_vec . x ); pose . orientation = quaternion_operation :: convertEulerAngleToQuaternion ( rpy ); pose . position = getPoint ( s ); return pose ; } double HermiteCurve :: get2DCurvature ( double s , bool autoscale ) const { if ( autoscale ) { s = s / getLength (); } double s2 = s * s ; double x_dot = 3 * ax_ * s2 + 2 * bx_ * s + cx_ ; double x_dot_dot = 6 * ax_ * s + 2 * bx_ ; double y_dot = 3 * ay_ * s2 + 2 * by_ * s + cy_ ; double y_dot_dot = 6 * ay_ * s + 2 * by_ ; return ( x_dot * y_dot_dot - x_dot_dot * y_dot ) / std :: pow ( x_dot * x_dot + y_dot * y_dot , 1.5 ); } double HermiteCurve :: getMaximu2DCurvature () const { std :: vector < double > curvatures ; for ( double s = 0 ; s <= 1 ; s = s + 0.01 ) { double curvature = get2DCurvature ( s ); curvatures . push_back ( curvature ); } return * std :: max_element ( curvatures . begin (), curvatures . end ()); } double HermiteCurve :: getLength ( size_t num_points ) const { auto trajectory = getTrajectory ( num_points ); double ret = 0.0 ; for ( size_t i = 0 ; i < trajectory . size () - 1 ; i ++ ) { ret = ret + std :: sqrt ( std :: pow ( trajectory [ i + 1 ]. x - trajectory [ i ]. x , 2 ) + std :: pow ( trajectory [ i + 1 ]. y - trajectory [ i ]. y , 2 ) + std :: pow ( trajectory [ i + 1 ]. z - trajectory [ i ]. z , 2 )); } return ret ; } const geometry_msgs :: msg :: Point HermiteCurve :: getPoint ( double s , bool autoscale ) const { if ( autoscale ) { s = s / getLength (); } geometry_msgs :: msg :: Point p ; p . x = ax_ * std :: pow ( s , 3 ) + bx_ * std :: pow ( s , 2 ) + cx_ * s + dx_ ; p . y = ay_ * std :: pow ( s , 3 ) + by_ * std :: pow ( s , 2 ) + cy_ * s + dy_ ; p . z = az_ * std :: pow ( s , 3 ) + bz_ * std :: pow ( s , 2 ) + cz_ * s + dz_ ; return p ; } } // namespace math } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/hermite__curve_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/hermite_curve.hpp # Namespaces # Name simulation_api::math simulation_api Classes # Name class simulation_api::math::HermiteCurve Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__MATH__HERMITE_CURVE_HPP_ #define SIMULATION_API__MATH__HERMITE_CURVE_HPP_ #include <simulation_api/math/polynomial_solver.hpp> #include <openscenario_msgs/msg/hermite_curve.hpp> #include <quaternion_operation/quaternion_operation.h> #include <geometry_msgs/msg/point.hpp> #include <geometry_msgs/msg/pose.hpp> #include <geometry_msgs/msg/vector3.hpp> #include <boost/optional.hpp> #include <vector> namespace simulation_api { namespace math { class HermiteCurve { private : double ax_ , bx_ , cx_ , dx_ ; double ay_ , by_ , cy_ , dy_ ; double az_ , bz_ , cz_ , dz_ ; simulation_api :: math :: PolynomialSolver solver_ ; public : explicit HermiteCurve ( const openscenario_msgs :: msg :: HermiteCurve & curve ); HermiteCurve ( geometry_msgs :: msg :: Pose start_pose , geometry_msgs :: msg :: Pose goal_pose , geometry_msgs :: msg :: Vector3 start_vec , geometry_msgs :: msg :: Vector3 goal_vec ); HermiteCurve ( double ax , double bx , double cx , double dx , double ay , double by , double cy , double dy , double az , double bz , double cz , double dz ); std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( size_t num_points = 30 ) const ; const std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( double start_s , double end_s , double resolution , bool autoscale = false ) const ; const geometry_msgs :: msg :: Pose getPose ( double s , bool autoscale = false ) const ; const geometry_msgs :: msg :: Point getPoint ( double s , bool autoscale = false ) const ; const geometry_msgs :: msg :: Vector3 getTangentVector ( double s , bool autoscale = false ) const ; const geometry_msgs :: msg :: Vector3 getNormalVector ( double s , bool autoscale = false ) const ; double get2DCurvature ( double s , bool autoscale = false ) const ; double getMaximu2DCurvature () const ; double getLength ( size_t num_points = 100 ) const ; boost :: optional < double > getSValue ( geometry_msgs :: msg :: Point position , double threadhold_distance = 1.0 , unsigned int initial_resolution = 30 , unsigned int max_iteration = 30 , double tolerance = 0.001 , bool autoscale = false ) const ; double getSquaredDistanceIn2D ( geometry_msgs :: msg :: Point point , double s , bool autoscale = false ) const ; boost :: optional < double > getCollisionPointIn2D ( geometry_msgs :: msg :: Point point0 , geometry_msgs :: msg :: Point point1 , bool search_backward = false ) const ; boost :: optional < double > getCollisionPointIn2D ( std :: vector < geometry_msgs :: msg :: Point > polygon , bool search_backward = false ) const ; const openscenario_msgs :: msg :: HermiteCurve toRosMsg () const ; private : double getNewtonMethodStepSize ( geometry_msgs :: msg :: Point point , double s , bool autoscale = false ) const ; }; } // namespace math } // namespace simulation_api #endif // SIMULATION_API__MATH__HERMITE_CURVE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/hermite_curve.hpp"},{"location":"package/simulation_api/markdown/Files/hermite__curve_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apimathhermite_curvehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/hermite_curve.hpp"},{"location":"package/simulation_api/markdown/Files/hermite__curve_8hpp/#namespaces","text":"Name simulation_api::math simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/hermite__curve_8hpp/#classes","text":"Name class simulation_api::math::HermiteCurve","title":"Classes"},{"location":"package/simulation_api/markdown/Files/hermite__curve_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__MATH__HERMITE_CURVE_HPP_ #define SIMULATION_API__MATH__HERMITE_CURVE_HPP_ #include <simulation_api/math/polynomial_solver.hpp> #include <openscenario_msgs/msg/hermite_curve.hpp> #include <quaternion_operation/quaternion_operation.h> #include <geometry_msgs/msg/point.hpp> #include <geometry_msgs/msg/pose.hpp> #include <geometry_msgs/msg/vector3.hpp> #include <boost/optional.hpp> #include <vector> namespace simulation_api { namespace math { class HermiteCurve { private : double ax_ , bx_ , cx_ , dx_ ; double ay_ , by_ , cy_ , dy_ ; double az_ , bz_ , cz_ , dz_ ; simulation_api :: math :: PolynomialSolver solver_ ; public : explicit HermiteCurve ( const openscenario_msgs :: msg :: HermiteCurve & curve ); HermiteCurve ( geometry_msgs :: msg :: Pose start_pose , geometry_msgs :: msg :: Pose goal_pose , geometry_msgs :: msg :: Vector3 start_vec , geometry_msgs :: msg :: Vector3 goal_vec ); HermiteCurve ( double ax , double bx , double cx , double dx , double ay , double by , double cy , double dy , double az , double bz , double cz , double dz ); std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( size_t num_points = 30 ) const ; const std :: vector < geometry_msgs :: msg :: Point > getTrajectory ( double start_s , double end_s , double resolution , bool autoscale = false ) const ; const geometry_msgs :: msg :: Pose getPose ( double s , bool autoscale = false ) const ; const geometry_msgs :: msg :: Point getPoint ( double s , bool autoscale = false ) const ; const geometry_msgs :: msg :: Vector3 getTangentVector ( double s , bool autoscale = false ) const ; const geometry_msgs :: msg :: Vector3 getNormalVector ( double s , bool autoscale = false ) const ; double get2DCurvature ( double s , bool autoscale = false ) const ; double getMaximu2DCurvature () const ; double getLength ( size_t num_points = 100 ) const ; boost :: optional < double > getSValue ( geometry_msgs :: msg :: Point position , double threadhold_distance = 1.0 , unsigned int initial_resolution = 30 , unsigned int max_iteration = 30 , double tolerance = 0.001 , bool autoscale = false ) const ; double getSquaredDistanceIn2D ( geometry_msgs :: msg :: Point point , double s , bool autoscale = false ) const ; boost :: optional < double > getCollisionPointIn2D ( geometry_msgs :: msg :: Point point0 , geometry_msgs :: msg :: Point point1 , bool search_backward = false ) const ; boost :: optional < double > getCollisionPointIn2D ( std :: vector < geometry_msgs :: msg :: Point > polygon , bool search_backward = false ) const ; const openscenario_msgs :: msg :: HermiteCurve toRosMsg () const ; private : double getNewtonMethodStepSize ( geometry_msgs :: msg :: Point point , double s , bool autoscale = false ) const ; }; } // namespace math } // namespace simulation_api #endif // SIMULATION_API__MATH__HERMITE_CURVE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/lane__change__action_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/lane_change_action.cpp # Namespaces # Name entity_behavior::vehicle entity_behavior Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/lane_change_action.hpp> #include <simulation_api/entity/vehicle_parameter.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <string> #include <memory> #include <algorithm> #include <vector> namespace entity_behavior { namespace vehicle { LaneChangeAction :: LaneChangeAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: VehicleActionNode ( name , config ) {} const boost :: optional < openscenario_msgs :: msg :: Obstacle > LaneChangeAction :: calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & ) { return boost :: none ; } const openscenario_msgs :: msg :: WaypointsArray LaneChangeAction :: calculateWaypoints () { if ( ! curve_ ) { throw BehaviorTreeRuntimeError ( \"curve is null\" ); } if ( ! to_lanelet_id_ ) { throw BehaviorTreeRuntimeError ( \"to lanelet id is null\" ); } if ( entity_status . action_status . twist . linear . x >= 0 ) { openscenario_msgs :: msg :: WaypointsArray waypoints ; double horizon = boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x * 5 , 20 , 50 ); auto following_lanelets = hdmap_utils -> getFollowingLanelets ( to_lanelet_id_ . get (), 0 ); double l = curve_ -> getLength (); double rest_s = current_s_ + horizon - l ; if ( rest_s < 0 ) { const auto curve_waypoints = curve_ -> getTrajectory ( current_s_ , current_s_ + horizon , 1.0 , true ); waypoints . waypoints = curve_waypoints ; } else { std :: vector < geometry_msgs :: msg :: Point > center_points = hdmap_utils -> getCenterPoints ( following_lanelets ); simulation_api :: math :: CatmullRomSpline spline ( center_points ); const auto straight_waypoints = spline . getTrajectory ( target_s_ , target_s_ + rest_s , 1.0 ); waypoints . waypoints = straight_waypoints ; const auto curve_waypoints = curve_ -> getTrajectory ( current_s_ , l , 1.0 , true ); waypoints . waypoints = curve_waypoints ; std :: copy ( straight_waypoints . begin (), straight_waypoints . end (), std :: back_inserter ( waypoints . waypoints )); } return waypoints ; } else { return openscenario_msgs :: msg :: WaypointsArray (); } } void LaneChangeAction :: getBlackBoardValues () { VehicleActionNode :: getBlackBoardValues (); std :: int64_t to_lanelet_id ; if ( ! getInput < std :: int64_t > ( \"to_lanelet_id\" , to_lanelet_id )) { to_lanelet_id_ = boost :: none ; } else { to_lanelet_id_ = to_lanelet_id ; } } BT :: NodeStatus LaneChangeAction :: tick () { getBlackBoardValues (); if ( request != \"lane_change\" ) { curve_ = boost :: none ; current_s_ = 0 ; return BT :: NodeStatus :: FAILURE ; } if ( ! to_lanelet_id_ ) { curve_ = boost :: none ; current_s_ = 0 ; return BT :: NodeStatus :: FAILURE ; } if ( ! curve_ ) { if ( request == \"lane_change\" ) { if ( ! hdmap_utils -> canChangeLane ( entity_status . lanelet_pose . lanelet_id , to_lanelet_id_ . get ())) { return BT :: NodeStatus :: FAILURE ; } auto from_pose = hdmap_utils -> toMapPose ( entity_status . lanelet_pose ). pose ; auto ret = hdmap_utils -> getLaneChangeTrajectory ( from_pose , to_lanelet_id_ . get ()); if ( ret ) { curve_ = ret -> first ; target_s_ = ret -> second ; } else { return BT :: NodeStatus :: FAILURE ; } } } if ( curve_ ) { double current_linear_vel = entity_status . action_status . twist . linear . x ; current_s_ = current_s_ + current_linear_vel * step_time ; if ( current_s_ < curve_ -> getLength ()) { geometry_msgs :: msg :: Pose pose = curve_ -> getPose ( current_s_ , true ); openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . pose = pose ; auto lanelet_pose = hdmap_utils -> toLaneletPose ( pose ); if ( lanelet_pose ) { entity_status_updated . lanelet_pose = lanelet_pose . get (); } else { entity_status_updated . lanelet_pose_valid = false ; } entity_status_updated . action_status = entity_status . action_status ; setOutput ( \"updated_status\" , entity_status_updated ); const auto waypoints = calculateWaypoints (); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: RUNNING ; } else { const auto waypoints = calculateWaypoints (); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); double s = ( current_s_ - curve_ -> getLength ()) + target_s_ ; curve_ = boost :: none ; current_s_ = 0 ; openscenario_msgs :: msg :: EntityStatus entity_status_updated ; openscenario_msgs :: msg :: LaneletPose lanelet_pose ; lanelet_pose . lanelet_id = to_lanelet_id_ . get (); lanelet_pose . s = s ; lanelet_pose . offset = 0 ; entity_status_updated . pose = hdmap_utils -> toMapPose ( lanelet_pose ). pose ; entity_status_updated . lanelet_pose = lanelet_pose ; entity_status_updated . action_status = entity_status . action_status ; setOutput ( \"updated_status\" , entity_status_updated ); return BT :: NodeStatus :: SUCCESS ; } } return BT :: NodeStatus :: FAILURE ; } } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/lane_change_action.cpp"},{"location":"package/simulation_api/markdown/Files/lane__change__action_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorvehiclelane_change_actioncpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/lane_change_action.cpp"},{"location":"package/simulation_api/markdown/Files/lane__change__action_8cpp/#namespaces","text":"Name entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/lane__change__action_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/lane_change_action.hpp> #include <simulation_api/entity/vehicle_parameter.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <string> #include <memory> #include <algorithm> #include <vector> namespace entity_behavior { namespace vehicle { LaneChangeAction :: LaneChangeAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: VehicleActionNode ( name , config ) {} const boost :: optional < openscenario_msgs :: msg :: Obstacle > LaneChangeAction :: calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & ) { return boost :: none ; } const openscenario_msgs :: msg :: WaypointsArray LaneChangeAction :: calculateWaypoints () { if ( ! curve_ ) { throw BehaviorTreeRuntimeError ( \"curve is null\" ); } if ( ! to_lanelet_id_ ) { throw BehaviorTreeRuntimeError ( \"to lanelet id is null\" ); } if ( entity_status . action_status . twist . linear . x >= 0 ) { openscenario_msgs :: msg :: WaypointsArray waypoints ; double horizon = boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x * 5 , 20 , 50 ); auto following_lanelets = hdmap_utils -> getFollowingLanelets ( to_lanelet_id_ . get (), 0 ); double l = curve_ -> getLength (); double rest_s = current_s_ + horizon - l ; if ( rest_s < 0 ) { const auto curve_waypoints = curve_ -> getTrajectory ( current_s_ , current_s_ + horizon , 1.0 , true ); waypoints . waypoints = curve_waypoints ; } else { std :: vector < geometry_msgs :: msg :: Point > center_points = hdmap_utils -> getCenterPoints ( following_lanelets ); simulation_api :: math :: CatmullRomSpline spline ( center_points ); const auto straight_waypoints = spline . getTrajectory ( target_s_ , target_s_ + rest_s , 1.0 ); waypoints . waypoints = straight_waypoints ; const auto curve_waypoints = curve_ -> getTrajectory ( current_s_ , l , 1.0 , true ); waypoints . waypoints = curve_waypoints ; std :: copy ( straight_waypoints . begin (), straight_waypoints . end (), std :: back_inserter ( waypoints . waypoints )); } return waypoints ; } else { return openscenario_msgs :: msg :: WaypointsArray (); } } void LaneChangeAction :: getBlackBoardValues () { VehicleActionNode :: getBlackBoardValues (); std :: int64_t to_lanelet_id ; if ( ! getInput < std :: int64_t > ( \"to_lanelet_id\" , to_lanelet_id )) { to_lanelet_id_ = boost :: none ; } else { to_lanelet_id_ = to_lanelet_id ; } } BT :: NodeStatus LaneChangeAction :: tick () { getBlackBoardValues (); if ( request != \"lane_change\" ) { curve_ = boost :: none ; current_s_ = 0 ; return BT :: NodeStatus :: FAILURE ; } if ( ! to_lanelet_id_ ) { curve_ = boost :: none ; current_s_ = 0 ; return BT :: NodeStatus :: FAILURE ; } if ( ! curve_ ) { if ( request == \"lane_change\" ) { if ( ! hdmap_utils -> canChangeLane ( entity_status . lanelet_pose . lanelet_id , to_lanelet_id_ . get ())) { return BT :: NodeStatus :: FAILURE ; } auto from_pose = hdmap_utils -> toMapPose ( entity_status . lanelet_pose ). pose ; auto ret = hdmap_utils -> getLaneChangeTrajectory ( from_pose , to_lanelet_id_ . get ()); if ( ret ) { curve_ = ret -> first ; target_s_ = ret -> second ; } else { return BT :: NodeStatus :: FAILURE ; } } } if ( curve_ ) { double current_linear_vel = entity_status . action_status . twist . linear . x ; current_s_ = current_s_ + current_linear_vel * step_time ; if ( current_s_ < curve_ -> getLength ()) { geometry_msgs :: msg :: Pose pose = curve_ -> getPose ( current_s_ , true ); openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . pose = pose ; auto lanelet_pose = hdmap_utils -> toLaneletPose ( pose ); if ( lanelet_pose ) { entity_status_updated . lanelet_pose = lanelet_pose . get (); } else { entity_status_updated . lanelet_pose_valid = false ; } entity_status_updated . action_status = entity_status . action_status ; setOutput ( \"updated_status\" , entity_status_updated ); const auto waypoints = calculateWaypoints (); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: RUNNING ; } else { const auto waypoints = calculateWaypoints (); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); double s = ( current_s_ - curve_ -> getLength ()) + target_s_ ; curve_ = boost :: none ; current_s_ = 0 ; openscenario_msgs :: msg :: EntityStatus entity_status_updated ; openscenario_msgs :: msg :: LaneletPose lanelet_pose ; lanelet_pose . lanelet_id = to_lanelet_id_ . get (); lanelet_pose . s = s ; lanelet_pose . offset = 0 ; entity_status_updated . pose = hdmap_utils -> toMapPose ( lanelet_pose ). pose ; entity_status_updated . lanelet_pose = lanelet_pose ; entity_status_updated . action_status = entity_status . action_status ; setOutput ( \"updated_status\" , entity_status_updated ); return BT :: NodeStatus :: SUCCESS ; } } return BT :: NodeStatus :: FAILURE ; } } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/lane__change__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/lane_change_action.hpp # Namespaces # Name entity_behavior::vehicle entity_behavior Classes # Name class entity_behavior::vehicle::LaneChangeAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__LANE_CHANGE_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__LANE_CHANGE_ACTION_HPP_ #include <simulation_api/math/hermite_curve.hpp> #include <simulation_api/entity/vehicle_parameter.hpp> #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <openscenario_msgs/msg/entity_status.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <behaviortree_cpp_v3/behavior_tree.h> #include <behaviortree_cpp_v3/bt_factory.h> #include <boost/optional.hpp> #include <string> #include <memory> #include <vector> namespace entity_behavior { namespace vehicle { class LaneChangeAction : public entity_behavior :: VehicleActionNode { public : LaneChangeAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; static BT :: PortsList providedPorts () { BT :: PortsList ports = { BT :: InputPort < std :: int64_t > ( \"to_lanelet_id\" ) }; BT :: PortsList parent_ports = entity_behavior :: VehicleActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override ; const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override ; void getBlackBoardValues (); private : boost :: optional < simulation_api :: math :: HermiteCurve > curve_ ; double current_s_ ; double target_s_ ; boost :: optional < std :: int64_t > to_lanelet_id_ ; }; } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__LANE_CHANGE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/lane_change_action.hpp"},{"location":"package/simulation_api/markdown/Files/lane__change__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorvehiclelane_change_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/lane_change_action.hpp"},{"location":"package/simulation_api/markdown/Files/lane__change__action_8hpp/#namespaces","text":"Name entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/lane__change__action_8hpp/#classes","text":"Name class entity_behavior::vehicle::LaneChangeAction","title":"Classes"},{"location":"package/simulation_api/markdown/Files/lane__change__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__LANE_CHANGE_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__LANE_CHANGE_ACTION_HPP_ #include <simulation_api/math/hermite_curve.hpp> #include <simulation_api/entity/vehicle_parameter.hpp> #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <openscenario_msgs/msg/entity_status.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <behaviortree_cpp_v3/behavior_tree.h> #include <behaviortree_cpp_v3/bt_factory.h> #include <boost/optional.hpp> #include <string> #include <memory> #include <vector> namespace entity_behavior { namespace vehicle { class LaneChangeAction : public entity_behavior :: VehicleActionNode { public : LaneChangeAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; static BT :: PortsList providedPorts () { BT :: PortsList ports = { BT :: InputPort < std :: int64_t > ( \"to_lanelet_id\" ) }; BT :: PortsList parent_ports = entity_behavior :: VehicleActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override ; const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override ; void getBlackBoardValues (); private : boost :: optional < simulation_api :: math :: HermiteCurve > curve_ ; double current_s_ ; double target_s_ ; boost :: optional < std :: int64_t > to_lanelet_id_ ; }; } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__LANE_CHANGE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/metric__base_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/metric_base.cpp # Namespaces # Name metrics Source code # // Copyright 2015-2021 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/metrics/metric_base.hpp> #include <string> #include <memory> namespace metrics { MetricBase :: MetricBase ( std :: string metrics_type ) : metrics_type ( metrics_type ) { lifecycle_ = MetricLifecycle :: INACTIVE ; error_ = boost :: none ; } MetricBase ::~ MetricBase () {} void MetricBase :: setEntityManager ( std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr ) { entity_manager_ptr_ = entity_manager_ptr ; } void MetricBase :: success () { if ( lifecycle_ != MetricLifecycle :: ACTIVE ) { THROW_METRICS_CALCULATION_ERROR ( \"lifecycle of the metric should be active\" ); } lifecycle_ = MetricLifecycle :: SUCCESS ; } void MetricBase :: activate () { if ( lifecycle_ != MetricLifecycle :: INACTIVE ) { THROW_METRICS_CALCULATION_ERROR ( \"lifecycle of the metric should be inactive\" ); } lifecycle_ = MetricLifecycle :: ACTIVE ; } void MetricBase :: failure ( SpecificationViolationError error ) { if ( lifecycle_ != MetricLifecycle :: ACTIVE ) { THROW_METRICS_CALCULATION_ERROR ( \"lifecycle of the metric should be active\" ); } error_ = error ; lifecycle_ = MetricLifecycle :: FAILURE ; } nlohmann :: json MetricBase :: to_base_json () { nlohmann :: json json ; json [ \"type\" ] = metrics_type ; std :: string lifecycle ; switch ( lifecycle_ ) { case MetricLifecycle :: INACTIVE : lifecycle = \"inactive\" ; break ; case MetricLifecycle :: ACTIVE : lifecycle = \"active\" ; break ; case MetricLifecycle :: FAILURE : lifecycle = \"failure\" ; break ; case MetricLifecycle :: SUCCESS : lifecycle = \"success\" ; break ; } json [ \"lifecycle\" ] = lifecycle ; return json ; } void MetricBase :: throwException () { if ( error_ ) { throw error_ . get (); } THROW_METRICS_CALCULATION_ERROR ( \"error is empty\" ); } } // namespace metrics Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/metric_base.cpp"},{"location":"package/simulation_api/markdown/Files/metric__base_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmetricsmetric_basecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/metric_base.cpp"},{"location":"package/simulation_api/markdown/Files/metric__base_8cpp/#namespaces","text":"Name metrics","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/metric__base_8cpp/#source-code","text":"// Copyright 2015-2021 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/metrics/metric_base.hpp> #include <string> #include <memory> namespace metrics { MetricBase :: MetricBase ( std :: string metrics_type ) : metrics_type ( metrics_type ) { lifecycle_ = MetricLifecycle :: INACTIVE ; error_ = boost :: none ; } MetricBase ::~ MetricBase () {} void MetricBase :: setEntityManager ( std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr ) { entity_manager_ptr_ = entity_manager_ptr ; } void MetricBase :: success () { if ( lifecycle_ != MetricLifecycle :: ACTIVE ) { THROW_METRICS_CALCULATION_ERROR ( \"lifecycle of the metric should be active\" ); } lifecycle_ = MetricLifecycle :: SUCCESS ; } void MetricBase :: activate () { if ( lifecycle_ != MetricLifecycle :: INACTIVE ) { THROW_METRICS_CALCULATION_ERROR ( \"lifecycle of the metric should be inactive\" ); } lifecycle_ = MetricLifecycle :: ACTIVE ; } void MetricBase :: failure ( SpecificationViolationError error ) { if ( lifecycle_ != MetricLifecycle :: ACTIVE ) { THROW_METRICS_CALCULATION_ERROR ( \"lifecycle of the metric should be active\" ); } error_ = error ; lifecycle_ = MetricLifecycle :: FAILURE ; } nlohmann :: json MetricBase :: to_base_json () { nlohmann :: json json ; json [ \"type\" ] = metrics_type ; std :: string lifecycle ; switch ( lifecycle_ ) { case MetricLifecycle :: INACTIVE : lifecycle = \"inactive\" ; break ; case MetricLifecycle :: ACTIVE : lifecycle = \"active\" ; break ; case MetricLifecycle :: FAILURE : lifecycle = \"failure\" ; break ; case MetricLifecycle :: SUCCESS : lifecycle = \"success\" ; break ; } json [ \"lifecycle\" ] = lifecycle ; return json ; } void MetricBase :: throwException () { if ( error_ ) { throw error_ . get (); } THROW_METRICS_CALCULATION_ERROR ( \"error is empty\" ); } } // namespace metrics Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/metric__base_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metric_base.hpp # Namespaces # Name metrics Classes # Name class metrics::SpecificationViolationError class metrics::MetricsCalculationError class metrics::MetricBase Defines # Name THROW_METRICS_CALCULATION_ERROR (description) SPECIFICATION_VIOLATION_ERROR (description) Macro Documentation # define THROW_METRICS_CALCULATION_ERROR # #define THROW_METRICS_CALCULATION_ERROR( description ) throw MetricsCalculationError ( \\ description , __FILE__ , __LINE__ ); define SPECIFICATION_VIOLATION_ERROR # #define SPECIFICATION_VIOLATION_ERROR( description ) SpecificationViolationError ( \\ description , __FILE__ , __LINE__ ) Source code # // Copyright 2015-2021 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__METRICS__METRIC_BASE_HPP_ #define SIMULATION_API__METRICS__METRIC_BASE_HPP_ #include <simulation_api/entity/entity_manager.hpp> #include <nlohmann/json.hpp> #include <boost/optional.hpp> #include <stdexcept> #include <string> #include <memory> namespace metrics { class SpecificationViolationError : public std :: runtime_error { public : explicit SpecificationViolationError ( const char * message ) : runtime_error ( message ) {} explicit SpecificationViolationError ( std :: string message ) : runtime_error ( message . c_str ()) {} explicit SpecificationViolationError ( std :: string message , const char * file , int line ) : runtime_error ( message + \" \\n File:\" + file + \" \\n Line:\" + std :: to_string ( line )) {} }; class MetricsCalculationError : public std :: runtime_error { public : explicit MetricsCalculationError ( const char * message ) : runtime_error ( message ) {} explicit MetricsCalculationError ( std :: string message ) : runtime_error ( message . c_str ()) {} explicit MetricsCalculationError ( std :: string message , const char * file , int line ) : runtime_error ( message + \" \\n File:\" + file + \" \\n Line:\" + std :: to_string ( line )) {} }; #define SPECIFICATION_VIOLATION_ERROR(description) \\ SpecificationViolationError( \\ description, __FILE__, __LINE__) #define THROW_METRICS_CALCULATION_ERROR(description) \\ throw MetricsCalculationError( \\ description, __FILE__, __LINE__); enum class MetricLifecycle { INACTIVE , ACTIVE , FAILURE , SUCCESS }; class MetricBase { public : explicit MetricBase ( std :: string metrics_type ); virtual ~ MetricBase (); virtual bool activateTrigger () = 0 ; virtual void update () = 0 ; void success (); void failure ( SpecificationViolationError error ); void activate (); virtual nlohmann :: json to_json () = 0 ; nlohmann :: json to_base_json (); void setEntityManager ( std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr ); const std :: string metrics_type ; MetricLifecycle getLifecycle () { return lifecycle_ ; } void throwException (); protected : std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr_ ; private : boost :: optional < SpecificationViolationError > error_ ; MetricLifecycle lifecycle_ ; }; } // namespace metrics #endif // SIMULATION_API__METRICS__METRIC_BASE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metric_base.hpp"},{"location":"package/simulation_api/markdown/Files/metric__base_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apimetricsmetric_basehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metric_base.hpp"},{"location":"package/simulation_api/markdown/Files/metric__base_8hpp/#namespaces","text":"Name metrics","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/metric__base_8hpp/#classes","text":"Name class metrics::SpecificationViolationError class metrics::MetricsCalculationError class metrics::MetricBase","title":"Classes"},{"location":"package/simulation_api/markdown/Files/metric__base_8hpp/#defines","text":"Name THROW_METRICS_CALCULATION_ERROR (description) SPECIFICATION_VIOLATION_ERROR (description)","title":"Defines"},{"location":"package/simulation_api/markdown/Files/metric__base_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"package/simulation_api/markdown/Files/metric__base_8hpp/#define-throw_metrics_calculation_error","text":"#define THROW_METRICS_CALCULATION_ERROR( description ) throw MetricsCalculationError ( \\ description , __FILE__ , __LINE__ );","title":"define THROW_METRICS_CALCULATION_ERROR"},{"location":"package/simulation_api/markdown/Files/metric__base_8hpp/#define-specification_violation_error","text":"#define SPECIFICATION_VIOLATION_ERROR( description ) SpecificationViolationError ( \\ description , __FILE__ , __LINE__ )","title":"define SPECIFICATION_VIOLATION_ERROR"},{"location":"package/simulation_api/markdown/Files/metric__base_8hpp/#source-code","text":"// Copyright 2015-2021 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__METRICS__METRIC_BASE_HPP_ #define SIMULATION_API__METRICS__METRIC_BASE_HPP_ #include <simulation_api/entity/entity_manager.hpp> #include <nlohmann/json.hpp> #include <boost/optional.hpp> #include <stdexcept> #include <string> #include <memory> namespace metrics { class SpecificationViolationError : public std :: runtime_error { public : explicit SpecificationViolationError ( const char * message ) : runtime_error ( message ) {} explicit SpecificationViolationError ( std :: string message ) : runtime_error ( message . c_str ()) {} explicit SpecificationViolationError ( std :: string message , const char * file , int line ) : runtime_error ( message + \" \\n File:\" + file + \" \\n Line:\" + std :: to_string ( line )) {} }; class MetricsCalculationError : public std :: runtime_error { public : explicit MetricsCalculationError ( const char * message ) : runtime_error ( message ) {} explicit MetricsCalculationError ( std :: string message ) : runtime_error ( message . c_str ()) {} explicit MetricsCalculationError ( std :: string message , const char * file , int line ) : runtime_error ( message + \" \\n File:\" + file + \" \\n Line:\" + std :: to_string ( line )) {} }; #define SPECIFICATION_VIOLATION_ERROR(description) \\ SpecificationViolationError( \\ description, __FILE__, __LINE__) #define THROW_METRICS_CALCULATION_ERROR(description) \\ throw MetricsCalculationError( \\ description, __FILE__, __LINE__); enum class MetricLifecycle { INACTIVE , ACTIVE , FAILURE , SUCCESS }; class MetricBase { public : explicit MetricBase ( std :: string metrics_type ); virtual ~ MetricBase (); virtual bool activateTrigger () = 0 ; virtual void update () = 0 ; void success (); void failure ( SpecificationViolationError error ); void activate (); virtual nlohmann :: json to_json () = 0 ; nlohmann :: json to_base_json (); void setEntityManager ( std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr ); const std :: string metrics_type ; MetricLifecycle getLifecycle () { return lifecycle_ ; } void throwException (); protected : std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr_ ; private : boost :: optional < SpecificationViolationError > error_ ; MetricLifecycle lifecycle_ ; }; } // namespace metrics #endif // SIMULATION_API__METRICS__METRIC_BASE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/metrics_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metrics.hpp # Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__METRICS__METRICS_HPP_ #define SIMULATION_API__METRICS__METRICS_HPP_ #include <simulation_api/metrics/metric_base.hpp> #include <simulation_api/metrics/traveled_distance_metric.hpp> #include <simulation_api/metrics/momentary_stop_metric.hpp> #include <simulation_api/metrics/reaction_time_metric.hpp> #endif // SIMULATION_API__METRICS__METRICS_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metrics.hpp"},{"location":"package/simulation_api/markdown/Files/metrics_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apimetricsmetricshpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metrics.hpp"},{"location":"package/simulation_api/markdown/Files/metrics_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__METRICS__METRICS_HPP_ #define SIMULATION_API__METRICS__METRICS_HPP_ #include <simulation_api/metrics/metric_base.hpp> #include <simulation_api/metrics/traveled_distance_metric.hpp> #include <simulation_api/metrics/momentary_stop_metric.hpp> #include <simulation_api/metrics/reaction_time_metric.hpp> #endif // SIMULATION_API__METRICS__METRICS_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/metrics__manager_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/metrics_manager.cpp # Namespaces # Name metrics Source code # // Copyright 2015-2021 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/metrics/metrics_manager.hpp> #include <simulation_api/metrics/metric_base.hpp> #include <memory> #include <vector> #include <string> #include <iostream> namespace metrics { MetricsManager :: MetricsManager ( bool verbose , const std :: string & logfile_path ) : logfile_path ( logfile_path ), metrics_ () { verbose_ = verbose ; } void MetricsManager :: setVerbose ( bool verbose ) { verbose_ = verbose ; } void MetricsManager :: calculate () { nlohmann :: json log ; std :: vector < std :: string > disable_metrics_list = {}; for ( auto & metric : metrics_ ) { if ( metric . second -> getLifecycle () == MetricLifecycle :: INACTIVE ) { if ( metric . second -> activateTrigger ()) { metric . second -> activate (); } } if ( metric . second -> getLifecycle () == MetricLifecycle :: ACTIVE ) { metric . second -> update (); } log [ metric . first ] = metric . second -> to_json (); if ( verbose_ ) { std :: cout << \"metric : \" << metric . first << \" => \" << log [ metric . first ] << std :: endl ; } if ( metric . second -> getLifecycle () == MetricLifecycle :: SUCCESS || metric . second -> getLifecycle () == MetricLifecycle :: FAILURE ) { disable_metrics_list . emplace_back ( metric . first ); } } for ( const auto name : disable_metrics_list ) { if ( metrics_ [ name ] -> getLifecycle () == MetricLifecycle :: FAILURE ) { metrics_ [ name ] -> throwException (); } metrics_ . erase ( name ); } double current_time = entity_manager_ptr_ -> getCurrentTime (); log_ [ std :: to_string ( current_time )] = log ; std :: ofstream file ( logfile_path ); file << log_ ; } void MetricsManager :: setEntityManager ( std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr ) { entity_manager_ptr_ = entity_manager_ptr ; } } // namespace metrics Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/metrics_manager.cpp"},{"location":"package/simulation_api/markdown/Files/metrics__manager_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmetricsmetrics_managercpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/metrics_manager.cpp"},{"location":"package/simulation_api/markdown/Files/metrics__manager_8cpp/#namespaces","text":"Name metrics","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/metrics__manager_8cpp/#source-code","text":"// Copyright 2015-2021 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/metrics/metrics_manager.hpp> #include <simulation_api/metrics/metric_base.hpp> #include <memory> #include <vector> #include <string> #include <iostream> namespace metrics { MetricsManager :: MetricsManager ( bool verbose , const std :: string & logfile_path ) : logfile_path ( logfile_path ), metrics_ () { verbose_ = verbose ; } void MetricsManager :: setVerbose ( bool verbose ) { verbose_ = verbose ; } void MetricsManager :: calculate () { nlohmann :: json log ; std :: vector < std :: string > disable_metrics_list = {}; for ( auto & metric : metrics_ ) { if ( metric . second -> getLifecycle () == MetricLifecycle :: INACTIVE ) { if ( metric . second -> activateTrigger ()) { metric . second -> activate (); } } if ( metric . second -> getLifecycle () == MetricLifecycle :: ACTIVE ) { metric . second -> update (); } log [ metric . first ] = metric . second -> to_json (); if ( verbose_ ) { std :: cout << \"metric : \" << metric . first << \" => \" << log [ metric . first ] << std :: endl ; } if ( metric . second -> getLifecycle () == MetricLifecycle :: SUCCESS || metric . second -> getLifecycle () == MetricLifecycle :: FAILURE ) { disable_metrics_list . emplace_back ( metric . first ); } } for ( const auto name : disable_metrics_list ) { if ( metrics_ [ name ] -> getLifecycle () == MetricLifecycle :: FAILURE ) { metrics_ [ name ] -> throwException (); } metrics_ . erase ( name ); } double current_time = entity_manager_ptr_ -> getCurrentTime (); log_ [ std :: to_string ( current_time )] = log ; std :: ofstream file ( logfile_path ); file << log_ ; } void MetricsManager :: setEntityManager ( std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr ) { entity_manager_ptr_ = entity_manager_ptr ; } } // namespace metrics Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/metrics__manager_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metrics_manager.hpp # Namespaces # Name metrics Classes # Name class metrics::MetricsManager Source code # // Copyright 2015-2021 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__METRICS__METRICS_MANAGER_HPP_ #define SIMULATION_API__METRICS__METRICS_MANAGER_HPP_ #include <simulation_api/entity/entity_manager.hpp> #include <simulation_api/metrics/metric_base.hpp> #include <nlohmann/json.hpp> #include <unordered_map> #include <memory> #include <string> #include <utility> #include <fstream> namespace metrics { class MetricsManager { public : explicit MetricsManager ( bool verbose , const std :: string & logfile_path ); ~ MetricsManager () { std :: ofstream file ( logfile_path ); file << log_ ; } void setVerbose ( bool verbose ); void setEntityManager ( std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr ); template < typename T , typename ... Ts > void addMetric ( std :: string name , Ts && ... xs ) { auto metric_ptr = std :: make_shared < T > ( std :: forward < Ts > ( xs )...); metric_ptr -> setEntityManager ( this -> entity_manager_ptr_ ); metrics_ . insert ({ name , metric_ptr }); } void calculate (); const std :: string logfile_path ; private : bool verbose_ ; nlohmann :: json log_ ; std :: unordered_map < std :: string , std :: shared_ptr < MetricBase >> metrics_ ; std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr_ ; }; } // namespace metrics #endif // SIMULATION_API__METRICS__METRICS_MANAGER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metrics_manager.hpp"},{"location":"package/simulation_api/markdown/Files/metrics__manager_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apimetricsmetrics_managerhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/metrics_manager.hpp"},{"location":"package/simulation_api/markdown/Files/metrics__manager_8hpp/#namespaces","text":"Name metrics","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/metrics__manager_8hpp/#classes","text":"Name class metrics::MetricsManager","title":"Classes"},{"location":"package/simulation_api/markdown/Files/metrics__manager_8hpp/#source-code","text":"// Copyright 2015-2021 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__METRICS__METRICS_MANAGER_HPP_ #define SIMULATION_API__METRICS__METRICS_MANAGER_HPP_ #include <simulation_api/entity/entity_manager.hpp> #include <simulation_api/metrics/metric_base.hpp> #include <nlohmann/json.hpp> #include <unordered_map> #include <memory> #include <string> #include <utility> #include <fstream> namespace metrics { class MetricsManager { public : explicit MetricsManager ( bool verbose , const std :: string & logfile_path ); ~ MetricsManager () { std :: ofstream file ( logfile_path ); file << log_ ; } void setVerbose ( bool verbose ); void setEntityManager ( std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr ); template < typename T , typename ... Ts > void addMetric ( std :: string name , Ts && ... xs ) { auto metric_ptr = std :: make_shared < T > ( std :: forward < Ts > ( xs )...); metric_ptr -> setEntityManager ( this -> entity_manager_ptr_ ); metrics_ . insert ({ name , metric_ptr }); } void calculate (); const std :: string logfile_path ; private : bool verbose_ ; nlohmann :: json log_ ; std :: unordered_map < std :: string , std :: shared_ptr < MetricBase >> metrics_ ; std :: shared_ptr < simulation_api :: entity :: EntityManager > entity_manager_ptr_ ; }; } // namespace metrics #endif // SIMULATION_API__METRICS__METRICS_MANAGER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/momentary__stop__metric_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/momentary_stop_metric.cpp # Namespaces # Name metrics Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/metrics/momentary_stop_metric.hpp> #include <string> namespace metrics { void MomentaryStopMetric :: update () { auto status = entity_manager_ptr_ -> getEntityStatus ( target_entity ); if ( ! status ) { THROW_METRICS_CALCULATION_ERROR ( \"failed to get target entity status.\" ); return ; } boost :: optional < double > distance ; switch ( stop_target_lanelet_type ) { case StopTargetLaneletType :: STOP_LINE : distance = entity_manager_ptr_ -> getDistanceToStopLine ( target_entity , stop_target_lanelet_id ); break ; case StopTargetLaneletType :: CROSSWALK : distance = entity_manager_ptr_ -> getDistanceToCrosswalk ( target_entity , stop_target_lanelet_id ); break ; default : THROW_METRICS_CALCULATION_ERROR ( \"invalid lanlet type.\" ); break ; } if ( ! distance ) { THROW_METRICS_CALCULATION_ERROR ( \"failed to calculate distance to stop line.\" ); } distance_to_stopline_ = distance . get (); linear_acceleration_ = status -> action_status . accel . linear . x ; if ( min_acceleration <= linear_acceleration_ && linear_acceleration_ <= max_acceleration ) { auto standstill_duration = entity_manager_ptr_ -> getStandStillDuration ( target_entity ); if ( ! standstill_duration ) { THROW_METRICS_CALCULATION_ERROR ( \"failed to calculate standstill duration.\" ); } standstill_duration_ = standstill_duration . get (); if ( entity_manager_ptr_ -> isStopping ( target_entity ) && standstill_duration . get () >= stop_duration ) { success (); } if ( distance . get () <= stop_sequence_end_distance ) { failure ( SPECIFICATION_VIOLATION_ERROR ( \"overrun detected\" )); } return ; } else { failure ( SPECIFICATION_VIOLATION_ERROR ( \"acceleration is out of range.\" )); } } bool MomentaryStopMetric :: activateTrigger () { auto status = entity_manager_ptr_ -> getEntityStatus ( target_entity ); if ( ! status ) { return false ; } boost :: optional < double > distance ; switch ( stop_target_lanelet_type ) { case StopTargetLaneletType :: STOP_LINE : distance = entity_manager_ptr_ -> getDistanceToStopLine ( target_entity , stop_target_lanelet_id ); break ; case StopTargetLaneletType :: CROSSWALK : distance = entity_manager_ptr_ -> getDistanceToCrosswalk ( target_entity , stop_target_lanelet_id ); break ; default : THROW_METRICS_CALCULATION_ERROR ( \"invalid lanlet type.\" ); break ; } if ( ! distance ) { return false ; } if ( distance . get () <= stop_sequence_start_distance ) { return true ; } return false ; } nlohmann :: json MomentaryStopMetric :: to_json () { nlohmann :: json json = MetricBase :: to_base_json (); if ( getLifecycle () != MetricLifecycle :: INACTIVE ) { json [ \"linear_acceleration\" ] = linear_acceleration_ ; json [ \"stop_duration\" ] = standstill_duration_ ; json [ \"distance_to_stopline\" ] = distance_to_stopline_ ; } return json ; } } // namespace metrics Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/momentary_stop_metric.cpp"},{"location":"package/simulation_api/markdown/Files/momentary__stop__metric_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmetricsmomentary_stop_metriccpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/momentary_stop_metric.cpp"},{"location":"package/simulation_api/markdown/Files/momentary__stop__metric_8cpp/#namespaces","text":"Name metrics","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/momentary__stop__metric_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/metrics/momentary_stop_metric.hpp> #include <string> namespace metrics { void MomentaryStopMetric :: update () { auto status = entity_manager_ptr_ -> getEntityStatus ( target_entity ); if ( ! status ) { THROW_METRICS_CALCULATION_ERROR ( \"failed to get target entity status.\" ); return ; } boost :: optional < double > distance ; switch ( stop_target_lanelet_type ) { case StopTargetLaneletType :: STOP_LINE : distance = entity_manager_ptr_ -> getDistanceToStopLine ( target_entity , stop_target_lanelet_id ); break ; case StopTargetLaneletType :: CROSSWALK : distance = entity_manager_ptr_ -> getDistanceToCrosswalk ( target_entity , stop_target_lanelet_id ); break ; default : THROW_METRICS_CALCULATION_ERROR ( \"invalid lanlet type.\" ); break ; } if ( ! distance ) { THROW_METRICS_CALCULATION_ERROR ( \"failed to calculate distance to stop line.\" ); } distance_to_stopline_ = distance . get (); linear_acceleration_ = status -> action_status . accel . linear . x ; if ( min_acceleration <= linear_acceleration_ && linear_acceleration_ <= max_acceleration ) { auto standstill_duration = entity_manager_ptr_ -> getStandStillDuration ( target_entity ); if ( ! standstill_duration ) { THROW_METRICS_CALCULATION_ERROR ( \"failed to calculate standstill duration.\" ); } standstill_duration_ = standstill_duration . get (); if ( entity_manager_ptr_ -> isStopping ( target_entity ) && standstill_duration . get () >= stop_duration ) { success (); } if ( distance . get () <= stop_sequence_end_distance ) { failure ( SPECIFICATION_VIOLATION_ERROR ( \"overrun detected\" )); } return ; } else { failure ( SPECIFICATION_VIOLATION_ERROR ( \"acceleration is out of range.\" )); } } bool MomentaryStopMetric :: activateTrigger () { auto status = entity_manager_ptr_ -> getEntityStatus ( target_entity ); if ( ! status ) { return false ; } boost :: optional < double > distance ; switch ( stop_target_lanelet_type ) { case StopTargetLaneletType :: STOP_LINE : distance = entity_manager_ptr_ -> getDistanceToStopLine ( target_entity , stop_target_lanelet_id ); break ; case StopTargetLaneletType :: CROSSWALK : distance = entity_manager_ptr_ -> getDistanceToCrosswalk ( target_entity , stop_target_lanelet_id ); break ; default : THROW_METRICS_CALCULATION_ERROR ( \"invalid lanlet type.\" ); break ; } if ( ! distance ) { return false ; } if ( distance . get () <= stop_sequence_start_distance ) { return true ; } return false ; } nlohmann :: json MomentaryStopMetric :: to_json () { nlohmann :: json json = MetricBase :: to_base_json (); if ( getLifecycle () != MetricLifecycle :: INACTIVE ) { json [ \"linear_acceleration\" ] = linear_acceleration_ ; json [ \"stop_duration\" ] = standstill_duration_ ; json [ \"distance_to_stopline\" ] = distance_to_stopline_ ; } return json ; } } // namespace metrics Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/momentary__stop__metric_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/momentary_stop_metric.hpp # Namespaces # Name metrics Classes # Name class metrics::MomentaryStopMetric Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__METRICS__MOMENTARY_STOP_METRIC_HPP_ #define SIMULATION_API__METRICS__MOMENTARY_STOP_METRIC_HPP_ #include <simulation_api/metrics/metric_base.hpp> #include <string> namespace metrics { class MomentaryStopMetric : public MetricBase { public : enum class StopTargetLaneletType { STOP_LINE , CROSSWALK }; MomentaryStopMetric ( std :: string target_entity , double min_acceleration , double max_acceleration , std :: int64_t stop_target_lanelet_id , StopTargetLaneletType stop_target_lanelet_type , double stop_sequence_start_distance , double stop_sequence_end_distance , double stop_duration ) : MetricBase ( \"MomentaryStop\" ), target_entity ( target_entity ), min_acceleration ( min_acceleration ), max_acceleration ( max_acceleration ), stop_target_lanelet_id ( stop_target_lanelet_id ), stop_target_lanelet_type ( stop_target_lanelet_type ), stop_sequence_start_distance ( stop_sequence_start_distance ), stop_sequence_end_distance ( stop_sequence_end_distance ), stop_duration ( stop_duration ) {} ~ MomentaryStopMetric () override = default ; void update () override ; bool activateTrigger () override ; const std :: string target_entity ; const double min_acceleration ; const double max_acceleration ; const std :: int64_t stop_target_lanelet_id ; const StopTargetLaneletType stop_target_lanelet_type ; const double stop_sequence_start_distance ; const double stop_sequence_end_distance ; const double stop_duration ; nlohmann :: json to_json (); private : double linear_acceleration_ ; double standstill_duration_ ; double distance_to_stopline_ ; }; } // namespace metrics #endif // SIMULATION_API__METRICS__MOMENTARY_STOP_METRIC_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/momentary_stop_metric.hpp"},{"location":"package/simulation_api/markdown/Files/momentary__stop__metric_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apimetricsmomentary_stop_metrichpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/momentary_stop_metric.hpp"},{"location":"package/simulation_api/markdown/Files/momentary__stop__metric_8hpp/#namespaces","text":"Name metrics","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/momentary__stop__metric_8hpp/#classes","text":"Name class metrics::MomentaryStopMetric","title":"Classes"},{"location":"package/simulation_api/markdown/Files/momentary__stop__metric_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__METRICS__MOMENTARY_STOP_METRIC_HPP_ #define SIMULATION_API__METRICS__MOMENTARY_STOP_METRIC_HPP_ #include <simulation_api/metrics/metric_base.hpp> #include <string> namespace metrics { class MomentaryStopMetric : public MetricBase { public : enum class StopTargetLaneletType { STOP_LINE , CROSSWALK }; MomentaryStopMetric ( std :: string target_entity , double min_acceleration , double max_acceleration , std :: int64_t stop_target_lanelet_id , StopTargetLaneletType stop_target_lanelet_type , double stop_sequence_start_distance , double stop_sequence_end_distance , double stop_duration ) : MetricBase ( \"MomentaryStop\" ), target_entity ( target_entity ), min_acceleration ( min_acceleration ), max_acceleration ( max_acceleration ), stop_target_lanelet_id ( stop_target_lanelet_id ), stop_target_lanelet_type ( stop_target_lanelet_type ), stop_sequence_start_distance ( stop_sequence_start_distance ), stop_sequence_end_distance ( stop_sequence_end_distance ), stop_duration ( stop_duration ) {} ~ MomentaryStopMetric () override = default ; void update () override ; bool activateTrigger () override ; const std :: string target_entity ; const double min_acceleration ; const double max_acceleration ; const std :: int64_t stop_target_lanelet_id ; const StopTargetLaneletType stop_target_lanelet_type ; const double stop_sequence_start_distance ; const double stop_sequence_end_distance ; const double stop_duration ; nlohmann :: json to_json (); private : double linear_acceleration_ ; double standstill_duration_ ; double distance_to_stopline_ ; }; } // namespace metrics #endif // SIMULATION_API__METRICS__MOMENTARY_STOP_METRIC_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/pedestrian_2behavior__tree_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/behavior_tree.cpp # Namespaces # Name entity_behavior::pedestrian entity_behavior Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/pedestrian/behavior_tree.hpp> #include <ament_index_cpp/get_package_share_directory.hpp> #include <iostream> #include <utility> #include <string> #include <algorithm> namespace entity_behavior { namespace pedestrian { BehaviorTree :: BehaviorTree () { std :: string path = ament_index_cpp :: get_package_share_directory ( \"simulation_api\" ) + \"/resource/pedestrian_entity_behavior.xml\" ; factory_ . registerNodeType < entity_behavior :: pedestrian :: FollowLaneAction > ( \"FollowLane\" ); factory_ . registerNodeType < entity_behavior :: pedestrian :: WalkStraightAction > ( \"WalkStraightAction\" ); tree_ = factory_ . createTreeFromFile ( path ); current_action_ = \"root\" ; // logger_cout_ptr_ = std::make_shared<BT::StdCoutLogger>(tree_); setupLogger (); setRequest ( \"none\" ); } void BehaviorTree :: setRequest ( std :: string request ) { request_ = request ; setValueToBlackBoard ( \"request\" , request ); } void BehaviorTree :: setupLogger () { first_timestamp_ = std :: chrono :: high_resolution_clock :: now (); auto subscribeCallback = [ this ]( BT :: TimePoint timestamp , const BT :: TreeNode & node , BT :: NodeStatus prev , BT :: NodeStatus status ) { if ( status != BT :: NodeStatus :: IDLE ) { if ( type_ == BT :: TimestampType :: ABSOLUTE ) { this -> callback ( timestamp . time_since_epoch (), node , prev , status ); } else { this -> callback ( timestamp - first_timestamp_ , node , prev , status ); } } }; auto visitor = [ this , subscribeCallback ]( BT :: TreeNode * node ) { subscribers_ . push_back ( node -> subscribeToStatusChange ( std :: move ( subscribeCallback ))); }; BT :: applyRecursiveVisitor ( tree_ . rootNode (), visitor ); } BT :: NodeStatus BehaviorTree :: tick ( double current_time , double step_time ) { setValueToBlackBoard ( \"current_time\" , current_time ); setValueToBlackBoard ( \"step_time\" , step_time ); auto ret = tree_ . rootNode () -> executeTick (); return ret ; } void BehaviorTree :: callback ( BT :: Duration timestamp , const BT :: TreeNode & node , BT :: NodeStatus prev_status , BT :: NodeStatus status ) { constexpr const char * whitespaces = \" \" ; constexpr const size_t ws_count = 25 ; double since_epoch = std :: chrono :: duration < double > ( timestamp ). count (); printf ( \"[%.3f]: %s%s %s -> %s\" , since_epoch , node . name (). c_str (), & whitespaces [ std :: min ( ws_count , node . name (). size ())], toStr ( prev_status , true ). c_str (), toStr ( status , true ). c_str () ); std :: cout << std :: endl ; if ( status != BT :: NodeStatus :: SUCCESS ) { current_action_ = node . name (); } if ( status == BT :: NodeStatus :: SUCCESS || status == BT :: NodeStatus :: FAILURE ) { if ( request_ == current_action_ ) { setRequest ( \"none\" ); } } } } // namespace pedestrian } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/behavior_tree.cpp"},{"location":"package/simulation_api/markdown/Files/pedestrian_2behavior__tree_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorpedestrianbehavior_treecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/behavior_tree.cpp"},{"location":"package/simulation_api/markdown/Files/pedestrian_2behavior__tree_8cpp/#namespaces","text":"Name entity_behavior::pedestrian entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/pedestrian_2behavior__tree_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/pedestrian/behavior_tree.hpp> #include <ament_index_cpp/get_package_share_directory.hpp> #include <iostream> #include <utility> #include <string> #include <algorithm> namespace entity_behavior { namespace pedestrian { BehaviorTree :: BehaviorTree () { std :: string path = ament_index_cpp :: get_package_share_directory ( \"simulation_api\" ) + \"/resource/pedestrian_entity_behavior.xml\" ; factory_ . registerNodeType < entity_behavior :: pedestrian :: FollowLaneAction > ( \"FollowLane\" ); factory_ . registerNodeType < entity_behavior :: pedestrian :: WalkStraightAction > ( \"WalkStraightAction\" ); tree_ = factory_ . createTreeFromFile ( path ); current_action_ = \"root\" ; // logger_cout_ptr_ = std::make_shared<BT::StdCoutLogger>(tree_); setupLogger (); setRequest ( \"none\" ); } void BehaviorTree :: setRequest ( std :: string request ) { request_ = request ; setValueToBlackBoard ( \"request\" , request ); } void BehaviorTree :: setupLogger () { first_timestamp_ = std :: chrono :: high_resolution_clock :: now (); auto subscribeCallback = [ this ]( BT :: TimePoint timestamp , const BT :: TreeNode & node , BT :: NodeStatus prev , BT :: NodeStatus status ) { if ( status != BT :: NodeStatus :: IDLE ) { if ( type_ == BT :: TimestampType :: ABSOLUTE ) { this -> callback ( timestamp . time_since_epoch (), node , prev , status ); } else { this -> callback ( timestamp - first_timestamp_ , node , prev , status ); } } }; auto visitor = [ this , subscribeCallback ]( BT :: TreeNode * node ) { subscribers_ . push_back ( node -> subscribeToStatusChange ( std :: move ( subscribeCallback ))); }; BT :: applyRecursiveVisitor ( tree_ . rootNode (), visitor ); } BT :: NodeStatus BehaviorTree :: tick ( double current_time , double step_time ) { setValueToBlackBoard ( \"current_time\" , current_time ); setValueToBlackBoard ( \"step_time\" , step_time ); auto ret = tree_ . rootNode () -> executeTick (); return ret ; } void BehaviorTree :: callback ( BT :: Duration timestamp , const BT :: TreeNode & node , BT :: NodeStatus prev_status , BT :: NodeStatus status ) { constexpr const char * whitespaces = \" \" ; constexpr const size_t ws_count = 25 ; double since_epoch = std :: chrono :: duration < double > ( timestamp ). count (); printf ( \"[%.3f]: %s%s %s -> %s\" , since_epoch , node . name (). c_str (), & whitespaces [ std :: min ( ws_count , node . name (). size ())], toStr ( prev_status , true ). c_str (), toStr ( status , true ). c_str () ); std :: cout << std :: endl ; if ( status != BT :: NodeStatus :: SUCCESS ) { current_action_ = node . name (); } if ( status == BT :: NodeStatus :: SUCCESS || status == BT :: NodeStatus :: FAILURE ) { if ( request_ == current_action_ ) { setRequest ( \"none\" ); } } } } // namespace pedestrian } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/pedestrian_2behavior__tree_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/behavior_tree.hpp # Namespaces # Name entity_behavior::pedestrian entity_behavior Classes # Name class entity_behavior::pedestrian::BehaviorTree Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__PEDESTRIAN__BEHAVIOR_TREE_HPP_ #define SIMULATION_API__BEHAVIOR__PEDESTRIAN__BEHAVIOR_TREE_HPP_ #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <simulation_api/behavior/pedestrian/follow_lane_action.hpp> #include <simulation_api/behavior/pedestrian/walk_straight_action.hpp> #include <openscenario_msgs/msg/entity_status.hpp> #include <geometry_msgs/msg/point.hpp> #include <behaviortree_cpp_v3/bt_factory.h> #include <behaviortree_cpp_v3/loggers/bt_cout_logger.h> #include <memory> #include <functional> #include <map> #include <vector> #include <string> namespace entity_behavior { namespace pedestrian { class BehaviorTree { public : BehaviorTree (); BT :: NodeStatus tick ( double current_time , double step_time ); const std :: string getCurrentAction () const { return current_action_ ; } template < typename T > void setValueToBlackBoard ( std :: string key , T value ) { tree_ . rootBlackboard () -> set ( key , value ); } openscenario_msgs :: msg :: EntityStatus getUpdatedStatus () { openscenario_msgs :: msg :: EntityStatus status ; tree_ . rootBlackboard () -> get ( \"updated_status\" , status ); return status ; } void setRequest ( std :: string request ); private : std :: string request_ ; BT :: BehaviorTreeFactory factory_ ; BT :: Tree tree_ ; std :: shared_ptr < BT :: StdCoutLogger > logger_cout_ptr_ ; void callback ( BT :: Duration timestamp , const BT :: TreeNode & node , BT :: NodeStatus prev_status , BT :: NodeStatus status ); void setupLogger (); BT :: TimestampType type_ ; BT :: TimePoint first_timestamp_ ; std :: vector < BT :: TreeNode :: StatusChangeSubscriber > subscribers_ ; std :: string current_action_ ; }; } // namespace pedestrian } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__PEDESTRIAN__BEHAVIOR_TREE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/behavior_tree.hpp"},{"location":"package/simulation_api/markdown/Files/pedestrian_2behavior__tree_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorpedestrianbehavior_treehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/behavior_tree.hpp"},{"location":"package/simulation_api/markdown/Files/pedestrian_2behavior__tree_8hpp/#namespaces","text":"Name entity_behavior::pedestrian entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/pedestrian_2behavior__tree_8hpp/#classes","text":"Name class entity_behavior::pedestrian::BehaviorTree","title":"Classes"},{"location":"package/simulation_api/markdown/Files/pedestrian_2behavior__tree_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__PEDESTRIAN__BEHAVIOR_TREE_HPP_ #define SIMULATION_API__BEHAVIOR__PEDESTRIAN__BEHAVIOR_TREE_HPP_ #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <simulation_api/behavior/pedestrian/follow_lane_action.hpp> #include <simulation_api/behavior/pedestrian/walk_straight_action.hpp> #include <openscenario_msgs/msg/entity_status.hpp> #include <geometry_msgs/msg/point.hpp> #include <behaviortree_cpp_v3/bt_factory.h> #include <behaviortree_cpp_v3/loggers/bt_cout_logger.h> #include <memory> #include <functional> #include <map> #include <vector> #include <string> namespace entity_behavior { namespace pedestrian { class BehaviorTree { public : BehaviorTree (); BT :: NodeStatus tick ( double current_time , double step_time ); const std :: string getCurrentAction () const { return current_action_ ; } template < typename T > void setValueToBlackBoard ( std :: string key , T value ) { tree_ . rootBlackboard () -> set ( key , value ); } openscenario_msgs :: msg :: EntityStatus getUpdatedStatus () { openscenario_msgs :: msg :: EntityStatus status ; tree_ . rootBlackboard () -> get ( \"updated_status\" , status ); return status ; } void setRequest ( std :: string request ); private : std :: string request_ ; BT :: BehaviorTreeFactory factory_ ; BT :: Tree tree_ ; std :: shared_ptr < BT :: StdCoutLogger > logger_cout_ptr_ ; void callback ( BT :: Duration timestamp , const BT :: TreeNode & node , BT :: NodeStatus prev_status , BT :: NodeStatus status ); void setupLogger (); BT :: TimestampType type_ ; BT :: TimePoint first_timestamp_ ; std :: vector < BT :: TreeNode :: StatusChangeSubscriber > subscribers_ ; std :: string current_action_ ; }; } // namespace pedestrian } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__PEDESTRIAN__BEHAVIOR_TREE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/pedestrian_2follow__lane__action_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/follow_lane_action.cpp # Namespaces # Name entity_behavior::pedestrian entity_behavior Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/pedestrian/follow_lane_action.hpp> #include <quaternion_operation/quaternion_operation.h> #include <boost/algorithm/clamp.hpp> #include <iostream> #include <string> #include <memory> #include <vector> namespace entity_behavior { namespace pedestrian { FollowLaneAction :: FollowLaneAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: PedestrianActionNode ( name , config ) {} void FollowLaneAction :: getBlackBoardValues () { PedestrianActionNode :: getBlackBoardValues (); } BT :: NodeStatus FollowLaneAction :: tick () { getBlackBoardValues (); if ( request != \"none\" && request != \"follow_lane\" ) { return BT :: NodeStatus :: FAILURE ; } if ( ! entity_status . lanelet_pose_valid ) { setOutput ( \"updated_status\" , stopAtEndOfRoad ()); return BT :: NodeStatus :: RUNNING ; } auto following_lanelets = hdmap_utils -> getFollowingLanelets ( entity_status . lanelet_pose . lanelet_id ); if ( ! target_speed ) { target_speed = hdmap_utils -> getSpeedLimit ( following_lanelets ); } geometry_msgs :: msg :: Accel accel_new ; accel_new = entity_status . action_status . accel ; double target_accel = ( target_speed . get () - entity_status . action_status . twist . linear . x ) / step_time ; if ( entity_status . action_status . twist . linear . x > target_speed . get ()) { target_accel = boost :: algorithm :: clamp ( target_accel , -5 , 0 ); /*\u3000target_accel = boost::algorithm::clamp(target_accel, -1*vehicle_param_ptr->performance.max_deceleration, vehicle_param_ptr->performance.max_acceleration); */ } else { target_accel = boost :: algorithm :: clamp ( target_accel , 0 , 3 ); /* target_accel = boost::algorithm::clamp(target_accel, -1*vehicle_param_ptr->performance.max_deceleration, vehicle_param_ptr->performance.max_acceleration);*/ } accel_new . linear . x = target_accel ; geometry_msgs :: msg :: Twist twist_new ; twist_new . linear . x = boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x + accel_new . linear . x * step_time , 0 , 5.0 ); twist_new . linear . y = 0.0 ; twist_new . linear . z = 0.0 ; twist_new . angular . x = 0.0 ; twist_new . angular . y = 0.0 ; twist_new . angular . z = 0.0 ; double new_s = entity_status . lanelet_pose . s + ( twist_new . linear . x + entity_status . action_status . twist . linear . x ) / 2.0 * step_time ; geometry_msgs :: msg :: Vector3 rpy = entity_status . lanelet_pose . rpy ; openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . time = current_time + step_time ; entity_status_updated . lanelet_pose . lanelet_id = entity_status . lanelet_pose . lanelet_id ; entity_status_updated . lanelet_pose . s = new_s ; entity_status_updated . lanelet_pose . offset = entity_status . lanelet_pose . offset ; entity_status_updated . lanelet_pose . rpy = rpy ; entity_status_updated . action_status . twist = twist_new ; entity_status_updated . action_status . accel = accel_new ; entity_status_updated . pose = hdmap_utils -> toMapPose ( entity_status . lanelet_pose ). pose ; setOutput ( \"updated_status\" , entity_status_updated ); return BT :: NodeStatus :: RUNNING ; } } // namespace pedestrian } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/follow_lane_action.cpp"},{"location":"package/simulation_api/markdown/Files/pedestrian_2follow__lane__action_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorpedestrianfollow_lane_actioncpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/follow_lane_action.cpp"},{"location":"package/simulation_api/markdown/Files/pedestrian_2follow__lane__action_8cpp/#namespaces","text":"Name entity_behavior::pedestrian entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/pedestrian_2follow__lane__action_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/pedestrian/follow_lane_action.hpp> #include <quaternion_operation/quaternion_operation.h> #include <boost/algorithm/clamp.hpp> #include <iostream> #include <string> #include <memory> #include <vector> namespace entity_behavior { namespace pedestrian { FollowLaneAction :: FollowLaneAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: PedestrianActionNode ( name , config ) {} void FollowLaneAction :: getBlackBoardValues () { PedestrianActionNode :: getBlackBoardValues (); } BT :: NodeStatus FollowLaneAction :: tick () { getBlackBoardValues (); if ( request != \"none\" && request != \"follow_lane\" ) { return BT :: NodeStatus :: FAILURE ; } if ( ! entity_status . lanelet_pose_valid ) { setOutput ( \"updated_status\" , stopAtEndOfRoad ()); return BT :: NodeStatus :: RUNNING ; } auto following_lanelets = hdmap_utils -> getFollowingLanelets ( entity_status . lanelet_pose . lanelet_id ); if ( ! target_speed ) { target_speed = hdmap_utils -> getSpeedLimit ( following_lanelets ); } geometry_msgs :: msg :: Accel accel_new ; accel_new = entity_status . action_status . accel ; double target_accel = ( target_speed . get () - entity_status . action_status . twist . linear . x ) / step_time ; if ( entity_status . action_status . twist . linear . x > target_speed . get ()) { target_accel = boost :: algorithm :: clamp ( target_accel , -5 , 0 ); /*\u3000target_accel = boost::algorithm::clamp(target_accel, -1*vehicle_param_ptr->performance.max_deceleration, vehicle_param_ptr->performance.max_acceleration); */ } else { target_accel = boost :: algorithm :: clamp ( target_accel , 0 , 3 ); /* target_accel = boost::algorithm::clamp(target_accel, -1*vehicle_param_ptr->performance.max_deceleration, vehicle_param_ptr->performance.max_acceleration);*/ } accel_new . linear . x = target_accel ; geometry_msgs :: msg :: Twist twist_new ; twist_new . linear . x = boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x + accel_new . linear . x * step_time , 0 , 5.0 ); twist_new . linear . y = 0.0 ; twist_new . linear . z = 0.0 ; twist_new . angular . x = 0.0 ; twist_new . angular . y = 0.0 ; twist_new . angular . z = 0.0 ; double new_s = entity_status . lanelet_pose . s + ( twist_new . linear . x + entity_status . action_status . twist . linear . x ) / 2.0 * step_time ; geometry_msgs :: msg :: Vector3 rpy = entity_status . lanelet_pose . rpy ; openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . time = current_time + step_time ; entity_status_updated . lanelet_pose . lanelet_id = entity_status . lanelet_pose . lanelet_id ; entity_status_updated . lanelet_pose . s = new_s ; entity_status_updated . lanelet_pose . offset = entity_status . lanelet_pose . offset ; entity_status_updated . lanelet_pose . rpy = rpy ; entity_status_updated . action_status . twist = twist_new ; entity_status_updated . action_status . accel = accel_new ; entity_status_updated . pose = hdmap_utils -> toMapPose ( entity_status . lanelet_pose ). pose ; setOutput ( \"updated_status\" , entity_status_updated ); return BT :: NodeStatus :: RUNNING ; } } // namespace pedestrian } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/pedestrian_2follow__lane__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/follow_lane_action.hpp # Namespaces # Name entity_behavior::pedestrian entity_behavior Classes # Name class entity_behavior::pedestrian::FollowLaneAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__PEDESTRIAN__FOLLOW_LANE_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__PEDESTRIAN__FOLLOW_LANE_ACTION_HPP_ #include <simulation_api/behavior/pedestrian/pedestrian_action_node.hpp> #include <simulation_api/entity/pedestrian_parameter.hpp> #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <openscenario_msgs/msg/entity_status.hpp> #include <behaviortree_cpp_v3/behavior_tree.h> #include <behaviortree_cpp_v3/bt_factory.h> #include <string> #include <memory> #include <vector> namespace entity_behavior { namespace pedestrian { class FollowLaneAction : public entity_behavior :: PedestrianActionNode { public : FollowLaneAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; void getBlackBoardValues (); static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: PedestrianActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } }; } // namespace pedestrian } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__PEDESTRIAN__FOLLOW_LANE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/follow_lane_action.hpp"},{"location":"package/simulation_api/markdown/Files/pedestrian_2follow__lane__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorpedestrianfollow_lane_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/follow_lane_action.hpp"},{"location":"package/simulation_api/markdown/Files/pedestrian_2follow__lane__action_8hpp/#namespaces","text":"Name entity_behavior::pedestrian entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/pedestrian_2follow__lane__action_8hpp/#classes","text":"Name class entity_behavior::pedestrian::FollowLaneAction","title":"Classes"},{"location":"package/simulation_api/markdown/Files/pedestrian_2follow__lane__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__PEDESTRIAN__FOLLOW_LANE_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__PEDESTRIAN__FOLLOW_LANE_ACTION_HPP_ #include <simulation_api/behavior/pedestrian/pedestrian_action_node.hpp> #include <simulation_api/entity/pedestrian_parameter.hpp> #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <openscenario_msgs/msg/entity_status.hpp> #include <behaviortree_cpp_v3/behavior_tree.h> #include <behaviortree_cpp_v3/bt_factory.h> #include <string> #include <memory> #include <vector> namespace entity_behavior { namespace pedestrian { class FollowLaneAction : public entity_behavior :: PedestrianActionNode { public : FollowLaneAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; void getBlackBoardValues (); static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: PedestrianActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } }; } // namespace pedestrian } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__PEDESTRIAN__FOLLOW_LANE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/pedestrian__action__node_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/pedestrian_action_node.cpp # Namespaces # Name entity_behavior Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/pedestrian/pedestrian_action_node.hpp> #include <memory> #include <string> namespace entity_behavior { PedestrianActionNode :: PedestrianActionNode ( const std :: string & name , const BT :: NodeConfiguration & config ) : ActionNode ( name , config ) {} void PedestrianActionNode :: getBlackBoardValues () { ActionNode :: getBlackBoardValues (); if ( ! getInput < openscenario_msgs :: msg :: PedestrianParameters > ( \"pedestrian_parameters\" , pedestrian_parameters )) { throw BehaviorTreeRuntimeError ( \"failed to get input pedestrian_parameters in PedestrianActionNode\" ); } } openscenario_msgs :: msg :: EntityStatus PedestrianActionNode :: calculateEntityStatusUpdated ( double target_speed ) { geometry_msgs :: msg :: Accel accel_new ; accel_new = entity_status . action_status . accel ; double target_accel = ( target_speed - entity_status . action_status . twist . linear . x ) / step_time ; if ( entity_status . action_status . twist . linear . x > target_speed ) { target_accel = boost :: algorithm :: clamp ( target_accel , -5 , 0 ); } else { target_accel = boost :: algorithm :: clamp ( target_accel , 0 , 3 ); } accel_new . linear . x = target_accel ; geometry_msgs :: msg :: Twist twist_new ; twist_new . linear . x = boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x + accel_new . linear . x * step_time , -10 , 10 ); twist_new . linear . y = 0.0 ; twist_new . linear . z = 0.0 ; twist_new . angular . x = 0.0 ; twist_new . angular . y = 0.0 ; twist_new . angular . z = 0.0 ; std :: int64_t new_lanelet_id = entity_status . lanelet_pose . lanelet_id ; double new_s = entity_status . lanelet_pose . s + ( twist_new . linear . x + entity_status . action_status . twist . linear . x ) / 2.0 * step_time ; if ( new_s < 0 ) { auto previous_lanlet_ids = hdmap_utils -> getPreviousLaneletIds ( entity_status . lanelet_pose . lanelet_id ); new_lanelet_id = previous_lanlet_ids [ 0 ]; new_s = new_s + hdmap_utils -> getLaneletLength ( new_lanelet_id ) - 0.01 ; openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . time = current_time + step_time ; entity_status_updated . lanelet_pose . lanelet_id = new_lanelet_id ; entity_status_updated . lanelet_pose . s = new_s ; entity_status_updated . lanelet_pose . offset = entity_status . lanelet_pose . offset ; entity_status_updated . lanelet_pose . rpy = entity_status . lanelet_pose . rpy ; entity_status_updated . action_status . twist = twist_new ; entity_status_updated . action_status . accel = accel_new ; entity_status_updated . pose = hdmap_utils -> toMapPose ( entity_status_updated . lanelet_pose ). pose ; return entity_status_updated ; } else { bool calculation_success = false ; for ( size_t i = 0 ; i < route_lanelets . size (); i ++ ) { if ( route_lanelets [ i ] == entity_status . lanelet_pose . lanelet_id ) { double length = hdmap_utils -> getLaneletLength ( entity_status . lanelet_pose . lanelet_id ); calculation_success = true ; if ( length < new_s ) { if ( i != ( route_lanelets . size () - 1 )) { new_s = new_s - length ; new_lanelet_id = route_lanelets [ i + 1 ]; break ; } else { new_s = new_s - length ; auto next_ids = hdmap_utils -> getNextLaneletIds ( route_lanelets [ i ]); if ( next_ids . empty ()) { return stopAtEndOfRoad (); } new_lanelet_id = next_ids [ 0 ]; break ; } } } } if ( ! calculation_success ) { throw BehaviorTreeRuntimeError ( \"failed to calculate next status calculateEntityStatusUpdated function\" ); } openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . time = current_time + step_time ; entity_status_updated . lanelet_pose . lanelet_id = new_lanelet_id ; entity_status_updated . lanelet_pose . s = new_s ; entity_status_updated . lanelet_pose . offset = entity_status . lanelet_pose . offset ; entity_status_updated . lanelet_pose . rpy = entity_status . lanelet_pose . rpy ; entity_status_updated . pose = hdmap_utils -> toMapPose ( entity_status_updated . lanelet_pose ). pose ; entity_status_updated . action_status . twist = twist_new ; entity_status_updated . action_status . accel = accel_new ; return entity_status_updated ; } throw BehaviorTreeRuntimeError ( \"failed to calculate next status calculateEntityStatusUpdated function\" ); } openscenario_msgs :: msg :: EntityStatus PedestrianActionNode :: calculateEntityStatusUpdatedInWorldFrame ( double target_speed ) { double target_accel = ( target_speed - entity_status . action_status . twist . linear . x ) / step_time ; if ( entity_status . action_status . twist . linear . x > target_speed ) { target_accel = boost :: algorithm :: clamp ( target_accel , -5 , 0 ); } else { target_accel = boost :: algorithm :: clamp ( target_accel , 0 , 3 ); } geometry_msgs :: msg :: Accel accel_new ; accel_new = entity_status . action_status . accel ; accel_new . linear . x = target_accel ; geometry_msgs :: msg :: Twist twist_new ; twist_new . linear . x = entity_status . action_status . twist . linear . x + entity_status . action_status . accel . linear . x * step_time ; twist_new . linear . y = entity_status . action_status . twist . linear . y + entity_status . action_status . accel . linear . y * step_time ; twist_new . linear . z = entity_status . action_status . twist . linear . z + entity_status . action_status . accel . linear . z * step_time ; twist_new . angular . x = entity_status . action_status . twist . angular . x + entity_status . action_status . accel . angular . x * step_time ; twist_new . angular . y = entity_status . action_status . twist . angular . y + entity_status . action_status . accel . angular . y * step_time ; twist_new . angular . z = entity_status . action_status . twist . angular . z + entity_status . action_status . accel . angular . z * step_time ; geometry_msgs :: msg :: Pose pose_new ; geometry_msgs :: msg :: Vector3 angular_trans_vec ; angular_trans_vec . z = twist_new . angular . z * step_time ; geometry_msgs :: msg :: Quaternion angular_trans_quat = quaternion_operation :: convertEulerAngleToQuaternion ( angular_trans_vec ); pose_new . orientation = quaternion_operation :: rotation ( entity_status . pose . orientation , angular_trans_quat ); Eigen :: Vector3d trans_vec ; trans_vec ( 0 ) = twist_new . linear . x * step_time ; trans_vec ( 1 ) = twist_new . linear . y * step_time ; trans_vec ( 2 ) = 0 ; Eigen :: Matrix3d rotation_mat = quaternion_operation :: getRotationMatrix ( pose_new . orientation ); trans_vec = rotation_mat * trans_vec ; pose_new . position . x = trans_vec ( 0 ) + entity_status . pose . position . x ; pose_new . position . y = trans_vec ( 1 ) + entity_status . pose . position . y ; pose_new . position . z = trans_vec ( 2 ) + entity_status . pose . position . z ; openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . time = current_time + step_time ; entity_status_updated . pose = pose_new ; entity_status_updated . action_status . twist = twist_new ; entity_status_updated . action_status . accel = accel_new ; entity_status_updated . lanelet_pose_valid = false ; return entity_status_updated ; } } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/pedestrian_action_node.cpp"},{"location":"package/simulation_api/markdown/Files/pedestrian__action__node_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorpedestrianpedestrian_action_nodecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/pedestrian_action_node.cpp"},{"location":"package/simulation_api/markdown/Files/pedestrian__action__node_8cpp/#namespaces","text":"Name entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/pedestrian__action__node_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/pedestrian/pedestrian_action_node.hpp> #include <memory> #include <string> namespace entity_behavior { PedestrianActionNode :: PedestrianActionNode ( const std :: string & name , const BT :: NodeConfiguration & config ) : ActionNode ( name , config ) {} void PedestrianActionNode :: getBlackBoardValues () { ActionNode :: getBlackBoardValues (); if ( ! getInput < openscenario_msgs :: msg :: PedestrianParameters > ( \"pedestrian_parameters\" , pedestrian_parameters )) { throw BehaviorTreeRuntimeError ( \"failed to get input pedestrian_parameters in PedestrianActionNode\" ); } } openscenario_msgs :: msg :: EntityStatus PedestrianActionNode :: calculateEntityStatusUpdated ( double target_speed ) { geometry_msgs :: msg :: Accel accel_new ; accel_new = entity_status . action_status . accel ; double target_accel = ( target_speed - entity_status . action_status . twist . linear . x ) / step_time ; if ( entity_status . action_status . twist . linear . x > target_speed ) { target_accel = boost :: algorithm :: clamp ( target_accel , -5 , 0 ); } else { target_accel = boost :: algorithm :: clamp ( target_accel , 0 , 3 ); } accel_new . linear . x = target_accel ; geometry_msgs :: msg :: Twist twist_new ; twist_new . linear . x = boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x + accel_new . linear . x * step_time , -10 , 10 ); twist_new . linear . y = 0.0 ; twist_new . linear . z = 0.0 ; twist_new . angular . x = 0.0 ; twist_new . angular . y = 0.0 ; twist_new . angular . z = 0.0 ; std :: int64_t new_lanelet_id = entity_status . lanelet_pose . lanelet_id ; double new_s = entity_status . lanelet_pose . s + ( twist_new . linear . x + entity_status . action_status . twist . linear . x ) / 2.0 * step_time ; if ( new_s < 0 ) { auto previous_lanlet_ids = hdmap_utils -> getPreviousLaneletIds ( entity_status . lanelet_pose . lanelet_id ); new_lanelet_id = previous_lanlet_ids [ 0 ]; new_s = new_s + hdmap_utils -> getLaneletLength ( new_lanelet_id ) - 0.01 ; openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . time = current_time + step_time ; entity_status_updated . lanelet_pose . lanelet_id = new_lanelet_id ; entity_status_updated . lanelet_pose . s = new_s ; entity_status_updated . lanelet_pose . offset = entity_status . lanelet_pose . offset ; entity_status_updated . lanelet_pose . rpy = entity_status . lanelet_pose . rpy ; entity_status_updated . action_status . twist = twist_new ; entity_status_updated . action_status . accel = accel_new ; entity_status_updated . pose = hdmap_utils -> toMapPose ( entity_status_updated . lanelet_pose ). pose ; return entity_status_updated ; } else { bool calculation_success = false ; for ( size_t i = 0 ; i < route_lanelets . size (); i ++ ) { if ( route_lanelets [ i ] == entity_status . lanelet_pose . lanelet_id ) { double length = hdmap_utils -> getLaneletLength ( entity_status . lanelet_pose . lanelet_id ); calculation_success = true ; if ( length < new_s ) { if ( i != ( route_lanelets . size () - 1 )) { new_s = new_s - length ; new_lanelet_id = route_lanelets [ i + 1 ]; break ; } else { new_s = new_s - length ; auto next_ids = hdmap_utils -> getNextLaneletIds ( route_lanelets [ i ]); if ( next_ids . empty ()) { return stopAtEndOfRoad (); } new_lanelet_id = next_ids [ 0 ]; break ; } } } } if ( ! calculation_success ) { throw BehaviorTreeRuntimeError ( \"failed to calculate next status calculateEntityStatusUpdated function\" ); } openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . time = current_time + step_time ; entity_status_updated . lanelet_pose . lanelet_id = new_lanelet_id ; entity_status_updated . lanelet_pose . s = new_s ; entity_status_updated . lanelet_pose . offset = entity_status . lanelet_pose . offset ; entity_status_updated . lanelet_pose . rpy = entity_status . lanelet_pose . rpy ; entity_status_updated . pose = hdmap_utils -> toMapPose ( entity_status_updated . lanelet_pose ). pose ; entity_status_updated . action_status . twist = twist_new ; entity_status_updated . action_status . accel = accel_new ; return entity_status_updated ; } throw BehaviorTreeRuntimeError ( \"failed to calculate next status calculateEntityStatusUpdated function\" ); } openscenario_msgs :: msg :: EntityStatus PedestrianActionNode :: calculateEntityStatusUpdatedInWorldFrame ( double target_speed ) { double target_accel = ( target_speed - entity_status . action_status . twist . linear . x ) / step_time ; if ( entity_status . action_status . twist . linear . x > target_speed ) { target_accel = boost :: algorithm :: clamp ( target_accel , -5 , 0 ); } else { target_accel = boost :: algorithm :: clamp ( target_accel , 0 , 3 ); } geometry_msgs :: msg :: Accel accel_new ; accel_new = entity_status . action_status . accel ; accel_new . linear . x = target_accel ; geometry_msgs :: msg :: Twist twist_new ; twist_new . linear . x = entity_status . action_status . twist . linear . x + entity_status . action_status . accel . linear . x * step_time ; twist_new . linear . y = entity_status . action_status . twist . linear . y + entity_status . action_status . accel . linear . y * step_time ; twist_new . linear . z = entity_status . action_status . twist . linear . z + entity_status . action_status . accel . linear . z * step_time ; twist_new . angular . x = entity_status . action_status . twist . angular . x + entity_status . action_status . accel . angular . x * step_time ; twist_new . angular . y = entity_status . action_status . twist . angular . y + entity_status . action_status . accel . angular . y * step_time ; twist_new . angular . z = entity_status . action_status . twist . angular . z + entity_status . action_status . accel . angular . z * step_time ; geometry_msgs :: msg :: Pose pose_new ; geometry_msgs :: msg :: Vector3 angular_trans_vec ; angular_trans_vec . z = twist_new . angular . z * step_time ; geometry_msgs :: msg :: Quaternion angular_trans_quat = quaternion_operation :: convertEulerAngleToQuaternion ( angular_trans_vec ); pose_new . orientation = quaternion_operation :: rotation ( entity_status . pose . orientation , angular_trans_quat ); Eigen :: Vector3d trans_vec ; trans_vec ( 0 ) = twist_new . linear . x * step_time ; trans_vec ( 1 ) = twist_new . linear . y * step_time ; trans_vec ( 2 ) = 0 ; Eigen :: Matrix3d rotation_mat = quaternion_operation :: getRotationMatrix ( pose_new . orientation ); trans_vec = rotation_mat * trans_vec ; pose_new . position . x = trans_vec ( 0 ) + entity_status . pose . position . x ; pose_new . position . y = trans_vec ( 1 ) + entity_status . pose . position . y ; pose_new . position . z = trans_vec ( 2 ) + entity_status . pose . position . z ; openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . time = current_time + step_time ; entity_status_updated . pose = pose_new ; entity_status_updated . action_status . twist = twist_new ; entity_status_updated . action_status . accel = accel_new ; entity_status_updated . lanelet_pose_valid = false ; return entity_status_updated ; } } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/pedestrian__action__node_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/pedestrian_action_node.hpp # Namespaces # Name entity_behavior Classes # Name class entity_behavior::PedestrianActionNode Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__PEDESTRIAN__PEDESTRIAN_ACTION_NODE_HPP_ #define SIMULATION_API__BEHAVIOR__PEDESTRIAN__PEDESTRIAN_ACTION_NODE_HPP_ #include <behaviortree_cpp_v3/action_node.h> #include <simulation_api/entity/pedestrian_parameter.hpp> #include <simulation_api/behavior/action_node.hpp> #include <openscenario_msgs/msg/pedestrian_parameters.hpp> #include <string> #include <memory> namespace entity_behavior { class PedestrianActionNode : public ActionNode { public : PedestrianActionNode ( const std :: string & name , const BT :: NodeConfiguration & config ); void getBlackBoardValues (); static BT :: PortsList providedPorts () { BT :: PortsList ports = { BT :: InputPort < openscenario_msgs :: msg :: PedestrianParameters > ( \"pedestrian_parameters\" ) }; BT :: PortsList parent_ports = entity_behavior :: ActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } openscenario_msgs :: msg :: PedestrianParameters pedestrian_parameters ; openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdatedInWorldFrame ( double target_speed ); openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdated ( double target_speed ); }; } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__PEDESTRIAN__PEDESTRIAN_ACTION_NODE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/pedestrian_action_node.hpp"},{"location":"package/simulation_api/markdown/Files/pedestrian__action__node_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorpedestrianpedestrian_action_nodehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/pedestrian_action_node.hpp"},{"location":"package/simulation_api/markdown/Files/pedestrian__action__node_8hpp/#namespaces","text":"Name entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/pedestrian__action__node_8hpp/#classes","text":"Name class entity_behavior::PedestrianActionNode","title":"Classes"},{"location":"package/simulation_api/markdown/Files/pedestrian__action__node_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__PEDESTRIAN__PEDESTRIAN_ACTION_NODE_HPP_ #define SIMULATION_API__BEHAVIOR__PEDESTRIAN__PEDESTRIAN_ACTION_NODE_HPP_ #include <behaviortree_cpp_v3/action_node.h> #include <simulation_api/entity/pedestrian_parameter.hpp> #include <simulation_api/behavior/action_node.hpp> #include <openscenario_msgs/msg/pedestrian_parameters.hpp> #include <string> #include <memory> namespace entity_behavior { class PedestrianActionNode : public ActionNode { public : PedestrianActionNode ( const std :: string & name , const BT :: NodeConfiguration & config ); void getBlackBoardValues (); static BT :: PortsList providedPorts () { BT :: PortsList ports = { BT :: InputPort < openscenario_msgs :: msg :: PedestrianParameters > ( \"pedestrian_parameters\" ) }; BT :: PortsList parent_ports = entity_behavior :: ActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } openscenario_msgs :: msg :: PedestrianParameters pedestrian_parameters ; openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdatedInWorldFrame ( double target_speed ); openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdated ( double target_speed ); }; } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__PEDESTRIAN__PEDESTRIAN_ACTION_NODE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/pedestrian__entity_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/pedestrian_entity.cpp # Namespaces # Name simulation_api::entity simulation_api Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/entity/pedestrian_entity.hpp> #include <simulation_api/entity/exception.hpp> #include <quaternion_operation/quaternion_operation.h> #include <boost/algorithm/clamp.hpp> #include <memory> #include <string> #include <vector> namespace simulation_api { namespace entity { PedestrianEntity :: PedestrianEntity ( std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state , openscenario_msgs :: msg :: PedestrianParameters params ) : EntityBase ( params . name , name , initial_state ), parameters ( params ) { tree_ptr_ = std :: make_shared < entity_behavior :: pedestrian :: BehaviorTree > (); tree_ptr_ -> setValueToBlackBoard ( \"pedestrian_parameters\" , parameters ); } PedestrianEntity :: PedestrianEntity ( std :: string name , openscenario_msgs :: msg :: PedestrianParameters params ) : EntityBase ( params . name , name ), parameters ( params ) { tree_ptr_ = std :: make_shared < entity_behavior :: pedestrian :: BehaviorTree > (); tree_ptr_ -> setValueToBlackBoard ( \"pedestrian_parameters\" , parameters ); } void PedestrianEntity :: requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) { tree_ptr_ -> setRequest ( \"follow_lane\" ); if ( ! status_ ) { return ; } if ( ! status_ -> lanelet_pose_valid ) { return ; } route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose , waypoints ); } void PedestrianEntity :: requestWalkStraight () { tree_ptr_ -> setRequest ( \"walk_straight\" ); } void PedestrianEntity :: requestAcquirePosition ( openscenario_msgs :: msg :: LaneletPose lanelet_pose ) { tree_ptr_ -> setRequest ( \"follow_lane\" ); if ( ! status_ ) { return ; } if ( ! status_ -> lanelet_pose_valid ) { return ; } route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose , lanelet_pose ); } void PedestrianEntity :: cancelRequest () { tree_ptr_ -> setRequest ( \"none\" ); } void PedestrianEntity :: setTargetSpeed ( double target_speed , bool continuous ) { target_speed_ = target_speed ; tree_ptr_ -> setValueToBlackBoard ( \"target_speed\" , target_speed_ ); if ( continuous ) { target_speed_ = boost :: none ; } } void PedestrianEntity :: onUpdate ( double current_time , double step_time ) { if ( ! status_ ) { return ; } tree_ptr_ -> setValueToBlackBoard ( \"other_entity_status\" , other_status_ ); tree_ptr_ -> setValueToBlackBoard ( \"entity_type_list\" , entity_type_list_ ); tree_ptr_ -> setValueToBlackBoard ( \"entity_status\" , status_ . get ()); if ( status_ -> lanelet_pose_valid ) { auto route = route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose ); tree_ptr_ -> setValueToBlackBoard ( \"route_lanelets\" , route ); } else { std :: vector < std :: int64_t > empty = {}; tree_ptr_ -> setValueToBlackBoard ( \"route_lanelets\" , empty ); } action_status_ = tree_ptr_ -> tick ( current_time , step_time ); while ( getCurrentAction () == \"root\" ) { action_status_ = tree_ptr_ -> tick ( current_time , step_time ); } auto status_updated = tree_ptr_ -> getUpdatedStatus (); if ( status_updated . lanelet_pose_valid ) { auto following_lanelets = hdmap_utils_ptr_ -> getFollowingLanelets ( status_updated . lanelet_pose . lanelet_id ); auto l = hdmap_utils_ptr_ -> getLaneletLength ( status_updated . lanelet_pose . lanelet_id ); if ( following_lanelets . size () == 1 && l <= status_updated . lanelet_pose . s ) { stopAtEndOfRoad (); return ; } } if ( target_speed_ ) { if ( status_updated . action_status . twist . linear . x >= target_speed_ . get ()) { target_speed_ = boost :: none ; tree_ptr_ -> setValueToBlackBoard ( \"target_speed\" , target_speed_ ); } } if ( ! status_ ) { linear_jerk_ = 0 ; } else { linear_jerk_ = ( status_updated . action_status . accel . linear . x - status_ -> action_status . accel . linear . x ) / step_time ; } setStatus ( status_updated ); updateStandStillDuration ( step_time ); } } // namespace entity } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/pedestrian_entity.cpp"},{"location":"package/simulation_api/markdown/Files/pedestrian__entity_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcentitypedestrian_entitycpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/pedestrian_entity.cpp"},{"location":"package/simulation_api/markdown/Files/pedestrian__entity_8cpp/#namespaces","text":"Name simulation_api::entity simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/pedestrian__entity_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/entity/pedestrian_entity.hpp> #include <simulation_api/entity/exception.hpp> #include <quaternion_operation/quaternion_operation.h> #include <boost/algorithm/clamp.hpp> #include <memory> #include <string> #include <vector> namespace simulation_api { namespace entity { PedestrianEntity :: PedestrianEntity ( std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state , openscenario_msgs :: msg :: PedestrianParameters params ) : EntityBase ( params . name , name , initial_state ), parameters ( params ) { tree_ptr_ = std :: make_shared < entity_behavior :: pedestrian :: BehaviorTree > (); tree_ptr_ -> setValueToBlackBoard ( \"pedestrian_parameters\" , parameters ); } PedestrianEntity :: PedestrianEntity ( std :: string name , openscenario_msgs :: msg :: PedestrianParameters params ) : EntityBase ( params . name , name ), parameters ( params ) { tree_ptr_ = std :: make_shared < entity_behavior :: pedestrian :: BehaviorTree > (); tree_ptr_ -> setValueToBlackBoard ( \"pedestrian_parameters\" , parameters ); } void PedestrianEntity :: requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) { tree_ptr_ -> setRequest ( \"follow_lane\" ); if ( ! status_ ) { return ; } if ( ! status_ -> lanelet_pose_valid ) { return ; } route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose , waypoints ); } void PedestrianEntity :: requestWalkStraight () { tree_ptr_ -> setRequest ( \"walk_straight\" ); } void PedestrianEntity :: requestAcquirePosition ( openscenario_msgs :: msg :: LaneletPose lanelet_pose ) { tree_ptr_ -> setRequest ( \"follow_lane\" ); if ( ! status_ ) { return ; } if ( ! status_ -> lanelet_pose_valid ) { return ; } route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose , lanelet_pose ); } void PedestrianEntity :: cancelRequest () { tree_ptr_ -> setRequest ( \"none\" ); } void PedestrianEntity :: setTargetSpeed ( double target_speed , bool continuous ) { target_speed_ = target_speed ; tree_ptr_ -> setValueToBlackBoard ( \"target_speed\" , target_speed_ ); if ( continuous ) { target_speed_ = boost :: none ; } } void PedestrianEntity :: onUpdate ( double current_time , double step_time ) { if ( ! status_ ) { return ; } tree_ptr_ -> setValueToBlackBoard ( \"other_entity_status\" , other_status_ ); tree_ptr_ -> setValueToBlackBoard ( \"entity_type_list\" , entity_type_list_ ); tree_ptr_ -> setValueToBlackBoard ( \"entity_status\" , status_ . get ()); if ( status_ -> lanelet_pose_valid ) { auto route = route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose ); tree_ptr_ -> setValueToBlackBoard ( \"route_lanelets\" , route ); } else { std :: vector < std :: int64_t > empty = {}; tree_ptr_ -> setValueToBlackBoard ( \"route_lanelets\" , empty ); } action_status_ = tree_ptr_ -> tick ( current_time , step_time ); while ( getCurrentAction () == \"root\" ) { action_status_ = tree_ptr_ -> tick ( current_time , step_time ); } auto status_updated = tree_ptr_ -> getUpdatedStatus (); if ( status_updated . lanelet_pose_valid ) { auto following_lanelets = hdmap_utils_ptr_ -> getFollowingLanelets ( status_updated . lanelet_pose . lanelet_id ); auto l = hdmap_utils_ptr_ -> getLaneletLength ( status_updated . lanelet_pose . lanelet_id ); if ( following_lanelets . size () == 1 && l <= status_updated . lanelet_pose . s ) { stopAtEndOfRoad (); return ; } } if ( target_speed_ ) { if ( status_updated . action_status . twist . linear . x >= target_speed_ . get ()) { target_speed_ = boost :: none ; tree_ptr_ -> setValueToBlackBoard ( \"target_speed\" , target_speed_ ); } } if ( ! status_ ) { linear_jerk_ = 0 ; } else { linear_jerk_ = ( status_updated . action_status . accel . linear . x - status_ -> action_status . accel . linear . x ) / step_time ; } setStatus ( status_updated ); updateStandStillDuration ( step_time ); } } // namespace entity } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/pedestrian__entity_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/pedestrian_entity.hpp # Namespaces # Name simulation_api::entity simulation_api Classes # Name class simulation_api::entity::PedestrianEntity Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__PEDESTRIAN_ENTITY_HPP_ #define SIMULATION_API__ENTITY__PEDESTRIAN_ENTITY_HPP_ #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/entity/pedestrian_parameter.hpp> #include <simulation_api/behavior/pedestrian/behavior_tree.hpp> #include <simulation_api/behavior/route_planner.hpp> #include <openscenario_msgs/msg/pedestrian_parameters.hpp> // headers in pugixml #include <pugixml.hpp> #include <boost/optional.hpp> #include <memory> #include <vector> #include <string> namespace simulation_api { namespace entity { class PedestrianEntity : public EntityBase { public : PedestrianEntity ( std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state , openscenario_msgs :: msg :: PedestrianParameters parameters ); PedestrianEntity ( std :: string name , openscenario_msgs :: msg :: PedestrianParameters parameters ); const openscenario_msgs :: msg :: PedestrianParameters parameters ; void onUpdate ( double current_time , double step_time ) override ; void requestAcquirePosition ( openscenario_msgs :: msg :: LaneletPose lanelet_pose ); void requestWalkStraight (); // void requestLaneChange(std::int64_t to_lanelet_id); void cancelRequest (); void setHdMapUtils ( std :: shared_ptr < hdmap_utils :: HdMapUtils > ptr ) { hdmap_utils_ptr_ = ptr ; route_planner_ptr_ = std :: make_shared < simulation_api :: RoutePlanner > ( ptr ); tree_ptr_ -> setValueToBlackBoard ( \"hdmap_utils\" , hdmap_utils_ptr_ ); } void setTrafficLightManager ( std :: shared_ptr < simulation_api :: TrafficLightManager > ptr ) { traffic_light_manager_ = ptr ; tree_ptr_ -> setValueToBlackBoard ( \"traffic_light_manager\" , traffic_light_manager_ ); } void setTargetSpeed ( double target_speed , bool continuous ); const openscenario_msgs :: msg :: BoundingBox getBoundingBox () const override { return parameters . bounding_box ; } void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) override ; const std :: string getCurrentAction () const { return tree_ptr_ -> getCurrentAction (); } std :: vector < std :: int64_t > getRouteLanelets ( double horizon = 100 ) { if ( ! status_ ) { return {}; } if ( status_ -> lanelet_pose_valid ) { return {}; } return route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose , horizon ); } private : std :: shared_ptr < entity_behavior :: pedestrian :: BehaviorTree > tree_ptr_ ; BT :: NodeStatus action_status_ ; boost :: optional < double > target_speed_ ; std :: shared_ptr < simulation_api :: RoutePlanner > route_planner_ptr_ ; }; } // namespace entity } // namespace simulation_api #endif // SIMULATION_API__ENTITY__PEDESTRIAN_ENTITY_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/pedestrian_entity.hpp"},{"location":"package/simulation_api/markdown/Files/pedestrian__entity_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apientitypedestrian_entityhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/pedestrian_entity.hpp"},{"location":"package/simulation_api/markdown/Files/pedestrian__entity_8hpp/#namespaces","text":"Name simulation_api::entity simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/pedestrian__entity_8hpp/#classes","text":"Name class simulation_api::entity::PedestrianEntity","title":"Classes"},{"location":"package/simulation_api/markdown/Files/pedestrian__entity_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__PEDESTRIAN_ENTITY_HPP_ #define SIMULATION_API__ENTITY__PEDESTRIAN_ENTITY_HPP_ #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/entity/pedestrian_parameter.hpp> #include <simulation_api/behavior/pedestrian/behavior_tree.hpp> #include <simulation_api/behavior/route_planner.hpp> #include <openscenario_msgs/msg/pedestrian_parameters.hpp> // headers in pugixml #include <pugixml.hpp> #include <boost/optional.hpp> #include <memory> #include <vector> #include <string> namespace simulation_api { namespace entity { class PedestrianEntity : public EntityBase { public : PedestrianEntity ( std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state , openscenario_msgs :: msg :: PedestrianParameters parameters ); PedestrianEntity ( std :: string name , openscenario_msgs :: msg :: PedestrianParameters parameters ); const openscenario_msgs :: msg :: PedestrianParameters parameters ; void onUpdate ( double current_time , double step_time ) override ; void requestAcquirePosition ( openscenario_msgs :: msg :: LaneletPose lanelet_pose ); void requestWalkStraight (); // void requestLaneChange(std::int64_t to_lanelet_id); void cancelRequest (); void setHdMapUtils ( std :: shared_ptr < hdmap_utils :: HdMapUtils > ptr ) { hdmap_utils_ptr_ = ptr ; route_planner_ptr_ = std :: make_shared < simulation_api :: RoutePlanner > ( ptr ); tree_ptr_ -> setValueToBlackBoard ( \"hdmap_utils\" , hdmap_utils_ptr_ ); } void setTrafficLightManager ( std :: shared_ptr < simulation_api :: TrafficLightManager > ptr ) { traffic_light_manager_ = ptr ; tree_ptr_ -> setValueToBlackBoard ( \"traffic_light_manager\" , traffic_light_manager_ ); } void setTargetSpeed ( double target_speed , bool continuous ); const openscenario_msgs :: msg :: BoundingBox getBoundingBox () const override { return parameters . bounding_box ; } void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) override ; const std :: string getCurrentAction () const { return tree_ptr_ -> getCurrentAction (); } std :: vector < std :: int64_t > getRouteLanelets ( double horizon = 100 ) { if ( ! status_ ) { return {}; } if ( status_ -> lanelet_pose_valid ) { return {}; } return route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose , horizon ); } private : std :: shared_ptr < entity_behavior :: pedestrian :: BehaviorTree > tree_ptr_ ; BT :: NodeStatus action_status_ ; boost :: optional < double > target_speed_ ; std :: shared_ptr < simulation_api :: RoutePlanner > route_planner_ptr_ ; }; } // namespace entity } // namespace simulation_api #endif // SIMULATION_API__ENTITY__PEDESTRIAN_ENTITY_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/pedestrian__parameter_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/pedestrian_parameter.hpp # Namespaces # Name simulation_api::entity simulation_api Classes # Name struct simulation_api::entity::PedestrianParameters Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__PEDESTRIAN_PARAMETER_HPP_ #define SIMULATION_API__ENTITY__PEDESTRIAN_PARAMETER_HPP_ // headers in pugixml #include <pugixml.hpp> #include <rclcpp/rclcpp.hpp> #include <geometry_msgs/msg/vector3.hpp> #include <boost/property_tree/ptree.hpp> #include <boost/property_tree/xml_parser.hpp> #include <boost/foreach.hpp> #include <simulation_api/entity/vehicle_parameter.hpp> #include <openscenario_msgs/msg/pedestrian_parameters.hpp> #include <string> #include <sstream> namespace simulation_api { namespace entity { struct PedestrianParameters { explicit PedestrianParameters ( const pugi :: xml_node & xml ) : name ( xml . child ( \"Pedestrian\" ). attribute ( \"name\" ). as_string ()), pedestrian_category ( xml . child ( \"Pedestrian\" ). attribute ( \"pedestrianCategory\" ). as_string ()), bounding_box ( xml . child ( \"Pedestrian\" )) {} PedestrianParameters ( std :: string name , std :: string pedestrian_category , BoundingBox bounding_box ) : name ( name ), pedestrian_category ( pedestrian_category ), bounding_box ( bounding_box ) {} const std :: string name ; const std :: string pedestrian_category ; const BoundingBox bounding_box ; std :: string toXml () const { using boost :: property_tree :: ptree ; ptree pt ; ptree & pedestrian_tree = pt . add ( \"Pedestrian\" , \"\" ); pedestrian_tree . put ( \"<xmlattr>.name\" , name ); pedestrian_tree . put ( \"<xmlattr>.PedestrianCategory\" , pedestrian_category ); ptree & center_tree = pedestrian_tree . add ( \"BoundingBox.Center\" , \"\" ); center_tree . put ( \"<xmlattr>.x\" , bounding_box . center . x ); center_tree . put ( \"<xmlattr>.y\" , bounding_box . center . y ); center_tree . put ( \"<xmlattr>.z\" , bounding_box . center . z ); ptree & dimensions_tree = pedestrian_tree . add ( \"BoundingBox.Dimensions\" , \"\" ); dimensions_tree . put ( \"<xmlattr>.width\" , bounding_box . dimensions . width ); dimensions_tree . put ( \"<xmlattr>.length\" , bounding_box . dimensions . length ); dimensions_tree . put ( \"<xmlattr>.height\" , bounding_box . dimensions . height ); std :: stringstream ss ; boost :: property_tree :: write_xml ( ss , pt ); return ss . str (); } const openscenario_msgs :: msg :: PedestrianParameters toRosMsg () const { openscenario_msgs :: msg :: PedestrianParameters msg ; msg . bounding_box = bounding_box . toRosMsg (); msg . name = name ; msg . pedestrian_category = pedestrian_category ; return msg ; } }; } // namespace entity } // namespace simulation_api #endif // SIMULATION_API__ENTITY__PEDESTRIAN_PARAMETER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/pedestrian_parameter.hpp"},{"location":"package/simulation_api/markdown/Files/pedestrian__parameter_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apientitypedestrian_parameterhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/pedestrian_parameter.hpp"},{"location":"package/simulation_api/markdown/Files/pedestrian__parameter_8hpp/#namespaces","text":"Name simulation_api::entity simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/pedestrian__parameter_8hpp/#classes","text":"Name struct simulation_api::entity::PedestrianParameters","title":"Classes"},{"location":"package/simulation_api/markdown/Files/pedestrian__parameter_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__PEDESTRIAN_PARAMETER_HPP_ #define SIMULATION_API__ENTITY__PEDESTRIAN_PARAMETER_HPP_ // headers in pugixml #include <pugixml.hpp> #include <rclcpp/rclcpp.hpp> #include <geometry_msgs/msg/vector3.hpp> #include <boost/property_tree/ptree.hpp> #include <boost/property_tree/xml_parser.hpp> #include <boost/foreach.hpp> #include <simulation_api/entity/vehicle_parameter.hpp> #include <openscenario_msgs/msg/pedestrian_parameters.hpp> #include <string> #include <sstream> namespace simulation_api { namespace entity { struct PedestrianParameters { explicit PedestrianParameters ( const pugi :: xml_node & xml ) : name ( xml . child ( \"Pedestrian\" ). attribute ( \"name\" ). as_string ()), pedestrian_category ( xml . child ( \"Pedestrian\" ). attribute ( \"pedestrianCategory\" ). as_string ()), bounding_box ( xml . child ( \"Pedestrian\" )) {} PedestrianParameters ( std :: string name , std :: string pedestrian_category , BoundingBox bounding_box ) : name ( name ), pedestrian_category ( pedestrian_category ), bounding_box ( bounding_box ) {} const std :: string name ; const std :: string pedestrian_category ; const BoundingBox bounding_box ; std :: string toXml () const { using boost :: property_tree :: ptree ; ptree pt ; ptree & pedestrian_tree = pt . add ( \"Pedestrian\" , \"\" ); pedestrian_tree . put ( \"<xmlattr>.name\" , name ); pedestrian_tree . put ( \"<xmlattr>.PedestrianCategory\" , pedestrian_category ); ptree & center_tree = pedestrian_tree . add ( \"BoundingBox.Center\" , \"\" ); center_tree . put ( \"<xmlattr>.x\" , bounding_box . center . x ); center_tree . put ( \"<xmlattr>.y\" , bounding_box . center . y ); center_tree . put ( \"<xmlattr>.z\" , bounding_box . center . z ); ptree & dimensions_tree = pedestrian_tree . add ( \"BoundingBox.Dimensions\" , \"\" ); dimensions_tree . put ( \"<xmlattr>.width\" , bounding_box . dimensions . width ); dimensions_tree . put ( \"<xmlattr>.length\" , bounding_box . dimensions . length ); dimensions_tree . put ( \"<xmlattr>.height\" , bounding_box . dimensions . height ); std :: stringstream ss ; boost :: property_tree :: write_xml ( ss , pt ); return ss . str (); } const openscenario_msgs :: msg :: PedestrianParameters toRosMsg () const { openscenario_msgs :: msg :: PedestrianParameters msg ; msg . bounding_box = bounding_box . toRosMsg (); msg . name = name ; msg . pedestrian_category = pedestrian_category ; return msg ; } }; } // namespace entity } // namespace simulation_api #endif // SIMULATION_API__ENTITY__PEDESTRIAN_PARAMETER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/polynomial__solver_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/polynomial_solver.cpp # Namespaces # Name simulation_api::math simulation_api Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/math/polynomial_solver.hpp> #include <vector> #include <cmath> #include <limits> #include <iostream> namespace simulation_api { namespace math { double PolynomialSolver :: cubicFunction ( double a , double b , double c , double d , double t ) const { return a * t * t * t + b * t * t + c * t + d ; } double PolynomialSolver :: quadraticFunction ( double a , double b , double c , double t ) const { return a * t * t + b * t + c ; } std :: vector < double > PolynomialSolver :: solveLinearEquation ( double a , double b , double min_value , double max_value ) const { constexpr double e = std :: numeric_limits < float >:: epsilon (); if ( std :: fabs ( a ) < e ) { if ( std :: fabs ( b ) < e ) { if ( min_value <= 0 && 0 <= max_value ) { return { 0 }; } } return {}; } double ret = - b / a ; if ( min_value <= ret && ret <= max_value ) { return { ret }; } return {}; } std :: vector < double > PolynomialSolver :: solveQuadraticEquation ( double a , double b , double c , double min_value , double max_value ) const { std :: vector < double > candidates , ret ; constexpr double e = std :: numeric_limits < float >:: epsilon (); if ( std :: fabs ( a ) < e ) { return solveLinearEquation ( b , c ); } double root = b * b - 4 * a * c ; if ( std :: fabs ( root ) < e ) { candidates = { - b / ( 2 * a )}; } else if ( root < 0 ) { candidates = {}; } else { candidates = {( - b - std :: sqrt ( root )) / ( 2 * a ), ( - b + std :: sqrt ( root )) / ( 2 * a )}; } for ( const auto candidate : candidates ) { if ( min_value <= candidate && candidate <= max_value ) { ret . emplace_back ( candidate ); } } return ret ; } std :: vector < double > PolynomialSolver :: solveCubicEquation ( double a , double b , double c , double d , double min_value , double max_value ) const { constexpr double e = std :: numeric_limits < float >:: epsilon (); if ( std :: fabs ( a ) < e ) { return solveQuadraticEquation ( b , c , d ); } std :: vector < double > solutions , candidates , ret ; auto result = solveP3 ( solutions , b / a , c / a , d / a ); if ( result == 3 ) { candidates = solutions ; } else if ( result == 2 ) { candidates = { solutions [ 0 ], solutions [ 1 ]}; } else if ( result == 1 ) { candidates = { solutions [ 0 ]}; } for ( const auto candidate : candidates ) { if ( min_value <= candidate && candidate <= max_value ) { ret . emplace_back ( candidate ); } } return ret ; } int PolynomialSolver :: solveP3 ( std :: vector < double > & x , double a , double b , double c ) const { x = std :: vector < double > ( 3 ); const double eps = 1e-14 ; double a2 = a * a ; double q = ( a2 - 3 * b ) / 9 ; double r = ( a * ( 2 * a2 - 9 * b ) + 27 * c ) / 54 ; // equation x^3 + q*x + r = 0 double r2 = r * r ; double q3 = q * q * q ; double A , B ; if ( r2 <= ( q3 + eps )) { //<<-- FIXED! double t = r / sqrt ( q3 ); if ( t < -1 ) { t = -1 ;} if ( t > 1 ) { t = 1 ;} t = acos ( t ); a /= 3 ; q = -2 * sqrt ( q ); x [ 0 ] = q * cos ( t / 3 ) - a ; x [ 1 ] = q * cos (( t + M_PI * 2 ) / 3 ) - a ; x [ 2 ] = q * cos (( t - M_PI * 2 ) / 3 ) - a ; return 3 ; } else { // A =-pow(fabs(r)+sqrt(r2-q3),1./3); A = - root3 ( fabs ( r ) + sqrt ( r2 - q3 )); if ( r < 0 ) { A = - A ;} if ( A == 0 ) { B = 0 ; } else { B = q / A ; } a /= 3 ; x [ 0 ] = ( A + B ) - a ; x [ 1 ] = -0.5 * ( A + B ) - a ; x [ 2 ] = 0.5 * sqrt ( 3. ) * ( A - B ); if ( fabs ( x [ 2 ]) < eps ) { x [ 2 ] = x [ 1 ]; return 2 ; } return 1 ; } return 0 ; } double PolynomialSolver :: _root3 ( double x ) const { double s = 1. ; while ( x < 1. ) { x *= 8. ; s *= 0.5 ; } while ( x > 8. ) { x *= 0.125 ; s *= 2. ; } double r = 1.5 ; r -= 1. / 3. * ( r - x / ( r * r ) ); r -= 1. / 3. * ( r - x / ( r * r ) ); r -= 1. / 3. * ( r - x / ( r * r ) ); r -= 1. / 3. * ( r - x / ( r * r ) ); r -= 1. / 3. * ( r - x / ( r * r ) ); r -= 1. / 3. * ( r - x / ( r * r ) ); return r * s ; } double PolynomialSolver :: root3 ( double x ) const { if ( x > 0 ) { return _root3 ( x );} else if ( x < 0 ) { return - _root3 ( - x );} else { return 0. ; } } } // namespace math } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/polynomial_solver.cpp"},{"location":"package/simulation_api/markdown/Files/polynomial__solver_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmathpolynomial_solvercpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/polynomial_solver.cpp"},{"location":"package/simulation_api/markdown/Files/polynomial__solver_8cpp/#namespaces","text":"Name simulation_api::math simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/polynomial__solver_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/math/polynomial_solver.hpp> #include <vector> #include <cmath> #include <limits> #include <iostream> namespace simulation_api { namespace math { double PolynomialSolver :: cubicFunction ( double a , double b , double c , double d , double t ) const { return a * t * t * t + b * t * t + c * t + d ; } double PolynomialSolver :: quadraticFunction ( double a , double b , double c , double t ) const { return a * t * t + b * t + c ; } std :: vector < double > PolynomialSolver :: solveLinearEquation ( double a , double b , double min_value , double max_value ) const { constexpr double e = std :: numeric_limits < float >:: epsilon (); if ( std :: fabs ( a ) < e ) { if ( std :: fabs ( b ) < e ) { if ( min_value <= 0 && 0 <= max_value ) { return { 0 }; } } return {}; } double ret = - b / a ; if ( min_value <= ret && ret <= max_value ) { return { ret }; } return {}; } std :: vector < double > PolynomialSolver :: solveQuadraticEquation ( double a , double b , double c , double min_value , double max_value ) const { std :: vector < double > candidates , ret ; constexpr double e = std :: numeric_limits < float >:: epsilon (); if ( std :: fabs ( a ) < e ) { return solveLinearEquation ( b , c ); } double root = b * b - 4 * a * c ; if ( std :: fabs ( root ) < e ) { candidates = { - b / ( 2 * a )}; } else if ( root < 0 ) { candidates = {}; } else { candidates = {( - b - std :: sqrt ( root )) / ( 2 * a ), ( - b + std :: sqrt ( root )) / ( 2 * a )}; } for ( const auto candidate : candidates ) { if ( min_value <= candidate && candidate <= max_value ) { ret . emplace_back ( candidate ); } } return ret ; } std :: vector < double > PolynomialSolver :: solveCubicEquation ( double a , double b , double c , double d , double min_value , double max_value ) const { constexpr double e = std :: numeric_limits < float >:: epsilon (); if ( std :: fabs ( a ) < e ) { return solveQuadraticEquation ( b , c , d ); } std :: vector < double > solutions , candidates , ret ; auto result = solveP3 ( solutions , b / a , c / a , d / a ); if ( result == 3 ) { candidates = solutions ; } else if ( result == 2 ) { candidates = { solutions [ 0 ], solutions [ 1 ]}; } else if ( result == 1 ) { candidates = { solutions [ 0 ]}; } for ( const auto candidate : candidates ) { if ( min_value <= candidate && candidate <= max_value ) { ret . emplace_back ( candidate ); } } return ret ; } int PolynomialSolver :: solveP3 ( std :: vector < double > & x , double a , double b , double c ) const { x = std :: vector < double > ( 3 ); const double eps = 1e-14 ; double a2 = a * a ; double q = ( a2 - 3 * b ) / 9 ; double r = ( a * ( 2 * a2 - 9 * b ) + 27 * c ) / 54 ; // equation x^3 + q*x + r = 0 double r2 = r * r ; double q3 = q * q * q ; double A , B ; if ( r2 <= ( q3 + eps )) { //<<-- FIXED! double t = r / sqrt ( q3 ); if ( t < -1 ) { t = -1 ;} if ( t > 1 ) { t = 1 ;} t = acos ( t ); a /= 3 ; q = -2 * sqrt ( q ); x [ 0 ] = q * cos ( t / 3 ) - a ; x [ 1 ] = q * cos (( t + M_PI * 2 ) / 3 ) - a ; x [ 2 ] = q * cos (( t - M_PI * 2 ) / 3 ) - a ; return 3 ; } else { // A =-pow(fabs(r)+sqrt(r2-q3),1./3); A = - root3 ( fabs ( r ) + sqrt ( r2 - q3 )); if ( r < 0 ) { A = - A ;} if ( A == 0 ) { B = 0 ; } else { B = q / A ; } a /= 3 ; x [ 0 ] = ( A + B ) - a ; x [ 1 ] = -0.5 * ( A + B ) - a ; x [ 2 ] = 0.5 * sqrt ( 3. ) * ( A - B ); if ( fabs ( x [ 2 ]) < eps ) { x [ 2 ] = x [ 1 ]; return 2 ; } return 1 ; } return 0 ; } double PolynomialSolver :: _root3 ( double x ) const { double s = 1. ; while ( x < 1. ) { x *= 8. ; s *= 0.5 ; } while ( x > 8. ) { x *= 0.125 ; s *= 2. ; } double r = 1.5 ; r -= 1. / 3. * ( r - x / ( r * r ) ); r -= 1. / 3. * ( r - x / ( r * r ) ); r -= 1. / 3. * ( r - x / ( r * r ) ); r -= 1. / 3. * ( r - x / ( r * r ) ); r -= 1. / 3. * ( r - x / ( r * r ) ); r -= 1. / 3. * ( r - x / ( r * r ) ); return r * s ; } double PolynomialSolver :: root3 ( double x ) const { if ( x > 0 ) { return _root3 ( x );} else if ( x < 0 ) { return - _root3 ( - x );} else { return 0. ; } } } // namespace math } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/polynomial__solver_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/polynomial_solver.hpp # Namespaces # Name simulation_api::math simulation_api Classes # Name class simulation_api::math::PolynomialSolver Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__MATH__POLYNOMIAL_SOLVER_HPP_ #define SIMULATION_API__MATH__POLYNOMIAL_SOLVER_HPP_ #include <vector> namespace simulation_api { namespace math { class PolynomialSolver { public : std :: vector < double > solveLinearEquation ( double a , double b , double min_value = 0 , double max_value = 1 ) const ; std :: vector < double > solveQuadraticEquation ( double a , double b , double c , double min_value = 0 , double max_value = 1 ) const ; std :: vector < double > solveCubicEquation ( double a , double b , double c , double d , double min_value = 0 , double max_value = 1 ) const ; double cubicFunction ( double a , double b , double c , double d , double t ) const ; double quadraticFunction ( double a , double b , double c , double t ) const ; private : int solveP3 ( std :: vector < double > & x , double a , double b , double c ) const ; double _root3 ( double x ) const ; double root3 ( double x ) const ; }; } // namespace math } // namespace simulation_api #endif // SIMULATION_API__MATH__POLYNOMIAL_SOLVER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/polynomial_solver.hpp"},{"location":"package/simulation_api/markdown/Files/polynomial__solver_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apimathpolynomial_solverhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/polynomial_solver.hpp"},{"location":"package/simulation_api/markdown/Files/polynomial__solver_8hpp/#namespaces","text":"Name simulation_api::math simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/polynomial__solver_8hpp/#classes","text":"Name class simulation_api::math::PolynomialSolver","title":"Classes"},{"location":"package/simulation_api/markdown/Files/polynomial__solver_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__MATH__POLYNOMIAL_SOLVER_HPP_ #define SIMULATION_API__MATH__POLYNOMIAL_SOLVER_HPP_ #include <vector> namespace simulation_api { namespace math { class PolynomialSolver { public : std :: vector < double > solveLinearEquation ( double a , double b , double min_value = 0 , double max_value = 1 ) const ; std :: vector < double > solveQuadraticEquation ( double a , double b , double c , double min_value = 0 , double max_value = 1 ) const ; std :: vector < double > solveCubicEquation ( double a , double b , double c , double d , double min_value = 0 , double max_value = 1 ) const ; double cubicFunction ( double a , double b , double c , double d , double t ) const ; double quadraticFunction ( double a , double b , double c , double t ) const ; private : int solveP3 ( std :: vector < double > & x , double a , double b , double c ) const ; double _root3 ( double x ) const ; double root3 ( double x ) const ; }; } // namespace math } // namespace simulation_api #endif // SIMULATION_API__MATH__POLYNOMIAL_SOLVER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/reaction__time__metric_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/reaction_time_metric.cpp # Namespaces # Name metrics Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/metrics/reaction_time_metric.hpp> #include <string> namespace metrics { ReactionTimeMetric :: ReactionTimeMetric ( std :: string target_entity , double maximum_reaction_time , double jerk_upper_threashold , double jerk_lower_threashold , bool check_upper_threashold , bool check_lower_threashold ) : MetricBase ( \"ReactionTime\" ), target_entity ( target_entity ), maximum_reaction_time ( maximum_reaction_time ), jerk_upper_threashold ( jerk_upper_threashold ), jerk_lower_threashold ( jerk_lower_threashold ), check_upper_threashold ( check_upper_threashold ), check_lower_threashold ( check_lower_threashold ) { elapsed_duration_ = 0 ; } bool ReactionTimeMetric :: activateTrigger () { return true ; } void ReactionTimeMetric :: update () { const auto jerk = entity_manager_ptr_ -> getLinearJerk ( target_entity ); if ( ! jerk ) { THROW_METRICS_CALCULATION_ERROR ( \"failed to calculate linear jerk.\" ); } current_linear_jerk_ = jerk . get (); if ( check_lower_threashold && jerk_lower_threashold >= jerk . get ()) { success (); return ; } if ( check_upper_threashold && jerk_upper_threashold <= jerk . get ()) { success (); return ; } if ( elapsed_duration_ > maximum_reaction_time ) { failure ( SPECIFICATION_VIOLATION_ERROR ( \"maximum reaction time is expired.\" )); return ; } elapsed_duration_ = elapsed_duration_ + entity_manager_ptr_ -> getStepTime (); } nlohmann :: json ReactionTimeMetric :: to_json () { nlohmann :: json json = MetricBase :: to_base_json (); if ( getLifecycle () != MetricLifecycle :: INACTIVE ) { json [ \"elapsed_duration\" ] = elapsed_duration_ ; json [ \"current linear jerk\" ] = current_linear_jerk_ ; } return json ; } } // namespace metrics Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/reaction_time_metric.cpp"},{"location":"package/simulation_api/markdown/Files/reaction__time__metric_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmetricsreaction_time_metriccpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/reaction_time_metric.cpp"},{"location":"package/simulation_api/markdown/Files/reaction__time__metric_8cpp/#namespaces","text":"Name metrics","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/reaction__time__metric_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/metrics/reaction_time_metric.hpp> #include <string> namespace metrics { ReactionTimeMetric :: ReactionTimeMetric ( std :: string target_entity , double maximum_reaction_time , double jerk_upper_threashold , double jerk_lower_threashold , bool check_upper_threashold , bool check_lower_threashold ) : MetricBase ( \"ReactionTime\" ), target_entity ( target_entity ), maximum_reaction_time ( maximum_reaction_time ), jerk_upper_threashold ( jerk_upper_threashold ), jerk_lower_threashold ( jerk_lower_threashold ), check_upper_threashold ( check_upper_threashold ), check_lower_threashold ( check_lower_threashold ) { elapsed_duration_ = 0 ; } bool ReactionTimeMetric :: activateTrigger () { return true ; } void ReactionTimeMetric :: update () { const auto jerk = entity_manager_ptr_ -> getLinearJerk ( target_entity ); if ( ! jerk ) { THROW_METRICS_CALCULATION_ERROR ( \"failed to calculate linear jerk.\" ); } current_linear_jerk_ = jerk . get (); if ( check_lower_threashold && jerk_lower_threashold >= jerk . get ()) { success (); return ; } if ( check_upper_threashold && jerk_upper_threashold <= jerk . get ()) { success (); return ; } if ( elapsed_duration_ > maximum_reaction_time ) { failure ( SPECIFICATION_VIOLATION_ERROR ( \"maximum reaction time is expired.\" )); return ; } elapsed_duration_ = elapsed_duration_ + entity_manager_ptr_ -> getStepTime (); } nlohmann :: json ReactionTimeMetric :: to_json () { nlohmann :: json json = MetricBase :: to_base_json (); if ( getLifecycle () != MetricLifecycle :: INACTIVE ) { json [ \"elapsed_duration\" ] = elapsed_duration_ ; json [ \"current linear jerk\" ] = current_linear_jerk_ ; } return json ; } } // namespace metrics Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/reaction__time__metric_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/reaction_time_metric.hpp # Namespaces # Name metrics Classes # Name class metrics::ReactionTimeMetric Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__METRICS__REACTION_TIME_METRIC_HPP_ #define SIMULATION_API__METRICS__REACTION_TIME_METRIC_HPP_ #include <simulation_api/metrics/metric_base.hpp> #include <string> namespace metrics { class ReactionTimeMetric : public MetricBase { public : explicit ReactionTimeMetric ( std :: string target_entity , double maximum_reaction_time , double jerk_upper_threashold , double jerk_lower_threashold , bool check_upper_threashold = true , bool check_lower_threashold = true ); ~ ReactionTimeMetric () override = default ; void update () override ; nlohmann :: json to_json (); bool activateTrigger () override ; const std :: string target_entity ; const double maximum_reaction_time ; const double jerk_upper_threashold ; const double jerk_lower_threashold ; const bool check_upper_threashold ; const bool check_lower_threashold ; private : double elapsed_duration_ ; double current_linear_jerk_ ; }; } // namespace metrics #endif // SIMULATION_API__METRICS__REACTION_TIME_METRIC_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/reaction_time_metric.hpp"},{"location":"package/simulation_api/markdown/Files/reaction__time__metric_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apimetricsreaction_time_metrichpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/reaction_time_metric.hpp"},{"location":"package/simulation_api/markdown/Files/reaction__time__metric_8hpp/#namespaces","text":"Name metrics","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/reaction__time__metric_8hpp/#classes","text":"Name class metrics::ReactionTimeMetric","title":"Classes"},{"location":"package/simulation_api/markdown/Files/reaction__time__metric_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__METRICS__REACTION_TIME_METRIC_HPP_ #define SIMULATION_API__METRICS__REACTION_TIME_METRIC_HPP_ #include <simulation_api/metrics/metric_base.hpp> #include <string> namespace metrics { class ReactionTimeMetric : public MetricBase { public : explicit ReactionTimeMetric ( std :: string target_entity , double maximum_reaction_time , double jerk_upper_threashold , double jerk_lower_threashold , bool check_upper_threashold = true , bool check_lower_threashold = true ); ~ ReactionTimeMetric () override = default ; void update () override ; nlohmann :: json to_json (); bool activateTrigger () override ; const std :: string target_entity ; const double maximum_reaction_time ; const double jerk_upper_threashold ; const double jerk_lower_threashold ; const bool check_upper_threashold ; const bool check_lower_threashold ; private : double elapsed_duration_ ; double current_linear_jerk_ ; }; } // namespace metrics #endif // SIMULATION_API__METRICS__REACTION_TIME_METRIC_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/route__planner_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/route_planner.cpp # Namespaces # Name simulation_api Source code # // Copyright 2015-2021 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/route_planner.hpp> #include <memory> #include <vector> #include <queue> namespace simulation_api { RoutePlanner :: RoutePlanner ( std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ptr ) { hdmap_utils_ptr_ = hdmap_utils_ptr ; } std :: vector < std :: int64_t > RoutePlanner :: getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , std :: vector < openscenario_msgs :: msg :: LaneletPose > waypoints , double horizon ) { waypoint_queue_ = {}; if ( waypoints . empty ()) { return getRouteLanelets ( entity_lanelet_pose , horizon ); } for ( const auto & waypoint : waypoints ) { waypoint_queue_ . push ( waypoint ); } return getRouteLanelets ( entity_lanelet_pose , waypoint_queue_ . front (), horizon ); } std :: vector < std :: int64_t > RoutePlanner :: getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , double horizon ) { if ( ! whole_route_ ) { return hdmap_utils_ptr_ -> getFollowingLanelets ( entity_lanelet_pose . lanelet_id , horizon , true ); } if ( ! waypoint_queue_ . empty ()) { if ( waypoint_queue_ . front (). lanelet_id == entity_lanelet_pose . lanelet_id ) { cancelGoal ( entity_lanelet_pose ); } } else { if ( hdmap_utils_ptr_ -> isInRoute ( entity_lanelet_pose . lanelet_id , whole_route_ . get () )) { return hdmap_utils_ptr_ -> getFollowingLanelets ( entity_lanelet_pose . lanelet_id , whole_route_ . get (), horizon , true ); } } cancelGoal ( entity_lanelet_pose ); if ( waypoint_queue_ . empty ()) { return hdmap_utils_ptr_ -> getFollowingLanelets ( entity_lanelet_pose . lanelet_id , horizon , true ); } return getRouteLanelets ( entity_lanelet_pose , waypoint_queue_ . front (), horizon ); } std :: vector < std :: int64_t > RoutePlanner :: getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , openscenario_msgs :: msg :: LaneletPose target_lanelet_pose , double horizon ) { plan ( entity_lanelet_pose , target_lanelet_pose ); if ( ! whole_route_ ) { return hdmap_utils_ptr_ -> getFollowingLanelets ( entity_lanelet_pose . lanelet_id , horizon , true ); } return hdmap_utils_ptr_ -> getFollowingLanelets ( entity_lanelet_pose . lanelet_id , whole_route_ . get (), horizon , true ); } void RoutePlanner :: cancelGoal () { whole_route_ = boost :: none ; } void RoutePlanner :: cancelGoal ( const openscenario_msgs :: msg :: LaneletPose & entity_lanelet_pose ) { while ( true ) { if ( waypoint_queue_ . empty ()) { cancelGoal (); break ; } if ( waypoint_queue_ . front (). lanelet_id == entity_lanelet_pose . lanelet_id ) { waypoint_queue_ . pop (); continue ; } else { break ; } } } void RoutePlanner :: plan ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , openscenario_msgs :: msg :: LaneletPose target_lanelet_pose ) { if ( target_lanelet_pose . lanelet_id == entity_lanelet_pose . lanelet_id && target_lanelet_pose . s <= entity_lanelet_pose . s ) { cancelGoal ( entity_lanelet_pose ); if ( waypoint_queue_ . empty ()) { return ; } } if ( ! whole_route_ ) { whole_route_ = hdmap_utils_ptr_ -> getRoute ( entity_lanelet_pose . lanelet_id , target_lanelet_pose . lanelet_id ); return ; } if ( hdmap_utils_ptr_ -> isInRoute ( entity_lanelet_pose . lanelet_id , whole_route_ . get () )) { return ; } else { whole_route_ = hdmap_utils_ptr_ -> getRoute ( entity_lanelet_pose . lanelet_id , target_lanelet_pose . lanelet_id ); return ; } } } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/route_planner.cpp"},{"location":"package/simulation_api/markdown/Files/route__planner_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorroute_plannercpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/route_planner.cpp"},{"location":"package/simulation_api/markdown/Files/route__planner_8cpp/#namespaces","text":"Name simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/route__planner_8cpp/#source-code","text":"// Copyright 2015-2021 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/route_planner.hpp> #include <memory> #include <vector> #include <queue> namespace simulation_api { RoutePlanner :: RoutePlanner ( std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ptr ) { hdmap_utils_ptr_ = hdmap_utils_ptr ; } std :: vector < std :: int64_t > RoutePlanner :: getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , std :: vector < openscenario_msgs :: msg :: LaneletPose > waypoints , double horizon ) { waypoint_queue_ = {}; if ( waypoints . empty ()) { return getRouteLanelets ( entity_lanelet_pose , horizon ); } for ( const auto & waypoint : waypoints ) { waypoint_queue_ . push ( waypoint ); } return getRouteLanelets ( entity_lanelet_pose , waypoint_queue_ . front (), horizon ); } std :: vector < std :: int64_t > RoutePlanner :: getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , double horizon ) { if ( ! whole_route_ ) { return hdmap_utils_ptr_ -> getFollowingLanelets ( entity_lanelet_pose . lanelet_id , horizon , true ); } if ( ! waypoint_queue_ . empty ()) { if ( waypoint_queue_ . front (). lanelet_id == entity_lanelet_pose . lanelet_id ) { cancelGoal ( entity_lanelet_pose ); } } else { if ( hdmap_utils_ptr_ -> isInRoute ( entity_lanelet_pose . lanelet_id , whole_route_ . get () )) { return hdmap_utils_ptr_ -> getFollowingLanelets ( entity_lanelet_pose . lanelet_id , whole_route_ . get (), horizon , true ); } } cancelGoal ( entity_lanelet_pose ); if ( waypoint_queue_ . empty ()) { return hdmap_utils_ptr_ -> getFollowingLanelets ( entity_lanelet_pose . lanelet_id , horizon , true ); } return getRouteLanelets ( entity_lanelet_pose , waypoint_queue_ . front (), horizon ); } std :: vector < std :: int64_t > RoutePlanner :: getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , openscenario_msgs :: msg :: LaneletPose target_lanelet_pose , double horizon ) { plan ( entity_lanelet_pose , target_lanelet_pose ); if ( ! whole_route_ ) { return hdmap_utils_ptr_ -> getFollowingLanelets ( entity_lanelet_pose . lanelet_id , horizon , true ); } return hdmap_utils_ptr_ -> getFollowingLanelets ( entity_lanelet_pose . lanelet_id , whole_route_ . get (), horizon , true ); } void RoutePlanner :: cancelGoal () { whole_route_ = boost :: none ; } void RoutePlanner :: cancelGoal ( const openscenario_msgs :: msg :: LaneletPose & entity_lanelet_pose ) { while ( true ) { if ( waypoint_queue_ . empty ()) { cancelGoal (); break ; } if ( waypoint_queue_ . front (). lanelet_id == entity_lanelet_pose . lanelet_id ) { waypoint_queue_ . pop (); continue ; } else { break ; } } } void RoutePlanner :: plan ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , openscenario_msgs :: msg :: LaneletPose target_lanelet_pose ) { if ( target_lanelet_pose . lanelet_id == entity_lanelet_pose . lanelet_id && target_lanelet_pose . s <= entity_lanelet_pose . s ) { cancelGoal ( entity_lanelet_pose ); if ( waypoint_queue_ . empty ()) { return ; } } if ( ! whole_route_ ) { whole_route_ = hdmap_utils_ptr_ -> getRoute ( entity_lanelet_pose . lanelet_id , target_lanelet_pose . lanelet_id ); return ; } if ( hdmap_utils_ptr_ -> isInRoute ( entity_lanelet_pose . lanelet_id , whole_route_ . get () )) { return ; } else { whole_route_ = hdmap_utils_ptr_ -> getRoute ( entity_lanelet_pose . lanelet_id , target_lanelet_pose . lanelet_id ); return ; } } } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/route__planner_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/route_planner.hpp # Namespaces # Name simulation_api Classes # Name class simulation_api::RoutePlanner Source code # // Copyright 2015-2021 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__ROUTE_PLANNER_HPP_ #define SIMULATION_API__BEHAVIOR__ROUTE_PLANNER_HPP_ #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <memory> #include <vector> #include <queue> namespace simulation_api { class RoutePlanner { public : explicit RoutePlanner ( std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ptr ); std :: vector < std :: int64_t > getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , std :: vector < openscenario_msgs :: msg :: LaneletPose > waypoints , double horizon = 100 ); std :: vector < std :: int64_t > getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , openscenario_msgs :: msg :: LaneletPose target_lanelet_pose , double horizon = 100 ); std :: vector < std :: int64_t > getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , double horizon = 100 ); void cancelGoal (); private : void cancelGoal ( const openscenario_msgs :: msg :: LaneletPose & entity_lanelet_pose ); void plan ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , openscenario_msgs :: msg :: LaneletPose target_lanelet_pose ); boost :: optional < std :: vector < std :: int64_t >> whole_route_ ; std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ptr_ ; std :: queue < openscenario_msgs :: msg :: LaneletPose > waypoint_queue_ ; }; } // namespace simulation_api #endif // SIMULATION_API__BEHAVIOR__ROUTE_PLANNER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/route_planner.hpp"},{"location":"package/simulation_api/markdown/Files/route__planner_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorroute_plannerhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/route_planner.hpp"},{"location":"package/simulation_api/markdown/Files/route__planner_8hpp/#namespaces","text":"Name simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/route__planner_8hpp/#classes","text":"Name class simulation_api::RoutePlanner","title":"Classes"},{"location":"package/simulation_api/markdown/Files/route__planner_8hpp/#source-code","text":"// Copyright 2015-2021 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__ROUTE_PLANNER_HPP_ #define SIMULATION_API__BEHAVIOR__ROUTE_PLANNER_HPP_ #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <memory> #include <vector> #include <queue> namespace simulation_api { class RoutePlanner { public : explicit RoutePlanner ( std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ptr ); std :: vector < std :: int64_t > getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , std :: vector < openscenario_msgs :: msg :: LaneletPose > waypoints , double horizon = 100 ); std :: vector < std :: int64_t > getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , openscenario_msgs :: msg :: LaneletPose target_lanelet_pose , double horizon = 100 ); std :: vector < std :: int64_t > getRouteLanelets ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , double horizon = 100 ); void cancelGoal (); private : void cancelGoal ( const openscenario_msgs :: msg :: LaneletPose & entity_lanelet_pose ); void plan ( openscenario_msgs :: msg :: LaneletPose entity_lanelet_pose , openscenario_msgs :: msg :: LaneletPose target_lanelet_pose ); boost :: optional < std :: vector < std :: int64_t >> whole_route_ ; std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ptr_ ; std :: queue < openscenario_msgs :: msg :: LaneletPose > waypoint_queue_ ; }; } // namespace simulation_api #endif // SIMULATION_API__BEHAVIOR__ROUTE_PLANNER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/scenario__runner__moc__node_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc/scenario_runner_moc_node.cpp # Classes # Name class ScenarioRunnerMoc Functions # Name int main (int argc, char * argv[]) Functions Documentation # function main # int main ( int argc , char * argv [] ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/api/api.hpp> #include <simulation_api/metrics/metrics.hpp> #include <quaternion_operation/quaternion_operation.h> #include <ament_index_cpp/get_package_share_directory.hpp> #include <rclcpp/rclcpp.hpp> // headers in STL #include <memory> #include <vector> #include <utility> #include <string> // headers in pugixml #include \"pugixml.hpp\" class ScenarioRunnerMoc : public rclcpp :: Node { public : explicit ScenarioRunnerMoc ( const rclcpp :: NodeOptions & option ) : Node ( \"scenario_runner\" , option ), api_ ( this , __FILE__ , ament_index_cpp :: get_package_share_directory ( \"kashiwanoha_map\" ) + \"/map/lanelet2_map.osm\" ) { api_ . setVerbose ( true ); api_ . initialize ( 1.0 , 0.05 ); pugi :: xml_document catalog_xml_doc ; catalog_xml_doc . load_string ( catalog_xml . c_str ()); auto vehicle_params = simulation_api :: entity :: VehicleParameters ( catalog_xml_doc ). toRosMsg (); vehicle_params . name = \"ego\" ; api_ . spawn ( false , \"ego\" , vehicle_params ); api_ . setEntityStatus ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 120545 , 0 ), simulation_api :: helper :: constructActionStatus ( 10 )); api_ . setTargetSpeed ( \"ego\" , 15 , true ); pugi :: xml_document pedestrian_xml_doc ; pedestrian_xml_doc . load_string ( pedestrian_xml . c_str ()); const auto pedestrian_params = simulation_api :: entity :: PedestrianParameters ( pedestrian_xml_doc ). toRosMsg (); api_ . spawn ( false , \"tom\" , pedestrian_params ); api_ . setEntityStatus ( \"tom\" , \"ego\" , simulation_api :: helper :: constructPose ( 10 , 3 , 0 , 0 , 0 , -1.57 ), simulation_api :: helper :: constructActionStatus ()); api_ . requestWalkStraight ( \"tom\" ); api_ . setTargetSpeed ( \"tom\" , 3 , true ); api_ . spawn ( false , \"bob\" , pedestrian_params , simulation_api :: helper :: constructLaneletPose ( 34378 , 0.0 ), simulation_api :: helper :: constructActionStatus ( 1 )); api_ . setTargetSpeed ( \"bob\" , 1 , true ); vehicle_params . name = \"npc1\" ; api_ . spawn ( false , \"npc1\" , vehicle_params , simulation_api :: helper :: constructLaneletPose ( 34579 , 20.0 ), simulation_api :: helper :: constructActionStatus ( 5 )); api_ . setTargetSpeed ( \"npc1\" , 5 , true ); lanechange_excuted_ = false ; vehicle_params . name = \"npc2\" ; api_ . spawn ( false , \"npc2\" , vehicle_params , simulation_api :: helper :: constructLaneletPose ( 34606 , 20.0 ), simulation_api :: helper :: constructActionStatus ( 5 )); api_ . setTargetSpeed ( \"npc2\" , 0 , true ); api_ . requestAssignRoute ( \"ego\" , std :: vector < openscenario_msgs :: msg :: LaneletPose > { simulation_api :: helper :: constructLaneletPose ( 34675 , 0.0 ), simulation_api :: helper :: constructLaneletPose ( 34690 , 0.0 ) }); api_ . requestAcquirePosition ( \"npc1\" , simulation_api :: helper :: constructLaneletPose ( 34675 , 0.0 ) ); api_ . spawn ( false , \"npc3\" , vehicle_params ); api_ . setEntityStatus ( \"npc3\" , simulation_api :: helper :: constructLaneletPose ( 34468 , 0 ), simulation_api :: helper :: constructActionStatus ( 10 )); /* api_.addMetric<metrics::TraveledDistanceMetric>(\"ego_traveled_distance\", \"ego\"); api_.addMetric<metrics::MomentaryStopMetric>( \"ego_momentary_stop0\", \"ego\", -10, 10, 34805, metrics::MomentaryStopMetric::StopTargetLaneletType::STOP_LINE, 30, 1, 0.05); api_.addMetric<metrics::MomentaryStopMetric>( \"ego_momentary_stop1\", \"ego\", -10, 10, 120635, metrics::MomentaryStopMetric::StopTargetLaneletType::STOP_LINE, 30, 1, 0.05); api_.addMetric<metrics::MomentaryStopMetric>( \"ego_momentary_stop_crosswalk\", \"ego\", -10, 10, 34378, metrics::MomentaryStopMetric::StopTargetLaneletType::CROSSWALK, 30, 1, 0.05); */ std :: vector < std :: pair < double , simulation_api :: TrafficLightColor >> phase ; phase = { { 10 , simulation_api :: TrafficLightColor :: GREEN }, { 10 , simulation_api :: TrafficLightColor :: YELLOW }, { 10 , simulation_api :: TrafficLightColor :: RED } }; api_ . setTrafficLightColorPhase ( 34802 , phase ); using namespace std :: chrono_literals ; update_timer_ = this -> create_wall_timer ( 50 ms , std :: bind ( & ScenarioRunnerMoc :: update , this )); } private : void update () { if ( api_ . getCurrentTime () >= 4 && api_ . entityExists ( \"tom\" )) { api_ . despawn ( \"tom\" ); } /* if (api_.getLinearJerk(\"ego\")) { std::cout << \"ego linear jerk :\" << api_.getLinearJerk(\"ego\").get() << std::endl; } */ if ( api_ . reachPosition ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 34615 , 10.0 ), 5 )) { api_ . requestAcquirePosition ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 35026 , 0.0 ) ); api_ . setTargetSpeed ( \"npc2\" , 13 , true ); } if ( api_ . reachPosition ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 34579 , 0.0 ), 5 )) { api_ . requestAcquirePosition ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 34675 , 0.0 ) ); api_ . setTargetSpeed ( \"npc2\" , 3 , true ); } if ( api_ . reachPosition ( \"npc2\" , simulation_api :: helper :: constructLaneletPose ( 34513 , 0.0 ), 5 )) { api_ . requestAcquirePosition ( \"npc2\" , simulation_api :: helper :: constructLaneletPose ( 34630 , 0.0 ) ); api_ . setTargetSpeed ( \"npc2\" , 13 , true ); } /* if (api_.checkCollision(\"ego\", \"npc1\")) { std::cout << \"npc1 collision!\" << std::endl; } if (api_.checkCollision(\"ego\", \"npc2\")) { std::cout << \"npc2 collision!\" << std::endl; } */ if ( current_time_ > 10.0 && api_ . entityExists ( \"bob\" )) { api_ . despawn ( \"bob\" ); } api_ . updateFrame (); current_time_ = current_time_ + 0.05 ; } bool lanechange_excuted_ ; bool target_speed_setted_ ; double current_time_ ; int port_ ; scenario_simulator :: API api_ ; rclcpp :: TimerBase :: SharedPtr update_timer_ ; std :: string catalog_xml = R \" ( <Vehicle name= 'vehicle.volkswagen.t2' vehicleCategory='car'> <ParameterDeclarations/> <Performance maxSpeed='69.444' maxAcceleration='200' maxDeceleration='10.0'/> <BoundingBox> <Center x='1.5' y='0.0' z='0.9'/> <Dimensions width='2.1' length='4.5' height='1.8'/> </BoundingBox> <Axles> <FrontAxle maxSteering='0.5' wheelDiameter='0.6' trackWidth='1.8' positionX='3.1' positionZ='0.3'/> <RearAxle maxSteering='0.0' wheelDiameter='0.6' trackWidth='1.8' positionX='0.0' positionZ='0.3'/> </Axles> <Properties> <Property name='type' value='ego_vehicle'/> </Properties> </Vehicle> ) \" ; std :: string pedestrian_xml = R \" ( <Pedestrian model='bob' mass='0.0' name='Bob' pedestrianCategory='pedestrian'> <BoundingBox> <Center x='0.0' y='0.0' z='0.5'/> <Dimensions width='1.0' length='1.0' height='2.0'/> </BoundingBox> <Properties/> </Pedestrian> ) \" ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: NodeOptions options ; auto component = std :: make_shared < ScenarioRunnerMoc > ( options ); rclcpp :: spin ( component ); rclcpp :: shutdown (); return 0 ; } Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc/scenario_runner_moc_node.cpp"},{"location":"package/simulation_api/markdown/Files/scenario__runner__moc__node_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmocscenario_runner_moc_nodecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/moc/scenario_runner_moc_node.cpp"},{"location":"package/simulation_api/markdown/Files/scenario__runner__moc__node_8cpp/#classes","text":"Name class ScenarioRunnerMoc","title":"Classes"},{"location":"package/simulation_api/markdown/Files/scenario__runner__moc__node_8cpp/#functions","text":"Name int main (int argc, char * argv[])","title":"Functions"},{"location":"package/simulation_api/markdown/Files/scenario__runner__moc__node_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/simulation_api/markdown/Files/scenario__runner__moc__node_8cpp/#function-main","text":"int main ( int argc , char * argv [] )","title":"function main"},{"location":"package/simulation_api/markdown/Files/scenario__runner__moc__node_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/api/api.hpp> #include <simulation_api/metrics/metrics.hpp> #include <quaternion_operation/quaternion_operation.h> #include <ament_index_cpp/get_package_share_directory.hpp> #include <rclcpp/rclcpp.hpp> // headers in STL #include <memory> #include <vector> #include <utility> #include <string> // headers in pugixml #include \"pugixml.hpp\" class ScenarioRunnerMoc : public rclcpp :: Node { public : explicit ScenarioRunnerMoc ( const rclcpp :: NodeOptions & option ) : Node ( \"scenario_runner\" , option ), api_ ( this , __FILE__ , ament_index_cpp :: get_package_share_directory ( \"kashiwanoha_map\" ) + \"/map/lanelet2_map.osm\" ) { api_ . setVerbose ( true ); api_ . initialize ( 1.0 , 0.05 ); pugi :: xml_document catalog_xml_doc ; catalog_xml_doc . load_string ( catalog_xml . c_str ()); auto vehicle_params = simulation_api :: entity :: VehicleParameters ( catalog_xml_doc ). toRosMsg (); vehicle_params . name = \"ego\" ; api_ . spawn ( false , \"ego\" , vehicle_params ); api_ . setEntityStatus ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 120545 , 0 ), simulation_api :: helper :: constructActionStatus ( 10 )); api_ . setTargetSpeed ( \"ego\" , 15 , true ); pugi :: xml_document pedestrian_xml_doc ; pedestrian_xml_doc . load_string ( pedestrian_xml . c_str ()); const auto pedestrian_params = simulation_api :: entity :: PedestrianParameters ( pedestrian_xml_doc ). toRosMsg (); api_ . spawn ( false , \"tom\" , pedestrian_params ); api_ . setEntityStatus ( \"tom\" , \"ego\" , simulation_api :: helper :: constructPose ( 10 , 3 , 0 , 0 , 0 , -1.57 ), simulation_api :: helper :: constructActionStatus ()); api_ . requestWalkStraight ( \"tom\" ); api_ . setTargetSpeed ( \"tom\" , 3 , true ); api_ . spawn ( false , \"bob\" , pedestrian_params , simulation_api :: helper :: constructLaneletPose ( 34378 , 0.0 ), simulation_api :: helper :: constructActionStatus ( 1 )); api_ . setTargetSpeed ( \"bob\" , 1 , true ); vehicle_params . name = \"npc1\" ; api_ . spawn ( false , \"npc1\" , vehicle_params , simulation_api :: helper :: constructLaneletPose ( 34579 , 20.0 ), simulation_api :: helper :: constructActionStatus ( 5 )); api_ . setTargetSpeed ( \"npc1\" , 5 , true ); lanechange_excuted_ = false ; vehicle_params . name = \"npc2\" ; api_ . spawn ( false , \"npc2\" , vehicle_params , simulation_api :: helper :: constructLaneletPose ( 34606 , 20.0 ), simulation_api :: helper :: constructActionStatus ( 5 )); api_ . setTargetSpeed ( \"npc2\" , 0 , true ); api_ . requestAssignRoute ( \"ego\" , std :: vector < openscenario_msgs :: msg :: LaneletPose > { simulation_api :: helper :: constructLaneletPose ( 34675 , 0.0 ), simulation_api :: helper :: constructLaneletPose ( 34690 , 0.0 ) }); api_ . requestAcquirePosition ( \"npc1\" , simulation_api :: helper :: constructLaneletPose ( 34675 , 0.0 ) ); api_ . spawn ( false , \"npc3\" , vehicle_params ); api_ . setEntityStatus ( \"npc3\" , simulation_api :: helper :: constructLaneletPose ( 34468 , 0 ), simulation_api :: helper :: constructActionStatus ( 10 )); /* api_.addMetric<metrics::TraveledDistanceMetric>(\"ego_traveled_distance\", \"ego\"); api_.addMetric<metrics::MomentaryStopMetric>( \"ego_momentary_stop0\", \"ego\", -10, 10, 34805, metrics::MomentaryStopMetric::StopTargetLaneletType::STOP_LINE, 30, 1, 0.05); api_.addMetric<metrics::MomentaryStopMetric>( \"ego_momentary_stop1\", \"ego\", -10, 10, 120635, metrics::MomentaryStopMetric::StopTargetLaneletType::STOP_LINE, 30, 1, 0.05); api_.addMetric<metrics::MomentaryStopMetric>( \"ego_momentary_stop_crosswalk\", \"ego\", -10, 10, 34378, metrics::MomentaryStopMetric::StopTargetLaneletType::CROSSWALK, 30, 1, 0.05); */ std :: vector < std :: pair < double , simulation_api :: TrafficLightColor >> phase ; phase = { { 10 , simulation_api :: TrafficLightColor :: GREEN }, { 10 , simulation_api :: TrafficLightColor :: YELLOW }, { 10 , simulation_api :: TrafficLightColor :: RED } }; api_ . setTrafficLightColorPhase ( 34802 , phase ); using namespace std :: chrono_literals ; update_timer_ = this -> create_wall_timer ( 50 ms , std :: bind ( & ScenarioRunnerMoc :: update , this )); } private : void update () { if ( api_ . getCurrentTime () >= 4 && api_ . entityExists ( \"tom\" )) { api_ . despawn ( \"tom\" ); } /* if (api_.getLinearJerk(\"ego\")) { std::cout << \"ego linear jerk :\" << api_.getLinearJerk(\"ego\").get() << std::endl; } */ if ( api_ . reachPosition ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 34615 , 10.0 ), 5 )) { api_ . requestAcquirePosition ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 35026 , 0.0 ) ); api_ . setTargetSpeed ( \"npc2\" , 13 , true ); } if ( api_ . reachPosition ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 34579 , 0.0 ), 5 )) { api_ . requestAcquirePosition ( \"ego\" , simulation_api :: helper :: constructLaneletPose ( 34675 , 0.0 ) ); api_ . setTargetSpeed ( \"npc2\" , 3 , true ); } if ( api_ . reachPosition ( \"npc2\" , simulation_api :: helper :: constructLaneletPose ( 34513 , 0.0 ), 5 )) { api_ . requestAcquirePosition ( \"npc2\" , simulation_api :: helper :: constructLaneletPose ( 34630 , 0.0 ) ); api_ . setTargetSpeed ( \"npc2\" , 13 , true ); } /* if (api_.checkCollision(\"ego\", \"npc1\")) { std::cout << \"npc1 collision!\" << std::endl; } if (api_.checkCollision(\"ego\", \"npc2\")) { std::cout << \"npc2 collision!\" << std::endl; } */ if ( current_time_ > 10.0 && api_ . entityExists ( \"bob\" )) { api_ . despawn ( \"bob\" ); } api_ . updateFrame (); current_time_ = current_time_ + 0.05 ; } bool lanechange_excuted_ ; bool target_speed_setted_ ; double current_time_ ; int port_ ; scenario_simulator :: API api_ ; rclcpp :: TimerBase :: SharedPtr update_timer_ ; std :: string catalog_xml = R \" ( <Vehicle name= 'vehicle.volkswagen.t2' vehicleCategory='car'> <ParameterDeclarations/> <Performance maxSpeed='69.444' maxAcceleration='200' maxDeceleration='10.0'/> <BoundingBox> <Center x='1.5' y='0.0' z='0.9'/> <Dimensions width='2.1' length='4.5' height='1.8'/> </BoundingBox> <Axles> <FrontAxle maxSteering='0.5' wheelDiameter='0.6' trackWidth='1.8' positionX='3.1' positionZ='0.3'/> <RearAxle maxSteering='0.0' wheelDiameter='0.6' trackWidth='1.8' positionX='0.0' positionZ='0.3'/> </Axles> <Properties> <Property name='type' value='ego_vehicle'/> </Properties> </Vehicle> ) \" ; std :: string pedestrian_xml = R \" ( <Pedestrian model='bob' mass='0.0' name='Bob' pedestrianCategory='pedestrian'> <BoundingBox> <Center x='0.0' y='0.0' z='0.5'/> <Dimensions width='1.0' length='1.0' height='2.0'/> </BoundingBox> <Properties/> </Pedestrian> ) \" ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: NodeOptions options ; auto component = std :: make_shared < ScenarioRunnerMoc > ( options ); rclcpp :: spin ( component ); rclcpp :: shutdown (); return 0 ; } Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/sim__model__ideal_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_ideal.cpp # Source code # // Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/vehicle_model/sim_model_ideal.hpp> SimModelIdealTwist :: SimModelIdealTwist () : SimModelInterface ( 3 /* dim x */ , 2 /* dim u */ ) {} double SimModelIdealTwist :: getX () { return state_ ( IDX :: X );} double SimModelIdealTwist :: getY () { return state_ ( IDX :: Y );} double SimModelIdealTwist :: getYaw () { return state_ ( IDX :: YAW );} double SimModelIdealTwist :: getVx () { return input_ ( IDX_U :: VX_DES );} double SimModelIdealTwist :: getWz () { return input_ ( IDX_U :: WZ_DES );} double SimModelIdealTwist :: getSteer () { return 0.0 ;} void SimModelIdealTwist :: update ( const double & dt ) { updateRungeKutta ( dt , input_ );} Eigen :: VectorXd SimModelIdealTwist :: calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) { const double yaw = state ( IDX :: YAW ); const double vx = input ( IDX_U :: VX_DES ); const double wz = input ( IDX_U :: WZ_DES ); Eigen :: VectorXd d_state = Eigen :: VectorXd :: Zero ( dim_x_ ); d_state ( IDX :: X ) = vx * cos ( yaw ); d_state ( IDX :: Y ) = vx * sin ( yaw ); d_state ( IDX :: YAW ) = wz ; return d_state ; } SimModelIdealSteer :: SimModelIdealSteer ( double wheelbase ) : SimModelInterface ( 3 /* dim x */ , 2 /* dim u */ ), wheelbase_ ( wheelbase ) {} double SimModelIdealSteer :: getX () { return state_ ( IDX :: X );} double SimModelIdealSteer :: getY () { return state_ ( IDX :: Y );} double SimModelIdealSteer :: getYaw () { return state_ ( IDX :: YAW );} double SimModelIdealSteer :: getVx () { return input_ ( IDX_U :: VX_DES );} double SimModelIdealSteer :: getWz () { return input_ ( IDX_U :: VX_DES ) * std :: tan ( input_ ( IDX_U :: STEER_DES )) / wheelbase_ ; } double SimModelIdealSteer :: getSteer () { return input_ ( IDX_U :: STEER_DES );} void SimModelIdealSteer :: update ( const double & dt ) { updateRungeKutta ( dt , input_ );} Eigen :: VectorXd SimModelIdealSteer :: calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) { const double yaw = state ( IDX :: YAW ); const double vx = input ( IDX_U :: VX_DES ); const double steer = input ( IDX_U :: STEER_DES ); Eigen :: VectorXd d_state = Eigen :: VectorXd :: Zero ( dim_x_ ); d_state ( IDX :: X ) = vx * cos ( yaw ); d_state ( IDX :: Y ) = vx * sin ( yaw ); d_state ( IDX :: YAW ) = vx * std :: tan ( steer ) / wheelbase_ ; return d_state ; } SimModelIdealAccel :: SimModelIdealAccel ( double wheelbase ) : SimModelInterface ( 4 /* dim x */ , 2 /* dim u */ ), wheelbase_ ( wheelbase ) {} double SimModelIdealAccel :: getX () { return state_ ( IDX :: X );} double SimModelIdealAccel :: getY () { return state_ ( IDX :: Y );} double SimModelIdealAccel :: getYaw () { return state_ ( IDX :: YAW );} double SimModelIdealAccel :: getVx () { return state_ ( IDX :: VX );} double SimModelIdealAccel :: getWz () { return state_ ( IDX :: VX ) * std :: tan ( input_ ( IDX_U :: STEER_DES )) / wheelbase_ ; } double SimModelIdealAccel :: getSteer () { return input_ ( IDX_U :: STEER_DES );} void SimModelIdealAccel :: update ( const double & dt ) { updateRungeKutta ( dt , input_ ); if ( state_ ( IDX :: VX ) < 0 ) { state_ ( IDX :: VX ) = 0 ; } } Eigen :: VectorXd SimModelIdealAccel :: calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) { const double vx = state ( IDX :: VX ); const double yaw = state ( IDX :: YAW ); const double ax = input ( IDX_U :: AX_DES ); const double steer = input ( IDX_U :: STEER_DES ); Eigen :: VectorXd d_state = Eigen :: VectorXd :: Zero ( dim_x_ ); d_state ( IDX :: X ) = vx * cos ( yaw ); d_state ( IDX :: Y ) = vx * sin ( yaw ); d_state ( IDX :: VX ) = ax ; d_state ( IDX :: YAW ) = vx * std :: tan ( steer ) / wheelbase_ ; return d_state ; } Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_ideal.cpp"},{"location":"package/simulation_api/markdown/Files/sim__model__ideal_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcvehicle_modelsim_model_idealcpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_ideal.cpp"},{"location":"package/simulation_api/markdown/Files/sim__model__ideal_8cpp/#source-code","text":"// Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/vehicle_model/sim_model_ideal.hpp> SimModelIdealTwist :: SimModelIdealTwist () : SimModelInterface ( 3 /* dim x */ , 2 /* dim u */ ) {} double SimModelIdealTwist :: getX () { return state_ ( IDX :: X );} double SimModelIdealTwist :: getY () { return state_ ( IDX :: Y );} double SimModelIdealTwist :: getYaw () { return state_ ( IDX :: YAW );} double SimModelIdealTwist :: getVx () { return input_ ( IDX_U :: VX_DES );} double SimModelIdealTwist :: getWz () { return input_ ( IDX_U :: WZ_DES );} double SimModelIdealTwist :: getSteer () { return 0.0 ;} void SimModelIdealTwist :: update ( const double & dt ) { updateRungeKutta ( dt , input_ );} Eigen :: VectorXd SimModelIdealTwist :: calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) { const double yaw = state ( IDX :: YAW ); const double vx = input ( IDX_U :: VX_DES ); const double wz = input ( IDX_U :: WZ_DES ); Eigen :: VectorXd d_state = Eigen :: VectorXd :: Zero ( dim_x_ ); d_state ( IDX :: X ) = vx * cos ( yaw ); d_state ( IDX :: Y ) = vx * sin ( yaw ); d_state ( IDX :: YAW ) = wz ; return d_state ; } SimModelIdealSteer :: SimModelIdealSteer ( double wheelbase ) : SimModelInterface ( 3 /* dim x */ , 2 /* dim u */ ), wheelbase_ ( wheelbase ) {} double SimModelIdealSteer :: getX () { return state_ ( IDX :: X );} double SimModelIdealSteer :: getY () { return state_ ( IDX :: Y );} double SimModelIdealSteer :: getYaw () { return state_ ( IDX :: YAW );} double SimModelIdealSteer :: getVx () { return input_ ( IDX_U :: VX_DES );} double SimModelIdealSteer :: getWz () { return input_ ( IDX_U :: VX_DES ) * std :: tan ( input_ ( IDX_U :: STEER_DES )) / wheelbase_ ; } double SimModelIdealSteer :: getSteer () { return input_ ( IDX_U :: STEER_DES );} void SimModelIdealSteer :: update ( const double & dt ) { updateRungeKutta ( dt , input_ );} Eigen :: VectorXd SimModelIdealSteer :: calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) { const double yaw = state ( IDX :: YAW ); const double vx = input ( IDX_U :: VX_DES ); const double steer = input ( IDX_U :: STEER_DES ); Eigen :: VectorXd d_state = Eigen :: VectorXd :: Zero ( dim_x_ ); d_state ( IDX :: X ) = vx * cos ( yaw ); d_state ( IDX :: Y ) = vx * sin ( yaw ); d_state ( IDX :: YAW ) = vx * std :: tan ( steer ) / wheelbase_ ; return d_state ; } SimModelIdealAccel :: SimModelIdealAccel ( double wheelbase ) : SimModelInterface ( 4 /* dim x */ , 2 /* dim u */ ), wheelbase_ ( wheelbase ) {} double SimModelIdealAccel :: getX () { return state_ ( IDX :: X );} double SimModelIdealAccel :: getY () { return state_ ( IDX :: Y );} double SimModelIdealAccel :: getYaw () { return state_ ( IDX :: YAW );} double SimModelIdealAccel :: getVx () { return state_ ( IDX :: VX );} double SimModelIdealAccel :: getWz () { return state_ ( IDX :: VX ) * std :: tan ( input_ ( IDX_U :: STEER_DES )) / wheelbase_ ; } double SimModelIdealAccel :: getSteer () { return input_ ( IDX_U :: STEER_DES );} void SimModelIdealAccel :: update ( const double & dt ) { updateRungeKutta ( dt , input_ ); if ( state_ ( IDX :: VX ) < 0 ) { state_ ( IDX :: VX ) = 0 ; } } Eigen :: VectorXd SimModelIdealAccel :: calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) { const double vx = state ( IDX :: VX ); const double yaw = state ( IDX :: YAW ); const double ax = input ( IDX_U :: AX_DES ); const double steer = input ( IDX_U :: STEER_DES ); Eigen :: VectorXd d_state = Eigen :: VectorXd :: Zero ( dim_x_ ); d_state ( IDX :: X ) = vx * cos ( yaw ); d_state ( IDX :: Y ) = vx * sin ( yaw ); d_state ( IDX :: VX ) = ax ; d_state ( IDX :: YAW ) = vx * std :: tan ( steer ) / wheelbase_ ; return d_state ; } Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/sim__model__ideal_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_ideal.hpp # simple planning simulator ideal velocity model (no dynamics for desired velocity & angular-velocity or steering) More... Classes # Name class SimModelIdealTwist class SimModelIdealSteer class SimModelIdealAccel Detailed Description # simple planning simulator ideal velocity model (no dynamics for desired velocity & angular-velocity or steering) Author : Takamasa Horibe Date : 2019.08.17 Source code # // Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_IDEAL_HPP_ #define SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_IDEAL_HPP_ #include <eigen3/Eigen/Core> #include <eigen3/Eigen/LU> #include <simulation_api/vehicle_model/sim_model_interface.hpp> #include <iostream> class SimModelIdealTwist : public SimModelInterface { public : SimModelIdealTwist (); ~ SimModelIdealTwist () = default ; private : enum IDX { X = 0 , Y , YAW , }; enum IDX_U { VX_DES = 0 , WZ_DES , }; double getX () override ; double getY () override ; double getYaw () override ; double getVx () override ; double getWz () override ; double getSteer () override ; void update ( const double & dt ) override ; Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) override ; }; class SimModelIdealSteer : public SimModelInterface { public : explicit SimModelIdealSteer ( double wheelbase ); ~ SimModelIdealSteer () = default ; private : enum IDX { X = 0 , Y , YAW , }; enum IDX_U { VX_DES = 0 , STEER_DES , }; const double wheelbase_ ; double getX () override ; double getY () override ; double getYaw () override ; double getVx () override ; double getWz () override ; double getSteer () override ; void update ( const double & dt ) override ; Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) override ; }; class SimModelIdealAccel : public SimModelInterface { public : explicit SimModelIdealAccel ( double wheelbase ); ~ SimModelIdealAccel () = default ; private : enum IDX { X = 0 , Y , YAW , VX , }; enum IDX_U { AX_DES = 0 , STEER_DES , }; const double wheelbase_ ; double getX () override ; double getY () override ; double getYaw () override ; double getVx () override ; double getWz () override ; double getSteer () override ; void update ( const double & dt ) override ; Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) override ; }; #endif // SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_IDEAL_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_ideal.hpp"},{"location":"package/simulation_api/markdown/Files/sim__model__ideal_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apivehicle_modelsim_model_idealhpp","text":"simple planning simulator ideal velocity model (no dynamics for desired velocity & angular-velocity or steering) More...","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_ideal.hpp"},{"location":"package/simulation_api/markdown/Files/sim__model__ideal_8hpp/#classes","text":"Name class SimModelIdealTwist class SimModelIdealSteer class SimModelIdealAccel","title":"Classes"},{"location":"package/simulation_api/markdown/Files/sim__model__ideal_8hpp/#detailed-description","text":"simple planning simulator ideal velocity model (no dynamics for desired velocity & angular-velocity or steering) Author : Takamasa Horibe Date : 2019.08.17","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Files/sim__model__ideal_8hpp/#source-code","text":"// Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_IDEAL_HPP_ #define SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_IDEAL_HPP_ #include <eigen3/Eigen/Core> #include <eigen3/Eigen/LU> #include <simulation_api/vehicle_model/sim_model_interface.hpp> #include <iostream> class SimModelIdealTwist : public SimModelInterface { public : SimModelIdealTwist (); ~ SimModelIdealTwist () = default ; private : enum IDX { X = 0 , Y , YAW , }; enum IDX_U { VX_DES = 0 , WZ_DES , }; double getX () override ; double getY () override ; double getYaw () override ; double getVx () override ; double getWz () override ; double getSteer () override ; void update ( const double & dt ) override ; Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) override ; }; class SimModelIdealSteer : public SimModelInterface { public : explicit SimModelIdealSteer ( double wheelbase ); ~ SimModelIdealSteer () = default ; private : enum IDX { X = 0 , Y , YAW , }; enum IDX_U { VX_DES = 0 , STEER_DES , }; const double wheelbase_ ; double getX () override ; double getY () override ; double getYaw () override ; double getVx () override ; double getWz () override ; double getSteer () override ; void update ( const double & dt ) override ; Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) override ; }; class SimModelIdealAccel : public SimModelInterface { public : explicit SimModelIdealAccel ( double wheelbase ); ~ SimModelIdealAccel () = default ; private : enum IDX { X = 0 , Y , YAW , VX , }; enum IDX_U { AX_DES = 0 , STEER_DES , }; const double wheelbase_ ; double getX () override ; double getY () override ; double getYaw () override ; double getVx () override ; double getWz () override ; double getSteer () override ; void update ( const double & dt ) override ; Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) override ; }; #endif // SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_IDEAL_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/sim__model__interface_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_interface.cpp # Source code # // Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/vehicle_model/sim_model_interface.hpp> SimModelInterface :: SimModelInterface ( int dim_x , int dim_u ) : dim_x_ ( dim_x ), dim_u_ ( dim_u ) { state_ = Eigen :: VectorXd :: Zero ( dim_x_ ); input_ = Eigen :: VectorXd :: Zero ( dim_u_ ); } void SimModelInterface :: updateRungeKutta ( const double & dt , const Eigen :: VectorXd & input ) { Eigen :: VectorXd k1 = calcModel ( state_ , input ); Eigen :: VectorXd k2 = calcModel ( state_ + k1 * 0.5 * dt , input ); Eigen :: VectorXd k3 = calcModel ( state_ + k2 * 0.5 * dt , input ); Eigen :: VectorXd k4 = calcModel ( state_ + k3 * dt , input ); state_ += 1.0 / 6.0 * ( k1 + 2.0 * k2 + 2.0 * k3 + k4 ) * dt ; } void SimModelInterface :: updateEuler ( const double & dt , const Eigen :: VectorXd & input ) { state_ += calcModel ( state_ , input ) * dt ; } void SimModelInterface :: getState ( Eigen :: VectorXd & state ) { state = state_ ;} void SimModelInterface :: getInput ( Eigen :: VectorXd & input ) { input = input_ ;} void SimModelInterface :: setState ( const Eigen :: VectorXd & state ) { state_ = state ;} void SimModelInterface :: setInput ( const Eigen :: VectorXd & input ) { input_ = input ;} Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_interface.cpp"},{"location":"package/simulation_api/markdown/Files/sim__model__interface_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcvehicle_modelsim_model_interfacecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_interface.cpp"},{"location":"package/simulation_api/markdown/Files/sim__model__interface_8cpp/#source-code","text":"// Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/vehicle_model/sim_model_interface.hpp> SimModelInterface :: SimModelInterface ( int dim_x , int dim_u ) : dim_x_ ( dim_x ), dim_u_ ( dim_u ) { state_ = Eigen :: VectorXd :: Zero ( dim_x_ ); input_ = Eigen :: VectorXd :: Zero ( dim_u_ ); } void SimModelInterface :: updateRungeKutta ( const double & dt , const Eigen :: VectorXd & input ) { Eigen :: VectorXd k1 = calcModel ( state_ , input ); Eigen :: VectorXd k2 = calcModel ( state_ + k1 * 0.5 * dt , input ); Eigen :: VectorXd k3 = calcModel ( state_ + k2 * 0.5 * dt , input ); Eigen :: VectorXd k4 = calcModel ( state_ + k3 * dt , input ); state_ += 1.0 / 6.0 * ( k1 + 2.0 * k2 + 2.0 * k3 + k4 ) * dt ; } void SimModelInterface :: updateEuler ( const double & dt , const Eigen :: VectorXd & input ) { state_ += calcModel ( state_ , input ) * dt ; } void SimModelInterface :: getState ( Eigen :: VectorXd & state ) { state = state_ ;} void SimModelInterface :: getInput ( Eigen :: VectorXd & input ) { input = input_ ;} void SimModelInterface :: setState ( const Eigen :: VectorXd & state ) { state_ = state ;} void SimModelInterface :: setInput ( const Eigen :: VectorXd & input ) { input_ = input ;} Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/sim__model__interface_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_interface.hpp # simple planning simulator model interface class More... Classes # Name class SimModelInterface Detailed Description # simple planning simulator model interface class Author : Takamasa Horibe Date : 2019.08.17 Source code # // Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_INTERFACE_HPP_ #define SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_INTERFACE_HPP_ #include <eigen3/Eigen/Core> #include <rclcpp/rclcpp.hpp> class SimModelInterface { protected : const int dim_x_ ; const int dim_u_ ; Eigen :: VectorXd state_ ; Eigen :: VectorXd input_ ; public : SimModelInterface ( int dim_x , int dim_u ); ~ SimModelInterface () = default ; void getState ( Eigen :: VectorXd & state ); void getInput ( Eigen :: VectorXd & input ); void setState ( const Eigen :: VectorXd & state ); void setInput ( const Eigen :: VectorXd & input ); void updateRungeKutta ( const double & dt , const Eigen :: VectorXd & input ); void updateEuler ( const double & dt , const Eigen :: VectorXd & input ); virtual void update ( const double & dt ) = 0 ; virtual double getX () = 0 ; virtual double getY () = 0 ; virtual double getYaw () = 0 ; virtual double getVx () = 0 ; virtual double getWz () = 0 ; virtual double getSteer () = 0 ; virtual Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) = 0 ; }; #endif // SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_INTERFACE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_interface.hpp"},{"location":"package/simulation_api/markdown/Files/sim__model__interface_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apivehicle_modelsim_model_interfacehpp","text":"simple planning simulator model interface class More...","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_interface.hpp"},{"location":"package/simulation_api/markdown/Files/sim__model__interface_8hpp/#classes","text":"Name class SimModelInterface","title":"Classes"},{"location":"package/simulation_api/markdown/Files/sim__model__interface_8hpp/#detailed-description","text":"simple planning simulator model interface class Author : Takamasa Horibe Date : 2019.08.17","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Files/sim__model__interface_8hpp/#source-code","text":"// Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_INTERFACE_HPP_ #define SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_INTERFACE_HPP_ #include <eigen3/Eigen/Core> #include <rclcpp/rclcpp.hpp> class SimModelInterface { protected : const int dim_x_ ; const int dim_u_ ; Eigen :: VectorXd state_ ; Eigen :: VectorXd input_ ; public : SimModelInterface ( int dim_x , int dim_u ); ~ SimModelInterface () = default ; void getState ( Eigen :: VectorXd & state ); void getInput ( Eigen :: VectorXd & input ); void setState ( const Eigen :: VectorXd & state ); void setInput ( const Eigen :: VectorXd & input ); void updateRungeKutta ( const double & dt , const Eigen :: VectorXd & input ); void updateEuler ( const double & dt , const Eigen :: VectorXd & input ); virtual void update ( const double & dt ) = 0 ; virtual double getX () = 0 ; virtual double getY () = 0 ; virtual double getYaw () = 0 ; virtual double getVx () = 0 ; virtual double getWz () = 0 ; virtual double getSteer () = 0 ; virtual Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) = 0 ; }; #endif // SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_INTERFACE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/sim__model__time__delay_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_time_delay.cpp # Source code # // Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/vehicle_model/sim_model_time_delay.hpp> #include <algorithm> /* * * SimModelTimeDelayTwist * */ SimModelTimeDelayTwist :: SimModelTimeDelayTwist ( double vx_lim , double wz_lim , double vx_rate_lim , double wz_rate_lim , double dt , double vx_delay , double vx_time_constant , double wz_delay , double wz_time_constant , double deadzone_delta_steer ) : SimModelInterface ( 5 /* dim x */ , 2 /* dim u */ ), MIN_TIME_CONSTANT ( 0.03 ), vx_lim_ ( vx_lim ), vx_rate_lim_ ( vx_rate_lim ), wz_lim_ ( wz_lim ), wz_rate_lim_ ( wz_rate_lim ), vx_delay_ ( vx_delay ), vx_time_constant_ ( std :: max ( vx_time_constant , MIN_TIME_CONSTANT )), wz_delay_ ( wz_delay ), wz_time_constant_ ( std :: max ( wz_time_constant , MIN_TIME_CONSTANT )), deadzone_delta_steer_ ( deadzone_delta_steer ) { if ( vx_time_constant < MIN_TIME_CONSTANT ) { std :: cout << \"Settings vx_time_constant is too small, replace it by \" << MIN_TIME_CONSTANT << std :: endl ; } if ( wz_time_constant < MIN_TIME_CONSTANT ) { std :: cout << \"Settings wz_time_constant is too small, replace it by \" << MIN_TIME_CONSTANT << std :: endl ; } initializeInputQueue ( dt ); } double SimModelTimeDelayTwist :: getX () { return state_ ( IDX :: X );} double SimModelTimeDelayTwist :: getY () { return state_ ( IDX :: Y );} double SimModelTimeDelayTwist :: getYaw () { return state_ ( IDX :: YAW );} double SimModelTimeDelayTwist :: getVx () { return state_ ( IDX :: VX );} double SimModelTimeDelayTwist :: getWz () { return state_ ( IDX :: WZ );} double SimModelTimeDelayTwist :: getSteer () { return 0.0 ;} void SimModelTimeDelayTwist :: update ( const double & dt ) { Eigen :: VectorXd delayed_input = Eigen :: VectorXd :: Zero ( dim_u_ ); vx_input_queue_ . push_back ( input_ ( IDX_U :: VX_DES )); delayed_input ( IDX_U :: VX_DES ) = vx_input_queue_ . front (); vx_input_queue_ . pop_front (); wz_input_queue_ . push_back ( input_ ( IDX_U :: WZ_DES )); delayed_input ( IDX_U :: WZ_DES ) = wz_input_queue_ . front (); wz_input_queue_ . pop_front (); // do not use deadzone_delta_steer (Steer IF does not exist in this model) updateRungeKutta ( dt , delayed_input ); } void SimModelTimeDelayTwist :: initializeInputQueue ( const double & dt ) { size_t vx_input_queue_size = static_cast < size_t > ( round ( vx_delay_ / dt )); for ( size_t i = 0 ; i < vx_input_queue_size ; i ++ ) { vx_input_queue_ . push_back ( 0.0 ); } size_t wz_input_queue_size = static_cast < size_t > ( round ( wz_delay_ / dt )); for ( size_t i = 0 ; i < wz_input_queue_size ; i ++ ) { wz_input_queue_ . push_back ( 0.0 ); } } Eigen :: VectorXd SimModelTimeDelayTwist :: calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) { const double vx = state ( IDX :: VX ); const double wz = state ( IDX :: WZ ); const double yaw = state ( IDX :: YAW ); const double delay_input_vx = input ( IDX_U :: VX_DES ); const double delay_input_wz = input ( IDX_U :: WZ_DES ); const double delay_vx_des = std :: max ( std :: min ( delay_input_vx , vx_lim_ ), - vx_lim_ ); const double delay_wz_des = std :: max ( std :: min ( delay_input_wz , wz_lim_ ), - wz_lim_ ); double vx_rate = - ( vx - delay_vx_des ) / vx_time_constant_ ; double wz_rate = - ( wz - delay_wz_des ) / wz_time_constant_ ; vx_rate = std :: min ( vx_rate_lim_ , std :: max ( - vx_rate_lim_ , vx_rate )); wz_rate = std :: min ( wz_rate_lim_ , std :: max ( - wz_rate_lim_ , wz_rate )); Eigen :: VectorXd d_state = Eigen :: VectorXd :: Zero ( dim_x_ ); d_state ( IDX :: X ) = vx * cos ( yaw ); d_state ( IDX :: Y ) = vx * sin ( yaw ); d_state ( IDX :: YAW ) = wz ; d_state ( IDX :: VX ) = vx_rate ; d_state ( IDX :: WZ ) = wz_rate ; return d_state ; } /* * * SimModelTimeDelaySteer * */ SimModelTimeDelaySteer :: SimModelTimeDelaySteer ( double vx_lim , double steer_lim , double vx_rate_lim , double steer_rate_lim , double wheelbase , double dt , double vx_delay , double vx_time_constant , double steer_delay , double steer_time_constant , double deadzone_delta_steer ) : SimModelInterface ( 5 /* dim x */ , 2 /* dim u */ ), MIN_TIME_CONSTANT ( 0.03 ), vx_lim_ ( vx_lim ), vx_rate_lim_ ( vx_rate_lim ), steer_lim_ ( steer_lim ), steer_rate_lim_ ( steer_rate_lim ), wheelbase_ ( wheelbase ), vx_delay_ ( vx_delay ), vx_time_constant_ ( std :: max ( vx_time_constant , MIN_TIME_CONSTANT )), steer_delay_ ( steer_delay ), steer_time_constant_ ( std :: max ( steer_time_constant , MIN_TIME_CONSTANT )), deadzone_delta_steer_ ( deadzone_delta_steer ) { if ( vx_time_constant < MIN_TIME_CONSTANT ) { std :: cout << \"Settings vx_time_constant is too small, replace it by \" << MIN_TIME_CONSTANT << std :: endl ; } if ( steer_time_constant < MIN_TIME_CONSTANT ) { std :: cout << \"Settings steer_time_constant is too small, replace it by \" << MIN_TIME_CONSTANT << std :: endl ; } initializeInputQueue ( dt ); } double SimModelTimeDelaySteer :: getX () { return state_ ( IDX :: X );} double SimModelTimeDelaySteer :: getY () { return state_ ( IDX :: Y );} double SimModelTimeDelaySteer :: getYaw () { return state_ ( IDX :: YAW );} double SimModelTimeDelaySteer :: getVx () { return state_ ( IDX :: VX );} double SimModelTimeDelaySteer :: getWz () { return state_ ( IDX :: VX ) * std :: tan ( state_ ( IDX :: STEER )) / wheelbase_ ; } double SimModelTimeDelaySteer :: getSteer () { return state_ ( IDX :: STEER );} void SimModelTimeDelaySteer :: update ( const double & dt ) { Eigen :: VectorXd delayed_input = Eigen :: VectorXd :: Zero ( dim_u_ ); vx_input_queue_ . push_back ( input_ ( IDX_U :: VX_DES )); delayed_input ( IDX_U :: VX_DES ) = vx_input_queue_ . front (); vx_input_queue_ . pop_front (); steer_input_queue_ . push_back ( input_ ( IDX_U :: STEER_DES )); const double raw_steer_command = steer_input_queue_ . front (); delayed_input ( IDX_U :: STEER_DES ) = sim_model_util :: getDummySteerCommandWithFriction ( getSteer (), raw_steer_command , deadzone_delta_steer_ ); steer_input_queue_ . pop_front (); updateRungeKutta ( dt , delayed_input ); } void SimModelTimeDelaySteer :: initializeInputQueue ( const double & dt ) { size_t vx_input_queue_size = static_cast < size_t > ( round ( vx_delay_ / dt )); for ( size_t i = 0 ; i < vx_input_queue_size ; i ++ ) { vx_input_queue_ . push_back ( 0.0 ); } size_t steer_input_queue_size = static_cast < size_t > ( round ( steer_delay_ / dt )); for ( size_t i = 0 ; i < steer_input_queue_size ; i ++ ) { steer_input_queue_ . push_back ( 0.0 ); } } Eigen :: VectorXd SimModelTimeDelaySteer :: calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) { const double vel = state ( IDX :: VX ); const double yaw = state ( IDX :: YAW ); const double steer = state ( IDX :: STEER ); const double delay_input_vel = input ( IDX_U :: VX_DES ); const double delay_input_steer = input ( IDX_U :: STEER_DES ); const double delay_vx_des = std :: max ( std :: min ( delay_input_vel , vx_lim_ ), - vx_lim_ ); const double delay_steer_des = std :: max ( std :: min ( delay_input_steer , steer_lim_ ), - steer_lim_ ); double vx_rate = - ( vel - delay_vx_des ) / vx_time_constant_ ; double steer_rate = - ( steer - delay_steer_des ) / steer_time_constant_ ; vx_rate = std :: min ( vx_rate_lim_ , std :: max ( - vx_rate_lim_ , vx_rate )); steer_rate = std :: min ( steer_rate_lim_ , std :: max ( - steer_rate_lim_ , steer_rate )); Eigen :: VectorXd d_state = Eigen :: VectorXd :: Zero ( dim_x_ ); d_state ( IDX :: X ) = vel * cos ( yaw ); d_state ( IDX :: Y ) = vel * sin ( yaw ); d_state ( IDX :: YAW ) = vel * std :: tan ( steer ) / wheelbase_ ; d_state ( IDX :: VX ) = vx_rate ; d_state ( IDX :: STEER ) = steer_rate ; return d_state ; } SimModelTimeDelaySteerAccel :: SimModelTimeDelaySteerAccel ( double vx_lim , double steer_lim , double vx_rate_lim , double steer_rate_lim , double wheelbase , double dt , double acc_delay , double acc_time_constant , double steer_delay , double steer_time_constant , double deadzone_delta_steer ) : SimModelInterface ( 6 /* dim x */ , 3 /* dim u */ ), MIN_TIME_CONSTANT ( 0.03 ), vx_lim_ ( vx_lim ), vx_rate_lim_ ( vx_rate_lim ), steer_lim_ ( steer_lim ), steer_rate_lim_ ( steer_rate_lim ), wheelbase_ ( wheelbase ), acc_delay_ ( acc_delay ), acc_time_constant_ ( std :: max ( acc_time_constant , MIN_TIME_CONSTANT )), steer_delay_ ( steer_delay ), steer_time_constant_ ( std :: max ( steer_time_constant , MIN_TIME_CONSTANT )), deadzone_delta_steer_ ( deadzone_delta_steer ) { if ( acc_time_constant < MIN_TIME_CONSTANT ) { std :: cout << \"Settings acc_time_constant is too small, replace it by\" << MIN_TIME_CONSTANT << std :: endl ; } if ( steer_time_constant < MIN_TIME_CONSTANT ) { std :: cout << \"Settings steer_time_constant is too small, replace it by\" << MIN_TIME_CONSTANT << std :: endl ; } initializeInputQueue ( dt ); } double SimModelTimeDelaySteerAccel :: getX () { return state_ ( IDX :: X );} double SimModelTimeDelaySteerAccel :: getY () { return state_ ( IDX :: Y );} double SimModelTimeDelaySteerAccel :: getYaw () { return state_ ( IDX :: YAW );} double SimModelTimeDelaySteerAccel :: getVx () { return state_ ( IDX :: VX );} double SimModelTimeDelaySteerAccel :: getWz () { return state_ ( IDX :: VX ) * std :: tan ( state_ ( IDX :: STEER )) / wheelbase_ ; } double SimModelTimeDelaySteerAccel :: getSteer () { return state_ ( IDX :: STEER );} void SimModelTimeDelaySteerAccel :: update ( const double & dt ) { Eigen :: VectorXd delayed_input = Eigen :: VectorXd :: Zero ( dim_u_ ); acc_input_queue_ . push_back ( input_ ( IDX_U :: ACCX_DES )); delayed_input ( IDX_U :: ACCX_DES ) = acc_input_queue_ . front (); acc_input_queue_ . pop_front (); steer_input_queue_ . push_back ( input_ ( IDX_U :: STEER_DES )); const double raw_steer_command = steer_input_queue_ . front (); delayed_input ( IDX_U :: STEER_DES ) = sim_model_util :: getDummySteerCommandWithFriction ( getSteer (), raw_steer_command , deadzone_delta_steer_ ); steer_input_queue_ . pop_front (); delayed_input ( IDX_U :: DRIVE_SHIFT ) = input_ ( IDX_U :: DRIVE_SHIFT ); updateRungeKutta ( dt , delayed_input ); // clip velocity and accel if ( delayed_input ( IDX_U :: DRIVE_SHIFT ) >= 0.0 ) { state_ ( IDX :: VX ) = std :: max ( 0.0 , std :: min ( state_ ( IDX :: VX ), vx_lim_ )); if ( std :: abs (( state_ ( IDX :: VX ) - 0.0 )) < 10e-9 || std :: abs (( state_ ( IDX :: VX ) - vx_lim_ )) < 10e-9 ) { state_ ( IDX :: ACCX ) = 0.0 ; } } else { state_ ( IDX :: VX ) = std :: min ( 0.0 , std :: max ( state_ ( IDX :: VX ), - vx_lim_ )); if ( std :: abs (( state_ ( IDX :: VX ) - 0.0 )) < 10e-9 || std :: abs (( state_ ( IDX :: VX ) - ( - vx_lim_ ))) < 10e-9 ) { state_ ( IDX :: ACCX ) = 0.0 ; } } } void SimModelTimeDelaySteerAccel :: initializeInputQueue ( const double & dt ) { size_t vx_input_queue_size = static_cast < size_t > ( round ( acc_delay_ / dt )); for ( size_t i = 0 ; i < vx_input_queue_size ; i ++ ) { acc_input_queue_ . push_back ( 0.0 ); } size_t steer_input_queue_size = static_cast < size_t > ( round ( steer_delay_ / dt )); for ( size_t i = 0 ; i < steer_input_queue_size ; i ++ ) { steer_input_queue_ . push_back ( 0.0 ); } } Eigen :: VectorXd SimModelTimeDelaySteerAccel :: calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) { double vel = state ( IDX :: VX ); double acc = state ( IDX :: ACCX ); const double yaw = state ( IDX :: YAW ); const double steer = state ( IDX :: STEER ); const double delay_input_acc = input ( IDX_U :: ACCX_DES ); const double delay_input_steer = input ( IDX_U :: STEER_DES ); const double drive_shift = input ( IDX_U :: DRIVE_SHIFT ); double delay_acc_des = std :: max ( std :: min ( delay_input_acc , vx_rate_lim_ ), - vx_rate_lim_ ); if ( ! ( drive_shift >= 0.0 )) { delay_acc_des *= -1 ; // reverse front-back } double delay_steer_des = std :: max ( std :: min ( delay_input_steer , steer_lim_ ), - steer_lim_ ); double accx_rate = - ( acc - delay_acc_des ) / acc_time_constant_ ; double steer_rate = - ( steer - delay_steer_des ) / steer_time_constant_ ; acc = std :: min ( vx_rate_lim_ , std :: max ( - vx_rate_lim_ , acc )); steer_rate = std :: min ( steer_rate_lim_ , std :: max ( - steer_rate_lim_ , steer_rate )); if ( drive_shift >= 0.0 ) { vel = std :: max ( 0.0 , std :: min ( vel , vx_lim_ )); } else { vel = std :: min ( 0.0 , std :: max ( vel , - vx_lim_ )); } Eigen :: VectorXd d_state = Eigen :: VectorXd :: Zero ( dim_x_ ); d_state ( IDX :: X ) = vel * cos ( yaw ); d_state ( IDX :: Y ) = vel * sin ( yaw ); d_state ( IDX :: YAW ) = vel * std :: tan ( steer ) / wheelbase_ ; d_state ( IDX :: VX ) = acc ; d_state ( IDX :: STEER ) = steer_rate ; d_state ( IDX :: ACCX ) = accx_rate ; return d_state ; } Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_time_delay.cpp"},{"location":"package/simulation_api/markdown/Files/sim__model__time__delay_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcvehicle_modelsim_model_time_delaycpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_time_delay.cpp"},{"location":"package/simulation_api/markdown/Files/sim__model__time__delay_8cpp/#source-code","text":"// Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/vehicle_model/sim_model_time_delay.hpp> #include <algorithm> /* * * SimModelTimeDelayTwist * */ SimModelTimeDelayTwist :: SimModelTimeDelayTwist ( double vx_lim , double wz_lim , double vx_rate_lim , double wz_rate_lim , double dt , double vx_delay , double vx_time_constant , double wz_delay , double wz_time_constant , double deadzone_delta_steer ) : SimModelInterface ( 5 /* dim x */ , 2 /* dim u */ ), MIN_TIME_CONSTANT ( 0.03 ), vx_lim_ ( vx_lim ), vx_rate_lim_ ( vx_rate_lim ), wz_lim_ ( wz_lim ), wz_rate_lim_ ( wz_rate_lim ), vx_delay_ ( vx_delay ), vx_time_constant_ ( std :: max ( vx_time_constant , MIN_TIME_CONSTANT )), wz_delay_ ( wz_delay ), wz_time_constant_ ( std :: max ( wz_time_constant , MIN_TIME_CONSTANT )), deadzone_delta_steer_ ( deadzone_delta_steer ) { if ( vx_time_constant < MIN_TIME_CONSTANT ) { std :: cout << \"Settings vx_time_constant is too small, replace it by \" << MIN_TIME_CONSTANT << std :: endl ; } if ( wz_time_constant < MIN_TIME_CONSTANT ) { std :: cout << \"Settings wz_time_constant is too small, replace it by \" << MIN_TIME_CONSTANT << std :: endl ; } initializeInputQueue ( dt ); } double SimModelTimeDelayTwist :: getX () { return state_ ( IDX :: X );} double SimModelTimeDelayTwist :: getY () { return state_ ( IDX :: Y );} double SimModelTimeDelayTwist :: getYaw () { return state_ ( IDX :: YAW );} double SimModelTimeDelayTwist :: getVx () { return state_ ( IDX :: VX );} double SimModelTimeDelayTwist :: getWz () { return state_ ( IDX :: WZ );} double SimModelTimeDelayTwist :: getSteer () { return 0.0 ;} void SimModelTimeDelayTwist :: update ( const double & dt ) { Eigen :: VectorXd delayed_input = Eigen :: VectorXd :: Zero ( dim_u_ ); vx_input_queue_ . push_back ( input_ ( IDX_U :: VX_DES )); delayed_input ( IDX_U :: VX_DES ) = vx_input_queue_ . front (); vx_input_queue_ . pop_front (); wz_input_queue_ . push_back ( input_ ( IDX_U :: WZ_DES )); delayed_input ( IDX_U :: WZ_DES ) = wz_input_queue_ . front (); wz_input_queue_ . pop_front (); // do not use deadzone_delta_steer (Steer IF does not exist in this model) updateRungeKutta ( dt , delayed_input ); } void SimModelTimeDelayTwist :: initializeInputQueue ( const double & dt ) { size_t vx_input_queue_size = static_cast < size_t > ( round ( vx_delay_ / dt )); for ( size_t i = 0 ; i < vx_input_queue_size ; i ++ ) { vx_input_queue_ . push_back ( 0.0 ); } size_t wz_input_queue_size = static_cast < size_t > ( round ( wz_delay_ / dt )); for ( size_t i = 0 ; i < wz_input_queue_size ; i ++ ) { wz_input_queue_ . push_back ( 0.0 ); } } Eigen :: VectorXd SimModelTimeDelayTwist :: calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) { const double vx = state ( IDX :: VX ); const double wz = state ( IDX :: WZ ); const double yaw = state ( IDX :: YAW ); const double delay_input_vx = input ( IDX_U :: VX_DES ); const double delay_input_wz = input ( IDX_U :: WZ_DES ); const double delay_vx_des = std :: max ( std :: min ( delay_input_vx , vx_lim_ ), - vx_lim_ ); const double delay_wz_des = std :: max ( std :: min ( delay_input_wz , wz_lim_ ), - wz_lim_ ); double vx_rate = - ( vx - delay_vx_des ) / vx_time_constant_ ; double wz_rate = - ( wz - delay_wz_des ) / wz_time_constant_ ; vx_rate = std :: min ( vx_rate_lim_ , std :: max ( - vx_rate_lim_ , vx_rate )); wz_rate = std :: min ( wz_rate_lim_ , std :: max ( - wz_rate_lim_ , wz_rate )); Eigen :: VectorXd d_state = Eigen :: VectorXd :: Zero ( dim_x_ ); d_state ( IDX :: X ) = vx * cos ( yaw ); d_state ( IDX :: Y ) = vx * sin ( yaw ); d_state ( IDX :: YAW ) = wz ; d_state ( IDX :: VX ) = vx_rate ; d_state ( IDX :: WZ ) = wz_rate ; return d_state ; } /* * * SimModelTimeDelaySteer * */ SimModelTimeDelaySteer :: SimModelTimeDelaySteer ( double vx_lim , double steer_lim , double vx_rate_lim , double steer_rate_lim , double wheelbase , double dt , double vx_delay , double vx_time_constant , double steer_delay , double steer_time_constant , double deadzone_delta_steer ) : SimModelInterface ( 5 /* dim x */ , 2 /* dim u */ ), MIN_TIME_CONSTANT ( 0.03 ), vx_lim_ ( vx_lim ), vx_rate_lim_ ( vx_rate_lim ), steer_lim_ ( steer_lim ), steer_rate_lim_ ( steer_rate_lim ), wheelbase_ ( wheelbase ), vx_delay_ ( vx_delay ), vx_time_constant_ ( std :: max ( vx_time_constant , MIN_TIME_CONSTANT )), steer_delay_ ( steer_delay ), steer_time_constant_ ( std :: max ( steer_time_constant , MIN_TIME_CONSTANT )), deadzone_delta_steer_ ( deadzone_delta_steer ) { if ( vx_time_constant < MIN_TIME_CONSTANT ) { std :: cout << \"Settings vx_time_constant is too small, replace it by \" << MIN_TIME_CONSTANT << std :: endl ; } if ( steer_time_constant < MIN_TIME_CONSTANT ) { std :: cout << \"Settings steer_time_constant is too small, replace it by \" << MIN_TIME_CONSTANT << std :: endl ; } initializeInputQueue ( dt ); } double SimModelTimeDelaySteer :: getX () { return state_ ( IDX :: X );} double SimModelTimeDelaySteer :: getY () { return state_ ( IDX :: Y );} double SimModelTimeDelaySteer :: getYaw () { return state_ ( IDX :: YAW );} double SimModelTimeDelaySteer :: getVx () { return state_ ( IDX :: VX );} double SimModelTimeDelaySteer :: getWz () { return state_ ( IDX :: VX ) * std :: tan ( state_ ( IDX :: STEER )) / wheelbase_ ; } double SimModelTimeDelaySteer :: getSteer () { return state_ ( IDX :: STEER );} void SimModelTimeDelaySteer :: update ( const double & dt ) { Eigen :: VectorXd delayed_input = Eigen :: VectorXd :: Zero ( dim_u_ ); vx_input_queue_ . push_back ( input_ ( IDX_U :: VX_DES )); delayed_input ( IDX_U :: VX_DES ) = vx_input_queue_ . front (); vx_input_queue_ . pop_front (); steer_input_queue_ . push_back ( input_ ( IDX_U :: STEER_DES )); const double raw_steer_command = steer_input_queue_ . front (); delayed_input ( IDX_U :: STEER_DES ) = sim_model_util :: getDummySteerCommandWithFriction ( getSteer (), raw_steer_command , deadzone_delta_steer_ ); steer_input_queue_ . pop_front (); updateRungeKutta ( dt , delayed_input ); } void SimModelTimeDelaySteer :: initializeInputQueue ( const double & dt ) { size_t vx_input_queue_size = static_cast < size_t > ( round ( vx_delay_ / dt )); for ( size_t i = 0 ; i < vx_input_queue_size ; i ++ ) { vx_input_queue_ . push_back ( 0.0 ); } size_t steer_input_queue_size = static_cast < size_t > ( round ( steer_delay_ / dt )); for ( size_t i = 0 ; i < steer_input_queue_size ; i ++ ) { steer_input_queue_ . push_back ( 0.0 ); } } Eigen :: VectorXd SimModelTimeDelaySteer :: calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) { const double vel = state ( IDX :: VX ); const double yaw = state ( IDX :: YAW ); const double steer = state ( IDX :: STEER ); const double delay_input_vel = input ( IDX_U :: VX_DES ); const double delay_input_steer = input ( IDX_U :: STEER_DES ); const double delay_vx_des = std :: max ( std :: min ( delay_input_vel , vx_lim_ ), - vx_lim_ ); const double delay_steer_des = std :: max ( std :: min ( delay_input_steer , steer_lim_ ), - steer_lim_ ); double vx_rate = - ( vel - delay_vx_des ) / vx_time_constant_ ; double steer_rate = - ( steer - delay_steer_des ) / steer_time_constant_ ; vx_rate = std :: min ( vx_rate_lim_ , std :: max ( - vx_rate_lim_ , vx_rate )); steer_rate = std :: min ( steer_rate_lim_ , std :: max ( - steer_rate_lim_ , steer_rate )); Eigen :: VectorXd d_state = Eigen :: VectorXd :: Zero ( dim_x_ ); d_state ( IDX :: X ) = vel * cos ( yaw ); d_state ( IDX :: Y ) = vel * sin ( yaw ); d_state ( IDX :: YAW ) = vel * std :: tan ( steer ) / wheelbase_ ; d_state ( IDX :: VX ) = vx_rate ; d_state ( IDX :: STEER ) = steer_rate ; return d_state ; } SimModelTimeDelaySteerAccel :: SimModelTimeDelaySteerAccel ( double vx_lim , double steer_lim , double vx_rate_lim , double steer_rate_lim , double wheelbase , double dt , double acc_delay , double acc_time_constant , double steer_delay , double steer_time_constant , double deadzone_delta_steer ) : SimModelInterface ( 6 /* dim x */ , 3 /* dim u */ ), MIN_TIME_CONSTANT ( 0.03 ), vx_lim_ ( vx_lim ), vx_rate_lim_ ( vx_rate_lim ), steer_lim_ ( steer_lim ), steer_rate_lim_ ( steer_rate_lim ), wheelbase_ ( wheelbase ), acc_delay_ ( acc_delay ), acc_time_constant_ ( std :: max ( acc_time_constant , MIN_TIME_CONSTANT )), steer_delay_ ( steer_delay ), steer_time_constant_ ( std :: max ( steer_time_constant , MIN_TIME_CONSTANT )), deadzone_delta_steer_ ( deadzone_delta_steer ) { if ( acc_time_constant < MIN_TIME_CONSTANT ) { std :: cout << \"Settings acc_time_constant is too small, replace it by\" << MIN_TIME_CONSTANT << std :: endl ; } if ( steer_time_constant < MIN_TIME_CONSTANT ) { std :: cout << \"Settings steer_time_constant is too small, replace it by\" << MIN_TIME_CONSTANT << std :: endl ; } initializeInputQueue ( dt ); } double SimModelTimeDelaySteerAccel :: getX () { return state_ ( IDX :: X );} double SimModelTimeDelaySteerAccel :: getY () { return state_ ( IDX :: Y );} double SimModelTimeDelaySteerAccel :: getYaw () { return state_ ( IDX :: YAW );} double SimModelTimeDelaySteerAccel :: getVx () { return state_ ( IDX :: VX );} double SimModelTimeDelaySteerAccel :: getWz () { return state_ ( IDX :: VX ) * std :: tan ( state_ ( IDX :: STEER )) / wheelbase_ ; } double SimModelTimeDelaySteerAccel :: getSteer () { return state_ ( IDX :: STEER );} void SimModelTimeDelaySteerAccel :: update ( const double & dt ) { Eigen :: VectorXd delayed_input = Eigen :: VectorXd :: Zero ( dim_u_ ); acc_input_queue_ . push_back ( input_ ( IDX_U :: ACCX_DES )); delayed_input ( IDX_U :: ACCX_DES ) = acc_input_queue_ . front (); acc_input_queue_ . pop_front (); steer_input_queue_ . push_back ( input_ ( IDX_U :: STEER_DES )); const double raw_steer_command = steer_input_queue_ . front (); delayed_input ( IDX_U :: STEER_DES ) = sim_model_util :: getDummySteerCommandWithFriction ( getSteer (), raw_steer_command , deadzone_delta_steer_ ); steer_input_queue_ . pop_front (); delayed_input ( IDX_U :: DRIVE_SHIFT ) = input_ ( IDX_U :: DRIVE_SHIFT ); updateRungeKutta ( dt , delayed_input ); // clip velocity and accel if ( delayed_input ( IDX_U :: DRIVE_SHIFT ) >= 0.0 ) { state_ ( IDX :: VX ) = std :: max ( 0.0 , std :: min ( state_ ( IDX :: VX ), vx_lim_ )); if ( std :: abs (( state_ ( IDX :: VX ) - 0.0 )) < 10e-9 || std :: abs (( state_ ( IDX :: VX ) - vx_lim_ )) < 10e-9 ) { state_ ( IDX :: ACCX ) = 0.0 ; } } else { state_ ( IDX :: VX ) = std :: min ( 0.0 , std :: max ( state_ ( IDX :: VX ), - vx_lim_ )); if ( std :: abs (( state_ ( IDX :: VX ) - 0.0 )) < 10e-9 || std :: abs (( state_ ( IDX :: VX ) - ( - vx_lim_ ))) < 10e-9 ) { state_ ( IDX :: ACCX ) = 0.0 ; } } } void SimModelTimeDelaySteerAccel :: initializeInputQueue ( const double & dt ) { size_t vx_input_queue_size = static_cast < size_t > ( round ( acc_delay_ / dt )); for ( size_t i = 0 ; i < vx_input_queue_size ; i ++ ) { acc_input_queue_ . push_back ( 0.0 ); } size_t steer_input_queue_size = static_cast < size_t > ( round ( steer_delay_ / dt )); for ( size_t i = 0 ; i < steer_input_queue_size ; i ++ ) { steer_input_queue_ . push_back ( 0.0 ); } } Eigen :: VectorXd SimModelTimeDelaySteerAccel :: calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) { double vel = state ( IDX :: VX ); double acc = state ( IDX :: ACCX ); const double yaw = state ( IDX :: YAW ); const double steer = state ( IDX :: STEER ); const double delay_input_acc = input ( IDX_U :: ACCX_DES ); const double delay_input_steer = input ( IDX_U :: STEER_DES ); const double drive_shift = input ( IDX_U :: DRIVE_SHIFT ); double delay_acc_des = std :: max ( std :: min ( delay_input_acc , vx_rate_lim_ ), - vx_rate_lim_ ); if ( ! ( drive_shift >= 0.0 )) { delay_acc_des *= -1 ; // reverse front-back } double delay_steer_des = std :: max ( std :: min ( delay_input_steer , steer_lim_ ), - steer_lim_ ); double accx_rate = - ( acc - delay_acc_des ) / acc_time_constant_ ; double steer_rate = - ( steer - delay_steer_des ) / steer_time_constant_ ; acc = std :: min ( vx_rate_lim_ , std :: max ( - vx_rate_lim_ , acc )); steer_rate = std :: min ( steer_rate_lim_ , std :: max ( - steer_rate_lim_ , steer_rate )); if ( drive_shift >= 0.0 ) { vel = std :: max ( 0.0 , std :: min ( vel , vx_lim_ )); } else { vel = std :: min ( 0.0 , std :: max ( vel , - vx_lim_ )); } Eigen :: VectorXd d_state = Eigen :: VectorXd :: Zero ( dim_x_ ); d_state ( IDX :: X ) = vel * cos ( yaw ); d_state ( IDX :: Y ) = vel * sin ( yaw ); d_state ( IDX :: YAW ) = vel * std :: tan ( steer ) / wheelbase_ ; d_state ( IDX :: VX ) = acc ; d_state ( IDX :: STEER ) = steer_rate ; d_state ( IDX :: ACCX ) = accx_rate ; return d_state ; } Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/sim__model__time__delay_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_time_delay.hpp # simple planning simulator model with time delay and 1-dimensional dynamics for velocity & steering More... Classes # Name class SimModelTimeDelayTwist class SimModelTimeDelaySteerAccel class SimModelTimeDelaySteer Detailed Description # simple planning simulator model with time delay and 1-dimensional dynamics for velocity & steering Author : Takamasa Horibe, Kim-Ngoc-Khanh Nguyen Date : 2019.08.17 Source code # // Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_TIME_DELAY_HPP_ #define SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_TIME_DELAY_HPP_ #include <eigen3/Eigen/Core> #include <eigen3/Eigen/LU> #include <simulation_api/vehicle_model/sim_model_interface.hpp> #include <simulation_api/vehicle_model/sim_model_util.hpp> #include <iostream> #include <queue> #include <deque> class SimModelTimeDelayTwist : public SimModelInterface { public : SimModelTimeDelayTwist ( double vx_lim , double angvel_lim , double vx_rate_lim , double wz_rate_lim , double dt , double vx_delay , double vx_time_constant , double wz_delay , double wz_time_constant , double deadzone_delta_steer ); ~ SimModelTimeDelayTwist () = default ; private : const double MIN_TIME_CONSTANT ; enum IDX { X = 0 , Y , YAW , VX , WZ , }; enum IDX_U { VX_DES = 0 , WZ_DES , }; const double vx_lim_ ; const double vx_rate_lim_ ; const double wz_lim_ ; const double wz_rate_lim_ ; std :: deque < double > vx_input_queue_ ; std :: deque < double > wz_input_queue_ ; const double vx_delay_ ; const double vx_time_constant_ ; const double wz_delay_ ; const double wz_time_constant_ ; const double deadzone_delta_steer_ ; void initializeInputQueue ( const double & dt ); double getX () override ; double getY () override ; double getYaw () override ; double getVx () override ; double getWz () override ; double getSteer () override ; void update ( const double & dt ) override ; Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) override ; }; class SimModelTimeDelaySteer : public SimModelInterface { public : SimModelTimeDelaySteer ( double vx_lim , double steer_lim , double vx_rate_lim , double steer_rate_lim , double wheelbase , double dt , double vx_delay , double vx_time_constant , double steer_delay , double steer_time_constant , double deadzone_delta_steer ); ~ SimModelTimeDelaySteer () = default ; private : const double MIN_TIME_CONSTANT ; enum IDX { X = 0 , Y , YAW , VX , STEER , }; enum IDX_U { VX_DES = 0 , STEER_DES , }; const double vx_lim_ ; const double vx_rate_lim_ ; const double steer_lim_ ; const double steer_rate_lim_ ; const double wheelbase_ ; std :: deque < double > vx_input_queue_ ; std :: deque < double > steer_input_queue_ ; const double vx_delay_ ; const double vx_time_constant_ ; const double steer_delay_ ; const double steer_time_constant_ ; const double deadzone_delta_steer_ ; void initializeInputQueue ( const double & dt ); double getX () override ; double getY () override ; double getYaw () override ; double getVx () override ; double getWz () override ; double getSteer () override ; void update ( const double & dt ) override ; Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) override ; }; class SimModelTimeDelaySteerAccel : public SimModelInterface { public : SimModelTimeDelaySteerAccel ( double vx_lim , double steer_lim , double vx_rate_lim , double steer_rate_lim , double wheelbase , double dt , double acc_delay , double acc_time_constant , double steer_delay , double steer_time_constant , double deadzone_delta_steer ); ~ SimModelTimeDelaySteerAccel () = default ; private : const double MIN_TIME_CONSTANT ; enum IDX { X = 0 , Y , YAW , VX , STEER , ACCX , }; enum IDX_U { ACCX_DES = 0 , STEER_DES , DRIVE_SHIFT , }; const double vx_lim_ ; const double vx_rate_lim_ ; const double steer_lim_ ; const double steer_rate_lim_ ; const double wheelbase_ ; std :: deque < double > acc_input_queue_ ; std :: deque < double > steer_input_queue_ ; const double acc_delay_ ; const double acc_time_constant_ ; const double steer_delay_ ; const double steer_time_constant_ ; const double deadzone_delta_steer_ ; void initializeInputQueue ( const double & dt ); double getX () override ; double getY () override ; double getYaw () override ; double getVx () override ; double getWz () override ; double getSteer () override ; void update ( const double & dt ) override ; Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) override ; }; #endif // SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_TIME_DELAY_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_time_delay.hpp"},{"location":"package/simulation_api/markdown/Files/sim__model__time__delay_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apivehicle_modelsim_model_time_delayhpp","text":"simple planning simulator model with time delay and 1-dimensional dynamics for velocity & steering More...","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_time_delay.hpp"},{"location":"package/simulation_api/markdown/Files/sim__model__time__delay_8hpp/#classes","text":"Name class SimModelTimeDelayTwist class SimModelTimeDelaySteerAccel class SimModelTimeDelaySteer","title":"Classes"},{"location":"package/simulation_api/markdown/Files/sim__model__time__delay_8hpp/#detailed-description","text":"simple planning simulator model with time delay and 1-dimensional dynamics for velocity & steering Author : Takamasa Horibe, Kim-Ngoc-Khanh Nguyen Date : 2019.08.17","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Files/sim__model__time__delay_8hpp/#source-code","text":"// Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_TIME_DELAY_HPP_ #define SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_TIME_DELAY_HPP_ #include <eigen3/Eigen/Core> #include <eigen3/Eigen/LU> #include <simulation_api/vehicle_model/sim_model_interface.hpp> #include <simulation_api/vehicle_model/sim_model_util.hpp> #include <iostream> #include <queue> #include <deque> class SimModelTimeDelayTwist : public SimModelInterface { public : SimModelTimeDelayTwist ( double vx_lim , double angvel_lim , double vx_rate_lim , double wz_rate_lim , double dt , double vx_delay , double vx_time_constant , double wz_delay , double wz_time_constant , double deadzone_delta_steer ); ~ SimModelTimeDelayTwist () = default ; private : const double MIN_TIME_CONSTANT ; enum IDX { X = 0 , Y , YAW , VX , WZ , }; enum IDX_U { VX_DES = 0 , WZ_DES , }; const double vx_lim_ ; const double vx_rate_lim_ ; const double wz_lim_ ; const double wz_rate_lim_ ; std :: deque < double > vx_input_queue_ ; std :: deque < double > wz_input_queue_ ; const double vx_delay_ ; const double vx_time_constant_ ; const double wz_delay_ ; const double wz_time_constant_ ; const double deadzone_delta_steer_ ; void initializeInputQueue ( const double & dt ); double getX () override ; double getY () override ; double getYaw () override ; double getVx () override ; double getWz () override ; double getSteer () override ; void update ( const double & dt ) override ; Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) override ; }; class SimModelTimeDelaySteer : public SimModelInterface { public : SimModelTimeDelaySteer ( double vx_lim , double steer_lim , double vx_rate_lim , double steer_rate_lim , double wheelbase , double dt , double vx_delay , double vx_time_constant , double steer_delay , double steer_time_constant , double deadzone_delta_steer ); ~ SimModelTimeDelaySteer () = default ; private : const double MIN_TIME_CONSTANT ; enum IDX { X = 0 , Y , YAW , VX , STEER , }; enum IDX_U { VX_DES = 0 , STEER_DES , }; const double vx_lim_ ; const double vx_rate_lim_ ; const double steer_lim_ ; const double steer_rate_lim_ ; const double wheelbase_ ; std :: deque < double > vx_input_queue_ ; std :: deque < double > steer_input_queue_ ; const double vx_delay_ ; const double vx_time_constant_ ; const double steer_delay_ ; const double steer_time_constant_ ; const double deadzone_delta_steer_ ; void initializeInputQueue ( const double & dt ); double getX () override ; double getY () override ; double getYaw () override ; double getVx () override ; double getWz () override ; double getSteer () override ; void update ( const double & dt ) override ; Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) override ; }; class SimModelTimeDelaySteerAccel : public SimModelInterface { public : SimModelTimeDelaySteerAccel ( double vx_lim , double steer_lim , double vx_rate_lim , double steer_rate_lim , double wheelbase , double dt , double acc_delay , double acc_time_constant , double steer_delay , double steer_time_constant , double deadzone_delta_steer ); ~ SimModelTimeDelaySteerAccel () = default ; private : const double MIN_TIME_CONSTANT ; enum IDX { X = 0 , Y , YAW , VX , STEER , ACCX , }; enum IDX_U { ACCX_DES = 0 , STEER_DES , DRIVE_SHIFT , }; const double vx_lim_ ; const double vx_rate_lim_ ; const double steer_lim_ ; const double steer_rate_lim_ ; const double wheelbase_ ; std :: deque < double > acc_input_queue_ ; std :: deque < double > steer_input_queue_ ; const double acc_delay_ ; const double acc_time_constant_ ; const double steer_delay_ ; const double steer_time_constant_ ; const double deadzone_delta_steer_ ; void initializeInputQueue ( const double & dt ); double getX () override ; double getY () override ; double getYaw () override ; double getVx () override ; double getWz () override ; double getSteer () override ; void update ( const double & dt ) override ; Eigen :: VectorXd calcModel ( const Eigen :: VectorXd & state , const Eigen :: VectorXd & input ) override ; }; #endif // SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_TIME_DELAY_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/sim__model__util_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_util.cpp # Namespaces # Name sim_model_util Source code # // Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/vehicle_model/sim_model_util.hpp> namespace sim_model_util { double getDummySteerCommandWithFriction ( const double steer , const double steer_command , const double deadzone_delta_steer ) { const double delta_steer = std :: fabs ( steer_command - steer ); // if delta steer is too small, ignore steer command (send current steer as steer command) if ( delta_steer < deadzone_delta_steer ) { return steer ; } return steer_command ; } } // namespace sim_model_util Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_util.cpp"},{"location":"package/simulation_api/markdown/Files/sim__model__util_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcvehicle_modelsim_model_utilcpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/vehicle_model/sim_model_util.cpp"},{"location":"package/simulation_api/markdown/Files/sim__model__util_8cpp/#namespaces","text":"Name sim_model_util","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/sim__model__util_8cpp/#source-code","text":"// Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/vehicle_model/sim_model_util.hpp> namespace sim_model_util { double getDummySteerCommandWithFriction ( const double steer , const double steer_command , const double deadzone_delta_steer ) { const double delta_steer = std :: fabs ( steer_command - steer ); // if delta steer is too small, ignore steer command (send current steer as steer command) if ( delta_steer < deadzone_delta_steer ) { return steer ; } return steer_command ; } } // namespace sim_model_util Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/sim__model__util_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_util.hpp # Namespaces # Name sim_model_util Source code # // Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_UTIL_HPP_ #define SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_UTIL_HPP_ #include <math.h> namespace sim_model_util { double getDummySteerCommandWithFriction ( const double steer , const double steer_command , const double deadzone_delta_steer ); } #endif // SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_UTIL_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_util.hpp"},{"location":"package/simulation_api/markdown/Files/sim__model__util_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apivehicle_modelsim_model_utilhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/vehicle_model/sim_model_util.hpp"},{"location":"package/simulation_api/markdown/Files/sim__model__util_8hpp/#namespaces","text":"Name sim_model_util","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/sim__model__util_8hpp/#source-code","text":"// Copyright 2015-2020 Autoware Foundation. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_UTIL_HPP_ #define SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_UTIL_HPP_ #include <math.h> namespace sim_model_util { double getDummySteerCommandWithFriction ( const double steer , const double steer_command , const double deadzone_delta_steer ); } #endif // SIMULATION_API__VEHICLE_MODEL__SIM_MODEL_UTIL_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/stop__at__crossing__entity__action_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.cpp # Namespaces # Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <string> #include <vector> #include <utility> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { StopAtCrossingEntityAction :: StopAtCrossingEntityAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: VehicleActionNode ( name , config ) { in_stop_sequence_ = false ; } const boost :: optional < openscenario_msgs :: msg :: Obstacle > StopAtCrossingEntityAction :: calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) { if ( ! distance_to_stop_target_ ) { return boost :: none ; } if ( distance_to_stop_target_ . get () < 0 ) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( waypoints . waypoints ); if ( distance_to_stop_target_ . get () > spline . getLength ()) { return boost :: none ; } openscenario_msgs :: msg :: Obstacle obstacle ; obstacle . type = obstacle . ENTITY ; obstacle . s = distance_to_stop_target_ . get (); return obstacle ; } const openscenario_msgs :: msg :: WaypointsArray StopAtCrossingEntityAction :: calculateWaypoints () { if ( ! entity_status . lanelet_pose_valid ) { throw BehaviorTreeRuntimeError ( \"failed to assign lane\" ); } if ( entity_status . action_status . twist . linear . x >= 0 ) { openscenario_msgs :: msg :: WaypointsArray waypoints ; simulation_api :: math :: CatmullRomSpline spline ( hdmap_utils -> getCenterPoints ( route_lanelets )); waypoints . waypoints = spline . getTrajectory ( entity_status . lanelet_pose . s , entity_status . lanelet_pose . s + getHorizon (), 1.0 ); return waypoints ; } else { return openscenario_msgs :: msg :: WaypointsArray (); } } boost :: optional < double > StopAtCrossingEntityAction :: calculateTargetSpeed ( double current_velocity ) { if ( ! distance_to_stop_target_ ) { return boost :: none ; } double rest_distance = distance_to_stop_target_ . get () - ( vehicle_parameters . bounding_box . dimensions . x + 3 ); if ( rest_distance < calculateStopDistance ()) { if ( rest_distance > 0 ) { return std :: sqrt ( 2 * 5 * rest_distance ); } else { return 0 ; } } return current_velocity ; } BT :: NodeStatus StopAtCrossingEntityAction :: tick () { getBlackBoardValues (); if ( request != \"none\" && request != \"follow_lane\" ) { in_stop_sequence_ = false ; return BT :: NodeStatus :: FAILURE ; } if ( ! entity_status . lanelet_pose_valid ) { in_stop_sequence_ = false ; return BT :: NodeStatus :: FAILURE ; } if ( ! driver_model . see_around ) { in_stop_sequence_ = false ; return BT :: NodeStatus :: FAILURE ; } if ( getRightOfWayEntities ( route_lanelets ). size () != 0 ) { in_stop_sequence_ = false ; return BT :: NodeStatus :: FAILURE ; } const auto waypoints = calculateWaypoints (); const auto spline = simulation_api :: math :: CatmullRomSpline ( waypoints . waypoints ); distance_to_stop_target_ = getDistanceToConflictingEntity ( route_lanelets , spline ); auto distance_to_stopline = hdmap_utils -> getDistanceToStopLine ( route_lanelets , waypoints . waypoints ); const auto distance_to_front_entity = getDistanceToFrontEntity (); if (( distance_to_front_entity || distance_to_stopline ) && distance_to_stop_target_ ) { if ( distance_to_front_entity . get () <= distance_to_stop_target_ . get ()) { in_stop_sequence_ = false ; return BT :: NodeStatus :: FAILURE ; } if ( distance_to_stopline . get () <= distance_to_stop_target_ . get ()) { in_stop_sequence_ = false ; return BT :: NodeStatus :: FAILURE ; } } if (( distance_to_front_entity || distance_to_stopline ) && ! distance_to_stop_target_ ) { in_stop_sequence_ = false ; return BT :: NodeStatus :: FAILURE ; } boost :: optional < double > target_linear_speed ; if ( distance_to_stop_target_ ) { target_linear_speed = calculateTargetSpeed ( entity_status . action_status . twist . linear . x ); } else { target_linear_speed = boost :: none ; } if ( ! distance_to_stop_target_ ) { setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( 0 )); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); in_stop_sequence_ = false ; return BT :: NodeStatus :: SUCCESS ; } if ( target_speed ) { if ( target_speed . get () > target_linear_speed . get ()) { target_speed = target_linear_speed . get (); } } else { target_speed = target_linear_speed . get (); } setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( target_speed . get ())); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); in_stop_sequence_ = true ; return BT :: NodeStatus :: RUNNING ; } } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.cpp"},{"location":"package/simulation_api/markdown/Files/stop__at__crossing__entity__action_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorvehiclefollow_lane_sequencestop_at_crossing_entity_actioncpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.cpp"},{"location":"package/simulation_api/markdown/Files/stop__at__crossing__entity__action_8cpp/#namespaces","text":"Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/stop__at__crossing__entity__action_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <string> #include <vector> #include <utility> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { StopAtCrossingEntityAction :: StopAtCrossingEntityAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: VehicleActionNode ( name , config ) { in_stop_sequence_ = false ; } const boost :: optional < openscenario_msgs :: msg :: Obstacle > StopAtCrossingEntityAction :: calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) { if ( ! distance_to_stop_target_ ) { return boost :: none ; } if ( distance_to_stop_target_ . get () < 0 ) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( waypoints . waypoints ); if ( distance_to_stop_target_ . get () > spline . getLength ()) { return boost :: none ; } openscenario_msgs :: msg :: Obstacle obstacle ; obstacle . type = obstacle . ENTITY ; obstacle . s = distance_to_stop_target_ . get (); return obstacle ; } const openscenario_msgs :: msg :: WaypointsArray StopAtCrossingEntityAction :: calculateWaypoints () { if ( ! entity_status . lanelet_pose_valid ) { throw BehaviorTreeRuntimeError ( \"failed to assign lane\" ); } if ( entity_status . action_status . twist . linear . x >= 0 ) { openscenario_msgs :: msg :: WaypointsArray waypoints ; simulation_api :: math :: CatmullRomSpline spline ( hdmap_utils -> getCenterPoints ( route_lanelets )); waypoints . waypoints = spline . getTrajectory ( entity_status . lanelet_pose . s , entity_status . lanelet_pose . s + getHorizon (), 1.0 ); return waypoints ; } else { return openscenario_msgs :: msg :: WaypointsArray (); } } boost :: optional < double > StopAtCrossingEntityAction :: calculateTargetSpeed ( double current_velocity ) { if ( ! distance_to_stop_target_ ) { return boost :: none ; } double rest_distance = distance_to_stop_target_ . get () - ( vehicle_parameters . bounding_box . dimensions . x + 3 ); if ( rest_distance < calculateStopDistance ()) { if ( rest_distance > 0 ) { return std :: sqrt ( 2 * 5 * rest_distance ); } else { return 0 ; } } return current_velocity ; } BT :: NodeStatus StopAtCrossingEntityAction :: tick () { getBlackBoardValues (); if ( request != \"none\" && request != \"follow_lane\" ) { in_stop_sequence_ = false ; return BT :: NodeStatus :: FAILURE ; } if ( ! entity_status . lanelet_pose_valid ) { in_stop_sequence_ = false ; return BT :: NodeStatus :: FAILURE ; } if ( ! driver_model . see_around ) { in_stop_sequence_ = false ; return BT :: NodeStatus :: FAILURE ; } if ( getRightOfWayEntities ( route_lanelets ). size () != 0 ) { in_stop_sequence_ = false ; return BT :: NodeStatus :: FAILURE ; } const auto waypoints = calculateWaypoints (); const auto spline = simulation_api :: math :: CatmullRomSpline ( waypoints . waypoints ); distance_to_stop_target_ = getDistanceToConflictingEntity ( route_lanelets , spline ); auto distance_to_stopline = hdmap_utils -> getDistanceToStopLine ( route_lanelets , waypoints . waypoints ); const auto distance_to_front_entity = getDistanceToFrontEntity (); if (( distance_to_front_entity || distance_to_stopline ) && distance_to_stop_target_ ) { if ( distance_to_front_entity . get () <= distance_to_stop_target_ . get ()) { in_stop_sequence_ = false ; return BT :: NodeStatus :: FAILURE ; } if ( distance_to_stopline . get () <= distance_to_stop_target_ . get ()) { in_stop_sequence_ = false ; return BT :: NodeStatus :: FAILURE ; } } if (( distance_to_front_entity || distance_to_stopline ) && ! distance_to_stop_target_ ) { in_stop_sequence_ = false ; return BT :: NodeStatus :: FAILURE ; } boost :: optional < double > target_linear_speed ; if ( distance_to_stop_target_ ) { target_linear_speed = calculateTargetSpeed ( entity_status . action_status . twist . linear . x ); } else { target_linear_speed = boost :: none ; } if ( ! distance_to_stop_target_ ) { setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( 0 )); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); in_stop_sequence_ = false ; return BT :: NodeStatus :: SUCCESS ; } if ( target_speed ) { if ( target_speed . get () > target_linear_speed . get ()) { target_speed = target_linear_speed . get (); } } else { target_speed = target_linear_speed . get (); } setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( target_speed . get ())); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); in_stop_sequence_ = true ; return BT :: NodeStatus :: RUNNING ; } } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/stop__at__crossing__entity__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.hpp # Namespaces # Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior Classes # Name class entity_behavior::vehicle::follow_lane_sequence::StopAtCrossingEntityAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_CROSSING_ENTITY_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_CROSSING_ENTITY_ACTION_HPP_ #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { class StopAtCrossingEntityAction : public entity_behavior :: VehicleActionNode { public : StopAtCrossingEntityAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: VehicleActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } boost :: optional < double > calculateTargetSpeed ( double current_velocity ); const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override ; const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override ; private : boost :: optional < double > distance_to_stop_target_ ; bool in_stop_sequence_ ; }; } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_CROSSING_ENTITY_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.hpp"},{"location":"package/simulation_api/markdown/Files/stop__at__crossing__entity__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorvehiclefollow_lane_sequencestop_at_crossing_entity_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.hpp"},{"location":"package/simulation_api/markdown/Files/stop__at__crossing__entity__action_8hpp/#namespaces","text":"Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/stop__at__crossing__entity__action_8hpp/#classes","text":"Name class entity_behavior::vehicle::follow_lane_sequence::StopAtCrossingEntityAction","title":"Classes"},{"location":"package/simulation_api/markdown/Files/stop__at__crossing__entity__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_CROSSING_ENTITY_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_CROSSING_ENTITY_ACTION_HPP_ #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { class StopAtCrossingEntityAction : public entity_behavior :: VehicleActionNode { public : StopAtCrossingEntityAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: VehicleActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } boost :: optional < double > calculateTargetSpeed ( double current_velocity ); const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override ; const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override ; private : boost :: optional < double > distance_to_stop_target_ ; bool in_stop_sequence_ ; }; } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_CROSSING_ENTITY_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/stop__at__stop__line__action_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.cpp # Namespaces # Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <string> #include <vector> #include <utility> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { StopAtStopLineAction :: StopAtStopLineAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: VehicleActionNode ( name , config ) { stopped_ = false ; } const boost :: optional < openscenario_msgs :: msg :: Obstacle > StopAtStopLineAction :: calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) { if ( ! distance_to_stopline_ ) { return boost :: none ; } if ( distance_to_stopline_ . get () < 0 ) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( waypoints . waypoints ); if ( distance_to_stopline_ . get () > spline . getLength ()) { return boost :: none ; } openscenario_msgs :: msg :: Obstacle obstacle ; obstacle . type = obstacle . ENTITY ; obstacle . s = distance_to_stopline_ . get (); return obstacle ; } const openscenario_msgs :: msg :: WaypointsArray StopAtStopLineAction :: calculateWaypoints () { if ( ! entity_status . lanelet_pose_valid ) { throw BehaviorTreeRuntimeError ( \"failed to assign lane\" ); } if ( entity_status . action_status . twist . linear . x >= 0 ) { openscenario_msgs :: msg :: WaypointsArray waypoints ; double horizon = boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x * 5 , 20 , 50 ); simulation_api :: math :: CatmullRomSpline spline ( hdmap_utils -> getCenterPoints ( route_lanelets )); waypoints . waypoints = spline . getTrajectory ( entity_status . lanelet_pose . s , entity_status . lanelet_pose . s + horizon , 1.0 ); return waypoints ; } else { return openscenario_msgs :: msg :: WaypointsArray (); } } boost :: optional < double > StopAtStopLineAction :: calculateTargetSpeed ( double current_velocity ) { if ( ! distance_to_stopline_ ) { return boost :: none ; } double rest_distance = distance_to_stopline_ . get () - ( vehicle_parameters . bounding_box . dimensions . x ); if ( rest_distance < calculateStopDistance ()) { if ( rest_distance > 0 ) { return std :: sqrt ( 2 * 5 * rest_distance ); } else { return 0 ; } } return current_velocity ; } BT :: NodeStatus StopAtStopLineAction :: tick () { getBlackBoardValues (); if ( request != \"none\" && request != \"follow_lane\" ) { stopped_ = false ; return BT :: NodeStatus :: FAILURE ; } if ( ! driver_model . see_around ) { return BT :: NodeStatus :: FAILURE ; } if ( getRightOfWayEntities ( route_lanelets ). size () != 0 ) { return BT :: NodeStatus :: FAILURE ; } const auto waypoints = calculateWaypoints (); distance_to_stopline_ = hdmap_utils -> getDistanceToStopLine ( route_lanelets , waypoints . waypoints ); if ( std :: fabs ( entity_status . action_status . twist . linear . x ) < 0.001 ) { if ( distance_to_stopline_ ) { if ( distance_to_stopline_ . get () <= vehicle_parameters . bounding_box . dimensions . x + 5 ) { stopped_ = true ; } } } if ( stopped_ ) { if ( ! target_speed ) { target_speed = hdmap_utils -> getSpeedLimit ( route_lanelets ); } if ( ! distance_to_stopline_ ) { stopped_ = false ; setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( target_speed . get ())); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: SUCCESS ; } setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( target_speed . get ())); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: RUNNING ; } auto target_linear_speed = calculateTargetSpeed ( entity_status . action_status . twist . linear . x ); if ( ! target_linear_speed ) { stopped_ = false ; return BT :: NodeStatus :: FAILURE ; } if ( target_speed ) { if ( target_speed . get () > target_linear_speed . get ()) { target_speed = target_linear_speed . get (); } } else { target_speed = target_linear_speed . get (); } setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( target_speed . get ())); stopped_ = false ; const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: RUNNING ; } } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.cpp"},{"location":"package/simulation_api/markdown/Files/stop__at__stop__line__action_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorvehiclefollow_lane_sequencestop_at_stop_line_actioncpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.cpp"},{"location":"package/simulation_api/markdown/Files/stop__at__stop__line__action_8cpp/#namespaces","text":"Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/stop__at__stop__line__action_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <string> #include <vector> #include <utility> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { StopAtStopLineAction :: StopAtStopLineAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: VehicleActionNode ( name , config ) { stopped_ = false ; } const boost :: optional < openscenario_msgs :: msg :: Obstacle > StopAtStopLineAction :: calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) { if ( ! distance_to_stopline_ ) { return boost :: none ; } if ( distance_to_stopline_ . get () < 0 ) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( waypoints . waypoints ); if ( distance_to_stopline_ . get () > spline . getLength ()) { return boost :: none ; } openscenario_msgs :: msg :: Obstacle obstacle ; obstacle . type = obstacle . ENTITY ; obstacle . s = distance_to_stopline_ . get (); return obstacle ; } const openscenario_msgs :: msg :: WaypointsArray StopAtStopLineAction :: calculateWaypoints () { if ( ! entity_status . lanelet_pose_valid ) { throw BehaviorTreeRuntimeError ( \"failed to assign lane\" ); } if ( entity_status . action_status . twist . linear . x >= 0 ) { openscenario_msgs :: msg :: WaypointsArray waypoints ; double horizon = boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x * 5 , 20 , 50 ); simulation_api :: math :: CatmullRomSpline spline ( hdmap_utils -> getCenterPoints ( route_lanelets )); waypoints . waypoints = spline . getTrajectory ( entity_status . lanelet_pose . s , entity_status . lanelet_pose . s + horizon , 1.0 ); return waypoints ; } else { return openscenario_msgs :: msg :: WaypointsArray (); } } boost :: optional < double > StopAtStopLineAction :: calculateTargetSpeed ( double current_velocity ) { if ( ! distance_to_stopline_ ) { return boost :: none ; } double rest_distance = distance_to_stopline_ . get () - ( vehicle_parameters . bounding_box . dimensions . x ); if ( rest_distance < calculateStopDistance ()) { if ( rest_distance > 0 ) { return std :: sqrt ( 2 * 5 * rest_distance ); } else { return 0 ; } } return current_velocity ; } BT :: NodeStatus StopAtStopLineAction :: tick () { getBlackBoardValues (); if ( request != \"none\" && request != \"follow_lane\" ) { stopped_ = false ; return BT :: NodeStatus :: FAILURE ; } if ( ! driver_model . see_around ) { return BT :: NodeStatus :: FAILURE ; } if ( getRightOfWayEntities ( route_lanelets ). size () != 0 ) { return BT :: NodeStatus :: FAILURE ; } const auto waypoints = calculateWaypoints (); distance_to_stopline_ = hdmap_utils -> getDistanceToStopLine ( route_lanelets , waypoints . waypoints ); if ( std :: fabs ( entity_status . action_status . twist . linear . x ) < 0.001 ) { if ( distance_to_stopline_ ) { if ( distance_to_stopline_ . get () <= vehicle_parameters . bounding_box . dimensions . x + 5 ) { stopped_ = true ; } } } if ( stopped_ ) { if ( ! target_speed ) { target_speed = hdmap_utils -> getSpeedLimit ( route_lanelets ); } if ( ! distance_to_stopline_ ) { stopped_ = false ; setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( target_speed . get ())); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: SUCCESS ; } setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( target_speed . get ())); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: RUNNING ; } auto target_linear_speed = calculateTargetSpeed ( entity_status . action_status . twist . linear . x ); if ( ! target_linear_speed ) { stopped_ = false ; return BT :: NodeStatus :: FAILURE ; } if ( target_speed ) { if ( target_speed . get () > target_linear_speed . get ()) { target_speed = target_linear_speed . get (); } } else { target_speed = target_linear_speed . get (); } setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( target_speed . get ())); stopped_ = false ; const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: RUNNING ; } } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/stop__at__stop__line__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.hpp # Namespaces # Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior Classes # Name class entity_behavior::vehicle::follow_lane_sequence::StopAtStopLineAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_STOP_LINE_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_STOP_LINE_ACTION_HPP_ #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { class StopAtStopLineAction : public entity_behavior :: VehicleActionNode { public : StopAtStopLineAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: VehicleActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } boost :: optional < double > calculateTargetSpeed ( double current_velocity ); const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override ; const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override ; private : bool stopped_ ; boost :: optional < double > distance_to_stopline_ ; }; } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_STOP_LINE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.hpp"},{"location":"package/simulation_api/markdown/Files/stop__at__stop__line__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorvehiclefollow_lane_sequencestop_at_stop_line_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.hpp"},{"location":"package/simulation_api/markdown/Files/stop__at__stop__line__action_8hpp/#namespaces","text":"Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/stop__at__stop__line__action_8hpp/#classes","text":"Name class entity_behavior::vehicle::follow_lane_sequence::StopAtStopLineAction","title":"Classes"},{"location":"package/simulation_api/markdown/Files/stop__at__stop__line__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_STOP_LINE_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_STOP_LINE_ACTION_HPP_ #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { class StopAtStopLineAction : public entity_behavior :: VehicleActionNode { public : StopAtStopLineAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: VehicleActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } boost :: optional < double > calculateTargetSpeed ( double current_velocity ); const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override ; const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override ; private : bool stopped_ ; boost :: optional < double > distance_to_stopline_ ; }; } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_STOP_LINE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/stop__at__traffic__light__action_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.cpp # Namespaces # Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <string> #include <vector> #include <utility> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { StopAtTrafficLightAction :: StopAtTrafficLightAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: VehicleActionNode ( name , config ) {} const boost :: optional < openscenario_msgs :: msg :: Obstacle > StopAtTrafficLightAction :: calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) { if ( ! distance_to_stop_target_ ) { return boost :: none ; } if ( distance_to_stop_target_ . get () < 0 ) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( waypoints . waypoints ); if ( distance_to_stop_target_ . get () > spline . getLength ()) { return boost :: none ; } openscenario_msgs :: msg :: Obstacle obstacle ; obstacle . type = obstacle . ENTITY ; obstacle . s = distance_to_stop_target_ . get (); return obstacle ; } const openscenario_msgs :: msg :: WaypointsArray StopAtTrafficLightAction :: calculateWaypoints () { if ( ! entity_status . lanelet_pose_valid ) { throw BehaviorTreeRuntimeError ( \"failed to assign lane\" ); } if ( entity_status . action_status . twist . linear . x >= 0 ) { openscenario_msgs :: msg :: WaypointsArray waypoints ; simulation_api :: math :: CatmullRomSpline spline ( hdmap_utils -> getCenterPoints ( route_lanelets )); waypoints . waypoints = spline . getTrajectory ( entity_status . lanelet_pose . s , entity_status . lanelet_pose . s + getHorizon (), 1.0 ); return waypoints ; } else { return openscenario_msgs :: msg :: WaypointsArray (); } } boost :: optional < double > StopAtTrafficLightAction :: calculateTargetSpeed ( double current_velocity ) { if ( ! distance_to_stop_target_ ) { return boost :: none ; } double rest_distance = distance_to_stop_target_ . get () - ( vehicle_parameters . bounding_box . dimensions . x + 3 ); if ( rest_distance < calculateStopDistance ()) { if ( rest_distance > 0 ) { return std :: sqrt ( 2 * 5 * rest_distance ); } else { return 0 ; } } return current_velocity ; } BT :: NodeStatus StopAtTrafficLightAction :: tick () { getBlackBoardValues (); if ( request != \"none\" && request != \"follow_lane\" ) { return BT :: NodeStatus :: FAILURE ; } if ( ! entity_status . lanelet_pose_valid ) { return BT :: NodeStatus :: FAILURE ; } if ( ! driver_model . see_around ) { return BT :: NodeStatus :: FAILURE ; } if ( getRightOfWayEntities ( route_lanelets ). size () != 0 ) { return BT :: NodeStatus :: FAILURE ; } const auto waypoints = calculateWaypoints (); const auto spline = simulation_api :: math :: CatmullRomSpline ( waypoints . waypoints ); const auto distance_to_traffic_stop_line = hdmap_utils -> getDistanceToTrafficLightStopLine ( route_lanelets , waypoints . waypoints ); if ( ! distance_to_traffic_stop_line ) { return BT :: NodeStatus :: FAILURE ; } distance_to_stop_target_ = getDistanceToTrafficLightStopLine ( route_lanelets , waypoints . waypoints ); boost :: optional < double > target_linear_speed ; if ( distance_to_stop_target_ ) { if ( distance_to_stop_target_ . get () > getHorizon ()) { return BT :: NodeStatus :: FAILURE ; } target_linear_speed = calculateTargetSpeed ( entity_status . action_status . twist . linear . x ); } else { return BT :: NodeStatus :: FAILURE ; } if ( ! distance_to_stop_target_ ) { setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( 0 )); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: SUCCESS ; } if ( target_speed ) { if ( target_speed . get () > target_linear_speed . get ()) { target_speed = target_linear_speed . get (); } } else { target_speed = target_linear_speed . get (); } setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( target_speed . get ())); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: RUNNING ; } } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.cpp"},{"location":"package/simulation_api/markdown/Files/stop__at__traffic__light__action_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorvehiclefollow_lane_sequencestop_at_traffic_light_actioncpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.cpp"},{"location":"package/simulation_api/markdown/Files/stop__at__traffic__light__action_8cpp/#namespaces","text":"Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/stop__at__traffic__light__action_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <string> #include <vector> #include <utility> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { StopAtTrafficLightAction :: StopAtTrafficLightAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: VehicleActionNode ( name , config ) {} const boost :: optional < openscenario_msgs :: msg :: Obstacle > StopAtTrafficLightAction :: calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) { if ( ! distance_to_stop_target_ ) { return boost :: none ; } if ( distance_to_stop_target_ . get () < 0 ) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( waypoints . waypoints ); if ( distance_to_stop_target_ . get () > spline . getLength ()) { return boost :: none ; } openscenario_msgs :: msg :: Obstacle obstacle ; obstacle . type = obstacle . ENTITY ; obstacle . s = distance_to_stop_target_ . get (); return obstacle ; } const openscenario_msgs :: msg :: WaypointsArray StopAtTrafficLightAction :: calculateWaypoints () { if ( ! entity_status . lanelet_pose_valid ) { throw BehaviorTreeRuntimeError ( \"failed to assign lane\" ); } if ( entity_status . action_status . twist . linear . x >= 0 ) { openscenario_msgs :: msg :: WaypointsArray waypoints ; simulation_api :: math :: CatmullRomSpline spline ( hdmap_utils -> getCenterPoints ( route_lanelets )); waypoints . waypoints = spline . getTrajectory ( entity_status . lanelet_pose . s , entity_status . lanelet_pose . s + getHorizon (), 1.0 ); return waypoints ; } else { return openscenario_msgs :: msg :: WaypointsArray (); } } boost :: optional < double > StopAtTrafficLightAction :: calculateTargetSpeed ( double current_velocity ) { if ( ! distance_to_stop_target_ ) { return boost :: none ; } double rest_distance = distance_to_stop_target_ . get () - ( vehicle_parameters . bounding_box . dimensions . x + 3 ); if ( rest_distance < calculateStopDistance ()) { if ( rest_distance > 0 ) { return std :: sqrt ( 2 * 5 * rest_distance ); } else { return 0 ; } } return current_velocity ; } BT :: NodeStatus StopAtTrafficLightAction :: tick () { getBlackBoardValues (); if ( request != \"none\" && request != \"follow_lane\" ) { return BT :: NodeStatus :: FAILURE ; } if ( ! entity_status . lanelet_pose_valid ) { return BT :: NodeStatus :: FAILURE ; } if ( ! driver_model . see_around ) { return BT :: NodeStatus :: FAILURE ; } if ( getRightOfWayEntities ( route_lanelets ). size () != 0 ) { return BT :: NodeStatus :: FAILURE ; } const auto waypoints = calculateWaypoints (); const auto spline = simulation_api :: math :: CatmullRomSpline ( waypoints . waypoints ); const auto distance_to_traffic_stop_line = hdmap_utils -> getDistanceToTrafficLightStopLine ( route_lanelets , waypoints . waypoints ); if ( ! distance_to_traffic_stop_line ) { return BT :: NodeStatus :: FAILURE ; } distance_to_stop_target_ = getDistanceToTrafficLightStopLine ( route_lanelets , waypoints . waypoints ); boost :: optional < double > target_linear_speed ; if ( distance_to_stop_target_ ) { if ( distance_to_stop_target_ . get () > getHorizon ()) { return BT :: NodeStatus :: FAILURE ; } target_linear_speed = calculateTargetSpeed ( entity_status . action_status . twist . linear . x ); } else { return BT :: NodeStatus :: FAILURE ; } if ( ! distance_to_stop_target_ ) { setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( 0 )); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: SUCCESS ; } if ( target_speed ) { if ( target_speed . get () > target_linear_speed . get ()) { target_speed = target_linear_speed . get (); } } else { target_speed = target_linear_speed . get (); } setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( target_speed . get ())); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: RUNNING ; } } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/stop__at__traffic__light__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.hpp # Namespaces # Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior Classes # Name class entity_behavior::vehicle::follow_lane_sequence::StopAtTrafficLightAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_TRAFFIC_LIGHT_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_TRAFFIC_LIGHT_ACTION_HPP_ #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { class StopAtTrafficLightAction : public entity_behavior :: VehicleActionNode { public : StopAtTrafficLightAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: VehicleActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } boost :: optional < double > calculateTargetSpeed ( double current_velocity ); const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override ; const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override ; private : boost :: optional < double > distance_to_stop_target_ ; }; } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_TRAFFIC_LIGHT_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.hpp"},{"location":"package/simulation_api/markdown/Files/stop__at__traffic__light__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorvehiclefollow_lane_sequencestop_at_traffic_light_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.hpp"},{"location":"package/simulation_api/markdown/Files/stop__at__traffic__light__action_8hpp/#namespaces","text":"Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/stop__at__traffic__light__action_8hpp/#classes","text":"Name class entity_behavior::vehicle::follow_lane_sequence::StopAtTrafficLightAction","title":"Classes"},{"location":"package/simulation_api/markdown/Files/stop__at__traffic__light__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_TRAFFIC_LIGHT_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_TRAFFIC_LIGHT_ACTION_HPP_ #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { class StopAtTrafficLightAction : public entity_behavior :: VehicleActionNode { public : StopAtTrafficLightAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: VehicleActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } boost :: optional < double > calculateTargetSpeed ( double current_velocity ); const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override ; const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override ; private : boost :: optional < double > distance_to_stop_target_ ; }; } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__STOP_AT_TRAFFIC_LIGHT_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/stop__watch_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper/stop_watch.hpp # Namespaces # Name simulation_api::helper simulation_api Classes # Name class simulation_api::helper::StopWatch Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__HELPER__STOP_WATCH_HPP_ #define SIMULATION_API__HELPER__STOP_WATCH_HPP_ #include <boost/optional.hpp> #include <chrono> #include <string> #include <iostream> namespace simulation_api { namespace helper { template < typename T > class StopWatch { public : explicit StopWatch ( const std :: string & name ) : name ( name ) {} void start () { end_time = boost :: none ; start_time = std :: chrono :: system_clock :: now (); } void stop () { end_time = std :: chrono :: system_clock :: now (); } void print () { if ( start_time && end_time ) { double elapsed = std :: chrono :: duration_cast < T > ( end_time . get () - start_time . get ()). count (); if ( typeid ( T ) == typeid ( std :: chrono :: microseconds )) { std :: cout << \"elapsed time in stop watch \" << name << \" : \" << elapsed << \" microseconds\" << std :: endl ; } if ( typeid ( T ) == typeid ( std :: chrono :: milliseconds )) { std :: cout << \"elapsed time in stop watch \" << name << \" : \" << elapsed << \" milliseconds\" << std :: endl ; } if ( typeid ( T ) == typeid ( std :: chrono :: seconds )) { std :: cout << \"elapsed time in stop watch \" << name << \" : \" << elapsed << \" seconds\" << std :: endl ; } } } private : const std :: string name ; boost :: optional < std :: chrono :: system_clock :: time_point > start_time , end_time ; }; } // namespace helper } // namespace simulation_api #endif // SIMULATION_API__HELPER__STOP_WATCH_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper/stop_watch.hpp"},{"location":"package/simulation_api/markdown/Files/stop__watch_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apihelperstop_watchhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/helper/stop_watch.hpp"},{"location":"package/simulation_api/markdown/Files/stop__watch_8hpp/#namespaces","text":"Name simulation_api::helper simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/stop__watch_8hpp/#classes","text":"Name class simulation_api::helper::StopWatch","title":"Classes"},{"location":"package/simulation_api/markdown/Files/stop__watch_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__HELPER__STOP_WATCH_HPP_ #define SIMULATION_API__HELPER__STOP_WATCH_HPP_ #include <boost/optional.hpp> #include <chrono> #include <string> #include <iostream> namespace simulation_api { namespace helper { template < typename T > class StopWatch { public : explicit StopWatch ( const std :: string & name ) : name ( name ) {} void start () { end_time = boost :: none ; start_time = std :: chrono :: system_clock :: now (); } void stop () { end_time = std :: chrono :: system_clock :: now (); } void print () { if ( start_time && end_time ) { double elapsed = std :: chrono :: duration_cast < T > ( end_time . get () - start_time . get ()). count (); if ( typeid ( T ) == typeid ( std :: chrono :: microseconds )) { std :: cout << \"elapsed time in stop watch \" << name << \" : \" << elapsed << \" microseconds\" << std :: endl ; } if ( typeid ( T ) == typeid ( std :: chrono :: milliseconds )) { std :: cout << \"elapsed time in stop watch \" << name << \" : \" << elapsed << \" milliseconds\" << std :: endl ; } if ( typeid ( T ) == typeid ( std :: chrono :: seconds )) { std :: cout << \"elapsed time in stop watch \" << name << \" : \" << elapsed << \" seconds\" << std :: endl ; } } } private : const std :: string name ; boost :: optional < std :: chrono :: system_clock :: time_point > start_time , end_time ; }; } // namespace helper } // namespace simulation_api #endif // SIMULATION_API__HELPER__STOP_WATCH_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/test__hdmap__utils_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src/test_hdmap_utils.cpp # Functions # Name int main (int argc, char ** argv) TEST (HdMapUtils , HdMapUtils1 ) Functions Documentation # function main # int main ( int argc , char ** argv ) function TEST # TEST ( HdMapUtils , HdMapUtils1 ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <ament_index_cpp/get_package_share_directory.hpp> #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <string> TEST ( HdMapUtils , HdMapUtils1 ) { std :: string path = ament_index_cpp :: get_package_share_directory ( \"simulation_api\" ) + \"/map/lanelet2_map.osm\" ; geographic_msgs :: msg :: GeoPoint origin ; origin . latitude = 35.61836750154 ; origin . longitude = 139.78066608243 ; hdmap_utils :: HdMapUtils hdmap_utils ( path , origin ); ASSERT_NO_THROW ( hdmap_utils . toMapBin ()); } int main ( int argc , char ** argv ) { testing :: InitGoogleTest ( & argc , argv ); return RUN_ALL_TESTS (); } Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src/test_hdmap_utils.cpp"},{"location":"package/simulation_api/markdown/Files/test__hdmap__utils_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apitestsrctest_hdmap_utilscpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src/test_hdmap_utils.cpp"},{"location":"package/simulation_api/markdown/Files/test__hdmap__utils_8cpp/#functions","text":"Name int main (int argc, char ** argv) TEST (HdMapUtils , HdMapUtils1 )","title":"Functions"},{"location":"package/simulation_api/markdown/Files/test__hdmap__utils_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/simulation_api/markdown/Files/test__hdmap__utils_8cpp/#function-main","text":"int main ( int argc , char ** argv )","title":"function main"},{"location":"package/simulation_api/markdown/Files/test__hdmap__utils_8cpp/#function-test","text":"TEST ( HdMapUtils , HdMapUtils1 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__hdmap__utils_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <ament_index_cpp/get_package_share_directory.hpp> #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <string> TEST ( HdMapUtils , HdMapUtils1 ) { std :: string path = ament_index_cpp :: get_package_share_directory ( \"simulation_api\" ) + \"/map/lanelet2_map.osm\" ; geographic_msgs :: msg :: GeoPoint origin ; origin . latitude = 35.61836750154 ; origin . longitude = 139.78066608243 ; hdmap_utils :: HdMapUtils hdmap_utils ( path , origin ); ASSERT_NO_THROW ( hdmap_utils . toMapBin ()); } int main ( int argc , char ** argv ) { testing :: InitGoogleTest ( & argc , argv ); return RUN_ALL_TESTS (); } Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src/test_math.cpp # Functions # Name int main (int argc, char ** argv) TEST (Math , PolynomialSolver1 ) TEST (Math , PolynomialSolver2 ) TEST (Math , PolynomialSolver3 ) TEST (Math , HermiteCurve1 ) TEST (Math , HermiteCurve2 ) TEST (Math , CatmullRomSpline1 ) TEST (Math , CatmullRomSpline2 ) TEST (Math , CatmullRomSpline3 ) TEST (Math , CatmullRomSpline4 ) TEST (Math , CatmullRomSpline5 ) TEST (Math , CatmullRomSpline6 ) TEST (Math , CatmullRomSpline7 ) TEST (Math , BoundingBox0 ) TEST (Math , BoundingBox1 ) TEST (Math , UUID ) TEST (Math , Distance0 ) TEST (Math , Distance1 ) TEST (Math , Distance2 ) TEST (Math , Distance3 ) Functions Documentation # function main # int main ( int argc , char ** argv ) function TEST # TEST ( Math , PolynomialSolver1 ) function TEST # TEST ( Math , PolynomialSolver2 ) function TEST # TEST ( Math , PolynomialSolver3 ) function TEST # TEST ( Math , HermiteCurve1 ) function TEST # TEST ( Math , HermiteCurve2 ) function TEST # TEST ( Math , CatmullRomSpline1 ) function TEST # TEST ( Math , CatmullRomSpline2 ) function TEST # TEST ( Math , CatmullRomSpline3 ) function TEST # TEST ( Math , CatmullRomSpline4 ) function TEST # TEST ( Math , CatmullRomSpline5 ) function TEST # TEST ( Math , CatmullRomSpline6 ) function TEST # TEST ( Math , CatmullRomSpline7 ) function TEST # TEST ( Math , BoundingBox0 ) function TEST # TEST ( Math , BoundingBox1 ) function TEST # TEST ( Math , UUID ) function TEST # TEST ( Math , Distance0 ) function TEST # TEST ( Math , Distance1 ) function TEST # TEST ( Math , Distance2 ) function TEST # TEST ( Math , Distance3 ) Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <simulation_api/math/bounding_box.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <simulation_api/math/distance.hpp> #include <simulation_api/math/hermite_curve.hpp> #include <simulation_api/math/polynomial_solver.hpp> #include <simulation_api/math/uuid.hpp> TEST ( Math , PolynomialSolver1 ) { simulation_api :: math :: PolynomialSolver solver ; auto ret = solver . solveLinearEquation ( -20 , 3 , 0 , 1 ); EXPECT_EQ ( ret . size (), static_cast < size_t > ( 1 )); EXPECT_DOUBLE_EQ ( ret [ 0 ], 0.15 ); } TEST ( Math , PolynomialSolver2 ) { simulation_api :: math :: PolynomialSolver solver ; auto ret = solver . solveQuadraticEquation ( 2 , 3 , -5 , 0 , 2 ); EXPECT_EQ ( ret . size (), static_cast < size_t > ( 1 )); EXPECT_DOUBLE_EQ ( ret [ 0 ], 1 ); } TEST ( Math , PolynomialSolver3 ) { simulation_api :: math :: PolynomialSolver solver ; auto ret = solver . solveCubicEquation ( 1 , -2 , -11 , 12 , 0 , 2 ); EXPECT_EQ ( ret . size (), static_cast < size_t > ( 1 )); EXPECT_DOUBLE_EQ ( ret [ 0 ], 1 ); } TEST ( Math , HermiteCurve1 ) { geometry_msgs :: msg :: Pose start_pose , goal_pose ; geometry_msgs :: msg :: Vector3 start_vec , goal_vec ; goal_pose . position . x = 1 ; start_vec . x = 1 ; goal_vec . x = 1 ; simulation_api :: math :: HermiteCurve curve ( start_pose , goal_pose , start_vec , goal_vec ); EXPECT_DOUBLE_EQ ( curve . getLength (), 1 ); EXPECT_DOUBLE_EQ ( curve . getPoint ( 0.5 , false ). x , 0.5 ); EXPECT_DOUBLE_EQ ( curve . getTangentVector ( 0.5 , false ). x , 1 ); EXPECT_DOUBLE_EQ ( curve . getMaximu2DCurvature (), 0 ); geometry_msgs :: msg :: Point p ; p . x = 0.1 ; p . y = 0 ; p . z = 0 ; EXPECT_TRUE ( curve . getSValue ( p , true )); EXPECT_TRUE ( ( curve . getSValue ( p , true ). get () > 0.099 ) && ( curve . getSValue ( p , true ). get () < 0.101 )); geometry_msgs :: msg :: Point start ; start . x = 0.1 ; start . y = 1.0 ; geometry_msgs :: msg :: Point goal ; goal . x = 0.1 ; goal . y = -1.0 ; auto collision_s = curve . getCollisionPointIn2D ( start , goal ); EXPECT_TRUE ( collision_s ); if ( collision_s ) { EXPECT_DOUBLE_EQ ( collision_s . get (), 0.1 ); } } TEST ( Math , HermiteCurve2 ) { geometry_msgs :: msg :: Pose start_pose , goal_pose ; geometry_msgs :: msg :: Vector3 start_vec , goal_vec ; goal_pose . position . x = 1 ; start_vec . x = 1 ; goal_vec . x = 1 ; simulation_api :: math :: HermiteCurve curve ( start_pose , goal_pose , start_vec , goal_vec ); EXPECT_DOUBLE_EQ ( curve . getLength (), 1 ); EXPECT_DOUBLE_EQ ( curve . getPoint ( 0.5 , false ). x , 0.5 ); EXPECT_DOUBLE_EQ ( curve . getTangentVector ( 0.5 , false ). x , 1 ); EXPECT_DOUBLE_EQ ( curve . getMaximu2DCurvature (), 0 ); geometry_msgs :: msg :: Point p ; p . x = 0.1 ; p . y = 0 ; p . z = 0 ; EXPECT_TRUE ( curve . getSValue ( p , true )); EXPECT_TRUE ( ( curve . getSValue ( p , true ). get () > 0.099 ) && ( curve . getSValue ( p , true ). get () < 0.101 )); geometry_msgs :: msg :: Point start ; start . x = 0.1 ; start . y = 1.0 ; geometry_msgs :: msg :: Point goal ; goal . x = 0.2 ; goal . y = -1.0 ; auto collision_s = curve . getCollisionPointIn2D ( start , goal ); EXPECT_TRUE ( collision_s ); if ( collision_s ) { EXPECT_DOUBLE_EQ ( collision_s . get (), 0.15 ); } } TEST ( Math , CatmullRomSpline1 ) { geometry_msgs :: msg :: Point p0 ; geometry_msgs :: msg :: Point p1 ; p1 . x = 1 ; geometry_msgs :: msg :: Point p2 ; p2 . x = 2 ; auto points = { p0 , p1 , p2 }; auto spline = simulation_api :: math :: CatmullRomSpline ( points ); EXPECT_DOUBLE_EQ ( spline . getLength (), 2 ); geometry_msgs :: msg :: Point start ; start . x = 0.1 ; start . y = 1.0 ; geometry_msgs :: msg :: Point goal ; goal . x = 0.1 ; goal . y = -1.0 ; auto collision_s = spline . getCollisionPointIn2D ( start , goal ); EXPECT_TRUE ( collision_s ); if ( collision_s ) { EXPECT_DOUBLE_EQ ( collision_s . get (), 0.1 ); } collision_s = spline . getCollisionPointIn2D ( start , goal , false ); EXPECT_TRUE ( collision_s ); if ( collision_s ) { EXPECT_DOUBLE_EQ ( collision_s . get (), 0.1 ); } } TEST ( Math , CatmullRomSpline2 ) { geometry_msgs :: msg :: Point p0 ; geometry_msgs :: msg :: Point p1 ; p1 . x = 1 ; p1 . y = 3 ; geometry_msgs :: msg :: Point p2 ; p2 . x = 2 ; p2 . y = 5 ; auto points = { p0 , p1 , p2 }; EXPECT_NO_THROW ( auto spline = simulation_api :: math :: CatmullRomSpline ( points )); } TEST ( Math , CatmullRomSpline3 ) { geometry_msgs :: msg :: Point p0 ; geometry_msgs :: msg :: Point p1 ; p1 . x = 1 ; p1 . y = 3 ; geometry_msgs :: msg :: Point p2 ; p2 . x = 2 ; p2 . y = 5 ; geometry_msgs :: msg :: Point p3 ; p3 . x = 4 ; p3 . y = 6 ; auto points = { p0 , p1 , p2 , p3 }; EXPECT_NO_THROW ( auto spline = simulation_api :: math :: CatmullRomSpline ( points )); } TEST ( Math , CatmullRomSpline4 ) { geometry_msgs :: msg :: Point p0 ; geometry_msgs :: msg :: Point p1 ; p1 . x = 1 ; p1 . y = 3 ; geometry_msgs :: msg :: Point p2 ; p2 . x = 2 ; p2 . y = 5 ; geometry_msgs :: msg :: Point p3 ; p3 . x = 4 ; p3 . y = 6 ; geometry_msgs :: msg :: Point p4 ; p4 . x = 4 ; p4 . y = 10 ; auto points = { p0 , p1 , p2 , p3 , p4 }; EXPECT_NO_THROW ( auto spline = simulation_api :: math :: CatmullRomSpline ( points )); } TEST ( Math , CatmullRomSpline5 ) { geometry_msgs :: msg :: Point p0 ; geometry_msgs :: msg :: Point p1 ; p1 . x = 1 ; geometry_msgs :: msg :: Point p2 ; p2 . x = 2 ; geometry_msgs :: msg :: Point p3 ; p3 . x = 3 ; geometry_msgs :: msg :: Point p4 ; p4 . x = 4 ; auto points = { p0 , p1 , p2 , p3 , p4 }; auto spline = simulation_api :: math :: CatmullRomSpline ( points ); EXPECT_DOUBLE_EQ ( spline . getLength (), 4 ); auto point = spline . getPoint ( 3 ); EXPECT_DOUBLE_EQ ( point . x , 3 ); EXPECT_DOUBLE_EQ ( point . y , 0 ); EXPECT_DOUBLE_EQ ( point . z , 0 ); } TEST ( Math , CatmullRomSpline6 ) { geometry_msgs :: msg :: Point p0 ; p0 . x = -30.9281 ; p0 . y = -23.1708 ; p0 . z = -0.132544 ; geometry_msgs :: msg :: Point p1 ; p1 . x = -29.2938 ; p1 . y = -22.2938 ; p1 . z = -0.162124 ; geometry_msgs :: msg :: Point p2 ; p2 . x = -27.6596 ; p2 . y = -21.4167 ; p2 . z = -0.191704 ; geometry_msgs :: msg :: Point p3 ; p3 . x = -33.0324 ; p3 . y = -92.7566 ; p3 . z = 2.28524 ; auto points = { p0 , p1 , p2 , p3 }; auto spline = simulation_api :: math :: CatmullRomSpline ( points ); } TEST ( Math , CatmullRomSpline7 ) { geometry_msgs :: msg :: Point p0 ; geometry_msgs :: msg :: Point p1 ; p1 . x = 1 ; geometry_msgs :: msg :: Point p2 ; p2 . x = 2 ; geometry_msgs :: msg :: Point p3 ; p3 . x = 4 ; auto points = { p0 , p1 , p2 , p3 }; auto spline = simulation_api :: math :: CatmullRomSpline ( points ); geometry_msgs :: msg :: Point p ; p . x = 0.1 ; p . y = 0 ; p . z = 0 ; EXPECT_TRUE ( spline . getSValue ( p )); // std::cout << \"result = \" << spline.getSValue(p).get() << std::endl; EXPECT_TRUE ( spline . getSValue ( p ). get () > 0.099 ); EXPECT_TRUE ( spline . getSValue ( p ). get () < 0.101 ); } TEST ( Math , BoundingBox0 ) { geometry_msgs :: msg :: Pose pose0 ; openscenario_msgs :: msg :: BoundingBox bbox0 ; bbox0 . dimensions . x = 3 ; bbox0 . dimensions . y = 3 ; bbox0 . dimensions . z = 3 ; geometry_msgs :: msg :: Pose pose1 ; openscenario_msgs :: msg :: BoundingBox bbox1 ; bbox1 . dimensions . x = 1 ; bbox1 . dimensions . y = 1 ; bbox1 . dimensions . z = 1 ; EXPECT_EQ ( simulation_api :: math :: getPolygonDistance ( pose0 , bbox0 , pose1 , bbox1 ), boost :: none ); } TEST ( Math , BoundingBox1 ) { geometry_msgs :: msg :: Pose pose0 ; openscenario_msgs :: msg :: BoundingBox bbox0 ; bbox0 . dimensions . x = 3 ; bbox0 . dimensions . y = 3 ; bbox0 . dimensions . z = 3 ; geometry_msgs :: msg :: Pose pose1 ; pose1 . position . y = 5 ; openscenario_msgs :: msg :: BoundingBox bbox1 ; bbox1 . dimensions . x = 1 ; bbox1 . dimensions . y = 1 ; bbox1 . dimensions . z = 1 ; EXPECT_TRUE ( simulation_api :: math :: getPolygonDistance ( pose0 , bbox0 , pose1 , bbox1 )); EXPECT_DOUBLE_EQ ( simulation_api :: math :: getPolygonDistance ( pose0 , bbox0 , pose1 , bbox1 ). get (), 3.0 ); } TEST ( Math , UUID ) { EXPECT_STREQ ( simulation_api :: math :: generateUUID ( \"test\" ). c_str (), simulation_api :: math :: generateUUID ( \"test\" ). c_str ()); } TEST ( Math , Distance0 ) { geometry_msgs :: msg :: Point p0 , p1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 0 ); p1 . x = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 1 ); p0 . y = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), std :: sqrt ( 2 )); } TEST ( Math , Distance1 ) { geometry_msgs :: msg :: Pose p0 , p1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 0 ); p1 . position . x = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 1 ); p0 . position . y = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), std :: sqrt ( 2 )); } TEST ( Math , Distance2 ) { geometry_msgs :: msg :: Point p0 ; geometry_msgs :: msg :: Pose p1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 0 ); p1 . position . x = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 1 ); p0 . y = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), std :: sqrt ( 2 )); } TEST ( Math , Distance3 ) { geometry_msgs :: msg :: Pose p0 ; geometry_msgs :: msg :: Point p1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 0 ); p1 . x = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 1 ); p0 . position . y = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), std :: sqrt ( 2 )); } int main ( int argc , char ** argv ) { testing :: InitGoogleTest ( & argc , argv ); return RUN_ALL_TESTS (); } Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src/test_math.cpp"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apitestsrctest_mathcpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/test/src/test_math.cpp"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#functions","text":"Name int main (int argc, char ** argv) TEST (Math , PolynomialSolver1 ) TEST (Math , PolynomialSolver2 ) TEST (Math , PolynomialSolver3 ) TEST (Math , HermiteCurve1 ) TEST (Math , HermiteCurve2 ) TEST (Math , CatmullRomSpline1 ) TEST (Math , CatmullRomSpline2 ) TEST (Math , CatmullRomSpline3 ) TEST (Math , CatmullRomSpline4 ) TEST (Math , CatmullRomSpline5 ) TEST (Math , CatmullRomSpline6 ) TEST (Math , CatmullRomSpline7 ) TEST (Math , BoundingBox0 ) TEST (Math , BoundingBox1 ) TEST (Math , UUID ) TEST (Math , Distance0 ) TEST (Math , Distance1 ) TEST (Math , Distance2 ) TEST (Math , Distance3 )","title":"Functions"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-main","text":"int main ( int argc , char ** argv )","title":"function main"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test","text":"TEST ( Math , PolynomialSolver1 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_1","text":"TEST ( Math , PolynomialSolver2 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_2","text":"TEST ( Math , PolynomialSolver3 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_3","text":"TEST ( Math , HermiteCurve1 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_4","text":"TEST ( Math , HermiteCurve2 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_5","text":"TEST ( Math , CatmullRomSpline1 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_6","text":"TEST ( Math , CatmullRomSpline2 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_7","text":"TEST ( Math , CatmullRomSpline3 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_8","text":"TEST ( Math , CatmullRomSpline4 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_9","text":"TEST ( Math , CatmullRomSpline5 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_10","text":"TEST ( Math , CatmullRomSpline6 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_11","text":"TEST ( Math , CatmullRomSpline7 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_12","text":"TEST ( Math , BoundingBox0 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_13","text":"TEST ( Math , BoundingBox1 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_14","text":"TEST ( Math , UUID )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_15","text":"TEST ( Math , Distance0 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_16","text":"TEST ( Math , Distance1 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_17","text":"TEST ( Math , Distance2 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#function-test_18","text":"TEST ( Math , Distance3 )","title":"function TEST"},{"location":"package/simulation_api/markdown/Files/test__math_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <simulation_api/math/bounding_box.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <simulation_api/math/distance.hpp> #include <simulation_api/math/hermite_curve.hpp> #include <simulation_api/math/polynomial_solver.hpp> #include <simulation_api/math/uuid.hpp> TEST ( Math , PolynomialSolver1 ) { simulation_api :: math :: PolynomialSolver solver ; auto ret = solver . solveLinearEquation ( -20 , 3 , 0 , 1 ); EXPECT_EQ ( ret . size (), static_cast < size_t > ( 1 )); EXPECT_DOUBLE_EQ ( ret [ 0 ], 0.15 ); } TEST ( Math , PolynomialSolver2 ) { simulation_api :: math :: PolynomialSolver solver ; auto ret = solver . solveQuadraticEquation ( 2 , 3 , -5 , 0 , 2 ); EXPECT_EQ ( ret . size (), static_cast < size_t > ( 1 )); EXPECT_DOUBLE_EQ ( ret [ 0 ], 1 ); } TEST ( Math , PolynomialSolver3 ) { simulation_api :: math :: PolynomialSolver solver ; auto ret = solver . solveCubicEquation ( 1 , -2 , -11 , 12 , 0 , 2 ); EXPECT_EQ ( ret . size (), static_cast < size_t > ( 1 )); EXPECT_DOUBLE_EQ ( ret [ 0 ], 1 ); } TEST ( Math , HermiteCurve1 ) { geometry_msgs :: msg :: Pose start_pose , goal_pose ; geometry_msgs :: msg :: Vector3 start_vec , goal_vec ; goal_pose . position . x = 1 ; start_vec . x = 1 ; goal_vec . x = 1 ; simulation_api :: math :: HermiteCurve curve ( start_pose , goal_pose , start_vec , goal_vec ); EXPECT_DOUBLE_EQ ( curve . getLength (), 1 ); EXPECT_DOUBLE_EQ ( curve . getPoint ( 0.5 , false ). x , 0.5 ); EXPECT_DOUBLE_EQ ( curve . getTangentVector ( 0.5 , false ). x , 1 ); EXPECT_DOUBLE_EQ ( curve . getMaximu2DCurvature (), 0 ); geometry_msgs :: msg :: Point p ; p . x = 0.1 ; p . y = 0 ; p . z = 0 ; EXPECT_TRUE ( curve . getSValue ( p , true )); EXPECT_TRUE ( ( curve . getSValue ( p , true ). get () > 0.099 ) && ( curve . getSValue ( p , true ). get () < 0.101 )); geometry_msgs :: msg :: Point start ; start . x = 0.1 ; start . y = 1.0 ; geometry_msgs :: msg :: Point goal ; goal . x = 0.1 ; goal . y = -1.0 ; auto collision_s = curve . getCollisionPointIn2D ( start , goal ); EXPECT_TRUE ( collision_s ); if ( collision_s ) { EXPECT_DOUBLE_EQ ( collision_s . get (), 0.1 ); } } TEST ( Math , HermiteCurve2 ) { geometry_msgs :: msg :: Pose start_pose , goal_pose ; geometry_msgs :: msg :: Vector3 start_vec , goal_vec ; goal_pose . position . x = 1 ; start_vec . x = 1 ; goal_vec . x = 1 ; simulation_api :: math :: HermiteCurve curve ( start_pose , goal_pose , start_vec , goal_vec ); EXPECT_DOUBLE_EQ ( curve . getLength (), 1 ); EXPECT_DOUBLE_EQ ( curve . getPoint ( 0.5 , false ). x , 0.5 ); EXPECT_DOUBLE_EQ ( curve . getTangentVector ( 0.5 , false ). x , 1 ); EXPECT_DOUBLE_EQ ( curve . getMaximu2DCurvature (), 0 ); geometry_msgs :: msg :: Point p ; p . x = 0.1 ; p . y = 0 ; p . z = 0 ; EXPECT_TRUE ( curve . getSValue ( p , true )); EXPECT_TRUE ( ( curve . getSValue ( p , true ). get () > 0.099 ) && ( curve . getSValue ( p , true ). get () < 0.101 )); geometry_msgs :: msg :: Point start ; start . x = 0.1 ; start . y = 1.0 ; geometry_msgs :: msg :: Point goal ; goal . x = 0.2 ; goal . y = -1.0 ; auto collision_s = curve . getCollisionPointIn2D ( start , goal ); EXPECT_TRUE ( collision_s ); if ( collision_s ) { EXPECT_DOUBLE_EQ ( collision_s . get (), 0.15 ); } } TEST ( Math , CatmullRomSpline1 ) { geometry_msgs :: msg :: Point p0 ; geometry_msgs :: msg :: Point p1 ; p1 . x = 1 ; geometry_msgs :: msg :: Point p2 ; p2 . x = 2 ; auto points = { p0 , p1 , p2 }; auto spline = simulation_api :: math :: CatmullRomSpline ( points ); EXPECT_DOUBLE_EQ ( spline . getLength (), 2 ); geometry_msgs :: msg :: Point start ; start . x = 0.1 ; start . y = 1.0 ; geometry_msgs :: msg :: Point goal ; goal . x = 0.1 ; goal . y = -1.0 ; auto collision_s = spline . getCollisionPointIn2D ( start , goal ); EXPECT_TRUE ( collision_s ); if ( collision_s ) { EXPECT_DOUBLE_EQ ( collision_s . get (), 0.1 ); } collision_s = spline . getCollisionPointIn2D ( start , goal , false ); EXPECT_TRUE ( collision_s ); if ( collision_s ) { EXPECT_DOUBLE_EQ ( collision_s . get (), 0.1 ); } } TEST ( Math , CatmullRomSpline2 ) { geometry_msgs :: msg :: Point p0 ; geometry_msgs :: msg :: Point p1 ; p1 . x = 1 ; p1 . y = 3 ; geometry_msgs :: msg :: Point p2 ; p2 . x = 2 ; p2 . y = 5 ; auto points = { p0 , p1 , p2 }; EXPECT_NO_THROW ( auto spline = simulation_api :: math :: CatmullRomSpline ( points )); } TEST ( Math , CatmullRomSpline3 ) { geometry_msgs :: msg :: Point p0 ; geometry_msgs :: msg :: Point p1 ; p1 . x = 1 ; p1 . y = 3 ; geometry_msgs :: msg :: Point p2 ; p2 . x = 2 ; p2 . y = 5 ; geometry_msgs :: msg :: Point p3 ; p3 . x = 4 ; p3 . y = 6 ; auto points = { p0 , p1 , p2 , p3 }; EXPECT_NO_THROW ( auto spline = simulation_api :: math :: CatmullRomSpline ( points )); } TEST ( Math , CatmullRomSpline4 ) { geometry_msgs :: msg :: Point p0 ; geometry_msgs :: msg :: Point p1 ; p1 . x = 1 ; p1 . y = 3 ; geometry_msgs :: msg :: Point p2 ; p2 . x = 2 ; p2 . y = 5 ; geometry_msgs :: msg :: Point p3 ; p3 . x = 4 ; p3 . y = 6 ; geometry_msgs :: msg :: Point p4 ; p4 . x = 4 ; p4 . y = 10 ; auto points = { p0 , p1 , p2 , p3 , p4 }; EXPECT_NO_THROW ( auto spline = simulation_api :: math :: CatmullRomSpline ( points )); } TEST ( Math , CatmullRomSpline5 ) { geometry_msgs :: msg :: Point p0 ; geometry_msgs :: msg :: Point p1 ; p1 . x = 1 ; geometry_msgs :: msg :: Point p2 ; p2 . x = 2 ; geometry_msgs :: msg :: Point p3 ; p3 . x = 3 ; geometry_msgs :: msg :: Point p4 ; p4 . x = 4 ; auto points = { p0 , p1 , p2 , p3 , p4 }; auto spline = simulation_api :: math :: CatmullRomSpline ( points ); EXPECT_DOUBLE_EQ ( spline . getLength (), 4 ); auto point = spline . getPoint ( 3 ); EXPECT_DOUBLE_EQ ( point . x , 3 ); EXPECT_DOUBLE_EQ ( point . y , 0 ); EXPECT_DOUBLE_EQ ( point . z , 0 ); } TEST ( Math , CatmullRomSpline6 ) { geometry_msgs :: msg :: Point p0 ; p0 . x = -30.9281 ; p0 . y = -23.1708 ; p0 . z = -0.132544 ; geometry_msgs :: msg :: Point p1 ; p1 . x = -29.2938 ; p1 . y = -22.2938 ; p1 . z = -0.162124 ; geometry_msgs :: msg :: Point p2 ; p2 . x = -27.6596 ; p2 . y = -21.4167 ; p2 . z = -0.191704 ; geometry_msgs :: msg :: Point p3 ; p3 . x = -33.0324 ; p3 . y = -92.7566 ; p3 . z = 2.28524 ; auto points = { p0 , p1 , p2 , p3 }; auto spline = simulation_api :: math :: CatmullRomSpline ( points ); } TEST ( Math , CatmullRomSpline7 ) { geometry_msgs :: msg :: Point p0 ; geometry_msgs :: msg :: Point p1 ; p1 . x = 1 ; geometry_msgs :: msg :: Point p2 ; p2 . x = 2 ; geometry_msgs :: msg :: Point p3 ; p3 . x = 4 ; auto points = { p0 , p1 , p2 , p3 }; auto spline = simulation_api :: math :: CatmullRomSpline ( points ); geometry_msgs :: msg :: Point p ; p . x = 0.1 ; p . y = 0 ; p . z = 0 ; EXPECT_TRUE ( spline . getSValue ( p )); // std::cout << \"result = \" << spline.getSValue(p).get() << std::endl; EXPECT_TRUE ( spline . getSValue ( p ). get () > 0.099 ); EXPECT_TRUE ( spline . getSValue ( p ). get () < 0.101 ); } TEST ( Math , BoundingBox0 ) { geometry_msgs :: msg :: Pose pose0 ; openscenario_msgs :: msg :: BoundingBox bbox0 ; bbox0 . dimensions . x = 3 ; bbox0 . dimensions . y = 3 ; bbox0 . dimensions . z = 3 ; geometry_msgs :: msg :: Pose pose1 ; openscenario_msgs :: msg :: BoundingBox bbox1 ; bbox1 . dimensions . x = 1 ; bbox1 . dimensions . y = 1 ; bbox1 . dimensions . z = 1 ; EXPECT_EQ ( simulation_api :: math :: getPolygonDistance ( pose0 , bbox0 , pose1 , bbox1 ), boost :: none ); } TEST ( Math , BoundingBox1 ) { geometry_msgs :: msg :: Pose pose0 ; openscenario_msgs :: msg :: BoundingBox bbox0 ; bbox0 . dimensions . x = 3 ; bbox0 . dimensions . y = 3 ; bbox0 . dimensions . z = 3 ; geometry_msgs :: msg :: Pose pose1 ; pose1 . position . y = 5 ; openscenario_msgs :: msg :: BoundingBox bbox1 ; bbox1 . dimensions . x = 1 ; bbox1 . dimensions . y = 1 ; bbox1 . dimensions . z = 1 ; EXPECT_TRUE ( simulation_api :: math :: getPolygonDistance ( pose0 , bbox0 , pose1 , bbox1 )); EXPECT_DOUBLE_EQ ( simulation_api :: math :: getPolygonDistance ( pose0 , bbox0 , pose1 , bbox1 ). get (), 3.0 ); } TEST ( Math , UUID ) { EXPECT_STREQ ( simulation_api :: math :: generateUUID ( \"test\" ). c_str (), simulation_api :: math :: generateUUID ( \"test\" ). c_str ()); } TEST ( Math , Distance0 ) { geometry_msgs :: msg :: Point p0 , p1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 0 ); p1 . x = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 1 ); p0 . y = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), std :: sqrt ( 2 )); } TEST ( Math , Distance1 ) { geometry_msgs :: msg :: Pose p0 , p1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 0 ); p1 . position . x = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 1 ); p0 . position . y = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), std :: sqrt ( 2 )); } TEST ( Math , Distance2 ) { geometry_msgs :: msg :: Point p0 ; geometry_msgs :: msg :: Pose p1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 0 ); p1 . position . x = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 1 ); p0 . y = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), std :: sqrt ( 2 )); } TEST ( Math , Distance3 ) { geometry_msgs :: msg :: Pose p0 ; geometry_msgs :: msg :: Point p1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 0 ); p1 . x = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), 1 ); p0 . position . y = 1 ; EXPECT_DOUBLE_EQ ( simulation_api :: math :: getDistance ( p0 , p1 ), std :: sqrt ( 2 )); } int main ( int argc , char ** argv ) { testing :: InitGoogleTest ( & argc , argv ); return RUN_ALL_TESTS (); } Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/traffic__controller_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic/traffic_controller.cpp # class implementation for the traffic controller More... Namespaces # Name simulation_api::traffic simulation_api Detailed Description # class implementation for the traffic controller Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021} Source code # // Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/traffic/traffic_controller.hpp> #include <simulation_api/traffic/traffic_sink.hpp> #include <string> #include <vector> #include <memory> #include <utility> namespace simulation_api { namespace traffic { TrafficController :: TrafficController ( std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils , const std :: function < std :: vector < std :: string > ( void ) > & get_entity_names_function , const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > & get_entity_pose_function , const std :: function < void ( std :: string ) > & despawn_function , bool auto_sink ) : hdmap_utils_ ( hdmap_utils ), get_entity_names_function ( get_entity_names_function ), get_entity_pose_function ( get_entity_pose_function ), despawn_function ( despawn_function ), auto_sink ( auto_sink ) { if ( auto_sink ) { autoSink (); } } void TrafficController :: autoSink () { for ( const auto & lanelet_id : hdmap_utils_ -> getLaneletIds ()) { if ( hdmap_utils_ -> getNextLaneletIds ( lanelet_id ). empty ()) { openscenario_msgs :: msg :: LaneletPose lanelet_pose ; lanelet_pose . lanelet_id = lanelet_id ; lanelet_pose . s = hdmap_utils_ -> getLaneletLength ( lanelet_id ); const auto pose = hdmap_utils_ -> toMapPose ( lanelet_pose ); addModule < simulation_api :: traffic :: TrafficSink > ( 1 , pose . pose . position , get_entity_names_function , get_entity_pose_function , despawn_function ); } } } void TrafficController :: execute () { for ( const auto & module : modules_ ) { module -> execute (); } } } // namespace traffic } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic/traffic_controller.cpp"},{"location":"package/simulation_api/markdown/Files/traffic__controller_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrctraffictraffic_controllercpp","text":"class implementation for the traffic controller More...","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic/traffic_controller.cpp"},{"location":"package/simulation_api/markdown/Files/traffic__controller_8cpp/#namespaces","text":"Name simulation_api::traffic simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/traffic__controller_8cpp/#detailed-description","text":"class implementation for the traffic controller Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021}","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Files/traffic__controller_8cpp/#source-code","text":"// Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/traffic/traffic_controller.hpp> #include <simulation_api/traffic/traffic_sink.hpp> #include <string> #include <vector> #include <memory> #include <utility> namespace simulation_api { namespace traffic { TrafficController :: TrafficController ( std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils , const std :: function < std :: vector < std :: string > ( void ) > & get_entity_names_function , const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > & get_entity_pose_function , const std :: function < void ( std :: string ) > & despawn_function , bool auto_sink ) : hdmap_utils_ ( hdmap_utils ), get_entity_names_function ( get_entity_names_function ), get_entity_pose_function ( get_entity_pose_function ), despawn_function ( despawn_function ), auto_sink ( auto_sink ) { if ( auto_sink ) { autoSink (); } } void TrafficController :: autoSink () { for ( const auto & lanelet_id : hdmap_utils_ -> getLaneletIds ()) { if ( hdmap_utils_ -> getNextLaneletIds ( lanelet_id ). empty ()) { openscenario_msgs :: msg :: LaneletPose lanelet_pose ; lanelet_pose . lanelet_id = lanelet_id ; lanelet_pose . s = hdmap_utils_ -> getLaneletLength ( lanelet_id ); const auto pose = hdmap_utils_ -> toMapPose ( lanelet_pose ); addModule < simulation_api :: traffic :: TrafficSink > ( 1 , pose . pose . position , get_entity_names_function , get_entity_pose_function , despawn_function ); } } } void TrafficController :: execute () { for ( const auto & module : modules_ ) { module -> execute (); } } } // namespace traffic } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/traffic__controller_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_controller.hpp # class definition for the traffic controller More... Namespaces # Name simulation_api::traffic simulation_api Classes # Name class simulation_api::traffic::TrafficController Detailed Description # class definition for the traffic controller Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021} Source code # // Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__TRAFFIC__TRAFFIC_CONTROLLER_HPP_ #define SIMULATION_API__TRAFFIC__TRAFFIC_CONTROLLER_HPP_ #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <simulation_api/traffic/traffic_module_base.hpp> #include <string> #include <vector> #include <memory> #include <utility> namespace simulation_api { namespace traffic { class TrafficController { public : explicit TrafficController ( std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils , const std :: function < std :: vector < std :: string > ( void ) > & get_entity_names_function , const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > & get_entity_pose_function , const std :: function < void ( std :: string ) > & despawn_function , bool auto_sink = false ); template < typename T , typename ... Ts > void addModule ( Ts && ... xs ) { auto module_ptr = std :: make_shared < T > ( std :: forward < Ts > ( xs )...); modules_ . emplace_back ( module_ptr ); } void execute (); private : void autoSink (); const std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ ; std :: vector < std :: shared_ptr < simulation_api :: traffic :: TraffiModuleBase >> modules_ ; const std :: function < std :: vector < std :: string > ( void ) > get_entity_names_function ; const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > get_entity_pose_function ; const std :: function < void ( const std :: string & ) > despawn_function ; public : const bool auto_sink ; }; } // namespace traffic } // namespace simulation_api #endif // SIMULATION_API__TRAFFIC__TRAFFIC_CONTROLLER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_controller.hpp"},{"location":"package/simulation_api/markdown/Files/traffic__controller_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apitraffictraffic_controllerhpp","text":"class definition for the traffic controller More...","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_controller.hpp"},{"location":"package/simulation_api/markdown/Files/traffic__controller_8hpp/#namespaces","text":"Name simulation_api::traffic simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/traffic__controller_8hpp/#classes","text":"Name class simulation_api::traffic::TrafficController","title":"Classes"},{"location":"package/simulation_api/markdown/Files/traffic__controller_8hpp/#detailed-description","text":"class definition for the traffic controller Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021}","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Files/traffic__controller_8hpp/#source-code","text":"// Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__TRAFFIC__TRAFFIC_CONTROLLER_HPP_ #define SIMULATION_API__TRAFFIC__TRAFFIC_CONTROLLER_HPP_ #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <simulation_api/traffic/traffic_module_base.hpp> #include <string> #include <vector> #include <memory> #include <utility> namespace simulation_api { namespace traffic { class TrafficController { public : explicit TrafficController ( std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils , const std :: function < std :: vector < std :: string > ( void ) > & get_entity_names_function , const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > & get_entity_pose_function , const std :: function < void ( std :: string ) > & despawn_function , bool auto_sink = false ); template < typename T , typename ... Ts > void addModule ( Ts && ... xs ) { auto module_ptr = std :: make_shared < T > ( std :: forward < Ts > ( xs )...); modules_ . emplace_back ( module_ptr ); } void execute (); private : void autoSink (); const std :: shared_ptr < hdmap_utils :: HdMapUtils > hdmap_utils_ ; std :: vector < std :: shared_ptr < simulation_api :: traffic :: TraffiModuleBase >> modules_ ; const std :: function < std :: vector < std :: string > ( void ) > get_entity_names_function ; const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > get_entity_pose_function ; const std :: function < void ( const std :: string & ) > despawn_function ; public : const bool auto_sink ; }; } // namespace traffic } // namespace simulation_api #endif // SIMULATION_API__TRAFFIC__TRAFFIC_CONTROLLER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/traffic__light_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights/traffic_light.cpp # Namespaces # Name simulation_api Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/traffic_lights/traffic_light.hpp> #include <simulation_api/color_utils/color_utils.hpp> #include <simulation_api/entity/exception.hpp> #include <vector> #include <limits> #include <utility> #include <unordered_map> #include <string> namespace simulation_api { TrafficLight :: TrafficLight ( std :: int64_t id , const std :: unordered_map < TrafficLightColor , geometry_msgs :: msg :: Point > & color_positions , const std :: unordered_map < TrafficLightArrow , geometry_msgs :: msg :: Point > & arrow_positions ) : id ( id ), color_positions_ ( color_positions ), arrow_positions_ ( arrow_positions ) { color_changed_ = true ; color_phase_ . setState ( TrafficLightColor :: NONE ); arrow_changed_ = true ; arrow_phase_ . setState ( TrafficLightArrow :: NONE ); } void TrafficLight :: setPosition ( const TrafficLightColor & color , const geometry_msgs :: msg :: Point & position ) { color_positions_ . insert ({ color , position }); } void TrafficLight :: setColorPhase ( const std :: vector < std :: pair < double , TrafficLightColor >> & phase , double time_offset ) { color_phase_ . setPhase ( phase , time_offset ); } void TrafficLight :: setArrowPhase ( const std :: vector < std :: pair < double , TrafficLightArrow >> & phase , double time_offset ) { arrow_phase_ . setPhase ( phase , time_offset ); } void TrafficLight :: setColor ( TrafficLightColor color ) { color_phase_ . setState ( color ); } void TrafficLight :: setArrow ( TrafficLightArrow arrow ) { arrow_phase_ . setState ( arrow ); } double TrafficLight :: getColorPhaseLength () const { return color_phase_ . getPhaseLength (); } double TrafficLight :: getArrowPhaseLength () const { return arrow_phase_ . getPhaseLength (); } TrafficLightArrow TrafficLight :: getArrow () const { return arrow_phase_ . getState (); } TrafficLightColor TrafficLight :: getColor () const { return color_phase_ . getState (); } bool TrafficLight :: colorChanged () const { return color_changed_ ; } bool TrafficLight :: arrowChanged () const { return arrow_changed_ ; } void TrafficLight :: update ( double step_time ) { const auto previous_arrow = getArrow (); arrow_phase_ . update ( step_time ); const auto arrow = getArrow (); if ( previous_arrow == arrow ) { arrow_changed_ = false ; } else { arrow_changed_ = true ; } const auto previous_color = getColor (); color_phase_ . update ( step_time ); const auto color = getColor (); if ( previous_color == color ) { color_changed_ = false ; } else { color_changed_ = true ; } } const geometry_msgs :: msg :: Point TrafficLight :: getPosition ( const TrafficLightColor & color ) { if ( color_positions_ . count ( color ) == 0 ) { throw simulation_api :: SimulationRuntimeError ( \"target color does not exists\" ); } return color_positions_ . at ( color ); } const geometry_msgs :: msg :: Point TrafficLight :: getPosition ( const TrafficLightArrow & arrow ) { if ( arrow_positions_ . count ( arrow ) == 0 ) { throw simulation_api :: SimulationRuntimeError ( \"target arrow does not exists\" ); } return arrow_positions_ . at ( arrow ); } } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights/traffic_light.cpp"},{"location":"package/simulation_api/markdown/Files/traffic__light_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrctraffic_lightstraffic_lightcpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights/traffic_light.cpp"},{"location":"package/simulation_api/markdown/Files/traffic__light_8cpp/#namespaces","text":"Name simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/traffic__light_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/traffic_lights/traffic_light.hpp> #include <simulation_api/color_utils/color_utils.hpp> #include <simulation_api/entity/exception.hpp> #include <vector> #include <limits> #include <utility> #include <unordered_map> #include <string> namespace simulation_api { TrafficLight :: TrafficLight ( std :: int64_t id , const std :: unordered_map < TrafficLightColor , geometry_msgs :: msg :: Point > & color_positions , const std :: unordered_map < TrafficLightArrow , geometry_msgs :: msg :: Point > & arrow_positions ) : id ( id ), color_positions_ ( color_positions ), arrow_positions_ ( arrow_positions ) { color_changed_ = true ; color_phase_ . setState ( TrafficLightColor :: NONE ); arrow_changed_ = true ; arrow_phase_ . setState ( TrafficLightArrow :: NONE ); } void TrafficLight :: setPosition ( const TrafficLightColor & color , const geometry_msgs :: msg :: Point & position ) { color_positions_ . insert ({ color , position }); } void TrafficLight :: setColorPhase ( const std :: vector < std :: pair < double , TrafficLightColor >> & phase , double time_offset ) { color_phase_ . setPhase ( phase , time_offset ); } void TrafficLight :: setArrowPhase ( const std :: vector < std :: pair < double , TrafficLightArrow >> & phase , double time_offset ) { arrow_phase_ . setPhase ( phase , time_offset ); } void TrafficLight :: setColor ( TrafficLightColor color ) { color_phase_ . setState ( color ); } void TrafficLight :: setArrow ( TrafficLightArrow arrow ) { arrow_phase_ . setState ( arrow ); } double TrafficLight :: getColorPhaseLength () const { return color_phase_ . getPhaseLength (); } double TrafficLight :: getArrowPhaseLength () const { return arrow_phase_ . getPhaseLength (); } TrafficLightArrow TrafficLight :: getArrow () const { return arrow_phase_ . getState (); } TrafficLightColor TrafficLight :: getColor () const { return color_phase_ . getState (); } bool TrafficLight :: colorChanged () const { return color_changed_ ; } bool TrafficLight :: arrowChanged () const { return arrow_changed_ ; } void TrafficLight :: update ( double step_time ) { const auto previous_arrow = getArrow (); arrow_phase_ . update ( step_time ); const auto arrow = getArrow (); if ( previous_arrow == arrow ) { arrow_changed_ = false ; } else { arrow_changed_ = true ; } const auto previous_color = getColor (); color_phase_ . update ( step_time ); const auto color = getColor (); if ( previous_color == color ) { color_changed_ = false ; } else { color_changed_ = true ; } } const geometry_msgs :: msg :: Point TrafficLight :: getPosition ( const TrafficLightColor & color ) { if ( color_positions_ . count ( color ) == 0 ) { throw simulation_api :: SimulationRuntimeError ( \"target color does not exists\" ); } return color_positions_ . at ( color ); } const geometry_msgs :: msg :: Point TrafficLight :: getPosition ( const TrafficLightArrow & arrow ) { if ( arrow_positions_ . count ( arrow ) == 0 ) { throw simulation_api :: SimulationRuntimeError ( \"target arrow does not exists\" ); } return arrow_positions_ . at ( arrow ); } } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/traffic__light_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light.hpp # Namespaces # Name simulation_api Classes # Name class simulation_api::TrafficLight Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_HPP_ #define SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_HPP_ #include <simulation_api/traffic_lights/traffic_light_state.hpp> #include <simulation_api/traffic_lights/traffic_light_phase.hpp> #include <simulation_api/color_utils/color_utils.hpp> #include <simulation_api/entity/exception.hpp> #include <vector> #include <limits> #include <utility> #include <iostream> #include <unordered_map> namespace simulation_api { class TrafficLight { using Duration = double ; public : explicit TrafficLight ( std :: int64_t id , const std :: unordered_map < TrafficLightColor , geometry_msgs :: msg :: Point > & color_positions = {}, const std :: unordered_map < TrafficLightArrow , geometry_msgs :: msg :: Point > & arrow_positions = {}); void setColorPhase ( const std :: vector < std :: pair < Duration , TrafficLightColor >> & phase , double time_offset = 0 ); void setArrowPhase ( const std :: vector < std :: pair < Duration , TrafficLightArrow >> & phase , double time_offset = 0 ); void setColor ( TrafficLightColor color ); void setArrow ( TrafficLightArrow arrow ); double getColorPhaseLength () const ; double getArrowPhaseLength () const ; void update ( double step_time ); TrafficLightArrow getArrow () const ; TrafficLightColor getColor () const ; const std :: int64_t id ; const geometry_msgs :: msg :: Point getPosition ( const TrafficLightColor & color ); void setPosition ( const TrafficLightColor & color , const geometry_msgs :: msg :: Point & position ); const geometry_msgs :: msg :: Point getPosition ( const TrafficLightArrow & arrow ); bool colorChanged () const ; bool arrowChanged () const ; private : std :: unordered_map < TrafficLightColor , geometry_msgs :: msg :: Point > color_positions_ ; std :: unordered_map < TrafficLightArrow , geometry_msgs :: msg :: Point > arrow_positions_ ; TrafficLightPhase < TrafficLightColor > color_phase_ ; TrafficLightPhase < TrafficLightArrow > arrow_phase_ ; bool color_changed_ ; bool arrow_changed_ ; }; } // namespace simulation_api #endif // SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light.hpp"},{"location":"package/simulation_api/markdown/Files/traffic__light_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apitraffic_lightstraffic_lighthpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light.hpp"},{"location":"package/simulation_api/markdown/Files/traffic__light_8hpp/#namespaces","text":"Name simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/traffic__light_8hpp/#classes","text":"Name class simulation_api::TrafficLight","title":"Classes"},{"location":"package/simulation_api/markdown/Files/traffic__light_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_HPP_ #define SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_HPP_ #include <simulation_api/traffic_lights/traffic_light_state.hpp> #include <simulation_api/traffic_lights/traffic_light_phase.hpp> #include <simulation_api/color_utils/color_utils.hpp> #include <simulation_api/entity/exception.hpp> #include <vector> #include <limits> #include <utility> #include <iostream> #include <unordered_map> namespace simulation_api { class TrafficLight { using Duration = double ; public : explicit TrafficLight ( std :: int64_t id , const std :: unordered_map < TrafficLightColor , geometry_msgs :: msg :: Point > & color_positions = {}, const std :: unordered_map < TrafficLightArrow , geometry_msgs :: msg :: Point > & arrow_positions = {}); void setColorPhase ( const std :: vector < std :: pair < Duration , TrafficLightColor >> & phase , double time_offset = 0 ); void setArrowPhase ( const std :: vector < std :: pair < Duration , TrafficLightArrow >> & phase , double time_offset = 0 ); void setColor ( TrafficLightColor color ); void setArrow ( TrafficLightArrow arrow ); double getColorPhaseLength () const ; double getArrowPhaseLength () const ; void update ( double step_time ); TrafficLightArrow getArrow () const ; TrafficLightColor getColor () const ; const std :: int64_t id ; const geometry_msgs :: msg :: Point getPosition ( const TrafficLightColor & color ); void setPosition ( const TrafficLightColor & color , const geometry_msgs :: msg :: Point & position ); const geometry_msgs :: msg :: Point getPosition ( const TrafficLightArrow & arrow ); bool colorChanged () const ; bool arrowChanged () const ; private : std :: unordered_map < TrafficLightColor , geometry_msgs :: msg :: Point > color_positions_ ; std :: unordered_map < TrafficLightArrow , geometry_msgs :: msg :: Point > arrow_positions_ ; TrafficLightPhase < TrafficLightColor > color_phase_ ; TrafficLightPhase < TrafficLightArrow > arrow_phase_ ; bool color_changed_ ; bool arrow_changed_ ; }; } // namespace simulation_api #endif // SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/traffic__light__manager_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights/traffic_light_manager.cpp # Namespaces # Name simulation_api Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/traffic_lights/traffic_light_manager.hpp> #include <simulation_api/entity/exception.hpp> #include <memory> #include <vector> #include <utility> #include <string> namespace simulation_api { TrafficLightManager :: TrafficLightManager ( std :: shared_ptr < hdmap_utils :: HdMapUtils > & hdmap_utils_ptr , rclcpp :: Publisher < visualization_msgs :: msg :: MarkerArray >:: SharedPtr publisher , const std :: shared_ptr < rclcpp :: Clock > & clock_ptr , const std :: string & map_frame ) : marker_pub_ ( publisher ), clock_ptr_ ( clock_ptr ), map_frame_ ( map_frame ) { traffic_lights_ = {}; const auto ids = hdmap_utils_ptr -> getTrafficLightIds (); for ( const auto id : ids ) { std :: shared_ptr < TrafficLight > light_ptr = std :: make_shared < TrafficLight > ( id ); auto red_position = hdmap_utils_ptr -> getTrafficLightBulbPosition ( id , TrafficLightColor :: RED ); if ( red_position ) { light_ptr -> setPosition ( TrafficLightColor :: RED , red_position . get ()); } auto yellow_position = hdmap_utils_ptr -> getTrafficLightBulbPosition ( id , TrafficLightColor :: YELLOW ); if ( yellow_position ) { light_ptr -> setPosition ( TrafficLightColor :: YELLOW , yellow_position . get ()); } auto green_position = hdmap_utils_ptr -> getTrafficLightBulbPosition ( id , TrafficLightColor :: GREEN ); if ( green_position ) { light_ptr -> setPosition ( TrafficLightColor :: GREEN , green_position . get ()); } traffic_lights_ . insert ({ id , light_ptr }); } } std :: vector < std :: int64_t > TrafficLightManager :: getIds () const { std :: vector < std :: int64_t > ret ; for ( const auto traffic_light : traffic_lights_ ) { ret . emplace_back ( traffic_light . first ); } return ret ; } void TrafficLightManager :: deleteAllMarkers () const { visualization_msgs :: msg :: MarkerArray msg ; visualization_msgs :: msg :: Marker marker ; marker . action = marker . DELETEALL ; msg . markers . push_back ( marker ); marker_pub_ -> publish ( msg ); } void TrafficLightManager :: drawMarkers () const { visualization_msgs :: msg :: MarkerArray msg ; const auto now = clock_ptr_ -> now (); for ( const auto light : traffic_lights_ ) { const auto color = light . second -> getColor (); if ( color == TrafficLightColor :: NONE ) { continue ; } else { visualization_msgs :: msg :: Marker marker ; marker . header . stamp = now ; marker . header . frame_id = map_frame_ ; marker . action = marker . ADD ; marker . ns = \"bulb\" ; marker . id = light . first ; marker . type = marker . SPHERE ; marker . pose . position = light . second -> getPosition ( light . second -> getColor ()); marker . pose . orientation = geometry_msgs :: msg :: Quaternion (); marker . scale . x = 0.3 ; marker . scale . y = 0.3 ; marker . scale . z = 0.3 ; if ( color == TrafficLightColor :: GREEN ) { marker . color = color_utils :: makeColorMsg ( \"green\" ); } if ( color == TrafficLightColor :: YELLOW ) { marker . color = color_utils :: makeColorMsg ( \"yellow\" ); } if ( color == TrafficLightColor :: RED ) { marker . color = color_utils :: makeColorMsg ( \"red\" ); } msg . markers . push_back ( marker ); } } marker_pub_ -> publish ( msg ); } void TrafficLightManager :: update ( double step_time ) { bool color_changed = false ; for ( const auto light : traffic_lights_ ) { light . second -> update ( step_time ); if ( light . second -> colorChanged ()) { color_changed = true ; } } if ( color_changed ) { deleteAllMarkers (); } drawMarkers (); } TrafficLightArrow TrafficLightManager :: getArrow ( std :: int64_t lanelet_id ) const { if ( traffic_lights_ . count ( lanelet_id ) == 0 ) { throw SimulationRuntimeError ( \"lanelet id does not match\" ); } return traffic_lights_ . at ( lanelet_id ) -> getArrow (); } TrafficLightColor TrafficLightManager :: getColor ( std :: int64_t lanelet_id ) const { if ( traffic_lights_ . count ( lanelet_id ) == 0 ) { throw SimulationRuntimeError ( \"lanelet id does not match\" ); } return traffic_lights_ . at ( lanelet_id ) -> getColor (); } } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights/traffic_light_manager.cpp"},{"location":"package/simulation_api/markdown/Files/traffic__light__manager_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrctraffic_lightstraffic_light_managercpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic_lights/traffic_light_manager.cpp"},{"location":"package/simulation_api/markdown/Files/traffic__light__manager_8cpp/#namespaces","text":"Name simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/traffic__light__manager_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/traffic_lights/traffic_light_manager.hpp> #include <simulation_api/entity/exception.hpp> #include <memory> #include <vector> #include <utility> #include <string> namespace simulation_api { TrafficLightManager :: TrafficLightManager ( std :: shared_ptr < hdmap_utils :: HdMapUtils > & hdmap_utils_ptr , rclcpp :: Publisher < visualization_msgs :: msg :: MarkerArray >:: SharedPtr publisher , const std :: shared_ptr < rclcpp :: Clock > & clock_ptr , const std :: string & map_frame ) : marker_pub_ ( publisher ), clock_ptr_ ( clock_ptr ), map_frame_ ( map_frame ) { traffic_lights_ = {}; const auto ids = hdmap_utils_ptr -> getTrafficLightIds (); for ( const auto id : ids ) { std :: shared_ptr < TrafficLight > light_ptr = std :: make_shared < TrafficLight > ( id ); auto red_position = hdmap_utils_ptr -> getTrafficLightBulbPosition ( id , TrafficLightColor :: RED ); if ( red_position ) { light_ptr -> setPosition ( TrafficLightColor :: RED , red_position . get ()); } auto yellow_position = hdmap_utils_ptr -> getTrafficLightBulbPosition ( id , TrafficLightColor :: YELLOW ); if ( yellow_position ) { light_ptr -> setPosition ( TrafficLightColor :: YELLOW , yellow_position . get ()); } auto green_position = hdmap_utils_ptr -> getTrafficLightBulbPosition ( id , TrafficLightColor :: GREEN ); if ( green_position ) { light_ptr -> setPosition ( TrafficLightColor :: GREEN , green_position . get ()); } traffic_lights_ . insert ({ id , light_ptr }); } } std :: vector < std :: int64_t > TrafficLightManager :: getIds () const { std :: vector < std :: int64_t > ret ; for ( const auto traffic_light : traffic_lights_ ) { ret . emplace_back ( traffic_light . first ); } return ret ; } void TrafficLightManager :: deleteAllMarkers () const { visualization_msgs :: msg :: MarkerArray msg ; visualization_msgs :: msg :: Marker marker ; marker . action = marker . DELETEALL ; msg . markers . push_back ( marker ); marker_pub_ -> publish ( msg ); } void TrafficLightManager :: drawMarkers () const { visualization_msgs :: msg :: MarkerArray msg ; const auto now = clock_ptr_ -> now (); for ( const auto light : traffic_lights_ ) { const auto color = light . second -> getColor (); if ( color == TrafficLightColor :: NONE ) { continue ; } else { visualization_msgs :: msg :: Marker marker ; marker . header . stamp = now ; marker . header . frame_id = map_frame_ ; marker . action = marker . ADD ; marker . ns = \"bulb\" ; marker . id = light . first ; marker . type = marker . SPHERE ; marker . pose . position = light . second -> getPosition ( light . second -> getColor ()); marker . pose . orientation = geometry_msgs :: msg :: Quaternion (); marker . scale . x = 0.3 ; marker . scale . y = 0.3 ; marker . scale . z = 0.3 ; if ( color == TrafficLightColor :: GREEN ) { marker . color = color_utils :: makeColorMsg ( \"green\" ); } if ( color == TrafficLightColor :: YELLOW ) { marker . color = color_utils :: makeColorMsg ( \"yellow\" ); } if ( color == TrafficLightColor :: RED ) { marker . color = color_utils :: makeColorMsg ( \"red\" ); } msg . markers . push_back ( marker ); } } marker_pub_ -> publish ( msg ); } void TrafficLightManager :: update ( double step_time ) { bool color_changed = false ; for ( const auto light : traffic_lights_ ) { light . second -> update ( step_time ); if ( light . second -> colorChanged ()) { color_changed = true ; } } if ( color_changed ) { deleteAllMarkers (); } drawMarkers (); } TrafficLightArrow TrafficLightManager :: getArrow ( std :: int64_t lanelet_id ) const { if ( traffic_lights_ . count ( lanelet_id ) == 0 ) { throw SimulationRuntimeError ( \"lanelet id does not match\" ); } return traffic_lights_ . at ( lanelet_id ) -> getArrow (); } TrafficLightColor TrafficLightManager :: getColor ( std :: int64_t lanelet_id ) const { if ( traffic_lights_ . count ( lanelet_id ) == 0 ) { throw SimulationRuntimeError ( \"lanelet id does not match\" ); } return traffic_lights_ . at ( lanelet_id ) -> getColor (); } } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/traffic__light__manager_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_manager.hpp # Namespaces # Name simulation_api Classes # Name class simulation_api::TrafficLightManager Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_MANAGER_HPP_ #define SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_MANAGER_HPP_ #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <simulation_api/traffic_lights/traffic_light.hpp> #include <rclcpp/rclcpp.hpp> #include <visualization_msgs/msg/marker_array.hpp> #include <memory> #include <unordered_map> #include <vector> #include <utility> #include <string> namespace simulation_api { class TrafficLightManager { public : explicit TrafficLightManager ( std :: shared_ptr < hdmap_utils :: HdMapUtils > & hdmap_utils_ptr , rclcpp :: Publisher < visualization_msgs :: msg :: MarkerArray >:: SharedPtr publisher , const std :: shared_ptr < rclcpp :: Clock > & clock_ptr , const std :: string & map_frame = \"map\" ); void update ( double step_time ); template < typename ... Ts > void setColorPhase ( std :: int64_t lanelet_id , Ts && ... xs ) { if ( traffic_lights_ . count ( lanelet_id ) == 0 ) { throw SimulationRuntimeError ( \"lanelet id does not match\" ); } traffic_lights_ . at ( lanelet_id ) -> setColorPhase ( std :: forward < Ts > ( xs )...); } template < typename ... Ts > void setArrowPhase ( std :: int64_t lanelet_id , Ts && ... xs ) { if ( traffic_lights_ . count ( lanelet_id ) == 0 ) { throw SimulationRuntimeError ( \"lanelet id does not match\" ); } traffic_lights_ . at ( lanelet_id ) -> setArrowPhase ( std :: forward < Ts > ( xs )...); } template < typename ... Ts > void setColor ( std :: int64_t lanelet_id , Ts && ... xs ) { if ( traffic_lights_ . count ( lanelet_id ) == 0 ) { throw SimulationRuntimeError ( \"lanelet id does not match\" ); } traffic_lights_ . at ( lanelet_id ) -> setColor ( std :: forward < Ts > ( xs )...); } template < typename ... Ts > void setArrow ( std :: int64_t lanelet_id , Ts && ... xs ) { if ( traffic_lights_ . count ( lanelet_id ) == 0 ) { throw SimulationRuntimeError ( \"lanelet id does not match\" ); } traffic_lights_ . at ( lanelet_id ) -> setArrow ( std :: forward < Ts > ( xs )...); } TrafficLightColor getColor ( std :: int64_t lanelet_id ) const ; TrafficLightArrow getArrow ( std :: int64_t lanelet_id ) const ; std :: vector < std :: int64_t > getIds () const ; private : void deleteAllMarkers () const ; void drawMarkers () const ; std :: unordered_map < std :: int64_t , std :: shared_ptr < TrafficLight >> traffic_lights_ ; const rclcpp :: Publisher < visualization_msgs :: msg :: MarkerArray >:: SharedPtr marker_pub_ ; const std :: shared_ptr < rclcpp :: Clock > clock_ptr_ ; const std :: string map_frame_ ; }; } // namespace simulation_api #endif // SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_MANAGER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_manager.hpp"},{"location":"package/simulation_api/markdown/Files/traffic__light__manager_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apitraffic_lightstraffic_light_managerhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_manager.hpp"},{"location":"package/simulation_api/markdown/Files/traffic__light__manager_8hpp/#namespaces","text":"Name simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/traffic__light__manager_8hpp/#classes","text":"Name class simulation_api::TrafficLightManager","title":"Classes"},{"location":"package/simulation_api/markdown/Files/traffic__light__manager_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_MANAGER_HPP_ #define SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_MANAGER_HPP_ #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <simulation_api/traffic_lights/traffic_light.hpp> #include <rclcpp/rclcpp.hpp> #include <visualization_msgs/msg/marker_array.hpp> #include <memory> #include <unordered_map> #include <vector> #include <utility> #include <string> namespace simulation_api { class TrafficLightManager { public : explicit TrafficLightManager ( std :: shared_ptr < hdmap_utils :: HdMapUtils > & hdmap_utils_ptr , rclcpp :: Publisher < visualization_msgs :: msg :: MarkerArray >:: SharedPtr publisher , const std :: shared_ptr < rclcpp :: Clock > & clock_ptr , const std :: string & map_frame = \"map\" ); void update ( double step_time ); template < typename ... Ts > void setColorPhase ( std :: int64_t lanelet_id , Ts && ... xs ) { if ( traffic_lights_ . count ( lanelet_id ) == 0 ) { throw SimulationRuntimeError ( \"lanelet id does not match\" ); } traffic_lights_ . at ( lanelet_id ) -> setColorPhase ( std :: forward < Ts > ( xs )...); } template < typename ... Ts > void setArrowPhase ( std :: int64_t lanelet_id , Ts && ... xs ) { if ( traffic_lights_ . count ( lanelet_id ) == 0 ) { throw SimulationRuntimeError ( \"lanelet id does not match\" ); } traffic_lights_ . at ( lanelet_id ) -> setArrowPhase ( std :: forward < Ts > ( xs )...); } template < typename ... Ts > void setColor ( std :: int64_t lanelet_id , Ts && ... xs ) { if ( traffic_lights_ . count ( lanelet_id ) == 0 ) { throw SimulationRuntimeError ( \"lanelet id does not match\" ); } traffic_lights_ . at ( lanelet_id ) -> setColor ( std :: forward < Ts > ( xs )...); } template < typename ... Ts > void setArrow ( std :: int64_t lanelet_id , Ts && ... xs ) { if ( traffic_lights_ . count ( lanelet_id ) == 0 ) { throw SimulationRuntimeError ( \"lanelet id does not match\" ); } traffic_lights_ . at ( lanelet_id ) -> setArrow ( std :: forward < Ts > ( xs )...); } TrafficLightColor getColor ( std :: int64_t lanelet_id ) const ; TrafficLightArrow getArrow ( std :: int64_t lanelet_id ) const ; std :: vector < std :: int64_t > getIds () const ; private : void deleteAllMarkers () const ; void drawMarkers () const ; std :: unordered_map < std :: int64_t , std :: shared_ptr < TrafficLight >> traffic_lights_ ; const rclcpp :: Publisher < visualization_msgs :: msg :: MarkerArray >:: SharedPtr marker_pub_ ; const std :: shared_ptr < rclcpp :: Clock > clock_ptr_ ; const std :: string map_frame_ ; }; } // namespace simulation_api #endif // SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_MANAGER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/traffic__light__phase_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_phase.hpp # Namespaces # Name simulation_api Classes # Name class simulation_api::TrafficLightPhase Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_PHASE_HPP_ #define SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_PHASE_HPP_ #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <simulation_api/entity/exception.hpp> #include <vector> #include <limits> #include <utility> namespace simulation_api { template < typename T > class TrafficLightPhase { public : TrafficLightPhase () { phase_ = {};} explicit TrafficLightPhase ( const std :: vector < std :: pair < double , T >> & phase ) : phase_ ( phase ) {} double getPhaseLength () const { if ( phase_ . empty ()) { throw SimulationRuntimeError ( \"phase is empty\" ); } double l = 0 ; for ( const auto p : phase_ ) { l = l + p . first ; } return l ; } const T getState () const { if ( phase_ . empty ()) { throw SimulationRuntimeError ( \"phase is empty\" ); } double t = 0 ; for ( const auto p : phase_ ) { t = t + p . first ; if ( t > elapsed_time_ ) { return p . second ; } } throw SimulationRuntimeError ( \"failed to get state in phase\" ); } void update ( double step_time ) { if ( phase_ . empty ()) { elapsed_time_ = 0 ; return ; } elapsed_time_ = elapsed_time_ + step_time ; if ( elapsed_time_ > getPhaseLength ()) { elapsed_time_ = elapsed_time_ - getPhaseLength (); } } void setState ( const T & state ) { phase_ = {}; phase_ . emplace_back ( std :: make_pair ( std :: numeric_limits < double >:: infinity (), state ) ); elapsed_time_ = 0 ; } void setPhase ( const std :: vector < std :: pair < double , T >> & phase , double time_offset = 0 ) { phase_ = phase ; elapsed_time_ = time_offset ; } const std :: vector < std :: pair < double , T >> getPhase () const { return phase_ ; } private : std :: vector < std :: pair < double , T >> phase_ ; double elapsed_time_ ; }; } // namespace simulation_api #endif // SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_PHASE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_phase.hpp"},{"location":"package/simulation_api/markdown/Files/traffic__light__phase_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apitraffic_lightstraffic_light_phasehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_phase.hpp"},{"location":"package/simulation_api/markdown/Files/traffic__light__phase_8hpp/#namespaces","text":"Name simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/traffic__light__phase_8hpp/#classes","text":"Name class simulation_api::TrafficLightPhase","title":"Classes"},{"location":"package/simulation_api/markdown/Files/traffic__light__phase_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_PHASE_HPP_ #define SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_PHASE_HPP_ #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <simulation_api/entity/exception.hpp> #include <vector> #include <limits> #include <utility> namespace simulation_api { template < typename T > class TrafficLightPhase { public : TrafficLightPhase () { phase_ = {};} explicit TrafficLightPhase ( const std :: vector < std :: pair < double , T >> & phase ) : phase_ ( phase ) {} double getPhaseLength () const { if ( phase_ . empty ()) { throw SimulationRuntimeError ( \"phase is empty\" ); } double l = 0 ; for ( const auto p : phase_ ) { l = l + p . first ; } return l ; } const T getState () const { if ( phase_ . empty ()) { throw SimulationRuntimeError ( \"phase is empty\" ); } double t = 0 ; for ( const auto p : phase_ ) { t = t + p . first ; if ( t > elapsed_time_ ) { return p . second ; } } throw SimulationRuntimeError ( \"failed to get state in phase\" ); } void update ( double step_time ) { if ( phase_ . empty ()) { elapsed_time_ = 0 ; return ; } elapsed_time_ = elapsed_time_ + step_time ; if ( elapsed_time_ > getPhaseLength ()) { elapsed_time_ = elapsed_time_ - getPhaseLength (); } } void setState ( const T & state ) { phase_ = {}; phase_ . emplace_back ( std :: make_pair ( std :: numeric_limits < double >:: infinity (), state ) ); elapsed_time_ = 0 ; } void setPhase ( const std :: vector < std :: pair < double , T >> & phase , double time_offset = 0 ) { phase_ = phase ; elapsed_time_ = time_offset ; } const std :: vector < std :: pair < double , T >> getPhase () const { return phase_ ; } private : std :: vector < std :: pair < double , T >> phase_ ; double elapsed_time_ ; }; } // namespace simulation_api #endif // SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_PHASE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/traffic__light__state_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_state.hpp # Namespaces # Name simulation_api Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_STATE_HPP_ #define SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_STATE_HPP_ namespace simulation_api { enum class TrafficLightColor { NONE , RED , GREEN , YELLOW }; enum class TrafficLightArrow { NONE , STRAIGHT , LEFT , RIGHT }; } // namespace simulation_api #endif // SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_STATE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_state.hpp"},{"location":"package/simulation_api/markdown/Files/traffic__light__state_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apitraffic_lightstraffic_light_statehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic_lights/traffic_light_state.hpp"},{"location":"package/simulation_api/markdown/Files/traffic__light__state_8hpp/#namespaces","text":"Name simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/traffic__light__state_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_STATE_HPP_ #define SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_STATE_HPP_ namespace simulation_api { enum class TrafficLightColor { NONE , RED , GREEN , YELLOW }; enum class TrafficLightArrow { NONE , STRAIGHT , LEFT , RIGHT }; } // namespace simulation_api #endif // SIMULATION_API__TRAFFIC_LIGHTS__TRAFFIC_LIGHT_STATE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/traffic__module__base_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_module_base.hpp # Namespaces # Name simulation_api::traffic simulation_api Classes # Name class simulation_api::traffic::TraffiModuleBase Source code # // Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__TRAFFIC__TRAFFIC_MODULE_BASE_HPP_ #define SIMULATION_API__TRAFFIC__TRAFFIC_MODULE_BASE_HPP_ namespace simulation_api { namespace traffic { class TraffiModuleBase { public : TraffiModuleBase () {} virtual void execute () = 0 ; }; } // namespace traffic } // namespace simulation_api #endif // SIMULATION_API__TRAFFIC__TRAFFIC_MODULE_BASE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_module_base.hpp"},{"location":"package/simulation_api/markdown/Files/traffic__module__base_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apitraffictraffic_module_basehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_module_base.hpp"},{"location":"package/simulation_api/markdown/Files/traffic__module__base_8hpp/#namespaces","text":"Name simulation_api::traffic simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/traffic__module__base_8hpp/#classes","text":"Name class simulation_api::traffic::TraffiModuleBase","title":"Classes"},{"location":"package/simulation_api/markdown/Files/traffic__module__base_8hpp/#source-code","text":"// Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__TRAFFIC__TRAFFIC_MODULE_BASE_HPP_ #define SIMULATION_API__TRAFFIC__TRAFFIC_MODULE_BASE_HPP_ namespace simulation_api { namespace traffic { class TraffiModuleBase { public : TraffiModuleBase () {} virtual void execute () = 0 ; }; } // namespace traffic } // namespace simulation_api #endif // SIMULATION_API__TRAFFIC__TRAFFIC_MODULE_BASE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/traffic__sink_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic/traffic_sink.cpp # implementation of the TrafficSink class More... Namespaces # Name simulation_api::traffic simulation_api Detailed Description # implementation of the TrafficSink class Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021} Source code # // Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/traffic/traffic_sink.hpp> #include <simulation_api/math/distance.hpp> #include <functional> #include <string> #include <vector> #include <memory> #include <iostream> namespace simulation_api { namespace traffic { TrafficSink :: TrafficSink ( double radius , const geometry_msgs :: msg :: Point & position , const std :: function < std :: vector < std :: string > ( void ) > & get_entity_names_function , const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > & get_entity_pose_function , const std :: function < void ( std :: string ) > & despawn_function ) : TraffiModuleBase (), radius ( radius ), position ( position ), get_entity_names_function ( get_entity_names_function ), get_entity_pose_function ( get_entity_pose_function ), despawn_function ( despawn_function ) { } void TrafficSink :: execute () { const auto names = get_entity_names_function (); for ( const auto & name : names ) { const auto pose = get_entity_pose_function ( name ); if ( simulation_api :: math :: getDistance ( position , pose ) <= radius ) { despawn_function ( name ); } } } } // namespace traffic } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic/traffic_sink.cpp"},{"location":"package/simulation_api/markdown/Files/traffic__sink_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrctraffictraffic_sinkcpp","text":"implementation of the TrafficSink class More...","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/traffic/traffic_sink.cpp"},{"location":"package/simulation_api/markdown/Files/traffic__sink_8cpp/#namespaces","text":"Name simulation_api::traffic simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/traffic__sink_8cpp/#detailed-description","text":"implementation of the TrafficSink class Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021}","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Files/traffic__sink_8cpp/#source-code","text":"// Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/traffic/traffic_sink.hpp> #include <simulation_api/math/distance.hpp> #include <functional> #include <string> #include <vector> #include <memory> #include <iostream> namespace simulation_api { namespace traffic { TrafficSink :: TrafficSink ( double radius , const geometry_msgs :: msg :: Point & position , const std :: function < std :: vector < std :: string > ( void ) > & get_entity_names_function , const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > & get_entity_pose_function , const std :: function < void ( std :: string ) > & despawn_function ) : TraffiModuleBase (), radius ( radius ), position ( position ), get_entity_names_function ( get_entity_names_function ), get_entity_pose_function ( get_entity_pose_function ), despawn_function ( despawn_function ) { } void TrafficSink :: execute () { const auto names = get_entity_names_function (); for ( const auto & name : names ) { const auto pose = get_entity_pose_function ( name ); if ( simulation_api :: math :: getDistance ( position , pose ) <= radius ) { despawn_function ( name ); } } } } // namespace traffic } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/traffic__sink_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_sink.hpp # class definition of the traffic sink More... Namespaces # Name simulation_api::traffic simulation_api Classes # Name class simulation_api::traffic::TrafficSink Detailed Description # class definition of the traffic sink Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021} Source code # // Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__TRAFFIC__TRAFFIC_SINK_HPP_ #define SIMULATION_API__TRAFFIC__TRAFFIC_SINK_HPP_ #include <simulation_api/traffic/traffic_module_base.hpp> #include <geometry_msgs/msg/pose.hpp> #include <functional> #include <string> #include <vector> namespace simulation_api { namespace traffic { class TrafficSink : public TraffiModuleBase { public : explicit TrafficSink ( double radius , const geometry_msgs :: msg :: Point & position , const std :: function < std :: vector < std :: string > ( void ) > & get_entity_names_function , const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > & get_entity_pose_function , const std :: function < void ( std :: string ) > & despawn_function ); const double radius ; const geometry_msgs :: msg :: Point position ; void execute () override ; private : const std :: function < std :: vector < std :: string > ( void ) > get_entity_names_function ; const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > get_entity_pose_function ; const std :: function < void ( const std :: string & ) > despawn_function ; }; } // namespace traffic } // namespace simulation_api #endif // SIMULATION_API__TRAFFIC__TRAFFIC_SINK_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_sink.hpp"},{"location":"package/simulation_api/markdown/Files/traffic__sink_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apitraffictraffic_sinkhpp","text":"class definition of the traffic sink More...","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/traffic/traffic_sink.hpp"},{"location":"package/simulation_api/markdown/Files/traffic__sink_8hpp/#namespaces","text":"Name simulation_api::traffic simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/traffic__sink_8hpp/#classes","text":"Name class simulation_api::traffic::TrafficSink","title":"Classes"},{"location":"package/simulation_api/markdown/Files/traffic__sink_8hpp/#detailed-description","text":"class definition of the traffic sink Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021}","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Files/traffic__sink_8hpp/#source-code","text":"// Copyright 2015-2020 TierIV.inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__TRAFFIC__TRAFFIC_SINK_HPP_ #define SIMULATION_API__TRAFFIC__TRAFFIC_SINK_HPP_ #include <simulation_api/traffic/traffic_module_base.hpp> #include <geometry_msgs/msg/pose.hpp> #include <functional> #include <string> #include <vector> namespace simulation_api { namespace traffic { class TrafficSink : public TraffiModuleBase { public : explicit TrafficSink ( double radius , const geometry_msgs :: msg :: Point & position , const std :: function < std :: vector < std :: string > ( void ) > & get_entity_names_function , const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > & get_entity_pose_function , const std :: function < void ( std :: string ) > & despawn_function ); const double radius ; const geometry_msgs :: msg :: Point position ; void execute () override ; private : const std :: function < std :: vector < std :: string > ( void ) > get_entity_names_function ; const std :: function < geometry_msgs :: msg :: Pose ( const std :: string & ) > get_entity_pose_function ; const std :: function < void ( const std :: string & ) > despawn_function ; }; } // namespace traffic } // namespace simulation_api #endif // SIMULATION_API__TRAFFIC__TRAFFIC_SINK_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/traveled__distance__metric_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/traveled_distance_metric.cpp # Namespaces # Name metrics Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/metrics/traveled_distance_metric.hpp> #include <string> namespace metrics { TraveledDistanceMetric :: TraveledDistanceMetric ( std :: string target_entity ) : MetricBase ( \"TraveledDistance\" ), target_entity ( target_entity ) { traveled_distance = 0 ; } bool TraveledDistanceMetric :: activateTrigger () { return true ; } void TraveledDistanceMetric :: update () { double step_time = entity_manager_ptr_ -> getStepTime (); auto status = entity_manager_ptr_ -> getEntityStatus ( target_entity ); if ( status ) { traveled_distance = traveled_distance + std :: fabs ( status . get (). action_status . twist . linear . x ) * step_time ; } } nlohmann :: json TraveledDistanceMetric :: to_json () { nlohmann :: json json = MetricBase :: to_base_json (); if ( getLifecycle () != MetricLifecycle :: INACTIVE ) { json [ \"traveled_distance\" ] = traveled_distance ; } return json ; } } // namespace metrics Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/traveled_distance_metric.cpp"},{"location":"package/simulation_api/markdown/Files/traveled__distance__metric_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmetricstraveled_distance_metriccpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/metrics/traveled_distance_metric.cpp"},{"location":"package/simulation_api/markdown/Files/traveled__distance__metric_8cpp/#namespaces","text":"Name metrics","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/traveled__distance__metric_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/metrics/traveled_distance_metric.hpp> #include <string> namespace metrics { TraveledDistanceMetric :: TraveledDistanceMetric ( std :: string target_entity ) : MetricBase ( \"TraveledDistance\" ), target_entity ( target_entity ) { traveled_distance = 0 ; } bool TraveledDistanceMetric :: activateTrigger () { return true ; } void TraveledDistanceMetric :: update () { double step_time = entity_manager_ptr_ -> getStepTime (); auto status = entity_manager_ptr_ -> getEntityStatus ( target_entity ); if ( status ) { traveled_distance = traveled_distance + std :: fabs ( status . get (). action_status . twist . linear . x ) * step_time ; } } nlohmann :: json TraveledDistanceMetric :: to_json () { nlohmann :: json json = MetricBase :: to_base_json (); if ( getLifecycle () != MetricLifecycle :: INACTIVE ) { json [ \"traveled_distance\" ] = traveled_distance ; } return json ; } } // namespace metrics Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/traveled__distance__metric_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/traveled_distance_metric.hpp # Namespaces # Name metrics Classes # Name class metrics::TraveledDistanceMetric Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__METRICS__TRAVELED_DISTANCE_METRIC_HPP_ #define SIMULATION_API__METRICS__TRAVELED_DISTANCE_METRIC_HPP_ #include <simulation_api/metrics/metric_base.hpp> #include <string> namespace metrics { class TraveledDistanceMetric : public MetricBase { public : explicit TraveledDistanceMetric ( std :: string target_entity ); ~ TraveledDistanceMetric () override = default ; void update () override ; nlohmann :: json to_json (); bool activateTrigger () override ; const std :: string target_entity ; private : double traveled_distance ; }; } // namespace metrics #endif // SIMULATION_API__METRICS__TRAVELED_DISTANCE_METRIC_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/traveled_distance_metric.hpp"},{"location":"package/simulation_api/markdown/Files/traveled__distance__metric_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apimetricstraveled_distance_metrichpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/metrics/traveled_distance_metric.hpp"},{"location":"package/simulation_api/markdown/Files/traveled__distance__metric_8hpp/#namespaces","text":"Name metrics","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/traveled__distance__metric_8hpp/#classes","text":"Name class metrics::TraveledDistanceMetric","title":"Classes"},{"location":"package/simulation_api/markdown/Files/traveled__distance__metric_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__METRICS__TRAVELED_DISTANCE_METRIC_HPP_ #define SIMULATION_API__METRICS__TRAVELED_DISTANCE_METRIC_HPP_ #include <simulation_api/metrics/metric_base.hpp> #include <string> namespace metrics { class TraveledDistanceMetric : public MetricBase { public : explicit TraveledDistanceMetric ( std :: string target_entity ); ~ TraveledDistanceMetric () override = default ; void update () override ; nlohmann :: json to_json (); bool activateTrigger () override ; const std :: string target_entity ; private : double traveled_distance ; }; } // namespace metrics #endif // SIMULATION_API__METRICS__TRAVELED_DISTANCE_METRIC_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/uuid_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/uuid.cpp # source files for generating UUID More... Namespaces # Name simulation_api::math simulation_api Detailed Description # source files for generating UUID Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021} Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <boost/uuid/uuid.hpp> #include <boost/uuid/uuid_io.hpp> #include <boost/uuid/uuid_generators.hpp> #include <boost/lexical_cast.hpp> #include <string> namespace simulation_api { namespace math { std :: string generateUUID ( const std :: string & seed ) { boost :: uuids :: uuid base = boost :: uuids :: string_generator ()( \"0123456789abcdef0123456789abcdef\" ); boost :: uuids :: name_generator gen ( base ); boost :: uuids :: uuid uuid = gen ( seed ); return boost :: lexical_cast < std :: string > ( uuid ); } } // namespace math } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/uuid.cpp"},{"location":"package/simulation_api/markdown/Files/uuid_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcmathuuidcpp","text":"source files for generating UUID More...","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/math/uuid.cpp"},{"location":"package/simulation_api/markdown/Files/uuid_8cpp/#namespaces","text":"Name simulation_api::math simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/uuid_8cpp/#detailed-description","text":"source files for generating UUID Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021}","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Files/uuid_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <boost/uuid/uuid.hpp> #include <boost/uuid/uuid_io.hpp> #include <boost/uuid/uuid_generators.hpp> #include <boost/lexical_cast.hpp> #include <string> namespace simulation_api { namespace math { std :: string generateUUID ( const std :: string & seed ) { boost :: uuids :: uuid base = boost :: uuids :: string_generator ()( \"0123456789abcdef0123456789abcdef\" ); boost :: uuids :: name_generator gen ( base ); boost :: uuids :: uuid uuid = gen ( seed ); return boost :: lexical_cast < std :: string > ( uuid ); } } // namespace math } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/uuid_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/uuid.hpp # header files for generating UUID More... Namespaces # Name simulation_api::math simulation_api Detailed Description # header files for generating UUID Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021} Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__MATH__UUID_HPP_ #define SIMULATION_API__MATH__UUID_HPP_ #include <string> namespace simulation_api { namespace math { std :: string generateUUID ( const std :: string & seed ); } // namespace math } // namespace simulation_api #endif // SIMULATION_API__MATH__UUID_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/uuid.hpp"},{"location":"package/simulation_api/markdown/Files/uuid_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apimathuuidhpp","text":"header files for generating UUID More...","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/math/uuid.hpp"},{"location":"package/simulation_api/markdown/Files/uuid_8hpp/#namespaces","text":"Name simulation_api::math simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/uuid_8hpp/#detailed-description","text":"header files for generating UUID Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-01 Copyright : Copyright(c) Tier IV.Inc {2015-2021}","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Files/uuid_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__MATH__UUID_HPP_ #define SIMULATION_API__MATH__UUID_HPP_ #include <string> namespace simulation_api { namespace math { std :: string generateUUID ( const std :: string & seed ); } // namespace math } // namespace simulation_api #endif // SIMULATION_API__MATH__UUID_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/vehicle_2behavior__tree_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/behavior_tree.cpp # Namespaces # Name entity_behavior::vehicle entity_behavior Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/yield_action.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/follow_lane_action.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.hpp> #include <simulation_api/behavior/vehicle/lane_change_action.hpp> #include <openscenario_msgs/msg/driver_model.hpp> #include <ament_index_cpp/get_package_share_directory.hpp> #include <iostream> #include <utility> #include <string> #include <algorithm> namespace entity_behavior { namespace vehicle { BehaviorTree :: BehaviorTree () { std :: string path = ament_index_cpp :: get_package_share_directory ( \"simulation_api\" ) + \"/resource/vehicle_entity_behavior.xml\" ; factory_ . registerNodeType < follow_lane_sequence :: FollowLaneAction > ( \"FollowLane\" ); factory_ . registerNodeType < follow_lane_sequence :: FollowFrontEntityAction > ( \"FollowFrontEntity\" ); factory_ . registerNodeType < follow_lane_sequence :: StopAtCrossingEntityAction > ( \"StopAtCrossingEntity\" ); factory_ . registerNodeType < follow_lane_sequence :: StopAtStopLineAction > ( \"StopAtStopLine\" ); factory_ . registerNodeType < follow_lane_sequence :: StopAtTrafficLightAction > ( \"StopAtTrafficLight\" ); factory_ . registerNodeType < follow_lane_sequence :: YieldAction > ( \"Yield\" ); factory_ . registerNodeType < LaneChangeAction > ( \"LaneChange\" ); tree_ = factory_ . createTreeFromFile ( path ); current_action_ = \"root\" ; // logger_cout_ptr_ = std::make_shared<BT::StdCoutLogger>(tree_); setupLogger (); setRequest ( \"none\" ); } void BehaviorTree :: setRequest ( std :: string request ) { request_ = request ; setValueToBlackBoard ( \"request\" , request ); } void BehaviorTree :: setupLogger () { first_timestamp_ = std :: chrono :: high_resolution_clock :: now (); auto subscribeCallback = [ this ]( BT :: TimePoint timestamp , const BT :: TreeNode & node , BT :: NodeStatus prev , BT :: NodeStatus status ) { if ( status != BT :: NodeStatus :: IDLE ) { if ( type_ == BT :: TimestampType :: ABSOLUTE ) { this -> callback ( timestamp . time_since_epoch (), node , prev , status ); } else { this -> callback ( timestamp - first_timestamp_ , node , prev , status ); } } }; auto visitor = [ this , subscribeCallback ]( BT :: TreeNode * node ) { subscribers_ . push_back ( node -> subscribeToStatusChange ( std :: move ( subscribeCallback ))); }; BT :: applyRecursiveVisitor ( tree_ . rootNode (), visitor ); } BT :: NodeStatus BehaviorTree :: tick ( double current_time , double step_time ) { setValueToBlackBoard ( \"current_time\" , current_time ); setValueToBlackBoard ( \"step_time\" , step_time ); return tree_ . rootNode () -> executeTick (); } void BehaviorTree :: callback ( BT :: Duration timestamp , const BT :: TreeNode & node , BT :: NodeStatus prev_status , BT :: NodeStatus status ) { constexpr const char * whitespaces = \" \" ; constexpr const size_t ws_count = 25 ; double since_epoch = std :: chrono :: duration < double > ( timestamp ). count (); printf ( \"[%.3f]: %s%s %s -> %s\" , since_epoch , node . name (). c_str (), & whitespaces [ std :: min ( ws_count , node . name (). size ())], toStr ( prev_status , true ). c_str (), toStr ( status , true ). c_str () ); std :: cout << std :: endl ; if ( status != BT :: NodeStatus :: SUCCESS ) { current_action_ = node . name (); } if ( status == BT :: NodeStatus :: SUCCESS || status == BT :: NodeStatus :: FAILURE ) { if ( request_ == current_action_ ) { setRequest ( \"none\" ); } } } } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/behavior_tree.cpp"},{"location":"package/simulation_api/markdown/Files/vehicle_2behavior__tree_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorvehiclebehavior_treecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/behavior_tree.cpp"},{"location":"package/simulation_api/markdown/Files/vehicle_2behavior__tree_8cpp/#namespaces","text":"Name entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/vehicle_2behavior__tree_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/yield_action.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/follow_lane_action.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/follow_front_entity_action.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_crossing_entity_action.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_stop_line_action.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/stop_at_traffic_light_action.hpp> #include <simulation_api/behavior/vehicle/lane_change_action.hpp> #include <openscenario_msgs/msg/driver_model.hpp> #include <ament_index_cpp/get_package_share_directory.hpp> #include <iostream> #include <utility> #include <string> #include <algorithm> namespace entity_behavior { namespace vehicle { BehaviorTree :: BehaviorTree () { std :: string path = ament_index_cpp :: get_package_share_directory ( \"simulation_api\" ) + \"/resource/vehicle_entity_behavior.xml\" ; factory_ . registerNodeType < follow_lane_sequence :: FollowLaneAction > ( \"FollowLane\" ); factory_ . registerNodeType < follow_lane_sequence :: FollowFrontEntityAction > ( \"FollowFrontEntity\" ); factory_ . registerNodeType < follow_lane_sequence :: StopAtCrossingEntityAction > ( \"StopAtCrossingEntity\" ); factory_ . registerNodeType < follow_lane_sequence :: StopAtStopLineAction > ( \"StopAtStopLine\" ); factory_ . registerNodeType < follow_lane_sequence :: StopAtTrafficLightAction > ( \"StopAtTrafficLight\" ); factory_ . registerNodeType < follow_lane_sequence :: YieldAction > ( \"Yield\" ); factory_ . registerNodeType < LaneChangeAction > ( \"LaneChange\" ); tree_ = factory_ . createTreeFromFile ( path ); current_action_ = \"root\" ; // logger_cout_ptr_ = std::make_shared<BT::StdCoutLogger>(tree_); setupLogger (); setRequest ( \"none\" ); } void BehaviorTree :: setRequest ( std :: string request ) { request_ = request ; setValueToBlackBoard ( \"request\" , request ); } void BehaviorTree :: setupLogger () { first_timestamp_ = std :: chrono :: high_resolution_clock :: now (); auto subscribeCallback = [ this ]( BT :: TimePoint timestamp , const BT :: TreeNode & node , BT :: NodeStatus prev , BT :: NodeStatus status ) { if ( status != BT :: NodeStatus :: IDLE ) { if ( type_ == BT :: TimestampType :: ABSOLUTE ) { this -> callback ( timestamp . time_since_epoch (), node , prev , status ); } else { this -> callback ( timestamp - first_timestamp_ , node , prev , status ); } } }; auto visitor = [ this , subscribeCallback ]( BT :: TreeNode * node ) { subscribers_ . push_back ( node -> subscribeToStatusChange ( std :: move ( subscribeCallback ))); }; BT :: applyRecursiveVisitor ( tree_ . rootNode (), visitor ); } BT :: NodeStatus BehaviorTree :: tick ( double current_time , double step_time ) { setValueToBlackBoard ( \"current_time\" , current_time ); setValueToBlackBoard ( \"step_time\" , step_time ); return tree_ . rootNode () -> executeTick (); } void BehaviorTree :: callback ( BT :: Duration timestamp , const BT :: TreeNode & node , BT :: NodeStatus prev_status , BT :: NodeStatus status ) { constexpr const char * whitespaces = \" \" ; constexpr const size_t ws_count = 25 ; double since_epoch = std :: chrono :: duration < double > ( timestamp ). count (); printf ( \"[%.3f]: %s%s %s -> %s\" , since_epoch , node . name (). c_str (), & whitespaces [ std :: min ( ws_count , node . name (). size ())], toStr ( prev_status , true ). c_str (), toStr ( status , true ). c_str () ); std :: cout << std :: endl ; if ( status != BT :: NodeStatus :: SUCCESS ) { current_action_ = node . name (); } if ( status == BT :: NodeStatus :: SUCCESS || status == BT :: NodeStatus :: FAILURE ) { if ( request_ == current_action_ ) { setRequest ( \"none\" ); } } } } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/vehicle_2behavior__tree_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/behavior_tree.hpp # Namespaces # Name entity_behavior::vehicle entity_behavior Classes # Name class entity_behavior::vehicle::BehaviorTree Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__BEHAVIOR_TREE_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__BEHAVIOR_TREE_HPP_ #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <openscenario_msgs/msg/entity_status.hpp> #include <openscenario_msgs/msg/waypoints_array.hpp> #include <openscenario_msgs/msg/obstacle.hpp> #include <geometry_msgs/msg/point.hpp> #include <behaviortree_cpp_v3/bt_factory.h> #include <behaviortree_cpp_v3/loggers/bt_cout_logger.h> #include <functional> #include <map> #include <vector> #include <string> #include <memory> namespace entity_behavior { namespace vehicle { class BehaviorTree { public : BehaviorTree (); BT :: NodeStatus tick ( double current_time , double step_time ); const std :: string getCurrentAction () const { return current_action_ ; } template < typename T > void setValueToBlackBoard ( std :: string key , T value ) { tree_ . rootBlackboard () -> set ( key , value ); } openscenario_msgs :: msg :: EntityStatus getUpdatedStatus () { openscenario_msgs :: msg :: EntityStatus status ; tree_ . rootBlackboard () -> get ( \"updated_status\" , status ); return status ; } openscenario_msgs :: msg :: WaypointsArray getWaypoints () { openscenario_msgs :: msg :: WaypointsArray waypoints ; tree_ . rootBlackboard () -> get ( \"waypoints\" , waypoints ); return waypoints ; } boost :: optional < openscenario_msgs :: msg :: Obstacle > getObstacle () { boost :: optional < openscenario_msgs :: msg :: Obstacle > obstacle ; tree_ . rootBlackboard () -> get ( \"obstacle\" , obstacle ); return obstacle ; } void setRequest ( std :: string request ); private : std :: string request_ ; BT :: BehaviorTreeFactory factory_ ; BT :: Tree tree_ ; std :: shared_ptr < BT :: StdCoutLogger > logger_cout_ptr_ ; void callback ( BT :: Duration timestamp , const BT :: TreeNode & node , BT :: NodeStatus prev_status , BT :: NodeStatus status ); void setupLogger (); BT :: TimestampType type_ ; BT :: TimePoint first_timestamp_ ; std :: vector < BT :: TreeNode :: StatusChangeSubscriber > subscribers_ ; std :: string current_action_ ; }; } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__BEHAVIOR_TREE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/behavior_tree.hpp"},{"location":"package/simulation_api/markdown/Files/vehicle_2behavior__tree_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorvehiclebehavior_treehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/behavior_tree.hpp"},{"location":"package/simulation_api/markdown/Files/vehicle_2behavior__tree_8hpp/#namespaces","text":"Name entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/vehicle_2behavior__tree_8hpp/#classes","text":"Name class entity_behavior::vehicle::BehaviorTree","title":"Classes"},{"location":"package/simulation_api/markdown/Files/vehicle_2behavior__tree_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__BEHAVIOR_TREE_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__BEHAVIOR_TREE_HPP_ #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <openscenario_msgs/msg/entity_status.hpp> #include <openscenario_msgs/msg/waypoints_array.hpp> #include <openscenario_msgs/msg/obstacle.hpp> #include <geometry_msgs/msg/point.hpp> #include <behaviortree_cpp_v3/bt_factory.h> #include <behaviortree_cpp_v3/loggers/bt_cout_logger.h> #include <functional> #include <map> #include <vector> #include <string> #include <memory> namespace entity_behavior { namespace vehicle { class BehaviorTree { public : BehaviorTree (); BT :: NodeStatus tick ( double current_time , double step_time ); const std :: string getCurrentAction () const { return current_action_ ; } template < typename T > void setValueToBlackBoard ( std :: string key , T value ) { tree_ . rootBlackboard () -> set ( key , value ); } openscenario_msgs :: msg :: EntityStatus getUpdatedStatus () { openscenario_msgs :: msg :: EntityStatus status ; tree_ . rootBlackboard () -> get ( \"updated_status\" , status ); return status ; } openscenario_msgs :: msg :: WaypointsArray getWaypoints () { openscenario_msgs :: msg :: WaypointsArray waypoints ; tree_ . rootBlackboard () -> get ( \"waypoints\" , waypoints ); return waypoints ; } boost :: optional < openscenario_msgs :: msg :: Obstacle > getObstacle () { boost :: optional < openscenario_msgs :: msg :: Obstacle > obstacle ; tree_ . rootBlackboard () -> get ( \"obstacle\" , obstacle ); return obstacle ; } void setRequest ( std :: string request ); private : std :: string request_ ; BT :: BehaviorTreeFactory factory_ ; BT :: Tree tree_ ; std :: shared_ptr < BT :: StdCoutLogger > logger_cout_ptr_ ; void callback ( BT :: Duration timestamp , const BT :: TreeNode & node , BT :: NodeStatus prev_status , BT :: NodeStatus status ); void setupLogger (); BT :: TimestampType type_ ; BT :: TimePoint first_timestamp_ ; std :: vector < BT :: TreeNode :: StatusChangeSubscriber > subscribers_ ; std :: string current_action_ ; }; } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__BEHAVIOR_TREE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/vehicle_2follow__lane__sequence_2follow__lane__action_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/follow_lane_action.cpp # Namespaces # Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/follow_lane_action.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { FollowLaneAction :: FollowLaneAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: VehicleActionNode ( name , config ) {} const boost :: optional < openscenario_msgs :: msg :: Obstacle > FollowLaneAction :: calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & ) { return boost :: none ; } const openscenario_msgs :: msg :: WaypointsArray FollowLaneAction :: calculateWaypoints () { if ( ! entity_status . lanelet_pose_valid ) { throw BehaviorTreeRuntimeError ( \"failed to assign lane\" ); } if ( entity_status . action_status . twist . linear . x >= 0 ) { openscenario_msgs :: msg :: WaypointsArray waypoints ; simulation_api :: math :: CatmullRomSpline spline ( hdmap_utils -> getCenterPoints ( route_lanelets )); waypoints . waypoints = spline . getTrajectory ( entity_status . lanelet_pose . s , entity_status . lanelet_pose . s + getHorizon (), 1.0 ); return waypoints ; } else { return openscenario_msgs :: msg :: WaypointsArray (); } } void FollowLaneAction :: getBlackBoardValues () { openscenario_msgs :: msg :: LaneletPose target_lanelet_pose ; VehicleActionNode :: getBlackBoardValues (); if ( ! getInput < openscenario_msgs :: msg :: LaneletPose > ( \"target_lanelet_pose\" , target_lanelet_pose )) { target_lanelet_pose_ = boost :: none ; } else { target_lanelet_pose_ = target_lanelet_pose ; } } BT :: NodeStatus FollowLaneAction :: tick () { getBlackBoardValues (); if ( request != \"none\" && request != \"follow_lane\" ) { return BT :: NodeStatus :: FAILURE ; } if ( ! entity_status . lanelet_pose_valid ) { setOutput ( \"updated_status\" , stopAtEndOfRoad ()); return BT :: NodeStatus :: RUNNING ; } if ( driver_model . see_around ) { if ( getRightOfWayEntities ( route_lanelets ). size () != 0 ) { return BT :: NodeStatus :: FAILURE ; } auto distance_to_front_entity = getDistanceToFrontEntity (); if ( distance_to_front_entity ) { if ( distance_to_front_entity . get () <= calculateStopDistance () + vehicle_parameters . bounding_box . dimensions . x + 5 ) { return BT :: NodeStatus :: FAILURE ; } } const auto waypoints = calculateWaypoints (); const auto distance_to_traffic_stop_line = getDistanceToTrafficLightStopLine ( route_lanelets , waypoints . waypoints ); if ( distance_to_traffic_stop_line ) { if ( distance_to_traffic_stop_line . get () <= getHorizon ()) { return BT :: NodeStatus :: FAILURE ; } } auto distance_to_stopline = hdmap_utils -> getDistanceToStopLine ( route_lanelets , waypoints . waypoints ); auto distance_to_conflicting_entity = getDistanceToConflictingEntity ( route_lanelets ); if ( distance_to_stopline ) { if ( distance_to_stopline . get () <= calculateStopDistance () + vehicle_parameters . bounding_box . dimensions . x * 0.5 + 5 ) { return BT :: NodeStatus :: FAILURE ; } } if ( distance_to_conflicting_entity ) { if ( distance_to_conflicting_entity . get () < ( vehicle_parameters . bounding_box . dimensions . x + calculateStopDistance ())) { return BT :: NodeStatus :: FAILURE ; } } } if ( ! target_speed ) { target_speed = hdmap_utils -> getSpeedLimit ( route_lanelets ); } auto updated_status = calculateEntityStatusUpdated ( target_speed . get ()); setOutput ( \"updated_status\" , updated_status ); const auto waypoints = calculateWaypoints (); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: RUNNING ; } } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/follow_lane_action.cpp"},{"location":"package/simulation_api/markdown/Files/vehicle_2follow__lane__sequence_2follow__lane__action_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorvehiclefollow_lane_sequencefollow_lane_actioncpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/follow_lane_action.cpp"},{"location":"package/simulation_api/markdown/Files/vehicle_2follow__lane__sequence_2follow__lane__action_8cpp/#namespaces","text":"Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/vehicle_2follow__lane__sequence_2follow__lane__action_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/follow_lane_sequence/follow_lane_action.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { FollowLaneAction :: FollowLaneAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: VehicleActionNode ( name , config ) {} const boost :: optional < openscenario_msgs :: msg :: Obstacle > FollowLaneAction :: calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & ) { return boost :: none ; } const openscenario_msgs :: msg :: WaypointsArray FollowLaneAction :: calculateWaypoints () { if ( ! entity_status . lanelet_pose_valid ) { throw BehaviorTreeRuntimeError ( \"failed to assign lane\" ); } if ( entity_status . action_status . twist . linear . x >= 0 ) { openscenario_msgs :: msg :: WaypointsArray waypoints ; simulation_api :: math :: CatmullRomSpline spline ( hdmap_utils -> getCenterPoints ( route_lanelets )); waypoints . waypoints = spline . getTrajectory ( entity_status . lanelet_pose . s , entity_status . lanelet_pose . s + getHorizon (), 1.0 ); return waypoints ; } else { return openscenario_msgs :: msg :: WaypointsArray (); } } void FollowLaneAction :: getBlackBoardValues () { openscenario_msgs :: msg :: LaneletPose target_lanelet_pose ; VehicleActionNode :: getBlackBoardValues (); if ( ! getInput < openscenario_msgs :: msg :: LaneletPose > ( \"target_lanelet_pose\" , target_lanelet_pose )) { target_lanelet_pose_ = boost :: none ; } else { target_lanelet_pose_ = target_lanelet_pose ; } } BT :: NodeStatus FollowLaneAction :: tick () { getBlackBoardValues (); if ( request != \"none\" && request != \"follow_lane\" ) { return BT :: NodeStatus :: FAILURE ; } if ( ! entity_status . lanelet_pose_valid ) { setOutput ( \"updated_status\" , stopAtEndOfRoad ()); return BT :: NodeStatus :: RUNNING ; } if ( driver_model . see_around ) { if ( getRightOfWayEntities ( route_lanelets ). size () != 0 ) { return BT :: NodeStatus :: FAILURE ; } auto distance_to_front_entity = getDistanceToFrontEntity (); if ( distance_to_front_entity ) { if ( distance_to_front_entity . get () <= calculateStopDistance () + vehicle_parameters . bounding_box . dimensions . x + 5 ) { return BT :: NodeStatus :: FAILURE ; } } const auto waypoints = calculateWaypoints (); const auto distance_to_traffic_stop_line = getDistanceToTrafficLightStopLine ( route_lanelets , waypoints . waypoints ); if ( distance_to_traffic_stop_line ) { if ( distance_to_traffic_stop_line . get () <= getHorizon ()) { return BT :: NodeStatus :: FAILURE ; } } auto distance_to_stopline = hdmap_utils -> getDistanceToStopLine ( route_lanelets , waypoints . waypoints ); auto distance_to_conflicting_entity = getDistanceToConflictingEntity ( route_lanelets ); if ( distance_to_stopline ) { if ( distance_to_stopline . get () <= calculateStopDistance () + vehicle_parameters . bounding_box . dimensions . x * 0.5 + 5 ) { return BT :: NodeStatus :: FAILURE ; } } if ( distance_to_conflicting_entity ) { if ( distance_to_conflicting_entity . get () < ( vehicle_parameters . bounding_box . dimensions . x + calculateStopDistance ())) { return BT :: NodeStatus :: FAILURE ; } } } if ( ! target_speed ) { target_speed = hdmap_utils -> getSpeedLimit ( route_lanelets ); } auto updated_status = calculateEntityStatusUpdated ( target_speed . get ()); setOutput ( \"updated_status\" , updated_status ); const auto waypoints = calculateWaypoints (); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: RUNNING ; } } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/vehicle_2follow__lane__sequence_2follow__lane__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/follow_lane_action.hpp # Namespaces # Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior Classes # Name class entity_behavior::vehicle::follow_lane_sequence::FollowLaneAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__FOLLOW_LANE_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__FOLLOW_LANE_ACTION_HPP_ #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { class FollowLaneAction : public entity_behavior :: VehicleActionNode { public : FollowLaneAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; void getBlackBoardValues (); static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: VehicleActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override ; const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override ; private : boost :: optional < openscenario_msgs :: msg :: LaneletPose > target_lanelet_pose_ ; }; } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__FOLLOW_LANE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/follow_lane_action.hpp"},{"location":"package/simulation_api/markdown/Files/vehicle_2follow__lane__sequence_2follow__lane__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorvehiclefollow_lane_sequencefollow_lane_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/follow_lane_action.hpp"},{"location":"package/simulation_api/markdown/Files/vehicle_2follow__lane__sequence_2follow__lane__action_8hpp/#namespaces","text":"Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/vehicle_2follow__lane__sequence_2follow__lane__action_8hpp/#classes","text":"Name class entity_behavior::vehicle::follow_lane_sequence::FollowLaneAction","title":"Classes"},{"location":"package/simulation_api/markdown/Files/vehicle_2follow__lane__sequence_2follow__lane__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__FOLLOW_LANE_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__FOLLOW_LANE_ACTION_HPP_ #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { class FollowLaneAction : public entity_behavior :: VehicleActionNode { public : FollowLaneAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; void getBlackBoardValues (); static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: VehicleActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override ; const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override ; private : boost :: optional < openscenario_msgs :: msg :: LaneletPose > target_lanelet_pose_ ; }; } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__FOLLOW_LANE_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/vehicle__action__node_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/vehicle_action_node.cpp # Namespaces # Name entity_behavior Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <string> #include <memory> #include <vector> #include <utility> namespace entity_behavior { VehicleActionNode :: VehicleActionNode ( const std :: string & name , const BT :: NodeConfiguration & config ) : ActionNode ( name , config ) {} void VehicleActionNode :: getBlackBoardValues () { ActionNode :: getBlackBoardValues (); if ( ! getInput < openscenario_msgs :: msg :: DriverModel > ( \"driver_model\" , driver_model )) { driver_model = openscenario_msgs :: msg :: DriverModel (); } if ( ! getInput < openscenario_msgs :: msg :: VehicleParameters > ( \"vehicle_parameters\" , vehicle_parameters )) { throw BehaviorTreeRuntimeError ( \"failed to get input vehicle_parameters in VehicleActionNode\" ); } } openscenario_msgs :: msg :: EntityStatus VehicleActionNode :: calculateEntityStatusUpdated ( double target_speed ) { geometry_msgs :: msg :: Accel accel_new ; accel_new = entity_status . action_status . accel ; double target_accel = ( target_speed - entity_status . action_status . twist . linear . x ) / step_time ; if ( entity_status . action_status . twist . linear . x > target_speed ) { target_accel = boost :: algorithm :: clamp ( target_accel , -5 , 0 ); } else { target_accel = boost :: algorithm :: clamp ( target_accel , 0 , 3 ); } accel_new . linear . x = target_accel ; geometry_msgs :: msg :: Twist twist_new ; twist_new . linear . x = boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x + accel_new . linear . x * step_time , -10 , vehicle_parameters . performance . max_speed ); twist_new . linear . y = 0.0 ; twist_new . linear . z = 0.0 ; twist_new . angular . x = 0.0 ; twist_new . angular . y = 0.0 ; twist_new . angular . z = 0.0 ; std :: int64_t new_lanelet_id = entity_status . lanelet_pose . lanelet_id ; double new_s = entity_status . lanelet_pose . s + ( twist_new . linear . x + entity_status . action_status . twist . linear . x ) / 2.0 * step_time ; if ( new_s < 0 ) { auto previous_lanlet_ids = hdmap_utils -> getPreviousLaneletIds ( entity_status . lanelet_pose . lanelet_id ); new_lanelet_id = previous_lanlet_ids [ 0 ]; new_s = new_s + hdmap_utils -> getLaneletLength ( new_lanelet_id ) - 0.01 ; openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . time = current_time + step_time ; entity_status_updated . lanelet_pose . lanelet_id = new_lanelet_id ; entity_status_updated . lanelet_pose . s = new_s ; entity_status_updated . lanelet_pose . offset = entity_status . lanelet_pose . offset ; entity_status_updated . lanelet_pose . rpy = entity_status . lanelet_pose . rpy ; entity_status_updated . action_status . twist = twist_new ; entity_status_updated . action_status . accel = accel_new ; entity_status_updated . pose = hdmap_utils -> toMapPose ( entity_status_updated . lanelet_pose ). pose ; return entity_status_updated ; } else { bool calculation_success = false ; for ( size_t i = 0 ; i < route_lanelets . size (); i ++ ) { if ( route_lanelets [ i ] == entity_status . lanelet_pose . lanelet_id ) { double length = hdmap_utils -> getLaneletLength ( entity_status . lanelet_pose . lanelet_id ); calculation_success = true ; if ( length < new_s ) { if ( i != ( route_lanelets . size () - 1 )) { new_s = new_s - length ; new_lanelet_id = route_lanelets [ i + 1 ]; break ; } else { new_s = new_s - length ; auto next_ids = hdmap_utils -> getNextLaneletIds ( route_lanelets [ i ]); if ( next_ids . empty ()) { return stopAtEndOfRoad (); } new_lanelet_id = next_ids [ 0 ]; break ; } } } } if ( ! calculation_success ) { throw BehaviorTreeRuntimeError ( \"failed to calculate next status calculateEntityStatusUpdated function\" ); } openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . time = current_time + step_time ; entity_status_updated . lanelet_pose . lanelet_id = new_lanelet_id ; entity_status_updated . lanelet_pose . s = new_s ; entity_status_updated . lanelet_pose . offset = entity_status . lanelet_pose . offset ; entity_status_updated . lanelet_pose . rpy = entity_status . lanelet_pose . rpy ; entity_status_updated . pose = hdmap_utils -> toMapPose ( entity_status_updated . lanelet_pose ). pose ; entity_status_updated . action_status . twist = twist_new ; entity_status_updated . action_status . accel = accel_new ; return entity_status_updated ; } throw BehaviorTreeRuntimeError ( \"failed to calculate next status calculateEntityStatusUpdated function\" ); } openscenario_msgs :: msg :: EntityStatus VehicleActionNode :: calculateEntityStatusUpdatedInWorldFrame ( double target_speed ) { if ( target_speed > vehicle_parameters . performance . max_speed ) { target_speed = vehicle_parameters . performance . max_speed ; } else { target_speed = entity_status . action_status . twist . linear . x ; } double target_accel = ( target_speed - entity_status . action_status . twist . linear . x ) / step_time ; if ( entity_status . action_status . twist . linear . x > target_speed ) { target_accel = boost :: algorithm :: clamp ( target_accel , -1 * driver_model . deceleration , 0 ); } else { target_accel = boost :: algorithm :: clamp ( target_accel , 0 , driver_model . acceleration ); } geometry_msgs :: msg :: Accel accel_new ; accel_new = entity_status . action_status . accel ; accel_new . linear . x = target_accel ; geometry_msgs :: msg :: Twist twist_new ; twist_new . linear . x = entity_status . action_status . twist . linear . x + entity_status . action_status . accel . linear . x * step_time ; twist_new . linear . y = entity_status . action_status . twist . linear . y + entity_status . action_status . accel . linear . y * step_time ; twist_new . linear . z = entity_status . action_status . twist . linear . z + entity_status . action_status . accel . linear . z * step_time ; twist_new . angular . x = entity_status . action_status . twist . angular . x + entity_status . action_status . accel . angular . x * step_time ; twist_new . angular . y = entity_status . action_status . twist . angular . y + entity_status . action_status . accel . angular . y * step_time ; twist_new . angular . z = entity_status . action_status . twist . angular . z + entity_status . action_status . accel . angular . z * step_time ; geometry_msgs :: msg :: Pose pose_new ; geometry_msgs :: msg :: Vector3 angular_trans_vec ; angular_trans_vec . z = twist_new . angular . z * step_time ; geometry_msgs :: msg :: Quaternion angular_trans_quat = quaternion_operation :: convertEulerAngleToQuaternion ( angular_trans_vec ); pose_new . orientation = quaternion_operation :: rotation ( entity_status . pose . orientation , angular_trans_quat ); Eigen :: Vector3d trans_vec ; trans_vec ( 0 ) = twist_new . linear . x * step_time ; trans_vec ( 1 ) = twist_new . linear . y * step_time ; trans_vec ( 2 ) = 0 ; Eigen :: Matrix3d rotation_mat = quaternion_operation :: getRotationMatrix ( pose_new . orientation ); trans_vec = rotation_mat * trans_vec ; pose_new . position . x = trans_vec ( 0 ) + entity_status . pose . position . x ; pose_new . position . y = trans_vec ( 1 ) + entity_status . pose . position . y ; pose_new . position . z = trans_vec ( 2 ) + entity_status . pose . position . z ; openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . time = current_time + step_time ; entity_status_updated . pose = pose_new ; entity_status_updated . action_status . twist = twist_new ; entity_status_updated . action_status . accel = accel_new ; entity_status_updated . lanelet_pose_valid = false ; return entity_status_updated ; } } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/vehicle_action_node.cpp"},{"location":"package/simulation_api/markdown/Files/vehicle__action__node_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorvehiclevehicle_action_nodecpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/vehicle_action_node.cpp"},{"location":"package/simulation_api/markdown/Files/vehicle__action__node_8cpp/#namespaces","text":"Name entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/vehicle__action__node_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <string> #include <memory> #include <vector> #include <utility> namespace entity_behavior { VehicleActionNode :: VehicleActionNode ( const std :: string & name , const BT :: NodeConfiguration & config ) : ActionNode ( name , config ) {} void VehicleActionNode :: getBlackBoardValues () { ActionNode :: getBlackBoardValues (); if ( ! getInput < openscenario_msgs :: msg :: DriverModel > ( \"driver_model\" , driver_model )) { driver_model = openscenario_msgs :: msg :: DriverModel (); } if ( ! getInput < openscenario_msgs :: msg :: VehicleParameters > ( \"vehicle_parameters\" , vehicle_parameters )) { throw BehaviorTreeRuntimeError ( \"failed to get input vehicle_parameters in VehicleActionNode\" ); } } openscenario_msgs :: msg :: EntityStatus VehicleActionNode :: calculateEntityStatusUpdated ( double target_speed ) { geometry_msgs :: msg :: Accel accel_new ; accel_new = entity_status . action_status . accel ; double target_accel = ( target_speed - entity_status . action_status . twist . linear . x ) / step_time ; if ( entity_status . action_status . twist . linear . x > target_speed ) { target_accel = boost :: algorithm :: clamp ( target_accel , -5 , 0 ); } else { target_accel = boost :: algorithm :: clamp ( target_accel , 0 , 3 ); } accel_new . linear . x = target_accel ; geometry_msgs :: msg :: Twist twist_new ; twist_new . linear . x = boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x + accel_new . linear . x * step_time , -10 , vehicle_parameters . performance . max_speed ); twist_new . linear . y = 0.0 ; twist_new . linear . z = 0.0 ; twist_new . angular . x = 0.0 ; twist_new . angular . y = 0.0 ; twist_new . angular . z = 0.0 ; std :: int64_t new_lanelet_id = entity_status . lanelet_pose . lanelet_id ; double new_s = entity_status . lanelet_pose . s + ( twist_new . linear . x + entity_status . action_status . twist . linear . x ) / 2.0 * step_time ; if ( new_s < 0 ) { auto previous_lanlet_ids = hdmap_utils -> getPreviousLaneletIds ( entity_status . lanelet_pose . lanelet_id ); new_lanelet_id = previous_lanlet_ids [ 0 ]; new_s = new_s + hdmap_utils -> getLaneletLength ( new_lanelet_id ) - 0.01 ; openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . time = current_time + step_time ; entity_status_updated . lanelet_pose . lanelet_id = new_lanelet_id ; entity_status_updated . lanelet_pose . s = new_s ; entity_status_updated . lanelet_pose . offset = entity_status . lanelet_pose . offset ; entity_status_updated . lanelet_pose . rpy = entity_status . lanelet_pose . rpy ; entity_status_updated . action_status . twist = twist_new ; entity_status_updated . action_status . accel = accel_new ; entity_status_updated . pose = hdmap_utils -> toMapPose ( entity_status_updated . lanelet_pose ). pose ; return entity_status_updated ; } else { bool calculation_success = false ; for ( size_t i = 0 ; i < route_lanelets . size (); i ++ ) { if ( route_lanelets [ i ] == entity_status . lanelet_pose . lanelet_id ) { double length = hdmap_utils -> getLaneletLength ( entity_status . lanelet_pose . lanelet_id ); calculation_success = true ; if ( length < new_s ) { if ( i != ( route_lanelets . size () - 1 )) { new_s = new_s - length ; new_lanelet_id = route_lanelets [ i + 1 ]; break ; } else { new_s = new_s - length ; auto next_ids = hdmap_utils -> getNextLaneletIds ( route_lanelets [ i ]); if ( next_ids . empty ()) { return stopAtEndOfRoad (); } new_lanelet_id = next_ids [ 0 ]; break ; } } } } if ( ! calculation_success ) { throw BehaviorTreeRuntimeError ( \"failed to calculate next status calculateEntityStatusUpdated function\" ); } openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . time = current_time + step_time ; entity_status_updated . lanelet_pose . lanelet_id = new_lanelet_id ; entity_status_updated . lanelet_pose . s = new_s ; entity_status_updated . lanelet_pose . offset = entity_status . lanelet_pose . offset ; entity_status_updated . lanelet_pose . rpy = entity_status . lanelet_pose . rpy ; entity_status_updated . pose = hdmap_utils -> toMapPose ( entity_status_updated . lanelet_pose ). pose ; entity_status_updated . action_status . twist = twist_new ; entity_status_updated . action_status . accel = accel_new ; return entity_status_updated ; } throw BehaviorTreeRuntimeError ( \"failed to calculate next status calculateEntityStatusUpdated function\" ); } openscenario_msgs :: msg :: EntityStatus VehicleActionNode :: calculateEntityStatusUpdatedInWorldFrame ( double target_speed ) { if ( target_speed > vehicle_parameters . performance . max_speed ) { target_speed = vehicle_parameters . performance . max_speed ; } else { target_speed = entity_status . action_status . twist . linear . x ; } double target_accel = ( target_speed - entity_status . action_status . twist . linear . x ) / step_time ; if ( entity_status . action_status . twist . linear . x > target_speed ) { target_accel = boost :: algorithm :: clamp ( target_accel , -1 * driver_model . deceleration , 0 ); } else { target_accel = boost :: algorithm :: clamp ( target_accel , 0 , driver_model . acceleration ); } geometry_msgs :: msg :: Accel accel_new ; accel_new = entity_status . action_status . accel ; accel_new . linear . x = target_accel ; geometry_msgs :: msg :: Twist twist_new ; twist_new . linear . x = entity_status . action_status . twist . linear . x + entity_status . action_status . accel . linear . x * step_time ; twist_new . linear . y = entity_status . action_status . twist . linear . y + entity_status . action_status . accel . linear . y * step_time ; twist_new . linear . z = entity_status . action_status . twist . linear . z + entity_status . action_status . accel . linear . z * step_time ; twist_new . angular . x = entity_status . action_status . twist . angular . x + entity_status . action_status . accel . angular . x * step_time ; twist_new . angular . y = entity_status . action_status . twist . angular . y + entity_status . action_status . accel . angular . y * step_time ; twist_new . angular . z = entity_status . action_status . twist . angular . z + entity_status . action_status . accel . angular . z * step_time ; geometry_msgs :: msg :: Pose pose_new ; geometry_msgs :: msg :: Vector3 angular_trans_vec ; angular_trans_vec . z = twist_new . angular . z * step_time ; geometry_msgs :: msg :: Quaternion angular_trans_quat = quaternion_operation :: convertEulerAngleToQuaternion ( angular_trans_vec ); pose_new . orientation = quaternion_operation :: rotation ( entity_status . pose . orientation , angular_trans_quat ); Eigen :: Vector3d trans_vec ; trans_vec ( 0 ) = twist_new . linear . x * step_time ; trans_vec ( 1 ) = twist_new . linear . y * step_time ; trans_vec ( 2 ) = 0 ; Eigen :: Matrix3d rotation_mat = quaternion_operation :: getRotationMatrix ( pose_new . orientation ); trans_vec = rotation_mat * trans_vec ; pose_new . position . x = trans_vec ( 0 ) + entity_status . pose . position . x ; pose_new . position . y = trans_vec ( 1 ) + entity_status . pose . position . y ; pose_new . position . z = trans_vec ( 2 ) + entity_status . pose . position . z ; openscenario_msgs :: msg :: EntityStatus entity_status_updated ; entity_status_updated . time = current_time + step_time ; entity_status_updated . pose = pose_new ; entity_status_updated . action_status . twist = twist_new ; entity_status_updated . action_status . accel = accel_new ; entity_status_updated . lanelet_pose_valid = false ; return entity_status_updated ; } } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/vehicle__action__node_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/vehicle_action_node.hpp # Namespaces # Name entity_behavior Classes # Name class entity_behavior::VehicleActionNode Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__VEHICLE_ACTION_NODE_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__VEHICLE_ACTION_NODE_HPP_ #include <behaviortree_cpp_v3/action_node.h> #include <simulation_api/entity/vehicle_parameter.hpp> #include <simulation_api/behavior/action_node.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <openscenario_msgs/msg/waypoints_array.hpp> #include <openscenario_msgs/msg/obstacle.hpp> #include <openscenario_msgs/msg/driver_model.hpp> #include <openscenario_msgs/msg/vehicle_parameters.hpp> #include <string> #include <memory> #include <vector> namespace entity_behavior { class VehicleActionNode : public ActionNode { public : VehicleActionNode ( const std :: string & name , const BT :: NodeConfiguration & config ); ~ VehicleActionNode () override = default ; void getBlackBoardValues (); static BT :: PortsList providedPorts () { BT :: PortsList ports = { BT :: InputPort < openscenario_msgs :: msg :: DriverModel > ( \"driver_model\" ), BT :: InputPort < openscenario_msgs :: msg :: VehicleParameters > ( \"vehicle_parameters\" ) }; BT :: PortsList parent_ports = entity_behavior :: ActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } openscenario_msgs :: msg :: VehicleParameters vehicle_parameters ; openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdated ( double target_speed ); openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdated ( double target_speed , const std :: vector < std :: int64_t > & following_lanelets ); openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdatedInWorldFrame ( double target_speed ); virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () = 0 ; virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) = 0 ; openscenario_msgs :: msg :: DriverModel driver_model ; }; } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__VEHICLE_ACTION_NODE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/vehicle_action_node.hpp"},{"location":"package/simulation_api/markdown/Files/vehicle__action__node_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorvehiclevehicle_action_nodehpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/vehicle_action_node.hpp"},{"location":"package/simulation_api/markdown/Files/vehicle__action__node_8hpp/#namespaces","text":"Name entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/vehicle__action__node_8hpp/#classes","text":"Name class entity_behavior::VehicleActionNode","title":"Classes"},{"location":"package/simulation_api/markdown/Files/vehicle__action__node_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__VEHICLE_ACTION_NODE_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__VEHICLE_ACTION_NODE_HPP_ #include <behaviortree_cpp_v3/action_node.h> #include <simulation_api/entity/vehicle_parameter.hpp> #include <simulation_api/behavior/action_node.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <openscenario_msgs/msg/waypoints_array.hpp> #include <openscenario_msgs/msg/obstacle.hpp> #include <openscenario_msgs/msg/driver_model.hpp> #include <openscenario_msgs/msg/vehicle_parameters.hpp> #include <string> #include <memory> #include <vector> namespace entity_behavior { class VehicleActionNode : public ActionNode { public : VehicleActionNode ( const std :: string & name , const BT :: NodeConfiguration & config ); ~ VehicleActionNode () override = default ; void getBlackBoardValues (); static BT :: PortsList providedPorts () { BT :: PortsList ports = { BT :: InputPort < openscenario_msgs :: msg :: DriverModel > ( \"driver_model\" ), BT :: InputPort < openscenario_msgs :: msg :: VehicleParameters > ( \"vehicle_parameters\" ) }; BT :: PortsList parent_ports = entity_behavior :: ActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } openscenario_msgs :: msg :: VehicleParameters vehicle_parameters ; openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdated ( double target_speed ); openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdated ( double target_speed , const std :: vector < std :: int64_t > & following_lanelets ); openscenario_msgs :: msg :: EntityStatus calculateEntityStatusUpdatedInWorldFrame ( double target_speed ); virtual const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () = 0 ; virtual const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) = 0 ; openscenario_msgs :: msg :: DriverModel driver_model ; }; } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__VEHICLE_ACTION_NODE_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/vehicle__entity_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/vehicle_entity.cpp # Namespaces # Name simulation_api::entity simulation_api Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/entity/vehicle_entity.hpp> #include <simulation_api/entity/exception.hpp> #include <openscenario_msgs/msg/vehicle_parameters.hpp> #include <quaternion_operation/quaternion_operation.h> #include <boost/algorithm/clamp.hpp> #include <memory> #include <string> #include <vector> namespace simulation_api { namespace entity { VehicleEntity :: VehicleEntity ( std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state , openscenario_msgs :: msg :: VehicleParameters params ) : EntityBase ( params . name , name , initial_state ), parameters ( params ) { tree_ptr_ = std :: make_shared < entity_behavior :: vehicle :: BehaviorTree > (); tree_ptr_ -> setValueToBlackBoard ( \"vehicle_parameters\" , parameters ); } void VehicleEntity :: requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) { if ( ! status_ ) { return ; } if ( ! status_ -> lanelet_pose_valid ) { return ; } route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose , waypoints ); } VehicleEntity :: VehicleEntity ( std :: string name , openscenario_msgs :: msg :: VehicleParameters params ) : EntityBase ( params . name , name ), parameters ( params ) { tree_ptr_ = std :: make_shared < entity_behavior :: vehicle :: BehaviorTree > (); tree_ptr_ -> setValueToBlackBoard ( \"vehicle_parameters\" , parameters ); } void VehicleEntity :: requestAcquirePosition ( openscenario_msgs :: msg :: LaneletPose lanelet_pose ) { if ( ! status_ ) { return ; } if ( ! status_ -> lanelet_pose_valid ) { return ; } route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose , lanelet_pose ); } void VehicleEntity :: requestLaneChange ( std :: int64_t to_lanelet_id ) { tree_ptr_ -> setRequest ( \"lane_change\" ); tree_ptr_ -> setValueToBlackBoard ( \"to_lanelet_id\" , to_lanelet_id ); } void VehicleEntity :: cancelRequest () { tree_ptr_ -> setRequest ( \"none\" ); } void VehicleEntity :: setTargetSpeed ( double target_speed , bool continuous ) { target_speed_ = target_speed ; tree_ptr_ -> setValueToBlackBoard ( \"target_speed\" , target_speed_ ); if ( continuous ) { target_speed_ = boost :: none ; } } void VehicleEntity :: onUpdate ( double current_time , double step_time ) { if ( ! status_ ) { return ; } tree_ptr_ -> setValueToBlackBoard ( \"other_entity_status\" , other_status_ ); tree_ptr_ -> setValueToBlackBoard ( \"entity_type_list\" , entity_type_list_ ); tree_ptr_ -> setValueToBlackBoard ( \"entity_status\" , status_ . get ()); if ( status_ -> lanelet_pose_valid ) { tree_ptr_ -> setValueToBlackBoard ( \"route_lanelets\" , route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose )); } else { std :: vector < std :: int64_t > empty = {}; tree_ptr_ -> setValueToBlackBoard ( \"route_lanelets\" , empty ); } action_status_ = tree_ptr_ -> tick ( current_time , step_time ); while ( getCurrentAction () == \"root\" ) { action_status_ = tree_ptr_ -> tick ( current_time , step_time ); } auto status_updated = tree_ptr_ -> getUpdatedStatus (); if ( status_updated . lanelet_pose_valid ) { auto following_lanelets = hdmap_utils_ptr_ -> getFollowingLanelets ( status_updated . lanelet_pose . lanelet_id ); auto l = hdmap_utils_ptr_ -> getLaneletLength ( status_updated . lanelet_pose . lanelet_id ); if ( following_lanelets . size () == 1 && l <= status_updated . lanelet_pose . s ) { stopAtEndOfRoad (); return ; } } if ( target_speed_ ) { if ( status_updated . action_status . twist . linear . x >= target_speed_ . get ()) { target_speed_ = boost :: none ; tree_ptr_ -> setValueToBlackBoard ( \"target_speed\" , target_speed_ ); } } if ( ! status_ ) { linear_jerk_ = 0 ; } else { linear_jerk_ = ( status_updated . action_status . accel . linear . x - status_ -> action_status . accel . linear . x ) / step_time ; } setStatus ( status_updated ); updateStandStillDuration ( step_time ); } } // namespace entity } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/vehicle_entity.cpp"},{"location":"package/simulation_api/markdown/Files/vehicle__entity_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcentityvehicle_entitycpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/entity/vehicle_entity.cpp"},{"location":"package/simulation_api/markdown/Files/vehicle__entity_8cpp/#namespaces","text":"Name simulation_api::entity simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/vehicle__entity_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/entity/vehicle_entity.hpp> #include <simulation_api/entity/exception.hpp> #include <openscenario_msgs/msg/vehicle_parameters.hpp> #include <quaternion_operation/quaternion_operation.h> #include <boost/algorithm/clamp.hpp> #include <memory> #include <string> #include <vector> namespace simulation_api { namespace entity { VehicleEntity :: VehicleEntity ( std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state , openscenario_msgs :: msg :: VehicleParameters params ) : EntityBase ( params . name , name , initial_state ), parameters ( params ) { tree_ptr_ = std :: make_shared < entity_behavior :: vehicle :: BehaviorTree > (); tree_ptr_ -> setValueToBlackBoard ( \"vehicle_parameters\" , parameters ); } void VehicleEntity :: requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) { if ( ! status_ ) { return ; } if ( ! status_ -> lanelet_pose_valid ) { return ; } route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose , waypoints ); } VehicleEntity :: VehicleEntity ( std :: string name , openscenario_msgs :: msg :: VehicleParameters params ) : EntityBase ( params . name , name ), parameters ( params ) { tree_ptr_ = std :: make_shared < entity_behavior :: vehicle :: BehaviorTree > (); tree_ptr_ -> setValueToBlackBoard ( \"vehicle_parameters\" , parameters ); } void VehicleEntity :: requestAcquirePosition ( openscenario_msgs :: msg :: LaneletPose lanelet_pose ) { if ( ! status_ ) { return ; } if ( ! status_ -> lanelet_pose_valid ) { return ; } route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose , lanelet_pose ); } void VehicleEntity :: requestLaneChange ( std :: int64_t to_lanelet_id ) { tree_ptr_ -> setRequest ( \"lane_change\" ); tree_ptr_ -> setValueToBlackBoard ( \"to_lanelet_id\" , to_lanelet_id ); } void VehicleEntity :: cancelRequest () { tree_ptr_ -> setRequest ( \"none\" ); } void VehicleEntity :: setTargetSpeed ( double target_speed , bool continuous ) { target_speed_ = target_speed ; tree_ptr_ -> setValueToBlackBoard ( \"target_speed\" , target_speed_ ); if ( continuous ) { target_speed_ = boost :: none ; } } void VehicleEntity :: onUpdate ( double current_time , double step_time ) { if ( ! status_ ) { return ; } tree_ptr_ -> setValueToBlackBoard ( \"other_entity_status\" , other_status_ ); tree_ptr_ -> setValueToBlackBoard ( \"entity_type_list\" , entity_type_list_ ); tree_ptr_ -> setValueToBlackBoard ( \"entity_status\" , status_ . get ()); if ( status_ -> lanelet_pose_valid ) { tree_ptr_ -> setValueToBlackBoard ( \"route_lanelets\" , route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose )); } else { std :: vector < std :: int64_t > empty = {}; tree_ptr_ -> setValueToBlackBoard ( \"route_lanelets\" , empty ); } action_status_ = tree_ptr_ -> tick ( current_time , step_time ); while ( getCurrentAction () == \"root\" ) { action_status_ = tree_ptr_ -> tick ( current_time , step_time ); } auto status_updated = tree_ptr_ -> getUpdatedStatus (); if ( status_updated . lanelet_pose_valid ) { auto following_lanelets = hdmap_utils_ptr_ -> getFollowingLanelets ( status_updated . lanelet_pose . lanelet_id ); auto l = hdmap_utils_ptr_ -> getLaneletLength ( status_updated . lanelet_pose . lanelet_id ); if ( following_lanelets . size () == 1 && l <= status_updated . lanelet_pose . s ) { stopAtEndOfRoad (); return ; } } if ( target_speed_ ) { if ( status_updated . action_status . twist . linear . x >= target_speed_ . get ()) { target_speed_ = boost :: none ; tree_ptr_ -> setValueToBlackBoard ( \"target_speed\" , target_speed_ ); } } if ( ! status_ ) { linear_jerk_ = 0 ; } else { linear_jerk_ = ( status_updated . action_status . accel . linear . x - status_ -> action_status . accel . linear . x ) / step_time ; } setStatus ( status_updated ); updateStandStillDuration ( step_time ); } } // namespace entity } // namespace simulation_api Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/vehicle__entity_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/vehicle_entity.hpp # Namespaces # Name simulation_api::entity simulation_api Classes # Name class simulation_api::entity::VehicleEntity Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__VEHICLE_ENTITY_HPP_ #define SIMULATION_API__ENTITY__VEHICLE_ENTITY_HPP_ #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/entity/vehicle_parameter.hpp> #include <simulation_api/behavior/vehicle/lane_change_action.hpp> #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/route_planner.hpp> #include <openscenario_msgs/msg/waypoints_array.hpp> #include <openscenario_msgs/msg/driver_model.hpp> #include <openscenario_msgs/msg/vehicle_parameters.hpp> #include <rclcpp/rclcpp.hpp> // headers in pugixml #include <pugixml.hpp> #include <boost/optional.hpp> #include <memory> #include <vector> #include <string> namespace simulation_api { namespace entity { class VehicleEntity : public EntityBase { public : VehicleEntity ( std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state , openscenario_msgs :: msg :: VehicleParameters parameters ); VehicleEntity ( std :: string name , openscenario_msgs :: msg :: VehicleParameters parameters ); const openscenario_msgs :: msg :: VehicleParameters parameters ; void onUpdate ( double current_time , double step_time ) override ; void requestAcquirePosition ( openscenario_msgs :: msg :: LaneletPose lanelet_pose ); void requestLaneChange ( std :: int64_t to_lanelet_id ); void cancelRequest (); void setDriverModel ( const openscenario_msgs :: msg :: DriverModel & model ) { tree_ptr_ -> setValueToBlackBoard ( \"driver_model\" , model ); } void setHdMapUtils ( std :: shared_ptr < hdmap_utils :: HdMapUtils > ptr ) { hdmap_utils_ptr_ = ptr ; route_planner_ptr_ = std :: make_shared < simulation_api :: RoutePlanner > ( ptr ); tree_ptr_ -> setValueToBlackBoard ( \"hdmap_utils\" , hdmap_utils_ptr_ ); } void setTrafficLightManager ( std :: shared_ptr < simulation_api :: TrafficLightManager > ptr ) { traffic_light_manager_ = ptr ; tree_ptr_ -> setValueToBlackBoard ( \"traffic_light_manager\" , traffic_light_manager_ ); } void setTargetSpeed ( double target_speed , bool continuous ); const openscenario_msgs :: msg :: BoundingBox getBoundingBox () const override { return parameters . bounding_box ; } void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) override ; const std :: string getCurrentAction () const { return tree_ptr_ -> getCurrentAction (); } openscenario_msgs :: msg :: WaypointsArray getWaypoints () { return tree_ptr_ -> getWaypoints (); } boost :: optional < openscenario_msgs :: msg :: Obstacle > getObstacle () { return tree_ptr_ -> getObstacle (); } std :: vector < std :: int64_t > getRouteLanelets ( double horizon = 100 ) { if ( ! status_ ) { return {}; } if ( ! status_ -> lanelet_pose_valid ) { return {}; } return route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose , horizon ); } private : std :: shared_ptr < entity_behavior :: vehicle :: BehaviorTree > tree_ptr_ ; BT :: NodeStatus action_status_ ; std :: int64_t to_lanelet_id_ ; boost :: optional < double > target_speed_ ; std :: shared_ptr < simulation_api :: RoutePlanner > route_planner_ptr_ ; }; } // namespace entity } // namespace simulation_api #endif // SIMULATION_API__ENTITY__VEHICLE_ENTITY_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/vehicle_entity.hpp"},{"location":"package/simulation_api/markdown/Files/vehicle__entity_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apientityvehicle_entityhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/vehicle_entity.hpp"},{"location":"package/simulation_api/markdown/Files/vehicle__entity_8hpp/#namespaces","text":"Name simulation_api::entity simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/vehicle__entity_8hpp/#classes","text":"Name class simulation_api::entity::VehicleEntity","title":"Classes"},{"location":"package/simulation_api/markdown/Files/vehicle__entity_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__VEHICLE_ENTITY_HPP_ #define SIMULATION_API__ENTITY__VEHICLE_ENTITY_HPP_ #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/entity/vehicle_parameter.hpp> #include <simulation_api/behavior/vehicle/lane_change_action.hpp> #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/behavior/route_planner.hpp> #include <openscenario_msgs/msg/waypoints_array.hpp> #include <openscenario_msgs/msg/driver_model.hpp> #include <openscenario_msgs/msg/vehicle_parameters.hpp> #include <rclcpp/rclcpp.hpp> // headers in pugixml #include <pugixml.hpp> #include <boost/optional.hpp> #include <memory> #include <vector> #include <string> namespace simulation_api { namespace entity { class VehicleEntity : public EntityBase { public : VehicleEntity ( std :: string name , const openscenario_msgs :: msg :: EntityStatus & initial_state , openscenario_msgs :: msg :: VehicleParameters parameters ); VehicleEntity ( std :: string name , openscenario_msgs :: msg :: VehicleParameters parameters ); const openscenario_msgs :: msg :: VehicleParameters parameters ; void onUpdate ( double current_time , double step_time ) override ; void requestAcquirePosition ( openscenario_msgs :: msg :: LaneletPose lanelet_pose ); void requestLaneChange ( std :: int64_t to_lanelet_id ); void cancelRequest (); void setDriverModel ( const openscenario_msgs :: msg :: DriverModel & model ) { tree_ptr_ -> setValueToBlackBoard ( \"driver_model\" , model ); } void setHdMapUtils ( std :: shared_ptr < hdmap_utils :: HdMapUtils > ptr ) { hdmap_utils_ptr_ = ptr ; route_planner_ptr_ = std :: make_shared < simulation_api :: RoutePlanner > ( ptr ); tree_ptr_ -> setValueToBlackBoard ( \"hdmap_utils\" , hdmap_utils_ptr_ ); } void setTrafficLightManager ( std :: shared_ptr < simulation_api :: TrafficLightManager > ptr ) { traffic_light_manager_ = ptr ; tree_ptr_ -> setValueToBlackBoard ( \"traffic_light_manager\" , traffic_light_manager_ ); } void setTargetSpeed ( double target_speed , bool continuous ); const openscenario_msgs :: msg :: BoundingBox getBoundingBox () const override { return parameters . bounding_box ; } void requestAssignRoute ( const std :: vector < openscenario_msgs :: msg :: LaneletPose > & waypoints ) override ; const std :: string getCurrentAction () const { return tree_ptr_ -> getCurrentAction (); } openscenario_msgs :: msg :: WaypointsArray getWaypoints () { return tree_ptr_ -> getWaypoints (); } boost :: optional < openscenario_msgs :: msg :: Obstacle > getObstacle () { return tree_ptr_ -> getObstacle (); } std :: vector < std :: int64_t > getRouteLanelets ( double horizon = 100 ) { if ( ! status_ ) { return {}; } if ( ! status_ -> lanelet_pose_valid ) { return {}; } return route_planner_ptr_ -> getRouteLanelets ( status_ -> lanelet_pose , horizon ); } private : std :: shared_ptr < entity_behavior :: vehicle :: BehaviorTree > tree_ptr_ ; BT :: NodeStatus action_status_ ; std :: int64_t to_lanelet_id_ ; boost :: optional < double > target_speed_ ; std :: shared_ptr < simulation_api :: RoutePlanner > route_planner_ptr_ ; }; } // namespace entity } // namespace simulation_api #endif // SIMULATION_API__ENTITY__VEHICLE_ENTITY_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/vehicle__parameter_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/vehicle_parameter.hpp # Namespaces # Name simulation_api::entity simulation_api Classes # Name struct simulation_api::entity::VehicleParameters struct simulation_api::entity::Performance struct simulation_api::entity::Dimensions struct simulation_api::entity::Center struct simulation_api::entity::BoundingBox struct simulation_api::entity::Axles struct simulation_api::entity::Axle Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__VEHICLE_PARAMETER_HPP_ #define SIMULATION_API__ENTITY__VEHICLE_PARAMETER_HPP_ // headers in pugixml #include <openscenario_msgs.pb.h> #include <openscenario_msgs/msg/bounding_box.hpp> #include <openscenario_msgs/msg/vehicle_parameters.hpp> #include <pugixml.hpp> #include <rclcpp/rclcpp.hpp> #include <geometry_msgs/msg/vector3.hpp> #include <boost/property_tree/ptree.hpp> #include <boost/property_tree/xml_parser.hpp> #include <boost/foreach.hpp> #include <sstream> #include <string> namespace simulation_api { namespace entity { struct Performance { explicit Performance ( const pugi :: xml_node & xml ) : max_speed ( xml . child ( \"Performance\" ). attribute ( \"maxSpeed\" ). as_double ()), max_acceleration ( xml . child ( \"Performance\" ). attribute ( \"maxAcceleration\" ). as_double ()), max_deceleration ( xml . child ( \"Performance\" ). attribute ( \"maxDeceleration\" ). as_double ()) {} Performance ( double max_speed , double max_acceleration , double max_deceleration ) : max_speed ( max_speed ), max_acceleration ( max_acceleration ), max_deceleration ( max_deceleration ) {} const double max_speed ; const double max_acceleration ; const double max_deceleration ; const openscenario_msgs :: msg :: Performance toRosMsg () const { openscenario_msgs :: msg :: Performance ret ; ret . max_speed = max_speed ; ret . max_acceleration = max_acceleration ; ret . max_deceleration = max_deceleration ; return ret ; } }; struct Center { explicit Center ( const pugi :: xml_node & xml ) : x ( xml . child ( \"BoundingBox\" ). child ( \"Center\" ). attribute ( \"x\" ). as_double ()), y ( xml . child ( \"BoundingBox\" ). child ( \"Center\" ). attribute ( \"y\" ). as_double ()), z ( xml . child ( \"BoundingBox\" ). child ( \"Center\" ). attribute ( \"z\" ). as_double ()) {} Center ( double x , double y , double z ) : x ( x ), y ( y ), z ( z ) {} const double x ; const double y ; const double z ; }; struct Dimensions { explicit Dimensions ( const pugi :: xml_node & xml ) : width ( xml . child ( \"BoundingBox\" ). child ( \"Dimensions\" ). attribute ( \"width\" ). as_double ()), length ( xml . child ( \"BoundingBox\" ). child ( \"Dimensions\" ). attribute ( \"length\" ). as_double ()), height ( xml . child ( \"BoundingBox\" ). child ( \"Dimensions\" ). attribute ( \"height\" ). as_double ()) {} Dimensions ( double width , double length , double height ) : width ( width ), length ( length ), height ( height ) {} const double width ; const double length ; const double height ; }; struct BoundingBox { explicit BoundingBox ( const pugi :: xml_node & xml ) : center ( xml ), dimensions ( xml ) {} BoundingBox ( Center center , Dimensions dimensions ) : center ( center ), dimensions ( dimensions ) {} const Center center ; const Dimensions dimensions ; const openscenario_msgs :: msg :: BoundingBox toRosMsg () const { openscenario_msgs :: msg :: BoundingBox ret ; ret . center . x = center . x ; ret . center . y = center . y ; ret . center . z = center . z ; ret . dimensions . x = dimensions . length ; ret . dimensions . y = dimensions . width ; ret . dimensions . z = dimensions . height ; return ret ; } }; struct Axle { explicit Axle ( const pugi :: xml_node & xml ) : max_steering ( xml . attribute ( \"maxSteering\" ). as_double ()), wheel_diameter ( xml . attribute ( \"wheelDiameter\" ). as_double ()), track_width ( xml . attribute ( \"trackWidth\" ). as_double ()), position_x ( xml . attribute ( \"positionX\" ). as_double ()), position_z ( xml . attribute ( \"positionZ\" ). as_double ()) {} Axle ( double max_steering , double wheel_diameter , double track_width , double position_x , double position_z ) : max_steering ( max_steering ), wheel_diameter ( wheel_diameter ), track_width ( track_width ), position_x ( position_x ), position_z ( position_z ) {} const double max_steering ; const double wheel_diameter ; const double track_width ; const double position_x ; const double position_z ; const openscenario_msgs :: msg :: Axle toRosMsg () const { openscenario_msgs :: msg :: Axle ret ; ret . max_steering = max_steering ; ret . wheel_diameter = wheel_diameter ; ret . track_width = track_width ; ret . position_x = position_x ; ret . position_z = position_z ; return ret ; } }; struct Axles { explicit Axles ( const pugi :: xml_node & xml ) : front_axle ( xml . child ( \"Axles\" ). child ( \"FrontAxle\" )), rear_axle ( xml . child ( \"Axles\" ). child ( \"RearAxle\" )) {} Axles ( Axle front_axle , Axle rear_axle ) : front_axle ( front_axle ), rear_axle ( rear_axle ) {} const Axle front_axle ; const Axle rear_axle ; const openscenario_msgs :: msg :: Axles toRosMsg () const { openscenario_msgs :: msg :: Axles ret ; ret . front_axle = front_axle . toRosMsg (); ret . rear_axle = rear_axle . toRosMsg (); return ret ; } }; struct VehicleParameters { explicit VehicleParameters ( const pugi :: xml_node & xml ) : performance ( xml . child ( \"Vehicle\" )), bounding_box ( xml . child ( \"Vehicle\" )), axles ( xml . child ( \"Vehicle\" )), name ( xml . attribute ( \"name\" ). as_string ()), vehicle_categoly ( xml . attribute ( \"vehicleCategory\" ). as_string ()) {} VehicleParameters ( std :: string name , std :: string vehicle_categoly , Performance performance , BoundingBox bounding_box , Axles axles ) : performance ( performance ), bounding_box ( bounding_box ), axles ( axles ), name ( name ), vehicle_categoly ( vehicle_categoly ) {} const Performance performance ; const BoundingBox bounding_box ; const Axles axles ; const std :: string name ; const std :: string vehicle_categoly ; const openscenario_msgs :: msg :: VehicleParameters toRosMsg () { openscenario_msgs :: msg :: VehicleParameters ret ; ret . name = name ; ret . vehicle_category = vehicle_categoly ; ret . bounding_box = bounding_box . toRosMsg (); ret . axles = axles . toRosMsg (); ret . performance = performance . toRosMsg (); return ret ; } std :: string toXml () const { using boost :: property_tree :: ptree ; ptree pt ; ptree & vehicle_tree = pt . add ( \"Vehicle\" , \"\" ); vehicle_tree . put ( \"<xmlattr>.name\" , name ); vehicle_tree . put ( \"<xmlattr>.vehicleCategory\" , vehicle_categoly ); ptree & performance_tree = vehicle_tree . add ( \"Performance\" , \"\" ); performance_tree . put ( \"<xmlattr>.maxSpeed\" , performance . max_speed ); performance_tree . put ( \"<xmlattr>.maxAcceleration\" , performance . max_acceleration ); performance_tree . put ( \"<xmlattr>.maxDeceleration\" , performance . max_deceleration ); ptree & center_tree = vehicle_tree . add ( \"BoundingBox.Center\" , \"\" ); center_tree . put ( \"<xmlattr>.x\" , bounding_box . center . x ); center_tree . put ( \"<xmlattr>.y\" , bounding_box . center . y ); center_tree . put ( \"<xmlattr>.z\" , bounding_box . center . z ); ptree & dimensions_tree = vehicle_tree . add ( \"BoundingBox.Dimensions\" , \"\" ); dimensions_tree . put ( \"<xmlattr>.width\" , bounding_box . dimensions . width ); dimensions_tree . put ( \"<xmlattr>.length\" , bounding_box . dimensions . length ); dimensions_tree . put ( \"<xmlattr>.height\" , bounding_box . dimensions . height ); ptree & front_axle_tree = vehicle_tree . add ( \"Axles.FrontAxle\" , \"\" ); front_axle_tree . put ( \"<xmlattr>.maxSteering\" , axles . front_axle . max_steering ); front_axle_tree . put ( \"<xmlattr>.wheelDiameter\" , axles . front_axle . wheel_diameter ); front_axle_tree . put ( \"<xmlattr>.trackWidth\" , axles . front_axle . track_width ); front_axle_tree . put ( \"<xmlattr>.positionX\" , axles . front_axle . position_x ); front_axle_tree . put ( \"<xmlattr>.positionZ\" , axles . front_axle . position_z ); ptree & rear_axle_tree = vehicle_tree . add ( \"Axles.RearAxle\" , \"\" ); rear_axle_tree . put ( \"<xmlattr>.maxSteering\" , axles . rear_axle . max_steering ); rear_axle_tree . put ( \"<xmlattr>.wheelDiameter\" , axles . rear_axle . wheel_diameter ); rear_axle_tree . put ( \"<xmlattr>.trackWidth\" , axles . rear_axle . track_width ); rear_axle_tree . put ( \"<xmlattr>.positionX\" , axles . rear_axle . position_x ); rear_axle_tree . put ( \"<xmlattr>.positionZ\" , axles . rear_axle . position_z ); std :: stringstream ss ; boost :: property_tree :: write_xml ( ss , pt ); return ss . str (); } }; } // namespace entity } // namespace simulation_api #endif // SIMULATION_API__ENTITY__VEHICLE_PARAMETER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/vehicle_parameter.hpp"},{"location":"package/simulation_api/markdown/Files/vehicle__parameter_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apientityvehicle_parameterhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/entity/vehicle_parameter.hpp"},{"location":"package/simulation_api/markdown/Files/vehicle__parameter_8hpp/#namespaces","text":"Name simulation_api::entity simulation_api","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/vehicle__parameter_8hpp/#classes","text":"Name struct simulation_api::entity::VehicleParameters struct simulation_api::entity::Performance struct simulation_api::entity::Dimensions struct simulation_api::entity::Center struct simulation_api::entity::BoundingBox struct simulation_api::entity::Axles struct simulation_api::entity::Axle","title":"Classes"},{"location":"package/simulation_api/markdown/Files/vehicle__parameter_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__ENTITY__VEHICLE_PARAMETER_HPP_ #define SIMULATION_API__ENTITY__VEHICLE_PARAMETER_HPP_ // headers in pugixml #include <openscenario_msgs.pb.h> #include <openscenario_msgs/msg/bounding_box.hpp> #include <openscenario_msgs/msg/vehicle_parameters.hpp> #include <pugixml.hpp> #include <rclcpp/rclcpp.hpp> #include <geometry_msgs/msg/vector3.hpp> #include <boost/property_tree/ptree.hpp> #include <boost/property_tree/xml_parser.hpp> #include <boost/foreach.hpp> #include <sstream> #include <string> namespace simulation_api { namespace entity { struct Performance { explicit Performance ( const pugi :: xml_node & xml ) : max_speed ( xml . child ( \"Performance\" ). attribute ( \"maxSpeed\" ). as_double ()), max_acceleration ( xml . child ( \"Performance\" ). attribute ( \"maxAcceleration\" ). as_double ()), max_deceleration ( xml . child ( \"Performance\" ). attribute ( \"maxDeceleration\" ). as_double ()) {} Performance ( double max_speed , double max_acceleration , double max_deceleration ) : max_speed ( max_speed ), max_acceleration ( max_acceleration ), max_deceleration ( max_deceleration ) {} const double max_speed ; const double max_acceleration ; const double max_deceleration ; const openscenario_msgs :: msg :: Performance toRosMsg () const { openscenario_msgs :: msg :: Performance ret ; ret . max_speed = max_speed ; ret . max_acceleration = max_acceleration ; ret . max_deceleration = max_deceleration ; return ret ; } }; struct Center { explicit Center ( const pugi :: xml_node & xml ) : x ( xml . child ( \"BoundingBox\" ). child ( \"Center\" ). attribute ( \"x\" ). as_double ()), y ( xml . child ( \"BoundingBox\" ). child ( \"Center\" ). attribute ( \"y\" ). as_double ()), z ( xml . child ( \"BoundingBox\" ). child ( \"Center\" ). attribute ( \"z\" ). as_double ()) {} Center ( double x , double y , double z ) : x ( x ), y ( y ), z ( z ) {} const double x ; const double y ; const double z ; }; struct Dimensions { explicit Dimensions ( const pugi :: xml_node & xml ) : width ( xml . child ( \"BoundingBox\" ). child ( \"Dimensions\" ). attribute ( \"width\" ). as_double ()), length ( xml . child ( \"BoundingBox\" ). child ( \"Dimensions\" ). attribute ( \"length\" ). as_double ()), height ( xml . child ( \"BoundingBox\" ). child ( \"Dimensions\" ). attribute ( \"height\" ). as_double ()) {} Dimensions ( double width , double length , double height ) : width ( width ), length ( length ), height ( height ) {} const double width ; const double length ; const double height ; }; struct BoundingBox { explicit BoundingBox ( const pugi :: xml_node & xml ) : center ( xml ), dimensions ( xml ) {} BoundingBox ( Center center , Dimensions dimensions ) : center ( center ), dimensions ( dimensions ) {} const Center center ; const Dimensions dimensions ; const openscenario_msgs :: msg :: BoundingBox toRosMsg () const { openscenario_msgs :: msg :: BoundingBox ret ; ret . center . x = center . x ; ret . center . y = center . y ; ret . center . z = center . z ; ret . dimensions . x = dimensions . length ; ret . dimensions . y = dimensions . width ; ret . dimensions . z = dimensions . height ; return ret ; } }; struct Axle { explicit Axle ( const pugi :: xml_node & xml ) : max_steering ( xml . attribute ( \"maxSteering\" ). as_double ()), wheel_diameter ( xml . attribute ( \"wheelDiameter\" ). as_double ()), track_width ( xml . attribute ( \"trackWidth\" ). as_double ()), position_x ( xml . attribute ( \"positionX\" ). as_double ()), position_z ( xml . attribute ( \"positionZ\" ). as_double ()) {} Axle ( double max_steering , double wheel_diameter , double track_width , double position_x , double position_z ) : max_steering ( max_steering ), wheel_diameter ( wheel_diameter ), track_width ( track_width ), position_x ( position_x ), position_z ( position_z ) {} const double max_steering ; const double wheel_diameter ; const double track_width ; const double position_x ; const double position_z ; const openscenario_msgs :: msg :: Axle toRosMsg () const { openscenario_msgs :: msg :: Axle ret ; ret . max_steering = max_steering ; ret . wheel_diameter = wheel_diameter ; ret . track_width = track_width ; ret . position_x = position_x ; ret . position_z = position_z ; return ret ; } }; struct Axles { explicit Axles ( const pugi :: xml_node & xml ) : front_axle ( xml . child ( \"Axles\" ). child ( \"FrontAxle\" )), rear_axle ( xml . child ( \"Axles\" ). child ( \"RearAxle\" )) {} Axles ( Axle front_axle , Axle rear_axle ) : front_axle ( front_axle ), rear_axle ( rear_axle ) {} const Axle front_axle ; const Axle rear_axle ; const openscenario_msgs :: msg :: Axles toRosMsg () const { openscenario_msgs :: msg :: Axles ret ; ret . front_axle = front_axle . toRosMsg (); ret . rear_axle = rear_axle . toRosMsg (); return ret ; } }; struct VehicleParameters { explicit VehicleParameters ( const pugi :: xml_node & xml ) : performance ( xml . child ( \"Vehicle\" )), bounding_box ( xml . child ( \"Vehicle\" )), axles ( xml . child ( \"Vehicle\" )), name ( xml . attribute ( \"name\" ). as_string ()), vehicle_categoly ( xml . attribute ( \"vehicleCategory\" ). as_string ()) {} VehicleParameters ( std :: string name , std :: string vehicle_categoly , Performance performance , BoundingBox bounding_box , Axles axles ) : performance ( performance ), bounding_box ( bounding_box ), axles ( axles ), name ( name ), vehicle_categoly ( vehicle_categoly ) {} const Performance performance ; const BoundingBox bounding_box ; const Axles axles ; const std :: string name ; const std :: string vehicle_categoly ; const openscenario_msgs :: msg :: VehicleParameters toRosMsg () { openscenario_msgs :: msg :: VehicleParameters ret ; ret . name = name ; ret . vehicle_category = vehicle_categoly ; ret . bounding_box = bounding_box . toRosMsg (); ret . axles = axles . toRosMsg (); ret . performance = performance . toRosMsg (); return ret ; } std :: string toXml () const { using boost :: property_tree :: ptree ; ptree pt ; ptree & vehicle_tree = pt . add ( \"Vehicle\" , \"\" ); vehicle_tree . put ( \"<xmlattr>.name\" , name ); vehicle_tree . put ( \"<xmlattr>.vehicleCategory\" , vehicle_categoly ); ptree & performance_tree = vehicle_tree . add ( \"Performance\" , \"\" ); performance_tree . put ( \"<xmlattr>.maxSpeed\" , performance . max_speed ); performance_tree . put ( \"<xmlattr>.maxAcceleration\" , performance . max_acceleration ); performance_tree . put ( \"<xmlattr>.maxDeceleration\" , performance . max_deceleration ); ptree & center_tree = vehicle_tree . add ( \"BoundingBox.Center\" , \"\" ); center_tree . put ( \"<xmlattr>.x\" , bounding_box . center . x ); center_tree . put ( \"<xmlattr>.y\" , bounding_box . center . y ); center_tree . put ( \"<xmlattr>.z\" , bounding_box . center . z ); ptree & dimensions_tree = vehicle_tree . add ( \"BoundingBox.Dimensions\" , \"\" ); dimensions_tree . put ( \"<xmlattr>.width\" , bounding_box . dimensions . width ); dimensions_tree . put ( \"<xmlattr>.length\" , bounding_box . dimensions . length ); dimensions_tree . put ( \"<xmlattr>.height\" , bounding_box . dimensions . height ); ptree & front_axle_tree = vehicle_tree . add ( \"Axles.FrontAxle\" , \"\" ); front_axle_tree . put ( \"<xmlattr>.maxSteering\" , axles . front_axle . max_steering ); front_axle_tree . put ( \"<xmlattr>.wheelDiameter\" , axles . front_axle . wheel_diameter ); front_axle_tree . put ( \"<xmlattr>.trackWidth\" , axles . front_axle . track_width ); front_axle_tree . put ( \"<xmlattr>.positionX\" , axles . front_axle . position_x ); front_axle_tree . put ( \"<xmlattr>.positionZ\" , axles . front_axle . position_z ); ptree & rear_axle_tree = vehicle_tree . add ( \"Axles.RearAxle\" , \"\" ); rear_axle_tree . put ( \"<xmlattr>.maxSteering\" , axles . rear_axle . max_steering ); rear_axle_tree . put ( \"<xmlattr>.wheelDiameter\" , axles . rear_axle . wheel_diameter ); rear_axle_tree . put ( \"<xmlattr>.trackWidth\" , axles . rear_axle . track_width ); rear_axle_tree . put ( \"<xmlattr>.positionX\" , axles . rear_axle . position_x ); rear_axle_tree . put ( \"<xmlattr>.positionZ\" , axles . rear_axle . position_z ); std :: stringstream ss ; boost :: property_tree :: write_xml ( ss , pt ); return ss . str (); } }; } // namespace entity } // namespace simulation_api #endif // SIMULATION_API__ENTITY__VEHICLE_PARAMETER_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/walk__straight__action_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/walk_straight_action.cpp # class implimentation of the walk straight action More... Namespaces # Name entity_behavior::pedestrian entity_behavior Detailed Description # class implimentation of the walk straight action Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-02 Copyright : Copyright(c) Tier IV.Inc {2015-2021} Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/pedestrian/walk_straight_action.hpp> #include <string> namespace entity_behavior { namespace pedestrian { WalkStraightAction :: WalkStraightAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: PedestrianActionNode ( name , config ) {} void WalkStraightAction :: getBlackBoardValues () { PedestrianActionNode :: getBlackBoardValues (); } BT :: NodeStatus WalkStraightAction :: tick () { getBlackBoardValues (); if ( request != \"walk_straight\" ) { return BT :: NodeStatus :: FAILURE ; } if ( ! target_speed ) { target_speed = 1.111 ; } auto updated_status = calculateEntityStatusUpdatedInWorldFrame ( target_speed . get ()); setOutput ( \"updated_status\" , updated_status ); return BT :: NodeStatus :: RUNNING ; } } // namespace pedestrian } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/walk_straight_action.cpp"},{"location":"package/simulation_api/markdown/Files/walk__straight__action_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorpedestrianwalk_straight_actioncpp","text":"class implimentation of the walk straight action More...","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/pedestrian/walk_straight_action.cpp"},{"location":"package/simulation_api/markdown/Files/walk__straight__action_8cpp/#namespaces","text":"Name entity_behavior::pedestrian entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/walk__straight__action_8cpp/#detailed-description","text":"class implimentation of the walk straight action Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-02 Copyright : Copyright(c) Tier IV.Inc {2015-2021}","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Files/walk__straight__action_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/pedestrian/walk_straight_action.hpp> #include <string> namespace entity_behavior { namespace pedestrian { WalkStraightAction :: WalkStraightAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: PedestrianActionNode ( name , config ) {} void WalkStraightAction :: getBlackBoardValues () { PedestrianActionNode :: getBlackBoardValues (); } BT :: NodeStatus WalkStraightAction :: tick () { getBlackBoardValues (); if ( request != \"walk_straight\" ) { return BT :: NodeStatus :: FAILURE ; } if ( ! target_speed ) { target_speed = 1.111 ; } auto updated_status = calculateEntityStatusUpdatedInWorldFrame ( target_speed . get ()); setOutput ( \"updated_status\" , updated_status ); return BT :: NodeStatus :: RUNNING ; } } // namespace pedestrian } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/walk__straight__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/walk_straight_action.hpp # class definition for the walk straight action More... Namespaces # Name entity_behavior::pedestrian entity_behavior Classes # Name class entity_behavior::pedestrian::WalkStraightAction Detailed Description # class definition for the walk straight action Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-02 Copyright : Copyright(c) Tier IV.Inc {2015-2021} Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__PEDESTRIAN__WALK_STRAIGHT_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__PEDESTRIAN__WALK_STRAIGHT_ACTION_HPP_ #include <simulation_api/behavior/pedestrian/pedestrian_action_node.hpp> #include <simulation_api/entity/pedestrian_parameter.hpp> #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <openscenario_msgs/msg/entity_status.hpp> #include <behaviortree_cpp_v3/behavior_tree.h> #include <behaviortree_cpp_v3/bt_factory.h> #include <string> #include <memory> #include <vector> namespace entity_behavior { namespace pedestrian { class WalkStraightAction : public entity_behavior :: PedestrianActionNode { public : WalkStraightAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; void getBlackBoardValues (); static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: PedestrianActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } }; } // namespace pedestrian } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__PEDESTRIAN__WALK_STRAIGHT_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/walk_straight_action.hpp"},{"location":"package/simulation_api/markdown/Files/walk__straight__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorpedestrianwalk_straight_actionhpp","text":"class definition for the walk straight action More...","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/pedestrian/walk_straight_action.hpp"},{"location":"package/simulation_api/markdown/Files/walk__straight__action_8hpp/#namespaces","text":"Name entity_behavior::pedestrian entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/walk__straight__action_8hpp/#classes","text":"Name class entity_behavior::pedestrian::WalkStraightAction","title":"Classes"},{"location":"package/simulation_api/markdown/Files/walk__straight__action_8hpp/#detailed-description","text":"class definition for the walk straight action Author : Masaya Kataoka ( masaya.kataoka@tier4.jp ) Version : 0.1 Date : 2021-04-02 Copyright : Copyright(c) Tier IV.Inc {2015-2021}","title":"Detailed Description"},{"location":"package/simulation_api/markdown/Files/walk__straight__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__PEDESTRIAN__WALK_STRAIGHT_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__PEDESTRIAN__WALK_STRAIGHT_ACTION_HPP_ #include <simulation_api/behavior/pedestrian/pedestrian_action_node.hpp> #include <simulation_api/entity/pedestrian_parameter.hpp> #include <simulation_api/hdmap_utils/hdmap_utils.hpp> #include <openscenario_msgs/msg/entity_status.hpp> #include <behaviortree_cpp_v3/behavior_tree.h> #include <behaviortree_cpp_v3/bt_factory.h> #include <string> #include <memory> #include <vector> namespace entity_behavior { namespace pedestrian { class WalkStraightAction : public entity_behavior :: PedestrianActionNode { public : WalkStraightAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; void getBlackBoardValues (); static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: PedestrianActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } }; } // namespace pedestrian } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__PEDESTRIAN__WALK_STRAIGHT_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/yield__action_8cpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/yield_action.cpp # Namespaces # Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/follow_lane_sequence/yield_action.hpp> #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <boost/algorithm/clamp.hpp> #include <string> #include <vector> #include <memory> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { YieldAction :: YieldAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: VehicleActionNode ( name , config ) {} const boost :: optional < openscenario_msgs :: msg :: Obstacle > YieldAction :: calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) { if ( ! distance_to_stop_target_ ) { return boost :: none ; } if ( distance_to_stop_target_ . get () < 0 ) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( waypoints . waypoints ); if ( distance_to_stop_target_ . get () > spline . getLength ()) { return boost :: none ; } openscenario_msgs :: msg :: Obstacle obstacle ; obstacle . type = obstacle . ENTITY ; obstacle . s = distance_to_stop_target_ . get (); return obstacle ; } const openscenario_msgs :: msg :: WaypointsArray YieldAction :: calculateWaypoints () { if ( ! entity_status . lanelet_pose_valid ) { throw BehaviorTreeRuntimeError ( \"failed to assign lane\" ); } if ( entity_status . action_status . twist . linear . x >= 0 ) { openscenario_msgs :: msg :: WaypointsArray waypoints ; double horizon = boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x * 5 , 20 , 50 ); simulation_api :: math :: CatmullRomSpline spline ( hdmap_utils -> getCenterPoints ( route_lanelets )); waypoints . waypoints = spline . getTrajectory ( entity_status . lanelet_pose . s , entity_status . lanelet_pose . s + horizon , 1.0 ); return waypoints ; } else { return openscenario_msgs :: msg :: WaypointsArray (); } } boost :: optional < double > YieldAction :: calculateTargetSpeed () { if ( ! distance_to_stop_target_ ) { return boost :: none ; } double rest_distance = distance_to_stop_target_ . get () - ( vehicle_parameters . bounding_box . dimensions . x ) - 10 ; if ( rest_distance < calculateStopDistance ()) { if ( rest_distance > 0 ) { return std :: sqrt ( 2 * 5 * rest_distance ); } else { return 0 ; } } return entity_status . action_status . twist . linear . x ; } BT :: NodeStatus YieldAction :: tick () { getBlackBoardValues (); if ( request != \"none\" && request != \"follow_lane\" ) { return BT :: NodeStatus :: FAILURE ; } if ( ! driver_model . see_around ) { return BT :: NodeStatus :: FAILURE ; } if ( ! entity_status . lanelet_pose_valid ) { return BT :: NodeStatus :: FAILURE ; } const auto right_of_way_entities = getRightOfWayEntities ( route_lanelets ); if ( right_of_way_entities . empty ()) { if ( ! target_speed ) { target_speed = hdmap_utils -> getSpeedLimit ( route_lanelets ); } setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( target_speed . get ())); const auto waypoints = calculateWaypoints (); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: SUCCESS ; } distance_to_stop_target_ = getYieldStopDistance ( route_lanelets ); target_speed = calculateTargetSpeed (); if ( ! target_speed ) { target_speed = hdmap_utils -> getSpeedLimit ( route_lanelets ); } setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( target_speed . get ())); const auto waypoints = calculateWaypoints (); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: RUNNING ; } } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/yield_action.cpp"},{"location":"package/simulation_api/markdown/Files/yield__action_8cpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apisrcbehaviorvehiclefollow_lane_sequenceyield_actioncpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/src/behavior/vehicle/follow_lane_sequence/yield_action.cpp"},{"location":"package/simulation_api/markdown/Files/yield__action_8cpp/#namespaces","text":"Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/yield__action_8cpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <simulation_api/behavior/vehicle/follow_lane_sequence/yield_action.hpp> #include <simulation_api/behavior/vehicle/behavior_tree.hpp> #include <simulation_api/math/catmull_rom_spline.hpp> #include <boost/algorithm/clamp.hpp> #include <string> #include <vector> #include <memory> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { YieldAction :: YieldAction ( const std :: string & name , const BT :: NodeConfiguration & config ) : entity_behavior :: VehicleActionNode ( name , config ) {} const boost :: optional < openscenario_msgs :: msg :: Obstacle > YieldAction :: calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) { if ( ! distance_to_stop_target_ ) { return boost :: none ; } if ( distance_to_stop_target_ . get () < 0 ) { return boost :: none ; } simulation_api :: math :: CatmullRomSpline spline ( waypoints . waypoints ); if ( distance_to_stop_target_ . get () > spline . getLength ()) { return boost :: none ; } openscenario_msgs :: msg :: Obstacle obstacle ; obstacle . type = obstacle . ENTITY ; obstacle . s = distance_to_stop_target_ . get (); return obstacle ; } const openscenario_msgs :: msg :: WaypointsArray YieldAction :: calculateWaypoints () { if ( ! entity_status . lanelet_pose_valid ) { throw BehaviorTreeRuntimeError ( \"failed to assign lane\" ); } if ( entity_status . action_status . twist . linear . x >= 0 ) { openscenario_msgs :: msg :: WaypointsArray waypoints ; double horizon = boost :: algorithm :: clamp ( entity_status . action_status . twist . linear . x * 5 , 20 , 50 ); simulation_api :: math :: CatmullRomSpline spline ( hdmap_utils -> getCenterPoints ( route_lanelets )); waypoints . waypoints = spline . getTrajectory ( entity_status . lanelet_pose . s , entity_status . lanelet_pose . s + horizon , 1.0 ); return waypoints ; } else { return openscenario_msgs :: msg :: WaypointsArray (); } } boost :: optional < double > YieldAction :: calculateTargetSpeed () { if ( ! distance_to_stop_target_ ) { return boost :: none ; } double rest_distance = distance_to_stop_target_ . get () - ( vehicle_parameters . bounding_box . dimensions . x ) - 10 ; if ( rest_distance < calculateStopDistance ()) { if ( rest_distance > 0 ) { return std :: sqrt ( 2 * 5 * rest_distance ); } else { return 0 ; } } return entity_status . action_status . twist . linear . x ; } BT :: NodeStatus YieldAction :: tick () { getBlackBoardValues (); if ( request != \"none\" && request != \"follow_lane\" ) { return BT :: NodeStatus :: FAILURE ; } if ( ! driver_model . see_around ) { return BT :: NodeStatus :: FAILURE ; } if ( ! entity_status . lanelet_pose_valid ) { return BT :: NodeStatus :: FAILURE ; } const auto right_of_way_entities = getRightOfWayEntities ( route_lanelets ); if ( right_of_way_entities . empty ()) { if ( ! target_speed ) { target_speed = hdmap_utils -> getSpeedLimit ( route_lanelets ); } setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( target_speed . get ())); const auto waypoints = calculateWaypoints (); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: SUCCESS ; } distance_to_stop_target_ = getYieldStopDistance ( route_lanelets ); target_speed = calculateTargetSpeed (); if ( ! target_speed ) { target_speed = hdmap_utils -> getSpeedLimit ( route_lanelets ); } setOutput ( \"updated_status\" , calculateEntityStatusUpdated ( target_speed . get ())); const auto waypoints = calculateWaypoints (); const auto obstacle = calculateObstacle ( waypoints ); setOutput ( \"waypoints\" , waypoints ); setOutput ( \"obstacle\" , obstacle ); return BT :: NodeStatus :: RUNNING ; } } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Files/yield__action_8hpp/","text":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/yield_action.hpp # Namespaces # Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior Classes # Name class entity_behavior::vehicle::follow_lane_sequence::YieldAction Source code # // Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__YIELD_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__YIELD_ACTION_HPP_ #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { class YieldAction : public entity_behavior :: VehicleActionNode { public : YieldAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: VehicleActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } boost :: optional < double > calculateTargetSpeed (); const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override ; const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override ; private : boost :: optional < double > distance_to_stop_target_ ; }; } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__YIELD_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/yield_action.hpp"},{"location":"package/simulation_api/markdown/Files/yield__action_8hpp/#homerunnerworkscenario_simulator_v2scenario_simulator_v2simulationsimulation_apiincludesimulation_apibehaviorvehiclefollow_lane_sequenceyield_actionhpp","text":"","title":"/home/runner/work/scenario_simulator_v2/scenario_simulator_v2/simulation/simulation_api/include/simulation_api/behavior/vehicle/follow_lane_sequence/yield_action.hpp"},{"location":"package/simulation_api/markdown/Files/yield__action_8hpp/#namespaces","text":"Name entity_behavior::vehicle::follow_lane_sequence entity_behavior::vehicle entity_behavior","title":"Namespaces"},{"location":"package/simulation_api/markdown/Files/yield__action_8hpp/#classes","text":"Name class entity_behavior::vehicle::follow_lane_sequence::YieldAction","title":"Classes"},{"location":"package/simulation_api/markdown/Files/yield__action_8hpp/#source-code","text":"// Copyright 2015-2020 Tier IV, Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__YIELD_ACTION_HPP_ #define SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__YIELD_ACTION_HPP_ #include <simulation_api/entity/entity_base.hpp> #include <simulation_api/behavior/vehicle/vehicle_action_node.hpp> #include <openscenario_msgs/msg/entity_trajectory.hpp> #include <string> #include <vector> namespace entity_behavior { namespace vehicle { namespace follow_lane_sequence { class YieldAction : public entity_behavior :: VehicleActionNode { public : YieldAction ( const std :: string & name , const BT :: NodeConfiguration & config ); BT :: NodeStatus tick () override ; static BT :: PortsList providedPorts () { BT :: PortsList ports = {}; BT :: PortsList parent_ports = entity_behavior :: VehicleActionNode :: providedPorts (); for ( const auto & parent_port : parent_ports ) { ports . emplace ( parent_port . first , parent_port . second ); } return ports ; } boost :: optional < double > calculateTargetSpeed (); const openscenario_msgs :: msg :: WaypointsArray calculateWaypoints () override ; const boost :: optional < openscenario_msgs :: msg :: Obstacle > calculateObstacle ( const openscenario_msgs :: msg :: WaypointsArray & waypoints ) override ; private : boost :: optional < double > distance_to_stop_target_ ; }; } // namespace follow_lane_sequence } // namespace vehicle } // namespace entity_behavior #endif // SIMULATION_API__BEHAVIOR__VEHICLE__FOLLOW_LANE_SEQUENCE__YIELD_ACTION_HPP_ Updated on 7 April 2021 at 00:31:55 UTC","title":"Source code"},{"location":"package/simulation_api/markdown/Modules/","text":"Modules # Updated on 7 April 2021 at 00:31:55 UTC","title":"Modules"},{"location":"package/simulation_api/markdown/Modules/#modules","text":"Updated on 7 April 2021 at 00:31:55 UTC","title":"Modules"},{"location":"package/simulation_api/markdown/Namespaces/","text":"Namespaces # namespace color_utils namespace entity_behavior namespace pedestrian namespace vehicle namespace follow_lane_sequence namespace hdmap_utils namespace metrics namespace scenario_simulator namespace sim_model_util namespace simulation_api namespace entity namespace helper namespace math namespace traffic Updated on 7 April 2021 at 00:31:55 UTC","title":"Namespaces"},{"location":"package/simulation_api/markdown/Namespaces/#namespaces","text":"namespace color_utils namespace entity_behavior namespace pedestrian namespace vehicle namespace follow_lane_sequence namespace hdmap_utils namespace metrics namespace scenario_simulator namespace sim_model_util namespace simulation_api namespace entity namespace helper namespace math namespace traffic Updated on 7 April 2021 at 00:31:55 UTC","title":"Namespaces"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/","text":"color_utils # Functions # Name void printYellow (const std::string & text) void printWhite (const std::string & text) void printRed (const std::string & text) void printMagenta (const std::string & text) void printGreen (const std::string & text) void printCyan (const std::string & text) void printBlue (const std::string & text) const std_msgs::msg::ColorRGBA makeColorMsg (std::string preset_name, double alpha =1.0) generate std_msgs::msg::ColorRGBA message from color name const std_msgs::msg::ColorRGBA fromRgba (double r, double g, double b, double alpha =1.0) generate std_msgs::msg::ColorRGBA message from rgb values const std_msgs::msg::ColorRGBA fromHsv (double h, double s, double v, double alpha =1.0) 0 <= h <= 1.0,0 <= s <= 1.0,0 <= v <= 1.0 Attributes # Name const std::map< std::string, std::array< float, 3 > > COLOR_NAME_DICT Functions Documentation # function printYellow # void printYellow ( const std :: string & text ) function printWhite # void printWhite ( const std :: string & text ) function printRed # void printRed ( const std :: string & text ) function printMagenta # void printMagenta ( const std :: string & text ) function printGreen # void printGreen ( const std :: string & text ) function printCyan # void printCyan ( const std :: string & text ) function printBlue # void printBlue ( const std :: string & text ) function makeColorMsg # const std_msgs :: msg :: ColorRGBA makeColorMsg ( std :: string preset_name , double alpha = 1.0 ) generate std_msgs::msg::ColorRGBA message from color name Parameters : preset_name the name of the color alpha alpha value of the color Return : std_msgs::msg::ColorRGBA function fromRgba # const std_msgs :: msg :: ColorRGBA fromRgba ( double r , double g , double b , double alpha = 1.0 ) generate std_msgs::msg::ColorRGBA message from rgb values Parameters : r red g green b blue alpha alpha value of the color Return : std_msgs::msg::ColorRGBA function fromHsv # const std_msgs :: msg :: ColorRGBA fromHsv ( double h , double s , double v , double alpha = 1.0 ) 0 <= h <= 1.0,0 <= s <= 1.0,0 <= v <= 1.0 Parameters : h hue s saturation v value generate std_msgs::msg::ColorRGBA message from hsv values Attributes Documentation # variable COLOR_NAME_DICT # const std :: map < std :: string , std :: array < float , 3 > > COLOR_NAME_DICT ; Todo : Read data from text data? Updated on 7 April 2021 at 00:31:55 UTC","title":"color_utils"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#color_utils","text":"","title":"color_utils"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#functions","text":"Name void printYellow (const std::string & text) void printWhite (const std::string & text) void printRed (const std::string & text) void printMagenta (const std::string & text) void printGreen (const std::string & text) void printCyan (const std::string & text) void printBlue (const std::string & text) const std_msgs::msg::ColorRGBA makeColorMsg (std::string preset_name, double alpha =1.0) generate std_msgs::msg::ColorRGBA message from color name const std_msgs::msg::ColorRGBA fromRgba (double r, double g, double b, double alpha =1.0) generate std_msgs::msg::ColorRGBA message from rgb values const std_msgs::msg::ColorRGBA fromHsv (double h, double s, double v, double alpha =1.0) 0 <= h <= 1.0,0 <= s <= 1.0,0 <= v <= 1.0","title":"Functions"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#attributes","text":"Name const std::map< std::string, std::array< float, 3 > > COLOR_NAME_DICT","title":"Attributes"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#function-printyellow","text":"void printYellow ( const std :: string & text )","title":"function printYellow"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#function-printwhite","text":"void printWhite ( const std :: string & text )","title":"function printWhite"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#function-printred","text":"void printRed ( const std :: string & text )","title":"function printRed"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#function-printmagenta","text":"void printMagenta ( const std :: string & text )","title":"function printMagenta"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#function-printgreen","text":"void printGreen ( const std :: string & text )","title":"function printGreen"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#function-printcyan","text":"void printCyan ( const std :: string & text )","title":"function printCyan"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#function-printblue","text":"void printBlue ( const std :: string & text )","title":"function printBlue"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#function-makecolormsg","text":"const std_msgs :: msg :: ColorRGBA makeColorMsg ( std :: string preset_name , double alpha = 1.0 ) generate std_msgs::msg::ColorRGBA message from color name Parameters : preset_name the name of the color alpha alpha value of the color Return : std_msgs::msg::ColorRGBA","title":"function makeColorMsg"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#function-fromrgba","text":"const std_msgs :: msg :: ColorRGBA fromRgba ( double r , double g , double b , double alpha = 1.0 ) generate std_msgs::msg::ColorRGBA message from rgb values Parameters : r red g green b blue alpha alpha value of the color Return : std_msgs::msg::ColorRGBA","title":"function fromRgba"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#function-fromhsv","text":"const std_msgs :: msg :: ColorRGBA fromHsv ( double h , double s , double v , double alpha = 1.0 ) 0 <= h <= 1.0,0 <= s <= 1.0,0 <= v <= 1.0 Parameters : h hue s saturation v value generate std_msgs::msg::ColorRGBA message from hsv values","title":"function fromHsv"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"package/simulation_api/markdown/Namespaces/namespacecolor__utils/#variable-color_name_dict","text":"const std :: map < std :: string , std :: array < float , 3 > > COLOR_NAME_DICT ; Todo : Read data from text data? Updated on 7 April 2021 at 00:31:55 UTC","title":"variable COLOR_NAME_DICT"},{"location":"package/simulation_api/markdown/Namespaces/namespaceentity__behavior/","text":"entity_behavior # Namespaces # Name entity_behavior::vehicle entity_behavior::pedestrian Classes # Name class entity_behavior::VehicleActionNode class entity_behavior::PedestrianActionNode class entity_behavior::BehaviorTreeRuntimeError class entity_behavior::ActionNode Updated on 7 April 2021 at 00:31:54 UTC","title":"entity_behavior"},{"location":"package/simulation_api/markdown/Namespaces/namespaceentity__behavior/#entity_behavior","text":"","title":"entity_behavior"},{"location":"package/simulation_api/markdown/Namespaces/namespaceentity__behavior/#namespaces","text":"Name entity_behavior::vehicle entity_behavior::pedestrian","title":"Namespaces"},{"location":"package/simulation_api/markdown/Namespaces/namespaceentity__behavior/#classes","text":"Name class entity_behavior::VehicleActionNode class entity_behavior::PedestrianActionNode class entity_behavior::BehaviorTreeRuntimeError class entity_behavior::ActionNode Updated on 7 April 2021 at 00:31:54 UTC","title":"Classes"},{"location":"package/simulation_api/markdown/Namespaces/namespaceentity__behavior_1_1pedestrian/","text":"entity_behavior::pedestrian # Classes # Name class entity_behavior::pedestrian::WalkStraightAction class entity_behavior::pedestrian::FollowLaneAction class entity_behavior::pedestrian::BehaviorTree Updated on 7 April 2021 at 00:31:55 UTC","title":"entity_behavior::pedestrian"},{"location":"package/simulation_api/markdown/Namespaces/namespaceentity__behavior_1_1pedestrian/#entity_behaviorpedestrian","text":"","title":"entity_behavior::pedestrian"},{"location":"package/simulation_api/markdown/Namespaces/namespaceentity__behavior_1_1pedestrian/#classes","text":"Name class entity_behavior::pedestrian::WalkStraightAction class entity_behavior::pedestrian::FollowLaneAction class entity_behavior::pedestrian::BehaviorTree Updated on 7 April 2021 at 00:31:55 UTC","title":"Classes"},{"location":"package/simulation_api/markdown/Namespaces/namespaceentity__behavior_1_1vehicle/","text":"entity_behavior::vehicle # Namespaces # Name entity_behavior::vehicle::follow_lane_sequence Classes # Name class entity_behavior::vehicle::LaneChangeAction class entity_behavior::vehicle::BehaviorTree Updated on 7 April 2021 at 00:31:54 UTC","title":"entity_behavior::vehicle"},{"location":"package/simulation_api/markdown/Namespaces/namespaceentity__behavior_1_1vehicle/#entity_behaviorvehicle","text":"","title":"entity_behavior::vehicle"},{"location":"package/simulation_api/markdown/Namespaces/namespaceentity__behavior_1_1vehicle/#namespaces","text":"Name entity_behavior::vehicle::follow_lane_sequence","title":"Namespaces"},{"location":"package/simulation_api/markdown/Namespaces/namespaceentity__behavior_1_1vehicle/#classes","text":"Name class entity_behavior::vehicle::LaneChangeAction class entity_behavior::vehicle::BehaviorTree Updated on 7 April 2021 at 00:31:54 UTC","title":"Classes"},{"location":"package/simulation_api/markdown/Namespaces/namespaceentity__behavior_1_1vehicle_1_1follow__lane__sequence/","text":"entity_behavior::vehicle::follow_lane_sequence # Classes # Name class entity_behavior::vehicle::follow_lane_sequence::YieldAction class entity_behavior::vehicle::follow_lane_sequence::StopAtTrafficLightAction class entity_behavior::vehicle::follow_lane_sequence::StopAtStopLineAction class entity_behavior::vehicle::follow_lane_sequence::StopAtCrossingEntityAction class entity_behavior::vehicle::follow_lane_sequence::FollowLaneAction class entity_behavior::vehicle::follow_lane_sequence::FollowFrontEntityAction Updated on 7 April 2021 at 00:31:54 UTC","title":"entity_behavior::vehicle::follow_lane_sequence"},{"location":"package/simulation_api/markdown/Namespaces/namespaceentity__behavior_1_1vehicle_1_1follow__lane__sequence/#entity_behaviorvehiclefollow_lane_sequence","text":"","title":"entity_behavior::vehicle::follow_lane_sequence"},{"location":"package/simulation_api/markdown/Namespaces/namespaceentity__behavior_1_1vehicle_1_1follow__lane__sequence/#classes","text":"Name class entity_behavior::vehicle::follow_lane_sequence::YieldAction class entity_behavior::vehicle::follow_lane_sequence::StopAtTrafficLightAction class entity_behavior::vehicle::follow_lane_sequence::StopAtStopLineAction class entity_behavior::vehicle::follow_lane_sequence::StopAtCrossingEntityAction class entity_behavior::vehicle::follow_lane_sequence::FollowLaneAction class entity_behavior::vehicle::follow_lane_sequence::FollowFrontEntityAction Updated on 7 April 2021 at 00:31:54 UTC","title":"Classes"},{"location":"package/simulation_api/markdown/Namespaces/namespacehdmap__utils/","text":"hdmap_utils # Classes # Name class hdmap_utils::HdMapUtils class hdmap_utils::HdMapError Updated on 7 April 2021 at 00:31:54 UTC","title":"hdmap_utils"},{"location":"package/simulation_api/markdown/Namespaces/namespacehdmap__utils/#hdmap_utils","text":"","title":"hdmap_utils"},{"location":"package/simulation_api/markdown/Namespaces/namespacehdmap__utils/#classes","text":"Name class hdmap_utils::HdMapUtils class hdmap_utils::HdMapError Updated on 7 April 2021 at 00:31:54 UTC","title":"Classes"},{"location":"package/simulation_api/markdown/Namespaces/namespacemetrics/","text":"metrics # Classes # Name class metrics::TraveledDistanceMetric class metrics::SpecificationViolationError class metrics::ReactionTimeMetric class metrics::MomentaryStopMetric class metrics::MetricsManager class metrics::MetricsCalculationError class metrics::MetricBase Types # Name enum MetricLifecycle { SUCCESS, INACTIVE, FAILURE, ACTIVE } Types Documentation # enum MetricLifecycle # Enumerator Value Description SUCCESS INACTIVE FAILURE ACTIVE Updated on 7 April 2021 at 00:31:54 UTC","title":"metrics"},{"location":"package/simulation_api/markdown/Namespaces/namespacemetrics/#metrics","text":"","title":"metrics"},{"location":"package/simulation_api/markdown/Namespaces/namespacemetrics/#classes","text":"Name class metrics::TraveledDistanceMetric class metrics::SpecificationViolationError class metrics::ReactionTimeMetric class metrics::MomentaryStopMetric class metrics::MetricsManager class metrics::MetricsCalculationError class metrics::MetricBase","title":"Classes"},{"location":"package/simulation_api/markdown/Namespaces/namespacemetrics/#types","text":"Name enum MetricLifecycle { SUCCESS, INACTIVE, FAILURE, ACTIVE }","title":"Types"},{"location":"package/simulation_api/markdown/Namespaces/namespacemetrics/#types-documentation","text":"","title":"Types Documentation"},{"location":"package/simulation_api/markdown/Namespaces/namespacemetrics/#enum-metriclifecycle","text":"Enumerator Value Description SUCCESS INACTIVE FAILURE ACTIVE Updated on 7 April 2021 at 00:31:54 UTC","title":"enum MetricLifecycle"},{"location":"package/simulation_api/markdown/Namespaces/namespacescenario__simulator/","text":"scenario_simulator # Classes # Name class scenario_simulator::ExecutionFailedError class scenario_simulator::API Updated on 7 April 2021 at 00:31:54 UTC","title":"scenario_simulator"},{"location":"package/simulation_api/markdown/Namespaces/namespacescenario__simulator/#scenario_simulator","text":"","title":"scenario_simulator"},{"location":"package/simulation_api/markdown/Namespaces/namespacescenario__simulator/#classes","text":"Name class scenario_simulator::ExecutionFailedError class scenario_simulator::API Updated on 7 April 2021 at 00:31:54 UTC","title":"Classes"},{"location":"package/simulation_api/markdown/Namespaces/namespacesim__model__util/","text":"sim_model_util # Functions # Name double getDummySteerCommandWithFriction (const double steer, const double steer_command, const double deadzone_delta_steer) Functions Documentation # function getDummySteerCommandWithFriction # double getDummySteerCommandWithFriction ( const double steer , const double steer_command , const double deadzone_delta_steer ) Updated on 7 April 2021 at 00:31:54 UTC","title":"sim_model_util"},{"location":"package/simulation_api/markdown/Namespaces/namespacesim__model__util/#sim_model_util","text":"","title":"sim_model_util"},{"location":"package/simulation_api/markdown/Namespaces/namespacesim__model__util/#functions","text":"Name double getDummySteerCommandWithFriction (const double steer, const double steer_command, const double deadzone_delta_steer)","title":"Functions"},{"location":"package/simulation_api/markdown/Namespaces/namespacesim__model__util/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/simulation_api/markdown/Namespaces/namespacesim__model__util/#function-getdummysteercommandwithfriction","text":"double getDummySteerCommandWithFriction ( const double steer , const double steer_command , const double deadzone_delta_steer ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function getDummySteerCommandWithFriction"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api/","text":"simulation_api # Namespaces # Name simulation_api::traffic simulation_api::math simulation_api::helper simulation_api::entity Classes # Name class simulation_api::TrafficLightPhase class simulation_api::TrafficLightManager class simulation_api::TrafficLight class simulation_api::SplineInterpolationError class simulation_api::SimulationRuntimeError class simulation_api::RoutePlanner Types # Name enum TrafficLightColor { YELLOW, RED, NONE, GREEN } enum TrafficLightArrow { STRAIGHT, RIGHT, NONE, LEFT } Types Documentation # enum TrafficLightColor # Enumerator Value Description YELLOW RED NONE GREEN enum TrafficLightArrow # Enumerator Value Description STRAIGHT RIGHT NONE LEFT Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api/#simulation_api","text":"","title":"simulation_api"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api/#namespaces","text":"Name simulation_api::traffic simulation_api::math simulation_api::helper simulation_api::entity","title":"Namespaces"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api/#classes","text":"Name class simulation_api::TrafficLightPhase class simulation_api::TrafficLightManager class simulation_api::TrafficLight class simulation_api::SplineInterpolationError class simulation_api::SimulationRuntimeError class simulation_api::RoutePlanner","title":"Classes"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api/#types","text":"Name enum TrafficLightColor { YELLOW, RED, NONE, GREEN } enum TrafficLightArrow { STRAIGHT, RIGHT, NONE, LEFT }","title":"Types"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api/#types-documentation","text":"","title":"Types Documentation"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api/#enum-trafficlightcolor","text":"Enumerator Value Description YELLOW RED NONE GREEN","title":"enum TrafficLightColor"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api/#enum-trafficlightarrow","text":"Enumerator Value Description STRAIGHT RIGHT NONE LEFT Updated on 7 April 2021 at 00:31:54 UTC","title":"enum TrafficLightArrow"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1entity/","text":"simulation_api::entity # Classes # Name struct simulation_api::entity::VehicleParameters class simulation_api::entity::VehicleEntity struct simulation_api::entity::Performance struct simulation_api::entity::PedestrianParameters class simulation_api::entity::PedestrianEntity class simulation_api::entity::LaneletMarkerQoS class simulation_api::entity::EntityMarkerQoS class simulation_api::entity::EntityManager class simulation_api::entity::EntityBase class simulation_api::entity::EgoEntity struct simulation_api::entity::Dimensions struct simulation_api::entity::Center struct simulation_api::entity::BoundingBox struct simulation_api::entity::Axles struct simulation_api::entity::Axle Types # Name enum Direction { STRAIGHT = 0, RIGHT = 2, LEFT = 1 } Types Documentation # enum Direction # Enumerator Value Description STRAIGHT 0 RIGHT 2 LEFT 1 Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::entity"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1entity/#simulation_apientity","text":"","title":"simulation_api::entity"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1entity/#classes","text":"Name struct simulation_api::entity::VehicleParameters class simulation_api::entity::VehicleEntity struct simulation_api::entity::Performance struct simulation_api::entity::PedestrianParameters class simulation_api::entity::PedestrianEntity class simulation_api::entity::LaneletMarkerQoS class simulation_api::entity::EntityMarkerQoS class simulation_api::entity::EntityManager class simulation_api::entity::EntityBase class simulation_api::entity::EgoEntity struct simulation_api::entity::Dimensions struct simulation_api::entity::Center struct simulation_api::entity::BoundingBox struct simulation_api::entity::Axles struct simulation_api::entity::Axle","title":"Classes"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1entity/#types","text":"Name enum Direction { STRAIGHT = 0, RIGHT = 2, LEFT = 1 }","title":"Types"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1entity/#types-documentation","text":"","title":"Types Documentation"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1entity/#enum-direction","text":"Enumerator Value Description STRAIGHT 0 RIGHT 2 LEFT 1 Updated on 7 April 2021 at 00:31:54 UTC","title":"enum Direction"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/","text":"simulation_api::helper # Classes # Name class simulation_api::helper::StopWatch Types # Name enum LidarType { VLP32, VLP16 } Functions # Name std::ostream & operator<< (std::ostream & os, const openscenario_msgs::msg::LaneletPose & ll_pose) geometry_msgs::msg::Vector3 constructRPYfronQuaternion (geometry_msgs::msg::Quaternion quaternion) helper function for constructing rpy geometry_msgs::msg::Vector3 constructRPY (double roll =0, double pitch =0, double yaw =0) helper function for constructing rpy geometry_msgs::msg::Pose constructPose (double x, double y, double z, double roll, double pitch, double yaw) helper function for constructing pose const simulation_api_schema::LidarConfiguration constructLidarConfiguration (LidarType type, std::string entity, std::string topic_name, double horizontal_resolution =1.0/180.0 *M_PI) openscenario_msgs::msg::LaneletPose constructLaneletPose (std::int64_t lanelet_id, double s, double offset =0, double roll =0, double pitch =0, double yaw =0) helper function for constructing lanelet pose const simulation_api_schema::DetectionSensorConfiguration constructDetectionSensorConfiguration (std::string entity, std::string topic_name, double update_duration) openscenario_msgs::msg::ActionStatus constructActionStatus (double linear_vel =0, double angular_vel =0, double linear_accel =0, double angular_accel =0) helper function for constructing action status Types Documentation # enum LidarType # Enumerator Value Description VLP32 VLP16 Functions Documentation # function operator<< # std :: ostream & operator << ( std :: ostream & os , const openscenario_msgs :: msg :: LaneletPose & ll_pose ) function constructRPYfronQuaternion # geometry_msgs :: msg :: Vector3 constructRPYfronQuaternion ( geometry_msgs :: msg :: Quaternion quaternion ) helper function for constructing rpy Parameters : quaternion quaternion class Return : geometry_msgs::msg::Vector3 RPY value function constructRPY # geometry_msgs :: msg :: Vector3 constructRPY ( double roll = 0 , double pitch = 0 , double yaw = 0 ) helper function for constructing rpy Parameters : roll roll value of the orientation pitch pitch value of the orientation yaw yaw value of the orientation Return : geometry_msgs::msg::Vector3 RPY values function constructPose # geometry_msgs :: msg :: Pose constructPose ( double x , double y , double z , double roll , double pitch , double yaw ) helper function for constructing pose Parameters : x x value in position y y value in position z z value in position roll roll value in orientation pitch pitch value in orientation yaw yaw value in orientation Return : geometry_msgs::msg::Pose function constructLidarConfiguration # const simulation_api_schema :: LidarConfiguration constructLidarConfiguration ( LidarType type , std :: string entity , std :: string topic_name , double horizontal_resolution = 1.0 / 180.0 * M_PI ) function constructLaneletPose # openscenario_msgs :: msg :: LaneletPose constructLaneletPose ( std :: int64_t lanelet_id , double s , double offset = 0 , double roll = 0 , double pitch = 0 , double yaw = 0 ) helper function for constructing lanelet pose Parameters : lanelet_id lanelet id s s value in lane coordinate offset offset value in lane coordinate roll roll value in the lane coordinate pitch pitch value in the lane coordinate yaw yaw value in the lane coordinate Return : openscenario_msgs::msg::LaneletPose function constructDetectionSensorConfiguration # const simulation_api_schema :: DetectionSensorConfiguration constructDetectionSensorConfiguration ( std :: string entity , std :: string topic_name , double update_duration ) function constructActionStatus # openscenario_msgs :: msg :: ActionStatus constructActionStatus ( double linear_vel = 0 , double angular_vel = 0 , double linear_accel = 0 , double angular_accel = 0 ) helper function for constructing action status Parameters : linear_vel linear velocity angular_vel angluar velocity linear_accel linear acceleration angular_accel angular acceleration Return : openscenario_msgs::msg::ActionStatus Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::helper"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/#simulation_apihelper","text":"","title":"simulation_api::helper"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/#classes","text":"Name class simulation_api::helper::StopWatch","title":"Classes"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/#types","text":"Name enum LidarType { VLP32, VLP16 }","title":"Types"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/#functions","text":"Name std::ostream & operator<< (std::ostream & os, const openscenario_msgs::msg::LaneletPose & ll_pose) geometry_msgs::msg::Vector3 constructRPYfronQuaternion (geometry_msgs::msg::Quaternion quaternion) helper function for constructing rpy geometry_msgs::msg::Vector3 constructRPY (double roll =0, double pitch =0, double yaw =0) helper function for constructing rpy geometry_msgs::msg::Pose constructPose (double x, double y, double z, double roll, double pitch, double yaw) helper function for constructing pose const simulation_api_schema::LidarConfiguration constructLidarConfiguration (LidarType type, std::string entity, std::string topic_name, double horizontal_resolution =1.0/180.0 *M_PI) openscenario_msgs::msg::LaneletPose constructLaneletPose (std::int64_t lanelet_id, double s, double offset =0, double roll =0, double pitch =0, double yaw =0) helper function for constructing lanelet pose const simulation_api_schema::DetectionSensorConfiguration constructDetectionSensorConfiguration (std::string entity, std::string topic_name, double update_duration) openscenario_msgs::msg::ActionStatus constructActionStatus (double linear_vel =0, double angular_vel =0, double linear_accel =0, double angular_accel =0) helper function for constructing action status","title":"Functions"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/#types-documentation","text":"","title":"Types Documentation"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/#enum-lidartype","text":"Enumerator Value Description VLP32 VLP16","title":"enum LidarType"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/#function-operator","text":"std :: ostream & operator << ( std :: ostream & os , const openscenario_msgs :: msg :: LaneletPose & ll_pose )","title":"function operator&lt;&lt;"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/#function-constructrpyfronquaternion","text":"geometry_msgs :: msg :: Vector3 constructRPYfronQuaternion ( geometry_msgs :: msg :: Quaternion quaternion ) helper function for constructing rpy Parameters : quaternion quaternion class Return : geometry_msgs::msg::Vector3 RPY value","title":"function constructRPYfronQuaternion"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/#function-constructrpy","text":"geometry_msgs :: msg :: Vector3 constructRPY ( double roll = 0 , double pitch = 0 , double yaw = 0 ) helper function for constructing rpy Parameters : roll roll value of the orientation pitch pitch value of the orientation yaw yaw value of the orientation Return : geometry_msgs::msg::Vector3 RPY values","title":"function constructRPY"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/#function-constructpose","text":"geometry_msgs :: msg :: Pose constructPose ( double x , double y , double z , double roll , double pitch , double yaw ) helper function for constructing pose Parameters : x x value in position y y value in position z z value in position roll roll value in orientation pitch pitch value in orientation yaw yaw value in orientation Return : geometry_msgs::msg::Pose","title":"function constructPose"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/#function-constructlidarconfiguration","text":"const simulation_api_schema :: LidarConfiguration constructLidarConfiguration ( LidarType type , std :: string entity , std :: string topic_name , double horizontal_resolution = 1.0 / 180.0 * M_PI )","title":"function constructLidarConfiguration"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/#function-constructlaneletpose","text":"openscenario_msgs :: msg :: LaneletPose constructLaneletPose ( std :: int64_t lanelet_id , double s , double offset = 0 , double roll = 0 , double pitch = 0 , double yaw = 0 ) helper function for constructing lanelet pose Parameters : lanelet_id lanelet id s s value in lane coordinate offset offset value in lane coordinate roll roll value in the lane coordinate pitch pitch value in the lane coordinate yaw yaw value in the lane coordinate Return : openscenario_msgs::msg::LaneletPose","title":"function constructLaneletPose"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/#function-constructdetectionsensorconfiguration","text":"const simulation_api_schema :: DetectionSensorConfiguration constructDetectionSensorConfiguration ( std :: string entity , std :: string topic_name , double update_duration )","title":"function constructDetectionSensorConfiguration"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1helper/#function-constructactionstatus","text":"openscenario_msgs :: msg :: ActionStatus constructActionStatus ( double linear_vel = 0 , double angular_vel = 0 , double linear_accel = 0 , double angular_accel = 0 ) helper function for constructing action status Parameters : linear_vel linear velocity angular_vel angluar velocity linear_accel linear acceleration angular_accel angular acceleration Return : openscenario_msgs::msg::ActionStatus Updated on 7 April 2021 at 00:31:54 UTC","title":"function constructActionStatus"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1math/","text":"simulation_api::math # Classes # Name class simulation_api::math::SplineInterpolationError class simulation_api::math::PolynomialSolver class simulation_api::math::HermiteCurve class simulation_api::math::CatmullRomSpline Functions # Name std::vector< geometry_msgs::msg::Point > transformPoints (geometry_msgs::msg::Pose pose, std::vector< geometry_msgs::msg::Point > points) boost::optional< double > getPolygonDistance (const geometry_msgs::msg::Pose & pose0, const openscenario_msgs::msg::BoundingBox & bbox0, const geometry_msgs::msg::Pose & pose1, const openscenario_msgs::msg::BoundingBox & bbox1) Get the Polygon Distance object. std::vector< geometry_msgs::msg::Point > getPointsFromBbox (openscenario_msgs::msg::BoundingBox bbox) double getDistance (const geometry_msgs::msg::Point & p0, const geometry_msgs::msg::Point & p1) double getDistance (const geometry_msgs::msg::Pose & p0, const geometry_msgs::msg::Point & p1) double getDistance (const geometry_msgs::msg::Point & p0, const geometry_msgs::msg::Pose & p1) double getDistance (const geometry_msgs::msg::Pose & p0, const geometry_msgs::msg::Pose & p1) const boost::geometry::model::polygon< boost::geometry::model::d2::point_xy< double > > get2DPolygon (const geometry_msgs::msg::Pose & pose, const openscenario_msgs::msg::BoundingBox & bbox) std::string generateUUID (const std::string & seed) bool checkCollision2D (geometry_msgs::msg::Pose pose0, openscenario_msgs::msg::BoundingBox bbox0, geometry_msgs::msg::Pose pose1, openscenario_msgs::msg::BoundingBox bbox1) Functions Documentation # function transformPoints # std :: vector < geometry_msgs :: msg :: Point > transformPoints ( geometry_msgs :: msg :: Pose pose , std :: vector < geometry_msgs :: msg :: Point > points ) function getPolygonDistance # boost :: optional < double > getPolygonDistance ( const geometry_msgs :: msg :: Pose & pose0 , const openscenario_msgs :: msg :: BoundingBox & bbox0 , const geometry_msgs :: msg :: Pose & pose1 , const openscenario_msgs :: msg :: BoundingBox & bbox1 ) Get the Polygon Distance object. Parameters : pose0 pose of the first bounding box bbox0 size of the first bounding box pose1 pose of the second bounding box bbox1 size of the second bounding box Returns : boost::none bounding box intersects 0 <= distance between two bounding boxes function getPointsFromBbox # std :: vector < geometry_msgs :: msg :: Point > getPointsFromBbox ( openscenario_msgs :: msg :: BoundingBox bbox ) function getDistance # double getDistance ( const geometry_msgs :: msg :: Point & p0 , const geometry_msgs :: msg :: Point & p1 ) function getDistance # double getDistance ( const geometry_msgs :: msg :: Pose & p0 , const geometry_msgs :: msg :: Point & p1 ) function getDistance # double getDistance ( const geometry_msgs :: msg :: Point & p0 , const geometry_msgs :: msg :: Pose & p1 ) function getDistance # double getDistance ( const geometry_msgs :: msg :: Pose & p0 , const geometry_msgs :: msg :: Pose & p1 ) function get2DPolygon # const boost :: geometry :: model :: polygon < boost :: geometry :: model :: d2 :: point_xy < double > > get2DPolygon ( const geometry_msgs :: msg :: Pose & pose , const openscenario_msgs :: msg :: BoundingBox & bbox ) function generateUUID # std :: string generateUUID ( const std :: string & seed ) function checkCollision2D # bool checkCollision2D ( geometry_msgs :: msg :: Pose pose0 , openscenario_msgs :: msg :: BoundingBox bbox0 , geometry_msgs :: msg :: Pose pose1 , openscenario_msgs :: msg :: BoundingBox bbox1 ) Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::math"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1math/#simulation_apimath","text":"","title":"simulation_api::math"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1math/#classes","text":"Name class simulation_api::math::SplineInterpolationError class simulation_api::math::PolynomialSolver class simulation_api::math::HermiteCurve class simulation_api::math::CatmullRomSpline","title":"Classes"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1math/#functions","text":"Name std::vector< geometry_msgs::msg::Point > transformPoints (geometry_msgs::msg::Pose pose, std::vector< geometry_msgs::msg::Point > points) boost::optional< double > getPolygonDistance (const geometry_msgs::msg::Pose & pose0, const openscenario_msgs::msg::BoundingBox & bbox0, const geometry_msgs::msg::Pose & pose1, const openscenario_msgs::msg::BoundingBox & bbox1) Get the Polygon Distance object. std::vector< geometry_msgs::msg::Point > getPointsFromBbox (openscenario_msgs::msg::BoundingBox bbox) double getDistance (const geometry_msgs::msg::Point & p0, const geometry_msgs::msg::Point & p1) double getDistance (const geometry_msgs::msg::Pose & p0, const geometry_msgs::msg::Point & p1) double getDistance (const geometry_msgs::msg::Point & p0, const geometry_msgs::msg::Pose & p1) double getDistance (const geometry_msgs::msg::Pose & p0, const geometry_msgs::msg::Pose & p1) const boost::geometry::model::polygon< boost::geometry::model::d2::point_xy< double > > get2DPolygon (const geometry_msgs::msg::Pose & pose, const openscenario_msgs::msg::BoundingBox & bbox) std::string generateUUID (const std::string & seed) bool checkCollision2D (geometry_msgs::msg::Pose pose0, openscenario_msgs::msg::BoundingBox bbox0, geometry_msgs::msg::Pose pose1, openscenario_msgs::msg::BoundingBox bbox1)","title":"Functions"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1math/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1math/#function-transformpoints","text":"std :: vector < geometry_msgs :: msg :: Point > transformPoints ( geometry_msgs :: msg :: Pose pose , std :: vector < geometry_msgs :: msg :: Point > points )","title":"function transformPoints"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1math/#function-getpolygondistance","text":"boost :: optional < double > getPolygonDistance ( const geometry_msgs :: msg :: Pose & pose0 , const openscenario_msgs :: msg :: BoundingBox & bbox0 , const geometry_msgs :: msg :: Pose & pose1 , const openscenario_msgs :: msg :: BoundingBox & bbox1 ) Get the Polygon Distance object. Parameters : pose0 pose of the first bounding box bbox0 size of the first bounding box pose1 pose of the second bounding box bbox1 size of the second bounding box Returns : boost::none bounding box intersects 0 <= distance between two bounding boxes","title":"function getPolygonDistance"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1math/#function-getpointsfrombbox","text":"std :: vector < geometry_msgs :: msg :: Point > getPointsFromBbox ( openscenario_msgs :: msg :: BoundingBox bbox )","title":"function getPointsFromBbox"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1math/#function-getdistance","text":"double getDistance ( const geometry_msgs :: msg :: Point & p0 , const geometry_msgs :: msg :: Point & p1 )","title":"function getDistance"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1math/#function-getdistance_1","text":"double getDistance ( const geometry_msgs :: msg :: Pose & p0 , const geometry_msgs :: msg :: Point & p1 )","title":"function getDistance"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1math/#function-getdistance_2","text":"double getDistance ( const geometry_msgs :: msg :: Point & p0 , const geometry_msgs :: msg :: Pose & p1 )","title":"function getDistance"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1math/#function-getdistance_3","text":"double getDistance ( const geometry_msgs :: msg :: Pose & p0 , const geometry_msgs :: msg :: Pose & p1 )","title":"function getDistance"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1math/#function-get2dpolygon","text":"const boost :: geometry :: model :: polygon < boost :: geometry :: model :: d2 :: point_xy < double > > get2DPolygon ( const geometry_msgs :: msg :: Pose & pose , const openscenario_msgs :: msg :: BoundingBox & bbox )","title":"function get2DPolygon"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1math/#function-generateuuid","text":"std :: string generateUUID ( const std :: string & seed )","title":"function generateUUID"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1math/#function-checkcollision2d","text":"bool checkCollision2D ( geometry_msgs :: msg :: Pose pose0 , openscenario_msgs :: msg :: BoundingBox bbox0 , geometry_msgs :: msg :: Pose pose1 , openscenario_msgs :: msg :: BoundingBox bbox1 ) Updated on 7 April 2021 at 00:31:54 UTC","title":"function checkCollision2D"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1traffic/","text":"simulation_api::traffic # Classes # Name class simulation_api::traffic::TrafficSink class simulation_api::traffic::TrafficController class simulation_api::traffic::TraffiModuleBase Updated on 7 April 2021 at 00:31:54 UTC","title":"simulation_api::traffic"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1traffic/#simulation_apitraffic","text":"","title":"simulation_api::traffic"},{"location":"package/simulation_api/markdown/Namespaces/namespacesimulation__api_1_1traffic/#classes","text":"Name class simulation_api::traffic::TrafficSink class simulation_api::traffic::TrafficController class simulation_api::traffic::TraffiModuleBase Updated on 7 April 2021 at 00:31:54 UTC","title":"Classes"},{"location":"package/simulation_api/markdown/Pages/","text":"Pages # Updated on 7 April 2021 at 00:31:55 UTC","title":"Pages"},{"location":"package/simulation_api/markdown/Pages/#pages","text":"Updated on 7 April 2021 at 00:31:55 UTC","title":"Pages"},{"location":"proto_doc/protobuf/","text":"Protocol Documentation # Table of Contents # geometry_msgs.proto Accel Point Pose Quaternion Twist Vector3 openscenario_msgs.proto ActionStatus Axle Axles BoundingBox EntityStatus LaneletPose PedestrianParameters Performance Property VehicleParameters Waypoints EntityType simulation_api_schema.proto AttachDetectionSensorRequest AttachDetectionSensorResponse AttachLidarSensorRequest AttachLidarSensorResponse DespawnEntityRequest DespawnEntityResponse DetectionSensorConfiguration InitializeRequest InitializeResponse LidarConfiguration Result SpawnPedestrianEntityRequest SpawnPedestrianEntityResponse SpawnVehicleEntityRequest SpawnVehicleEntityResponse UpdateEntityStatusRequest UpdateEntityStatusResponse UpdateFrameRequest UpdateFrameResponse UpdateSensorFrameRequest UpdateSensorFrameResponse UpdatedEntityStatus Scalar Value Types Top geometry_msgs.proto # Accel # Protobuf definiciton of geometry_msgs/msg/Accel type in ROS2. Field Type Label Description linear Vector3 Linear acceleration angular Vector3 Angular acceleration Point # Protobuf definiciton of geometry_msgs/msg/Point type in ROS2. Field Type Label Description x double X value in a cartesian coordinate. y double Y value in a cartesian coordinate. z double Z value in a cartesian coordinate. Pose # Protobuf definiciton of geometry_msgs/msg/Pose type in ROS2. Field Type Label Description position Point Position of the pose. orientation Quaternion Orientation of the pose. Quaternion # Protobuf definiciton of geometry_msgs/msg/Quaternion type in ROS2. Field Type Label Description x double X value in a quaternion. (0 <= x <= 1) y double Y value in a quaternion. (0 <= y <= 1) z double Z value in a quaternion. (0 <= z <= 1) w double W value in a quaternion. (0 <= w <= 1) Twist # Protobuf definiciton of geometry_msgs/msg/Twist type in ROS2. Field Type Label Description linear Vector3 Linear velocity angular Vector3 Angular velocity Vector3 # Protobuf definiciton of geometry_msgs/msg/Vector3 type in ROS2. Field Type Label Description x double First variable in vector y double Second variable in vector z double Third variable in vector Top openscenario_msgs.proto # ActionStatus # Protobuf definiciton of openscenario_msgs/msg/ActionStatus type in ROS2. Field Type Label Description current_action string Current acttion of the entity. twist geometry_msgs.Twist Velocity of the entity. accel geometry_msgs.Accel Acceleration of the entity. Axle # Protobuf definiciton of openscenario_msgs/msg/Axle type in ROS2. Field Type Label Description max_steering double Max steering of the entity axle. wheel_diameter double Wheel diameter of the entity axle. track_width double Track width of the entity axle. position_x double Position x of the entity axle.(longitudinal) position_z double Position z of the entity axle.(lateral) Axles # Protobuf definiciton of openscenario_msgs/msg/Axles type in ROS2. Field Type Label Description front_axle Axle Parameters of the front axle of the entity. rear_axle Axle Parameters of rear axle of the entity. BoundingBox # Protobuf definiciton of openscenario_msgs/msg/BoundingBox type in ROS2. Field Type Label Description center geometry_msgs.Point Center point of the bounding box. dimensions geometry_msgs.Vector3 Size of the bounding box. EntityStatus # Protobuf definiciton of openscenario_msgs/msg/EntityStatus type in ROS2. Field Type Label Description type EntityType Type of the entity. time double Current simulation time. name string Name of the entity. bounding_box BoundingBox Bounding box of the entity. action_status ActionStatus Action status of the entity. pose geometry_msgs.Pose Pose in map coordinate of the entity. lanelet_pose LaneletPose Pose in lane coordinate of the entity. lanelet_pose_valid bool If true, the lane matching of the entity is succeeded. LaneletPose # Protobuf definiciton of openscenario_msgs/msg/LaneletPose type in ROS2. Field Type Label Description lanlet_id int64 Lanelet id of the entity exists. s double S value in the lane coordinate. offset double Offset value in the lane coordinate. rpy geometry_msgs.Vector3 RPY(roll/pitch/yaw) value in the lane coordinate. PedestrianParameters # Protobuf definiciton of openscenario_msgs/msg/PedestrianParameters type in ROS2. Field Type Label Description name string Name of the pedestrian entity. pedestrian_category string Category of pedestrian entity. bounding_box BoundingBox Bounding box of the pedestrian entity. Performance # Protobuf definiciton of openscenario_msgs/msg/Performance type in ROS2. Field Type Label Description max_speed double Max speed of the entity. max_acceleration double Max acceleration of the entity. max_deceleration double Max deceleration of the entity. Property # Protobuf definiciton of openscenario_msgs/msg/Property type in ROS2. VehicleParameters # Protobuf definiciton of openscenario_msgs/msg/VehicleParameters type in ROS2. Field Type Label Description name string Name of the vehicle entity vehicle_category string Category of the vehicle entity. performance Performance Performance parameter of vehicle entity. bounding_box BoundingBox Bounding box of the vehicle entity. axles Axles Axles of the vehicle entity. property Property Other parameters of the vehicle entity. Waypoints # Protobuf definiciton of openscenario_msgs/msg/Waypoints type in ROS2. Field Type Label Description waypoints geometry_msgs.Point repeated Waypoints of the entity. EntityType # Protobuf definiciton of openscenario_msgs/msg/EntityType type in ROS2. Name Number Description EGO 0 Ego Vehicle (Autoware Vehicle) VEHICLE 1 Vehicle Entity (NPC Vehicle) PEDESTRIAN 2 Pedestrian Entity (NPC Pedestrian) Top simulation_api_schema.proto # AttachDetectionSensorRequest # Requests attaching detection sensor to the target entity. Field Type Label Description configuration DetectionSensorConfiguration Configuration of the detection sensor. AttachDetectionSensorResponse # Response of attaching detection sensor to the target entity. Field Type Label Description result Result Result of AttachDetectionSensorRequest AttachLidarSensorRequest # Requests attaching a lidar sensor to the target entity. Field Type Label Description configuration LidarConfiguration Configuration of the lidar sensor. AttachLidarSensorResponse # Response of attaching a lidar sensor to the target entity. Field Type Label Description result Result Result of AttachLidarSensorRequest DespawnEntityRequest # Requests despawning entity. Field Type Label Description name string Name of the entity you want to despawn. DespawnEntityResponse # Response of despawning entity. Field Type Label Description result Result Result of DespawnEntityRequest DetectionSensorConfiguration # Parameter configuration of the detection sensor Field Type Label Description entity string Name of the entity which you want to attach detection sensor. update_duration double Update duration of the detection sensor. topic_name string Topic name of the detection result. InitializeRequest # Requests initializing simulation. Field Type Label Description realtime_factor double Realtime factor of the simulation. step_time double Step time of the simulation. InitializeResponse # Result of initializing simulation. Field Type Label Description result Result Result of InitializeRequest LidarConfiguration # Parameter configuration of the lidar sensor Field Type Label Description entity string Name of the entity which you want to attach lidar. horizontal_resolution double Horizontal resolutions of the lidar. vertical_angles double repeated Vertical resolutions of the lidar. scan_duration double Scan duration of the lidar. topic_name string Topic name of the lidar pointcloud. Result # Result of the request Field Type Label Description success bool If true, the request was succeeded description string Description of why the request was failed. SpawnPedestrianEntityRequest # Requests spawning pedestrian entity. Field Type Label Description parameters openscenario_msgs.PedestrianParameters Parameters of pedestrian entity. SpawnPedestrianEntityResponse # Response of spawning vehicle entity. Field Type Label Description result Result Result of SpawnPedestrianEntityResponse SpawnVehicleEntityRequest # Requests spawning vehicle entity. Field Type Label Description parameters openscenario_msgs.VehicleParameters Parameters of vehicle entity. is_ego bool If true, the entity is Ego vehicle. (Autoware vehicle.) SpawnVehicleEntityResponse # Response of spawning vehicle entity. Field Type Label Description result Result Result of SpawnVehicleEntityResponse UpdateEntityStatusRequest # Requests updating entity status. Field Type Label Description status openscenario_msgs.EntityStatus repeated List of updateed entity status in traffic simulator. UpdateEntityStatusResponse # Response of updating entity status. Field Type Label Description result Result Result of UpdateEntityStatusRequest status UpdatedEntityStatus repeated List of updated entity status in sensor/dynamics simulator. UpdateFrameRequest # Requests updating simulation frame. Field Type Label Description current_time double Current simulation time UpdateFrameResponse # Response of updating simulation frame. Field Type Label Description result Result Result of UpdateFrameRequest UpdateSensorFrameRequest # Requests updating a frame of sensor simulation. Field Type Label Description current_time double Current simulation timestamp. UpdateSensorFrameResponse # Response of updating a frame of sensor simulation. Field Type Label Description result Result Result of UpdateSensorFrameRequest UpdatedEntityStatus # Updated entity status by the simulator. Field Type Label Description name string Name og the entity. action_status openscenario_msgs.ActionStatus Action status of the entity. pose geometry_msgs.Pose Pose of the entity in the map coordinate. Scalar Value Types # .proto Type Notes C++ Java Python Go C# PHP Ruby double double double float float64 double float Float float float float float float32 float float Float int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required) int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required) uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required) sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required) sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required) fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required) sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum bool bool boolean boolean bool bool boolean TrueClass/FalseClass string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8) bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)","title":"Protocol Documentation"},{"location":"proto_doc/protobuf/#protocol-documentation","text":"","title":"Protocol Documentation"},{"location":"proto_doc/protobuf/#table-of-contents","text":"geometry_msgs.proto Accel Point Pose Quaternion Twist Vector3 openscenario_msgs.proto ActionStatus Axle Axles BoundingBox EntityStatus LaneletPose PedestrianParameters Performance Property VehicleParameters Waypoints EntityType simulation_api_schema.proto AttachDetectionSensorRequest AttachDetectionSensorResponse AttachLidarSensorRequest AttachLidarSensorResponse DespawnEntityRequest DespawnEntityResponse DetectionSensorConfiguration InitializeRequest InitializeResponse LidarConfiguration Result SpawnPedestrianEntityRequest SpawnPedestrianEntityResponse SpawnVehicleEntityRequest SpawnVehicleEntityResponse UpdateEntityStatusRequest UpdateEntityStatusResponse UpdateFrameRequest UpdateFrameResponse UpdateSensorFrameRequest UpdateSensorFrameResponse UpdatedEntityStatus Scalar Value Types Top","title":"Table of Contents"},{"location":"proto_doc/protobuf/#geometry_msgsproto","text":"","title":"geometry_msgs.proto"},{"location":"proto_doc/protobuf/#accel","text":"Protobuf definiciton of geometry_msgs/msg/Accel type in ROS2. Field Type Label Description linear Vector3 Linear acceleration angular Vector3 Angular acceleration","title":"Accel"},{"location":"proto_doc/protobuf/#point","text":"Protobuf definiciton of geometry_msgs/msg/Point type in ROS2. Field Type Label Description x double X value in a cartesian coordinate. y double Y value in a cartesian coordinate. z double Z value in a cartesian coordinate.","title":"Point"},{"location":"proto_doc/protobuf/#pose","text":"Protobuf definiciton of geometry_msgs/msg/Pose type in ROS2. Field Type Label Description position Point Position of the pose. orientation Quaternion Orientation of the pose.","title":"Pose"},{"location":"proto_doc/protobuf/#quaternion","text":"Protobuf definiciton of geometry_msgs/msg/Quaternion type in ROS2. Field Type Label Description x double X value in a quaternion. (0 <= x <= 1) y double Y value in a quaternion. (0 <= y <= 1) z double Z value in a quaternion. (0 <= z <= 1) w double W value in a quaternion. (0 <= w <= 1)","title":"Quaternion"},{"location":"proto_doc/protobuf/#twist","text":"Protobuf definiciton of geometry_msgs/msg/Twist type in ROS2. Field Type Label Description linear Vector3 Linear velocity angular Vector3 Angular velocity","title":"Twist"},{"location":"proto_doc/protobuf/#vector3","text":"Protobuf definiciton of geometry_msgs/msg/Vector3 type in ROS2. Field Type Label Description x double First variable in vector y double Second variable in vector z double Third variable in vector Top","title":"Vector3"},{"location":"proto_doc/protobuf/#openscenario_msgsproto","text":"","title":"openscenario_msgs.proto"},{"location":"proto_doc/protobuf/#actionstatus","text":"Protobuf definiciton of openscenario_msgs/msg/ActionStatus type in ROS2. Field Type Label Description current_action string Current acttion of the entity. twist geometry_msgs.Twist Velocity of the entity. accel geometry_msgs.Accel Acceleration of the entity.","title":"ActionStatus"},{"location":"proto_doc/protobuf/#axle","text":"Protobuf definiciton of openscenario_msgs/msg/Axle type in ROS2. Field Type Label Description max_steering double Max steering of the entity axle. wheel_diameter double Wheel diameter of the entity axle. track_width double Track width of the entity axle. position_x double Position x of the entity axle.(longitudinal) position_z double Position z of the entity axle.(lateral)","title":"Axle"},{"location":"proto_doc/protobuf/#axles","text":"Protobuf definiciton of openscenario_msgs/msg/Axles type in ROS2. Field Type Label Description front_axle Axle Parameters of the front axle of the entity. rear_axle Axle Parameters of rear axle of the entity.","title":"Axles"},{"location":"proto_doc/protobuf/#boundingbox","text":"Protobuf definiciton of openscenario_msgs/msg/BoundingBox type in ROS2. Field Type Label Description center geometry_msgs.Point Center point of the bounding box. dimensions geometry_msgs.Vector3 Size of the bounding box.","title":"BoundingBox"},{"location":"proto_doc/protobuf/#entitystatus","text":"Protobuf definiciton of openscenario_msgs/msg/EntityStatus type in ROS2. Field Type Label Description type EntityType Type of the entity. time double Current simulation time. name string Name of the entity. bounding_box BoundingBox Bounding box of the entity. action_status ActionStatus Action status of the entity. pose geometry_msgs.Pose Pose in map coordinate of the entity. lanelet_pose LaneletPose Pose in lane coordinate of the entity. lanelet_pose_valid bool If true, the lane matching of the entity is succeeded.","title":"EntityStatus"},{"location":"proto_doc/protobuf/#laneletpose","text":"Protobuf definiciton of openscenario_msgs/msg/LaneletPose type in ROS2. Field Type Label Description lanlet_id int64 Lanelet id of the entity exists. s double S value in the lane coordinate. offset double Offset value in the lane coordinate. rpy geometry_msgs.Vector3 RPY(roll/pitch/yaw) value in the lane coordinate.","title":"LaneletPose"},{"location":"proto_doc/protobuf/#pedestrianparameters","text":"Protobuf definiciton of openscenario_msgs/msg/PedestrianParameters type in ROS2. Field Type Label Description name string Name of the pedestrian entity. pedestrian_category string Category of pedestrian entity. bounding_box BoundingBox Bounding box of the pedestrian entity.","title":"PedestrianParameters"},{"location":"proto_doc/protobuf/#performance","text":"Protobuf definiciton of openscenario_msgs/msg/Performance type in ROS2. Field Type Label Description max_speed double Max speed of the entity. max_acceleration double Max acceleration of the entity. max_deceleration double Max deceleration of the entity.","title":"Performance"},{"location":"proto_doc/protobuf/#property","text":"Protobuf definiciton of openscenario_msgs/msg/Property type in ROS2.","title":"Property"},{"location":"proto_doc/protobuf/#vehicleparameters","text":"Protobuf definiciton of openscenario_msgs/msg/VehicleParameters type in ROS2. Field Type Label Description name string Name of the vehicle entity vehicle_category string Category of the vehicle entity. performance Performance Performance parameter of vehicle entity. bounding_box BoundingBox Bounding box of the vehicle entity. axles Axles Axles of the vehicle entity. property Property Other parameters of the vehicle entity.","title":"VehicleParameters"},{"location":"proto_doc/protobuf/#waypoints","text":"Protobuf definiciton of openscenario_msgs/msg/Waypoints type in ROS2. Field Type Label Description waypoints geometry_msgs.Point repeated Waypoints of the entity.","title":"Waypoints"},{"location":"proto_doc/protobuf/#entitytype","text":"Protobuf definiciton of openscenario_msgs/msg/EntityType type in ROS2. Name Number Description EGO 0 Ego Vehicle (Autoware Vehicle) VEHICLE 1 Vehicle Entity (NPC Vehicle) PEDESTRIAN 2 Pedestrian Entity (NPC Pedestrian) Top","title":"EntityType"},{"location":"proto_doc/protobuf/#simulation_api_schemaproto","text":"","title":"simulation_api_schema.proto"},{"location":"proto_doc/protobuf/#attachdetectionsensorrequest","text":"Requests attaching detection sensor to the target entity. Field Type Label Description configuration DetectionSensorConfiguration Configuration of the detection sensor.","title":"AttachDetectionSensorRequest"},{"location":"proto_doc/protobuf/#attachdetectionsensorresponse","text":"Response of attaching detection sensor to the target entity. Field Type Label Description result Result Result of AttachDetectionSensorRequest","title":"AttachDetectionSensorResponse"},{"location":"proto_doc/protobuf/#attachlidarsensorrequest","text":"Requests attaching a lidar sensor to the target entity. Field Type Label Description configuration LidarConfiguration Configuration of the lidar sensor.","title":"AttachLidarSensorRequest"},{"location":"proto_doc/protobuf/#attachlidarsensorresponse","text":"Response of attaching a lidar sensor to the target entity. Field Type Label Description result Result Result of AttachLidarSensorRequest","title":"AttachLidarSensorResponse"},{"location":"proto_doc/protobuf/#despawnentityrequest","text":"Requests despawning entity. Field Type Label Description name string Name of the entity you want to despawn.","title":"DespawnEntityRequest"},{"location":"proto_doc/protobuf/#despawnentityresponse","text":"Response of despawning entity. Field Type Label Description result Result Result of DespawnEntityRequest","title":"DespawnEntityResponse"},{"location":"proto_doc/protobuf/#detectionsensorconfiguration","text":"Parameter configuration of the detection sensor Field Type Label Description entity string Name of the entity which you want to attach detection sensor. update_duration double Update duration of the detection sensor. topic_name string Topic name of the detection result.","title":"DetectionSensorConfiguration"},{"location":"proto_doc/protobuf/#initializerequest","text":"Requests initializing simulation. Field Type Label Description realtime_factor double Realtime factor of the simulation. step_time double Step time of the simulation.","title":"InitializeRequest"},{"location":"proto_doc/protobuf/#initializeresponse","text":"Result of initializing simulation. Field Type Label Description result Result Result of InitializeRequest","title":"InitializeResponse"},{"location":"proto_doc/protobuf/#lidarconfiguration","text":"Parameter configuration of the lidar sensor Field Type Label Description entity string Name of the entity which you want to attach lidar. horizontal_resolution double Horizontal resolutions of the lidar. vertical_angles double repeated Vertical resolutions of the lidar. scan_duration double Scan duration of the lidar. topic_name string Topic name of the lidar pointcloud.","title":"LidarConfiguration"},{"location":"proto_doc/protobuf/#result","text":"Result of the request Field Type Label Description success bool If true, the request was succeeded description string Description of why the request was failed.","title":"Result"},{"location":"proto_doc/protobuf/#spawnpedestrianentityrequest","text":"Requests spawning pedestrian entity. Field Type Label Description parameters openscenario_msgs.PedestrianParameters Parameters of pedestrian entity.","title":"SpawnPedestrianEntityRequest"},{"location":"proto_doc/protobuf/#spawnpedestrianentityresponse","text":"Response of spawning vehicle entity. Field Type Label Description result Result Result of SpawnPedestrianEntityResponse","title":"SpawnPedestrianEntityResponse"},{"location":"proto_doc/protobuf/#spawnvehicleentityrequest","text":"Requests spawning vehicle entity. Field Type Label Description parameters openscenario_msgs.VehicleParameters Parameters of vehicle entity. is_ego bool If true, the entity is Ego vehicle. (Autoware vehicle.)","title":"SpawnVehicleEntityRequest"},{"location":"proto_doc/protobuf/#spawnvehicleentityresponse","text":"Response of spawning vehicle entity. Field Type Label Description result Result Result of SpawnVehicleEntityResponse","title":"SpawnVehicleEntityResponse"},{"location":"proto_doc/protobuf/#updateentitystatusrequest","text":"Requests updating entity status. Field Type Label Description status openscenario_msgs.EntityStatus repeated List of updateed entity status in traffic simulator.","title":"UpdateEntityStatusRequest"},{"location":"proto_doc/protobuf/#updateentitystatusresponse","text":"Response of updating entity status. Field Type Label Description result Result Result of UpdateEntityStatusRequest status UpdatedEntityStatus repeated List of updated entity status in sensor/dynamics simulator.","title":"UpdateEntityStatusResponse"},{"location":"proto_doc/protobuf/#updateframerequest","text":"Requests updating simulation frame. Field Type Label Description current_time double Current simulation time","title":"UpdateFrameRequest"},{"location":"proto_doc/protobuf/#updateframeresponse","text":"Response of updating simulation frame. Field Type Label Description result Result Result of UpdateFrameRequest","title":"UpdateFrameResponse"},{"location":"proto_doc/protobuf/#updatesensorframerequest","text":"Requests updating a frame of sensor simulation. Field Type Label Description current_time double Current simulation timestamp.","title":"UpdateSensorFrameRequest"},{"location":"proto_doc/protobuf/#updatesensorframeresponse","text":"Response of updating a frame of sensor simulation. Field Type Label Description result Result Result of UpdateSensorFrameRequest","title":"UpdateSensorFrameResponse"},{"location":"proto_doc/protobuf/#updatedentitystatus","text":"Updated entity status by the simulator. Field Type Label Description name string Name og the entity. action_status openscenario_msgs.ActionStatus Action status of the entity. pose geometry_msgs.Pose Pose of the entity in the map coordinate.","title":"UpdatedEntityStatus"},{"location":"proto_doc/protobuf/#scalar-value-types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby double double double float float64 double float Float float float float float float32 float float Float int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required) int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required) uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required) sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required) sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required) fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required) sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum bool bool boolean boolean bool bool boolean TrueClass/FalseClass string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8) bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)","title":"Scalar Value Types"},{"location":"user_guide/scenario_editor/ChangeCoordinate/","text":"Change the coordinate system # Displayed coordinate change # You can change a coordinate of the displayed object position by following steps. When changing to the global coordinate: \"MAP\" on the menu -> \"Coordinate\" -> Select \"World\" When changing to the coordinate of the lane: \"MAP\" on the menu -> \"Coordinate\" -> Select \"Lane\" The position of the displayed object in \"Position\" on the right side of the screen will be changed to one corresponding to the selected coordinate. Lane select when lanes overlap # When you placed an object in a place where the lanes overlap on the lane coordinate, you can select an appropriate lane by following steps. \"MAP\" on the menu -> \"Coordinate\" -> Select \"Lane\" Place an object in the place the lanes overlap (e.g. intersection in a below figure). Click \"position\" row in \"Position\" window on the right side of the screen. Click a pencil icon on the right side of \"lane\" field. Select an appropriate lane from a selectable lane list. Click a check mark icon at the far right in \"position\" row.","title":"Change the coordinate system"},{"location":"user_guide/scenario_editor/ChangeCoordinate/#change-the-coordinate-system","text":"","title":"Change the coordinate system"},{"location":"user_guide/scenario_editor/ChangeCoordinate/#displayed-coordinate-change","text":"You can change a coordinate of the displayed object position by following steps. When changing to the global coordinate: \"MAP\" on the menu -> \"Coordinate\" -> Select \"World\" When changing to the coordinate of the lane: \"MAP\" on the menu -> \"Coordinate\" -> Select \"Lane\" The position of the displayed object in \"Position\" on the right side of the screen will be changed to one corresponding to the selected coordinate.","title":"Displayed coordinate change"},{"location":"user_guide/scenario_editor/ChangeCoordinate/#lane-select-when-lanes-overlap","text":"When you placed an object in a place where the lanes overlap on the lane coordinate, you can select an appropriate lane by following steps. \"MAP\" on the menu -> \"Coordinate\" -> Select \"Lane\" Place an object in the place the lanes overlap (e.g. intersection in a below figure). Click \"position\" row in \"Position\" window on the right side of the screen. Click a pencil icon on the right side of \"lane\" field. Select an appropriate lane from a selectable lane list. Click a check mark icon at the far right in \"position\" row.","title":"Lane select when lanes overlap"},{"location":"user_guide/scenario_editor/CreateSimpleScenario/","text":"Create a simple scenario # Launch a scenario editor and open a map # You can launch a scenario editor and open a map by following steps. Open https://scenario.tier4.jp/scenario_editor/restricted/ on Google Chrome \"MAP\" on the menu -> Select \"Load map\" Select osm file (Lanelet2) and click \"Import\" button The map opens and you can see a screen like a following figure. You can zoom in/out with mouse wheel on the map, move the map by dragging with right mouse button, and rotate the map by dragging with left mouse button. Place Ego car # You can place Ego car and set the destination on the map by following steps. \"EDIT\" on the menu -> \"Ego\" -> Select \"Set ego car\" Click where you would like to place the Ego car on the lane on the map. \"EDIT\" on the menu -> \"Ego\" -> Select \"Set ego car destination\" Click where you would like to set as a destination of the Ego car on the lane on the map. Objects which show Ego car and the destination are displayed on the map like a following figure. You can see that a condition to judge if Ego car arrived at the destination as a success criteria is added in \"Success\" window on the bottom of the screen. Velocity designation of Ego car # You can designate the target velocity of the Ego car by following steps. Click \"Speed\" in \"Entity\" window on the bottom left of the screen. Input the velocity value (m/s) in the form. Click the check mark icon on the right side of the form. Display a scenario # You can see a scenario under editing as a text by following steps. \"SCENARIO\" on the menu -> Select \"Open text editor\" A window like a following figure is shown and the scenario is displayed as a text. Export a scenario # You can export a scenario file by following steps. \"SCENARIO\" on the menu -> Select \"Export\" Input a name of the export file in the dialog box. Click \"Export\"\u3000button. The scenario is exported as a file. You can execute a simulator using the file. Do not forget!! : Please export scenario in Tier4 format V2.","title":"Create a simple scenario"},{"location":"user_guide/scenario_editor/CreateSimpleScenario/#create-a-simple-scenario","text":"","title":"Create a simple scenario"},{"location":"user_guide/scenario_editor/CreateSimpleScenario/#launch-a-scenario-editor-and-open-a-map","text":"You can launch a scenario editor and open a map by following steps. Open https://scenario.tier4.jp/scenario_editor/restricted/ on Google Chrome \"MAP\" on the menu -> Select \"Load map\" Select osm file (Lanelet2) and click \"Import\" button The map opens and you can see a screen like a following figure. You can zoom in/out with mouse wheel on the map, move the map by dragging with right mouse button, and rotate the map by dragging with left mouse button.","title":"Launch a scenario editor and open a map"},{"location":"user_guide/scenario_editor/CreateSimpleScenario/#place-ego-car","text":"You can place Ego car and set the destination on the map by following steps. \"EDIT\" on the menu -> \"Ego\" -> Select \"Set ego car\" Click where you would like to place the Ego car on the lane on the map. \"EDIT\" on the menu -> \"Ego\" -> Select \"Set ego car destination\" Click where you would like to set as a destination of the Ego car on the lane on the map. Objects which show Ego car and the destination are displayed on the map like a following figure. You can see that a condition to judge if Ego car arrived at the destination as a success criteria is added in \"Success\" window on the bottom of the screen.","title":"Place Ego car"},{"location":"user_guide/scenario_editor/CreateSimpleScenario/#velocity-designation-of-ego-car","text":"You can designate the target velocity of the Ego car by following steps. Click \"Speed\" in \"Entity\" window on the bottom left of the screen. Input the velocity value (m/s) in the form. Click the check mark icon on the right side of the form.","title":"Velocity designation of Ego car"},{"location":"user_guide/scenario_editor/CreateSimpleScenario/#display-a-scenario","text":"You can see a scenario under editing as a text by following steps. \"SCENARIO\" on the menu -> Select \"Open text editor\" A window like a following figure is shown and the scenario is displayed as a text.","title":"Display a scenario"},{"location":"user_guide/scenario_editor/CreateSimpleScenario/#export-a-scenario","text":"You can export a scenario file by following steps. \"SCENARIO\" on the menu -> Select \"Export\" Input a name of the export file in the dialog box. Click \"Export\"\u3000button. The scenario is exported as a file. You can execute a simulator using the file. Do not forget!! : Please export scenario in Tier4 format V2.","title":"Export a scenario"},{"location":"user_guide/scenario_editor/EditExistingScenario/","text":"Edit an existing scenario # Please go to following steps after completing Create a simple scenario . Load a scenario # You can load a scenario exported at Create a simple scenario by following steps after launching scenario editor and opening a map. \"SCENARIO\" on the menu -> Select \"Import yaml\" Select a scenario file from a displayed dialog. Click \"IMPORT\" button. After loading, the scenario contents are displayed. Add a Pedestrian # You can add a Pedestrian in a scenario by following steps. \"EDIT\" on the menu -> \"Pedestrian\" -> Select \"Add pedestrian\" Click where you would like to add a pedestrian on the map. Adjust the pedestrian direction by dragging an arrow of the pedestrian object on the map. As same as \"Velocity designation of Ego car\" in Create a simple map , designate the velocity of the pedestrian. As an example, set 0 m/s not to walk in an initial state. In the figure above, you can see that the pedestrian is placed in front of a crosswalk, faces toward the crosswalk and a pedestrian's target velocity is set at 0 m/s. Add a Point # You can add a Point (an object to indicate\u3000a place on the map) used for a starting condition of Event by following steps. \"EDIT\" on the menu -> \"Point\" -> Select \"Add point\" Click a point on the way from the initial position of Ego car to the destination. A new object is placed on the place where you clicked. Add an Act # You can add an Act which describes a motion of the pedestrian by following steps. \"SCENARIO\" on the menu -> Select \"Add new act\" Input data in the displayed dialog. (Refer the figure below.) Input \"Sample act\" in \"Act name\" Select \"Pedestrian0\" in \"Actors\" Select \"SimulationTime\" in \"Condition\" Select \"gt\" in \"Rule\" and input \"0\" in \u201dValue\" Click \"OK\" button. A new act is added and \"Act0\" tab is displayed in the bottom left window. Add an Event # You can add an Event which describes a condition of the pedestrian's motion start by following steps. Click \"Act0\" tab in the bottom left window. Click \"+\" icon on the left of the \"New event\". Input data in the displayed dialog. (Refer the figure below.) Input \u201dSample event\" in \"Event name\" Select \"ReachPosition\" in \"Condition\" Select \"/Point/Point0/position\" in \u201dPosition\", \"Ego\" in \"Trigger\" and input 1 in \"Tolerance\". Click \"OK\" button. Add an Action # You can add an Action which changes the velocity of the pedestrian by following steps. Click \"Act0\" tab in the bottom left window. Click \"+\" icon on the left of the \u201dNew action\". Input data in the displayed dialog. (Refer the figure below.) Select \"Speed\" in \"Action\" Input 1 in \"Value\" Click \"OK\" button. Export a scenario # You can export a scenario file by following steps. \"SCENARIO\" on the menu -> Select \"Export\" Input a name of the export file in the dialog box. Click \"Export\"\u3000button. The edited scenario is exported as a file. You can execute a simulator using the file. Do not forget!! : Please export scenario in Tier4 format V2.","title":"Edit an existing scenario"},{"location":"user_guide/scenario_editor/EditExistingScenario/#edit-an-existing-scenario","text":"Please go to following steps after completing Create a simple scenario .","title":"Edit an existing scenario"},{"location":"user_guide/scenario_editor/EditExistingScenario/#load-a-scenario","text":"You can load a scenario exported at Create a simple scenario by following steps after launching scenario editor and opening a map. \"SCENARIO\" on the menu -> Select \"Import yaml\" Select a scenario file from a displayed dialog. Click \"IMPORT\" button. After loading, the scenario contents are displayed.","title":"Load a scenario"},{"location":"user_guide/scenario_editor/EditExistingScenario/#add-a-pedestrian","text":"You can add a Pedestrian in a scenario by following steps. \"EDIT\" on the menu -> \"Pedestrian\" -> Select \"Add pedestrian\" Click where you would like to add a pedestrian on the map. Adjust the pedestrian direction by dragging an arrow of the pedestrian object on the map. As same as \"Velocity designation of Ego car\" in Create a simple map , designate the velocity of the pedestrian. As an example, set 0 m/s not to walk in an initial state. In the figure above, you can see that the pedestrian is placed in front of a crosswalk, faces toward the crosswalk and a pedestrian's target velocity is set at 0 m/s.","title":"Add a Pedestrian"},{"location":"user_guide/scenario_editor/EditExistingScenario/#add-a-point","text":"You can add a Point (an object to indicate\u3000a place on the map) used for a starting condition of Event by following steps. \"EDIT\" on the menu -> \"Point\" -> Select \"Add point\" Click a point on the way from the initial position of Ego car to the destination. A new object is placed on the place where you clicked.","title":"Add a Point"},{"location":"user_guide/scenario_editor/EditExistingScenario/#add-an-act","text":"You can add an Act which describes a motion of the pedestrian by following steps. \"SCENARIO\" on the menu -> Select \"Add new act\" Input data in the displayed dialog. (Refer the figure below.) Input \"Sample act\" in \"Act name\" Select \"Pedestrian0\" in \"Actors\" Select \"SimulationTime\" in \"Condition\" Select \"gt\" in \"Rule\" and input \"0\" in \u201dValue\" Click \"OK\" button. A new act is added and \"Act0\" tab is displayed in the bottom left window.","title":"Add an Act"},{"location":"user_guide/scenario_editor/EditExistingScenario/#add-an-event","text":"You can add an Event which describes a condition of the pedestrian's motion start by following steps. Click \"Act0\" tab in the bottom left window. Click \"+\" icon on the left of the \"New event\". Input data in the displayed dialog. (Refer the figure below.) Input \u201dSample event\" in \"Event name\" Select \"ReachPosition\" in \"Condition\" Select \"/Point/Point0/position\" in \u201dPosition\", \"Ego\" in \"Trigger\" and input 1 in \"Tolerance\". Click \"OK\" button.","title":"Add an Event"},{"location":"user_guide/scenario_editor/EditExistingScenario/#add-an-action","text":"You can add an Action which changes the velocity of the pedestrian by following steps. Click \"Act0\" tab in the bottom left window. Click \"+\" icon on the left of the \u201dNew action\". Input data in the displayed dialog. (Refer the figure below.) Select \"Speed\" in \"Action\" Input 1 in \"Value\" Click \"OK\" button.","title":"Add an Action"},{"location":"user_guide/scenario_editor/EditExistingScenario/#export-a-scenario","text":"You can export a scenario file by following steps. \"SCENARIO\" on the menu -> Select \"Export\" Input a name of the export file in the dialog box. Click \"Export\"\u3000button. The edited scenario is exported as a file. You can execute a simulator using the file. Do not forget!! : Please export scenario in Tier4 format V2.","title":"Export a scenario"},{"location":"user_guide/scenario_editor/RelativePosition/","text":"Set a position of an entity in relative position # Launch a scenario editor and open a map # You can launch a scenario editor and open a map by following steps. Open https://scenario.tier4.jp/scenario_editor/restricted/ on Google Chrome \"MAP\" on the menu -> Select \"Load map\" Select .osm file (Lanelet2) and click \"Import\" button The map opens and you can see a screen like a following figure. Place Ego car # You can place Ego car on the map by following steps. \"EDIT\" on the menu -> \"Ego\" -> Select \"Set ego car\" Click where you would like to place Ego car on the lane on the map. Place NPC # You can place NPC on the map by following steps. \"EDIT\" on the menu -> \"NPC\" -> Select \"Add NPC\" Click on the backward position of the Ego car Set the NPC's position relative to the Ego car # You can set the position of the NPC relative to the Ego car by following steps. Click on the \"frame\" row of \"Car1 (Npc1)\" in \"Position\" on the right side of the screen Select \"/Car/Car0/pose\" from the drop-down list and click the check mark icon on the right side of the form Click on the \"position\" row of \"Car1 (Npc1)\" in \"Position\" on the right side of the screen Enter a value of \"-10\" for \"x\" and \"0\" for \"y\" and click the check mark icon on the right side of the form The NPC position is set to 10 meters behind the Ego car. Set the position of the NPC with a parameter # You can set the position of the NPC with a parameter by following steps. Click \"+\" icon in \"Parameter\" on the bottom side of the screen. Input data in the displayed dialog. (Refer the figure below.) Input \"Distance\" in \"Name\" Input -20 in \"Start\" Input -10 in \"Stop\" Input 2 in \"Step\" Click \"OK\" button. Click on the \"position\" row of \"Car1 (Npc1)\" in \"Position\" on the right side of the screen Click on the pencil icon to the right of the \"x\" Select the radio button on the top of the input component that appears Select \"$Distance\" from the drop-down list Click check the check mark icon on the right side of the form \"Scenario\" on the menu -> Select \"Open text editor\" A window like a following figure is shown and the scenario is displayed as a text. You can see that the position of Npc1 is set using the element \"RelativeWorldPosition\" in the text \"StoryBoard\" -> \"Init\" -> \"Actions\" -> \"Private\". If it is not working properly, you may be using an old Scenario editor, please super-reload your browser and try again.","title":"Place an entity to relative position"},{"location":"user_guide/scenario_editor/RelativePosition/#set-a-position-of-an-entity-in-relative-position","text":"","title":"Set a position of an entity in relative position"},{"location":"user_guide/scenario_editor/RelativePosition/#launch-a-scenario-editor-and-open-a-map","text":"You can launch a scenario editor and open a map by following steps. Open https://scenario.tier4.jp/scenario_editor/restricted/ on Google Chrome \"MAP\" on the menu -> Select \"Load map\" Select .osm file (Lanelet2) and click \"Import\" button The map opens and you can see a screen like a following figure.","title":"Launch a scenario editor and open a map"},{"location":"user_guide/scenario_editor/RelativePosition/#place-ego-car","text":"You can place Ego car on the map by following steps. \"EDIT\" on the menu -> \"Ego\" -> Select \"Set ego car\" Click where you would like to place Ego car on the lane on the map.","title":"Place Ego car"},{"location":"user_guide/scenario_editor/RelativePosition/#place-npc","text":"You can place NPC on the map by following steps. \"EDIT\" on the menu -> \"NPC\" -> Select \"Add NPC\" Click on the backward position of the Ego car","title":"Place NPC"},{"location":"user_guide/scenario_editor/RelativePosition/#set-the-npcs-position-relative-to-the-ego-car","text":"You can set the position of the NPC relative to the Ego car by following steps. Click on the \"frame\" row of \"Car1 (Npc1)\" in \"Position\" on the right side of the screen Select \"/Car/Car0/pose\" from the drop-down list and click the check mark icon on the right side of the form Click on the \"position\" row of \"Car1 (Npc1)\" in \"Position\" on the right side of the screen Enter a value of \"-10\" for \"x\" and \"0\" for \"y\" and click the check mark icon on the right side of the form The NPC position is set to 10 meters behind the Ego car.","title":"Set the NPC's position relative to the Ego car"},{"location":"user_guide/scenario_editor/RelativePosition/#set-the-position-of-the-npc-with-a-parameter","text":"You can set the position of the NPC with a parameter by following steps. Click \"+\" icon in \"Parameter\" on the bottom side of the screen. Input data in the displayed dialog. (Refer the figure below.) Input \"Distance\" in \"Name\" Input -20 in \"Start\" Input -10 in \"Stop\" Input 2 in \"Step\" Click \"OK\" button. Click on the \"position\" row of \"Car1 (Npc1)\" in \"Position\" on the right side of the screen Click on the pencil icon to the right of the \"x\" Select the radio button on the top of the input component that appears Select \"$Distance\" from the drop-down list Click check the check mark icon on the right side of the form \"Scenario\" on the menu -> Select \"Open text editor\" A window like a following figure is shown and the scenario is displayed as a text. You can see that the position of Npc1 is set using the element \"RelativeWorldPosition\" in the text \"StoryBoard\" -> \"Init\" -> \"Actions\" -> \"Private\". If it is not working properly, you may be using an old Scenario editor, please super-reload your browser and try again.","title":"Set the position of the NPC with a parameter"},{"location":"user_guide/scenario_editor/ScenarioEditorUserGuide/","text":"Scenario Editor User Guide # You can access via this URL . Note! Scenario editor only supports Google Chrome. The latest version of Google Chrome (Currently, google chrome 86 ) is recommended. Detailed Documentations # Create a simple scenario Edit an existing scenario Change the coordinate system","title":"Overview"},{"location":"user_guide/scenario_editor/ScenarioEditorUserGuide/#scenario-editor-user-guide","text":"You can access via this URL . Note! Scenario editor only supports Google Chrome. The latest version of Google Chrome (Currently, google chrome 86 ) is recommended.","title":"Scenario Editor User Guide"},{"location":"user_guide/scenario_editor/ScenarioEditorUserGuide/#detailed-documentations","text":"Create a simple scenario Edit an existing scenario Change the coordinate system","title":"Detailed Documentations"},{"location":"user_guide/scenario_test_runner/HowToWriteWorkflowFile/","text":"How to write workflow file # The workflow file defines how to execute scenarios and its expected results. Supported parameters # name type required description default example path string yes Path to the .xosc (OpenSCENARIO .xml file.) file or T4V2 .yaml file. example expect string no Only success/failure/exception values are support. Scenario writers can define the scenarios should be end with expected results. success example step_time_ms int yes step_time_ms describes the step time of the simulation in milliseconds. 2 example Examples of writing parameters # path # You can solve relative path from the \"share\" directories in your ROS2 packages. path : $(find-pkg-share PACKAGE_NAME)/test/scenario/xosc/simple.xosc Or, you can solve absolute path like this way. path : /tmp/simple.xosc expect # success : Simulation terminated by success condition action. failure : Simulation terminated by failure condition action. exception : Simulation terminated by exceptions in openscenario_intertretor component. Examples # Scenario : - { path : $(find-pkg-share scenario_test_runner)/test/scenario/xosc/simple.xosc } - { path : $(find-pkg-share scenario_test_runner)/test/scenario/yaml/failure.yaml , expect : failure } - { path : $(find-pkg-share scenario_test_runner)/test/scenario/yaml/success.yaml , expect : success , step_time_ms : 2 }","title":"How to write workflow file"},{"location":"user_guide/scenario_test_runner/HowToWriteWorkflowFile/#how-to-write-workflow-file","text":"The workflow file defines how to execute scenarios and its expected results.","title":"How to write workflow file"},{"location":"user_guide/scenario_test_runner/HowToWriteWorkflowFile/#supported-parameters","text":"name type required description default example path string yes Path to the .xosc (OpenSCENARIO .xml file.) file or T4V2 .yaml file. example expect string no Only success/failure/exception values are support. Scenario writers can define the scenarios should be end with expected results. success example step_time_ms int yes step_time_ms describes the step time of the simulation in milliseconds. 2 example","title":"Supported parameters"},{"location":"user_guide/scenario_test_runner/HowToWriteWorkflowFile/#examples-of-writing-parameters","text":"","title":"Examples of writing parameters"},{"location":"user_guide/scenario_test_runner/HowToWriteWorkflowFile/#path","text":"You can solve relative path from the \"share\" directories in your ROS2 packages. path : $(find-pkg-share PACKAGE_NAME)/test/scenario/xosc/simple.xosc Or, you can solve absolute path like this way. path : /tmp/simple.xosc","title":"path"},{"location":"user_guide/scenario_test_runner/HowToWriteWorkflowFile/#expect","text":"success : Simulation terminated by success condition action. failure : Simulation terminated by failure condition action. exception : Simulation terminated by exceptions in openscenario_intertretor component.","title":"expect"},{"location":"user_guide/scenario_test_runner/HowToWriteWorkflowFile/#examples","text":"Scenario : - { path : $(find-pkg-share scenario_test_runner)/test/scenario/xosc/simple.xosc } - { path : $(find-pkg-share scenario_test_runner)/test/scenario/yaml/failure.yaml , expect : failure } - { path : $(find-pkg-share scenario_test_runner)/test/scenario/yaml/success.yaml , expect : success , step_time_ms : 2 }","title":"Examples"},{"location":"user_guide/scenario_test_runner/ScenarioFormatConversion/","text":"Scenario Format Conversion # Tier4 Format V2 -> OpenSCENARIO Format # To convert OpenSCENARIO, use these arguments Input Required Description input yes Tier4 format version2 yaml files in a specified directory, reference directory is relative to the current directory. output no Tier4 parameter distributed OpenSCENARIO .xosc files are generated in a specified directory. Default is under the current directory converted_xosc. You can execute scenario conversion by using ros2 command ros2 run scenario_test_utility.py --input=\"path to input yaml file\" --output=\"path to output directory\"","title":"Scenario Format Conversion"},{"location":"user_guide/scenario_test_runner/ScenarioFormatConversion/#scenario-format-conversion","text":"","title":"Scenario Format Conversion"},{"location":"user_guide/scenario_test_runner/ScenarioFormatConversion/#tier4-format-v2-openscenario-format","text":"To convert OpenSCENARIO, use these arguments Input Required Description input yes Tier4 format version2 yaml files in a specified directory, reference directory is relative to the current directory. output no Tier4 parameter distributed OpenSCENARIO .xosc files are generated in a specified directory. Default is under the current directory converted_xosc. You can execute scenario conversion by using ros2 command ros2 run scenario_test_utility.py --input=\"path to input yaml file\" --output=\"path to output directory\"","title":"Tier4 Format V2 -&gt; OpenSCENARIO Format"},{"location":"user_guide/scenario_test_runner/ScenarioTestRunner/","text":"Scenario Test Runner User Guide # Scenario Test Runner is being developed to assist in the definitive planning simulation using concept of OpenSCENARIO. Simulations are described in a \"YAML\" based format called a \"tier4 scenario format\". Then convert the scenario into an \"XML\" based format called an \"OpenSCENARIO\". The format has been found at OpenSCENARIO . How to use # ros2 launch scenario_test_runner scenario_test_runner.launch.py workflow: = '$(find-pkg-share scenario_test_runner)/workflow_example.yaml' log_directory: = '/tmp' The workflow file defines how to execute scenarios. If you want to know how to write the workflow file, read here. Detailed Documentations # How to write workflow file Scenario conversion Tips","title":"Overview"},{"location":"user_guide/scenario_test_runner/ScenarioTestRunner/#scenario-test-runner-user-guide","text":"Scenario Test Runner is being developed to assist in the definitive planning simulation using concept of OpenSCENARIO. Simulations are described in a \"YAML\" based format called a \"tier4 scenario format\". Then convert the scenario into an \"XML\" based format called an \"OpenSCENARIO\". The format has been found at OpenSCENARIO .","title":"Scenario Test Runner User Guide"},{"location":"user_guide/scenario_test_runner/ScenarioTestRunner/#how-to-use","text":"ros2 launch scenario_test_runner scenario_test_runner.launch.py workflow: = '$(find-pkg-share scenario_test_runner)/workflow_example.yaml' log_directory: = '/tmp' The workflow file defines how to execute scenarios. If you want to know how to write the workflow file, read here.","title":"How to use"},{"location":"user_guide/scenario_test_runner/ScenarioTestRunner/#detailed-documentations","text":"How to write workflow file Scenario conversion Tips","title":"Detailed Documentations"},{"location":"user_guide/scenario_test_runner/Tips/","text":"Tips about writing scenarios # Required Scenario Tags # CatalogLocations inside OpenSCENARIO is defined structure below. CatalogLocations in OpenSCENARIO specification must exist. CatalogLocations : or CatalogLocations : {}","title":"Tips about writing scenarios"},{"location":"user_guide/scenario_test_runner/Tips/#tips-about-writing-scenarios","text":"","title":"Tips about writing scenarios"},{"location":"user_guide/scenario_test_runner/Tips/#required-scenario-tags","text":"CatalogLocations inside OpenSCENARIO is defined structure below. CatalogLocations in OpenSCENARIO specification must exist. CatalogLocations : or CatalogLocations : {}","title":"Required Scenario Tags"}]}